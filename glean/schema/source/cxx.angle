schema cxx1.1 {
import builtin.1
import src.1

# A name (identifier)
predicate Name : string

# Types are their textual representations for now
predicate Type : string

# Named parameter
type Parameter =
  {
    name : Name,
    type : Type,
  }

# Type signature of function or method (without name or scope)
predicate Signature :
  {
    returns : Type,
    parameters : [Parameter],
  }

# -----------------------------------------------------------------------------
# Scopes and qualified names

# Fully qualified C++ namespace name (or anonymous)
predicate NamespaceQName :
  {
    name : maybe Name,
    parent : maybe NamespaceQName,
  }

# Access scope for C++ declaration
type Access = enum { Public | Protected | Private }

# Scope (still somewhat incomplete)
type Scope =
  {
    global_ : builtin.Unit |
    namespace_ : NamespaceQName |
    recordWithAccess :
      {
        record : QName,
        access : Access
      } |
    local : FunctionQName
  }

# Fully qualified name
predicate QName :
  {
    name : Name,
    scope : Scope,
  }

# C++ operator name
type Operator = string

# C++ literal operator name
type LiteralOperator = string

# Describe a function or method name (without parameters or scope)
predicate FunctionName :
  {
    name : Name |                         # ordinary name
    operator_ : Operator |                # C++ operator
    literalOperator : LiteralOperator |   # C++ literator operator (\"\"_x)
    constructor : builtin.Unit |
    destructor : builtin.Unit |
    conversionOperator : Type
  }

# Fully qualified function name
predicate FunctionQName :
  {
    name : FunctionName,
    scope : Scope,
  }

# -----------------------------------------------------------------------------
# Declarations

# A namespace declaration
predicate NamespaceDeclaration :
  {
    name : NamespaceQName,
    source : src.Range,
  }

# C++ record kind - struct/class/union
type RecordKind =
   {
     struct_ : builtin.Unit |
     class_ : builtin.Unit |
     union_ : builtin.Unit
   }

# Record declaration
predicate RecordDeclaration :
  {
    name : QName,
    kind : RecordKind,
    source : src.Range,
  }

# Enum declaration
predicate EnumDeclaration :
  {
    name : QName,
    isScoped : bool,
    type : maybe Type,
    source : src.Range,
  }

# C++ method ref qualifier
type RefQualifier = enum { None_ | LValue | RValue }

# Method signature
type MethodSignature =
  {
    isVirtual : bool,
    isConst : bool,
    isVolatile : bool,
    refQualifier : RefQualifier,
  }

# Function declaration
predicate FunctionDeclaration :
  {
    name : FunctionQName,
    signature : Signature,
    method : maybe MethodSignature,
    source : src.Range,
  }

# C++ method override
predicate MethodOverrides :
  {
    derived : FunctionDeclaration,
    base : FunctionDeclaration,
  }

# Objective C category identifier
type ObjcCategoryId =
  {
    className : Name,
    categoryName : Name,
  }

# Objective C container identifier
type ObjcContainerId =
  {
    protocol : Name |
    interface_ : Name |
    categoryInterface : ObjcCategoryId |
    extensionInterface : Name |
    implementation : Name |
    categoryImplementation : ObjcCategoryId |
  }

# Objective C container (protocol, interface etc.) declaration
predicate ObjcContainerDeclaration :
  {
    id : ObjcContainerId,
    source : src.Range,
  }

# Objective C selector
predicate ObjcSelector : [string]

# Objective C method declaration
predicate ObjcMethodDeclaration :
  {
    selector : ObjcSelector,
    container : ObjcContainerId,
    signature : Signature,
    isInstance : bool,
    isOptional : bool,
    isAccessor : bool,
    source : src.Range,
  }

# Objective C property declaration
predicate ObjcPropertyDeclaration :
  {
    name : Name,
    container : ObjcContainerId,
    type : Type,
    isInstance : bool,
    isOptional : bool,
    isReadOnly : bool,
    isAtomic : bool,
    source : src.Range,
  }

# Objective C property implementation kind
type ObjcPropertyKind = enum { Synthesize | Dynamic }

# Objective C property implementation
predicate ObjcPropertyImplementation :
  {
    declaration : ObjcPropertyDeclaration,
    kind : ObjcPropertyKind,
    ivar : maybe Name,
    source : src.Range,
  }

# C++ record base
type RecordBase =
  {
    base : RecordDeclaration,
    access : Access,
    isVirtual : bool,
  }

# Enumerator declaration (constant in an enum)
predicate Enumerator :
  {
    name : Name,
    enumeration : EnumDeclaration,   # TODO: qname?
    source : src.Range,
  }

# Enum definition
predicate EnumDefinition :
  {
    declaration : EnumDeclaration,
    enumerators : [Enumerator]
  }

# C++ function definition
# Will also have a body eventually
predicate FunctionDefinition :
  {
    declaration : FunctionDeclaration,
    isInline : bool,
  }

# Objective C interface-implementation relationship
predicate ObjcImplements :
  {
    implementation : ObjcContainerDeclaration,
    interface_ : ObjcContainerDeclaration,
  }

# Reverse of ObjcImplements; efficiently look up implementations
predicate ObjcInterfaceToImplementation :
  {
    interface_ : ObjcContainerDeclaration,
    implementation : ObjcContainerDeclaration,
  }
  stored { If, Im } where ObjcImplements { Im, If }

# Objective C method definition
# Will also have a body eventually
predicate ObjcMethodDefinition : ObjcMethodDeclaration

# Kind of a decl; used in DeclByName
type DeclKind =
  enum {
    namespace_ |
    usingDeclaration |
    usingDirective |
    record_ |
    enum_ |
    enumerator |
    function_ |
    variable |
    objcContainer |
    objcMethod |
    objcProperty |
    typeAlias |
    macro |
  }

} # end schema cxx1.1


schema cxx1.2 : cxx1.1 {
import pp1.1
import src.1

predicate Declarations : [Declaration]

# Two declarations refer to the same entity
predicate Same :
  {
    declaration1 : Declaration,
    declaration2 : Declaration,
  }

# Definitions

# Part of a namespace definition
predicate NamespaceDefinition :
  {
    declaration : NamespaceDeclaration,
    members : Declarations,
  }

predicate RecordDefinition :
  {
    declaration : RecordDeclaration,
    bases : [RecordBase],
    members : Declarations,
  }

# Objective C interface definition
predicate ObjcContainerDefinition :
  {
    declaration : ObjcContainerDeclaration,
    protocols : [ObjcContainerDeclaration],
    members : Declarations,
  }

# C++ preprocessor include trace
type IncludeTrace =
  {
    include_ : pp1.Include,
    trace : maybe Trace,
  }

# A C++ preprocessor event
type PPEvent =
  {
    include_ : IncludeTrace |
    define : pp1.Define |
    undef : pp1.Undef |
    use : pp1.Use |
  }

# A trace of preprocessor events in a C++ file
predicate PPTrace :
  {
    file : src.File,
    events : [PPEvent]
  }

# A trace of all interesting things in a C++ file
predicate Trace :
  {
    file : src.File,
    declarations : Declarations,
    preprocessor : PPTrace,
  }

# C++ type alias kind
type TypeAliasKind = enum { Typedef | Using }

# Type alias declaration (typedef or using)
predicate TypeAliasDeclaration :
  {
    name : QName,
    type : Type,
    kind : TypeAliasKind,
    source : src.Range,
  }
# Using declaration
predicate UsingDeclaration :
  {
    name : FunctionQName,
    source : src.Range,
  }

# Using directive
predicate UsingDirective :
  {
    name : QName,
    source : src.Range,
  }

# Kind of global variable
type GlobalVariableKind =
   enum {
    SimpleVariable |
    StaticVariable |
    StaticMember
   }

# Global variable attributes
type GlobalVariableAttribute =
  enum {
    Plain |
    Inline |
    Constexpr
  }

# Global variable description
type GlobalVariable =
  {
    kind : GlobalVariableKind,
    attribute : GlobalVariableAttribute,
    definition : bool,  # is this a declaration or a definition
  }

# Attributes of non-static member variables
type Field =
  {
    mutable_ : bool,
    bitsize : maybe nat,
  }

# Attributes of Objective C ivars
type ObjcIVar =
  {
    synthesize : bool,
    bitsize : maybe nat,
  }

# Kinds of variables
type VariableKind =
  {
    global_ : GlobalVariable |
    field : Field |
    ivar : ObjcIVar |
  }

# Variable declaration
predicate VariableDeclaration :
  {
    name : QName,
    type : Type,
    kind : VariableKind,
    source : src.Range,
  }

# Sum type of all declarations
type Declaration =
  {
    namespace_ : NamespaceDeclaration |
    usingDeclaration : UsingDeclaration |
    usingDirective : UsingDirective |
    record_ : RecordDeclaration |
    enum_ : EnumDeclaration |
    function_ : FunctionDeclaration |
    variable : VariableDeclaration |
    objcContainer : ObjcContainerDeclaration |
    objcMethod : ObjcMethodDeclaration |
    objcProperty : ObjcPropertyDeclaration |
    typeAlias : TypeAliasDeclaration |
  }

# What indirect xrefs can go through
type XRefVia =
  {
    usingDeclaration : UsingDeclaration |
    usingDirective : UsingDirective |
    macro : pp1.Use |
  }

# C++ cross-reference target
type XRefTarget =
  {
    declaration : Declaration |
    enumerator : Enumerator |
    objcSelector : ObjcSelector |
    unknown : src.Loc |
    indirect : XRefIndirectTarget |
  }

# Cross-reference that goes through something (macro or using)
predicate XRefIndirectTarget :
  {
    via : XRefVia,
    target : XRefTarget,
  }

# Cross-references to a known target
type FixedXRef =
  {
    target : XRefTarget,
    ranges : src.ByteSpans,
  }

# Note that "variable" corresponds to many "externals" in FileXRefs
# Cross-references in a file
predicate FileXRefMap :
  {
    file : src.File,
    fixed : [FixedXRef],
    variable : [src.ByteSpans],
  }

# Note that "externals" entries correspond to "variable" entries (in the "xmap")
# Instantiation of a FileCrossRefMap with set of external references
predicate FileXRefs :
  {
    xmap : FileXRefMap,
    externals : [XRefTarget],
  }

# Uses

# Note that ("target", "file") makes a unique key for these facts
# All uses of a declaration in a file
predicate TargetUses :
  {
    target : XRefTarget,
    file : src.File,
    uses : src.ByteSpans,
  }

# These are all disjoint equivalence classes.  Constructors within an array
# guaranteed identical. Array length is at least 2.
# All the declarations for a given entity.
predicate DeclFamily : [Declaration]

# These "decl" is a unique key here.  "decl" are only present iff they are
# in a cxx1.Same, otherwise they are implicitly in a singleton family.
# Map a declaration to its family.
predicate DeclToFamily :
  {
    decl : Declaration,
    family : DeclFamily,
  }

# Generalization of Function call facts, which handles references between
# any kinds of declarations.

# Declarations referred from a given declaration.
# Explicit version, because this v1 predicate refers to v2 things.
predicate DeclarationTargets.1 :
  {
    source : Declaration,
    targets : [Declaration],
  }

# Declarations referring to a given declaration.
predicate DeclarationSources.1 :
  {
    target : Declaration,
    sources : [Declaration],
  }

# Comment referring to a given declaration
predicate DeclarationComment.1 :
  {
    declaration : Declaration,
    file : src.File,
    span : src.ByteSpan,
  }
} # end schema cxx1.2

schema cxx1.3 : cxx1.2 {
import buck.2

# A trace of a translation unit
predicate TranslationUnitTrace :
  {
    tunit : buck.TranslationUnit,
    trace : Trace,
  }
} # end schema cxx1.3

schema cxx1.4 : cxx1.3 {
import buck.2
import pp1.1
import src.1

# The fileXRefs corresponding to a particular translation unit
predicate TranslationUnitXRefs :  # 2 is already used in cxx1
  {
    tunit : buck.TranslationUnit,
    xrefs : [FileXRefs]
  }

# The backing ivar of a property
predicate ObjcPropertyIVar :
  {
    property : ObjcPropertyDeclaration,
    ivar : VariableDeclaration,
  }

# Derived Predicates

# src.Range of an arbitrary Declaration.
predicate DeclarationSrcRange :
  {
    decl : Declaration,
    source : src.Range,
  }
  { D, R } where
     ( { namespace_ = X } = D;
       X = NamespaceDeclaration { source = R }) |
     ( { usingDeclaration = X } = D;
       X = UsingDeclaration { source = R }) |
     ( { usingDirective = X } = D;
       X = UsingDirective { source = R }) |
     ( { record_ = X } = D;
       X = RecordDeclaration { source = R }) |
     ( { enum_ = X } = D;
       X = EnumDeclaration { source = R }) |
     ( { function_ = X } = D;
       X = FunctionDeclaration { source = R }) |
     ( { variable = X } = D;
       X = VariableDeclaration { source = R }) |
     ( { objcContainer = X } = D;
       X = ObjcContainerDeclaration { source = R }) |
     ( { objcMethod = X } = D;
       X = ObjcMethodDeclaration { source = R }) |
     ( { objcProperty = X } = D;
       X = ObjcPropertyDeclaration { source = R }) |
     ( { typeAlias = X } = D;
       X = TypeAliasDeclaration { source = R })

# cxx1.RecordDefinition can lookup from Child to Parent. Reverse this
# here to lookup from Parent to Child.
predicate RecordDerived :
  {
    base : RecordDeclaration,
    derived : RecordDeclaration,
  }
  stored
  {Base, Derived}
  where
   cxx1.RecordDefinition{ declaration = Derived, bases = BS };
   cxx1.RecordBase { base = Base } = BS[..]

# cxx1.MethodsOverrides can lookup from Derived to Base. Reverse this
# here to lookup from Base to Derived.
predicate MethodOverridden :
  {
    base : FunctionDeclaration,
    derived : FunctionDeclaration,
  }
  stored
  {Base, Derived}
  where
    cxx1.MethodOverrides{derived = Derived, base = Base}

# This is a derived predicate to support searching for declarations by
# case-insensitive name prefix, to support things like autocomplete.
#
# Earlier idea that didn't work so well:
#
#  [
#    ("name_lowercase", string),
#    ("decl", declaration),
#  ]
#
# doesn't work because we get lots of facts with the same
# name. e.g. "facebook" has tons of namespace declarations. This would
# make it hard to do autocomplete, because there would be too many
# duplicate results for a prefix.  Also it generated too much data.
# We might try ("decl", [declaration]), but this would require
# keeping all the declarations in memory when we derive, and might also
# generate some very large facts for common names.
#
#  {
#    name_lowercase : string,
#    kind : DeclKind,
#    name : Name,
#  }
#
# Solves the problem of duplicate results - now there's only one fact
# for each decl kind.  Getting from a prefix to decls will be a 2-step
# process - first query cxx1.DeclByName by prefix, and then query
# the appropriate decl predicates by name.

# Declarations indexed by case-insensitive name
type DeclIdent =
  {
    name : Name |
    macro : pp1.Macro |
    selector : ObjcSelector |
  }

predicate DeclByName :
  {
    name_lowercase : string,
    kind : DeclKind,
    ident : DeclIdent
  }
  stored
  { prim.toLower Str, Kind, Ident }
  where
  { Str, Kind, Ident } =
     (
      { Str, DeclKind namespace_, DeclIdent { name = N } }
      where
      NamespaceDeclaration { name = Q };
      Q = NamespaceQName { name = { just = N }};
      N = Name Str
     ) |
     (
      { Str, DeclKind function_, DeclIdent { name = N } }
      where
      FunctionDeclaration { name = Q };
      Q = FunctionQName { name = F };
      F = FunctionName { name = N };
      N = Name Str
     ) |
     (
     { Str, DeclKind record_, DeclIdent { name = N } }
      where
      RecordDeclaration { name = Q };
      Q = QName { name = N };
      N = Name Str
     ) |
     (
     { Str, DeclKind enum_, DeclIdent { name = N } }
      where
      EnumDeclaration { name = Q };
      Q = QName { name = N };
      N = Name Str
     ) |
     (
     { Str, DeclKind enumerator, DeclIdent { name = N } }
      where
      EnumDefinition { enumerators = ES };
      { name = N } = ES[..];
      N = Name Str
     ) |
     (
     { Str, DeclKind variable, DeclIdent { name = N } }
      where
      VariableDeclaration { name = Q };
      Q = QName { name = N };
      N = Name Str
     ) |
     (
     { Str, DeclKind objcContainer, DeclIdent { name = N } }
      where
      ObjcContainerDeclaration { id = I };
      N =
      ( N where { protocol = N } = I) |
      ( N where { interface_ = N } = I) |
      ( N where { categoryInterface = { className = N }} = I) |
      ( N where { extensionInterface = N } = I) |
      ( N where { implementation = N } = I) |
      ( N where { categoryImplementation = { className = N }} = I);
      N = Name Str
     ) |
     (
     { Str, DeclKind objcProperty, DeclIdent { name = N } }
      where
      ObjcPropertyDeclaration { name = N };
      N = Name Str
     ) |
     (
     { Str, DeclKind objcMethod, DeclIdent { selector = S } }
      where
      ObjcMethodDeclaration { selector = S };
      S = ObjcSelector [Str]  # TODO
     ) |
     (
     { Str, DeclKind typeAlias, DeclIdent { name = N } }
      where
      TypeAliasDeclaration { name = Q };
      Q = QName { name = N };
      N = Name Str
     ) |
     (
     { Str, DeclKind macro, DeclIdent { macro = N } }
      where
      N = pp1.Macro Str
     )

# Use this derived predicate to handle declarations without a family in
# a uniform way as declarations with a family.
predicate DeclFamilyOf :
  {
    decl : Declaration,
    family : Declaration,
  }
  {Decl, FamDecl}
  where
    FamDecl = Decl |
    ( D where
      cxx1.DeclToFamily{decl=Decl, family=DF};
      DF=cxx1.DeclFamily F;
      D=F[..]
    )

# Maps from a declaration to a RecordDefinition that has
# (a family member of) the declaration as a member.

# With no care for the space use we could make a stored derived predicated from
# reversing the RecordDefinitions members, but since we care about space
# let's perform this search on the fly.
#
# This is quite an elaborate search, for the following reasons:
#
# - We have a Declaration R::F
# - A corresponding RecordDefinition can be found by searching for
#   RecordDefinition { declaration = { name = R }}
# - But there might be multiple of these (due to CPP, templates etc.),
#   and some of them might not even contain R::F, so we have to find a
#   correct one by searching for our R::F amongst the members.
# - Furthermore, since the members might not contain our R::F but another
#   decl in the same DeclFamily, we have to look up the family of R::F too.
#
# See T68843402 for progress on each declaration type.
#
# It might be worth swapping the order of the DeclFamilyOf and
# RecordDefinition queries, but to do that we would need to prove
# that all decl D in a family share an identical scope.

predicate DeclInRecord :
  {
    decl : Declaration,
    record : RecordDefinition,
  }
  {DeclIn, Record}
  where
  DeclFamilyOf{decl=DeclIn, family=Decl};

  Scope{recordWithAccess={record=QN}} =
    # Declaration{namespace} cannot be in a record
    # Declaration{objcContainer} cannot be in a record
    # Declaration{ObjcMethodDeclaration} cannot be in a record
    # Declaration{ObjcPropertyDeclaration} cannot be in a record
    (
      S where { usingDeclaration = X } = Decl;
      UsingDeclaration{name = FQN} = X;
      FunctionQName{scope = S} = FQN;
    ) | (
      S where { usingDirective = X } = Decl;
      UsingDirective{name = QN} = X;
      QName{scope = S} = QN
    ) | (
      S where { record_ = X } = Decl;
      RecordDeclaration{name = QN} = X;
      QName{scope = S} = QN
    ) | (
      S where { enum_ = X } = Decl;
      EnumDeclaration{name = QN} = X;
      QName{scope = S} = QN
    ) | (
      S where { function_ = X } = Decl;
      FunctionDeclaration{name = FQN} = X;
      FunctionQName{scope = S} = FQN;
    ) | (
      S where { variable = X } = Decl;
      VariableDeclaration{name = QN} = X;
      QName{scope = S} = QN
    ) | (
      S where { typeAlias = X } = Decl;
      TypeAliasDeclaration{name = QN} = X;
      QName{scope = S} = QN
    );
  Record = RecordDefinition{declaration={name = QN}, members=Decls};
  Decls = Declarations DS;
  Decl = DS[..];

# This is a work-around until RecordDefinition{members} is more
# complete.
# See T68843402 for progress on completing this.
#
# This is a fallback search, needed because the indexer is not putting all the
# declarations into Record{members}.
#
# The fallback is used to find the record with the right name in the right file.
#
# The right name alone is not enough ( consider how many Config, Env,
# ThriftSource, Backend types we have in Glean ). But the same QName in the same
# file is accurate enough for a fallback search.  To get more precise the client
# can compare byte ranges (which angle cannot do).
predicate DeclImpliesRecord :
  {
    decl : Declaration,
    record : RecordDefinition,
  }
  {DeclIn, Record}
  where
  DeclFamilyOf{decl=DeclIn, family=Decl};

  {Scope{recordWithAccess={record=QN}}, src.Range{file = File}} =
    # Declaration{namespace} cannot be in a record
    # Declaration{objcContainer} cannot be in a record
    # Declaration{ObjcMethodDeclaration} cannot be in a record
    # Declaration{ObjcPropertyDeclaration} cannot be in a record
    (
      {S, Src} where { usingDeclaration = X } = Decl;
      UsingDeclaration{name = FQN, source = Src} = X;
      FunctionQName{scope = S} = FQN;
    ) | (
      {S, Src} where { usingDirective = X } = Decl;
      UsingDirective{name = QN, source = Src} = X;
      QName{scope = S} = QN
    ) | (
      {S, Src} where { record_ = X } = Decl;
      RecordDeclaration{name = QN, source = Src} = X;
      QName{scope = S} = QN
    ) | (
      {S, Src} where { enum_ = X } = Decl;
      EnumDeclaration{name = QN, source = Src} = X;
      QName{scope = S} = QN
    ) | (
      {S, Src} where { function_ = X } = Decl;
      FunctionDeclaration{name = FQN, source = Src} = X;
      FunctionQName{scope = S} = FQN;
    ) | (
      {S, Src} where { variable = X } = Decl;
      VariableDeclaration{name = QN, source = Src} = X;
      QName{scope = S} = QN
    ) | (
      {S, Src} where { typeAlias = X } = Decl;
      TypeAliasDeclaration{name = QN, source = Src} = X;
      QName{scope = S} = QN
    );
  Record = RecordDefinition{declaration={name = QN, source = Src}};
  src.Range{file = File} = Src;

# This allows going from a objc method or property declaration
# to a definition that contains a family member of the declaration.
#
# If we could prove all decl D in a family share an
# identical container id then we could change the order
# of the queries for the DeclFamilyOf and ObjcContainerDefinition.
#
#  With no care for the space use we could make a stored derived predicated from
# reversing the RecordDefinitions members.  Since we care about space we can
# narrow the search space and then check the members.
predicate DeclInObjcContainer :
  {
    decl : Declaration,
    record : ObjcContainerDefinition,
  }
  {DeclIn, Container}
  where
  DeclFamilyOf{decl=DeclIn, family=Decl};

  CId =
    (
      CId where { objcMethod = X } = Decl;
      ObjcMethodDeclaration{container = CId} = X;
    ) | (
      CId where { objcProperty = X } = Decl;
      ObjcPropertyDeclaration{container = CId} = X;
    );
  Container = ObjcContainerDefinition{declaration={id = CId}, members=Decls};
  Decls = Declarations DS;
  Decl = DS[..];

# This allows going from an enumerator to the enum definition(s) that
# contain the enumerator.
#
#  With no care for the space use we could make a stored derived predicated from
# reversing the RecordDefinitions members.  Since we care about space we can
# narrow the search space and then check the enmerators list.
predicate EnumeratorInEnum :
  {
    enumerator : Enumerator,
    enum_ : EnumDefinition
  }
  {EnumeratorIn, EnumDefOut}
  where
    Enumerator{enumeration = Decl} = EnumeratorIn;
    EnumDefOut = EnumDefinition{declaration = Decl, enumerators = Enums};
    EnumeratorIn = Enums[..]

# Given a Declaration (in some file), find the Trace(s) (in that file) that
# contain the Declaration. Very useful for looking up members of a namespace.
predicate DeclarationInTrace :
  {
    decl : Declaration,
    trace : Trace
  }
  {Decl, T}
  where
  DeclarationSrcRange{decl = Decl, source = {file = F}};
  T = Trace{file = F, declarations = Decls};
  Decls = Declarations DS;
  Decl = DS[..]

predicate ObjcContainerBase :
    {
        declaration : ObjcContainerDeclaration,
        base : ObjcContainerDeclaration,
    }

predicate ObjcContainerInheritance :
    {
        base : ObjcContainerDeclaration,
        declaration : ObjcContainerDeclaration,
    }
    stored
    { Base, Decl }
    where
      ObjcContainerBase { Decl, Base }

predicate Attribute : string

predicate FunctionAttribute :
    {
        attr : Attribute,
        declaration : FunctionDeclaration,
    }

} # end schema cxx1.4
