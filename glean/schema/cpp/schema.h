#pragma once
// @generated
// Glean.Schema.Gen.Cpp definitions for fbcode/glean/lang/clang/schema.h
// by //glean/hs:predicates using --cpp

#include <tuple>
#include <boost/variant.hpp>
#include "glean/cpp/glean.h"



namespace facebook {

namespace glean {

namespace cpp {

namespace schema {

constexpr int version = 10;

namespace Thrift {

struct XRefTarget;

struct TypedConst;

struct TypedConstT;

struct UnionFieldVal;

struct UnionVal;

struct TypeDefType;

struct ToPython;

struct ToHack;

struct ToCpp2;

struct StructuredAnnotation;

struct StructFieldValValue;

struct StructFieldVal;

struct StructVal;

struct ServiceParent;

struct ServiceDefinition;

struct ServiceChild;

struct SearchByName;

enum class Qualifier;

struct QualName;

struct PythonValue;

struct PythonName;

struct PythonModuleFile;

struct PythonModuleContains;

struct PythonModule;

struct PythonMethod;

struct PythonItem;

struct PythonFunction;

struct PythonFileModule;

struct PythonField;

struct PythonClassContains;

struct PythonClass;

enum class PrimitiveType;

struct OutputTarget;

struct NamespaceValue;

struct NamespaceName;

struct Namespace;

enum class NamedKind;

struct NamedType;

struct NameLowerCase;

struct MapType;

struct MangleLang;

struct Mangle;

struct Loc;

struct NamedDecl;

struct ServiceName;

struct Target;

struct TargetX;

struct XRef;

struct Lang;

struct KeyValue;

struct Item;

struct IntegerLiteral;

struct Includes;

struct IncludeStatement;

struct IncludeSplice;

struct IncludeSpecial;

struct Identifier;

enum class HackRecordKind;

struct HackRecordContains;

struct HackRecord;

struct HackName;

struct HackMethod;

enum class HackMapKind;

struct HackMap;

struct HackKind;

enum class GenRole;

struct FunctionName;

struct FromPython;

struct FromHack;

struct FloatLiteral;

struct Literal;

struct FileXRefs;

struct FileTarget;

struct FileOutput;

struct FileError;

struct File;

struct FieldSpecification;

struct StructType;

struct UnqualField;

struct UnionType;

struct ExceptionVal;

struct ExceptionType;

struct ExceptionSpecName;

struct ExceptionSpecification;

struct ResultStream;

struct TypeDefException;

struct ExceptionName;

struct EnumerationType;

struct EnumValueDef;

struct EnumValue;

struct EnumVal;

struct DeclarationName;

struct DeclarationNameSpan;

struct FileDeclaration;

struct FunctionDeclarationName;

struct Cpp2ItemNamed;

struct ContainerType;

struct TypeSpecification;

struct ConstantType;

struct Constant;

struct CompileTarget;

} // namespace Thrift

namespace Testinfra {

struct TestId;

struct TaggedAssembly;

struct Tag;

struct OffsetSpan;

struct MeasuredFileOnly;

struct MeasuredFile;

enum class HashAlgo;

struct Folder;

struct FileLength;

struct FileHash;

struct FbId;

struct DatabaseMetadataField;

struct DatabaseMetadata;

struct CoveredOrLoadedFileTestIds;

struct CoveredFolder;

struct CoveredFileTestIds;

struct CoveredFileTestIds_4;

struct CoveredFileOnly;

struct CoveredFileByTagAndAssembly;

struct CoveredFileByPushBlockingAssembly;

struct CoveredFileAssemblies;

struct CoveredAssembly;

struct CoverageRange;

struct FileMetadata_2;

struct FileMetadata;

struct CoverageGranularity;

struct CoveredFile;

struct ContainsPushBlockingAssembly;

struct AssemblyId;

struct AssemblyByTag;

struct Assemblies;

} // namespace Testinfra

namespace Sys {

struct Blob;

} // namespace Sys

namespace Src {

struct RelByteSpan;

struct Range;

struct RangeContains;

struct PackedByteSpansGroup;

struct Loc;

enum class Language;

enum class IndexFailureReason;

struct IndexFailure;

struct FileLines;

struct FileLanguage;

struct FileDigest;

struct File;

struct ByteSpan;

struct ByteSpanContains;

struct FileLocation;

struct ByteRange;

} // namespace Src

namespace Spark {

namespace Ts {

struct VersionedCapability;

struct Version;

struct Type;

struct SymbolName;

struct SymbolInfoDef;

struct SymbolVersions;

struct SymbolCapabilities;

struct Symbol;

struct SymbolInfo;

struct SymbolLocation;

struct SymbolLocationInherited;

struct SymbolXRef;

struct SparkModule;

struct SignatureXRefs;

struct Signature;

enum class ReleaseStatus;

struct SymbolStatus;

struct PropertyExtDecl;

struct PropertyDeclaration;

struct PropertyInfo;

struct Name;

struct ModuleSymbol;

struct ModuleFiles;

struct ModuleExports;

struct ModuleBase;

struct MethodExtDecl;

struct MethodDeclaration;

struct MethodInfo;

struct InheritsFrom;

struct ExtDecl;

struct ExtDeclScope;

struct ExampleCode;

struct EnumeratorInfo;

struct EnumeratorDecl;

struct EnumInfo;

struct EnumDecl;

enum class DocumentType;

struct GatingInfo;

struct DocXRefs;

struct DocString;

struct DocLocationInherited;

struct DocLocation;

struct Doc;

struct Container;

struct Contains;

struct MethodDecl;

struct PropertyDecl;

struct ClassInfo;

struct ClassDecl;

struct ChangeKeyVersion;

struct ChangeKeyInfo;

struct ChangeKey;

struct CapabilityName;

enum class CapabilityConditionType;

struct CapabilityConditionResult;

struct CapabilityCondition;

struct Capability;

struct AccessorExtDecl;

struct AccessorDeclaration;

struct AccessorInfo;

struct AccessorDecl;

} // namespace Ts

} // namespace Spark

namespace Search {

namespace Python {

struct QueryToScopeCase;

struct PythonNameCase;

} // namespace Python

namespace Pp {

struct SearchByName;

struct SearchByName_1;

} // namespace Pp

namespace Java {

struct QueryToScopeCase;

struct NameCase;

} // namespace Java

namespace Hack {

struct QueryToScopeCase;

struct HackNameCase;

struct HackInAutoImportedNamespace;

} // namespace Hack

namespace Flow {

struct TypeDeclarationAsDeclaration;

struct QueryToScopeCase;

struct FlowModuleNameCase;

} // namespace Flow

namespace Cxx {

struct QueryToQNameCase;

struct QueryToNSQNameCase;

struct CxxNameCase;

} // namespace Cxx

} // namespace Search

namespace Scm {

struct Timestamp;

struct Rev;

struct RepoType;

struct RepoName;

struct Repo;

struct Commit;

} // namespace Scm

namespace Scip {

enum class TextEncoding;

struct SymbolName;

struct SymbolDocumentation;

struct Symbol;

struct SomeEntity;

struct ReferenceTarget;

struct Reference;

enum class ProtocolVersion;

struct Location;

struct LocalName;

struct Entity;

struct EntityDefinition;

struct EntityLocation;

struct EntityUses;

struct FileEntityXRefLocation;

struct ResolveLocation;

struct SearchBySymbol;

struct Documentation;

struct DefinitionUses;

struct DefinitionName;

struct DefinitionDocumentation;

struct Definition;

} // namespace Scip

namespace Python {

struct XRefViaName;

struct XRefsViaNameByFile;

struct VariableDeclaration;

struct VariableBySName;

struct TypeInfo;

struct Type;

struct StringLiteral;

struct SNameToName;

struct SName;

struct ResolveOriginalName;

struct Parameter;

struct NameToSName;

struct Name;

struct ModuleDefinition;

struct ModuleBySName;

struct Module;

struct MethodWithLocalName;

struct MethodOverrides;

struct MethodOverriden;

struct LocalNameLowerCase;

struct LocalName;

struct ImportStatementByAsSName;

struct ImportStatementByAsName;

struct ImportStatement;

struct ImportStarsByFile;

struct ImportStarStatement;

struct ImportStarLocation;

struct FunctionDeclaration;

struct FunctionBySName;

struct DerivedClassToBase;

struct Definition;

struct DefinitionLocation;

struct DefinitionsByFile;

struct IsTopLevelDefinition;

struct DeclarationContainer;

struct FunctionDefinition;

struct VariableDefinition;

struct Declaration;

struct DeclarationDefinition;

struct DeclarationDocstring;

struct DeclarationLocation;

struct DeclarationReference;

struct DeclarationToName;

struct DeclarationUses;

struct DeclarationWithLocalName;

struct DeclarationWithName;

struct DeclarationWithSName;

struct DeclarationsByFile;

struct DefinitionDeclaration;

struct DirectXRef;

struct DirectXRefsByFile;

struct IsAbstract;

struct IsTopLevelDeclaration;

struct NonImportDeclaration;

struct SNameWithDeclaration;

struct SearchByLocalName;

struct Contains;

struct ContainingTopLevelDeclaration;

struct ContainedByTopLevelDeclaration;

struct ContainedBy;

struct ClassDefinition;

struct ClassDeclaration;

struct ClassBySName;

struct CalleeToCaller;

struct BaseClassToDerived;

struct Argument;

struct CallArgument;

struct FileCall;

} // namespace Python

namespace Pp1 {

struct Use;

struct Undef;

struct Macro;

struct Include;

struct DefineUse;

struct Define;

} // namespace Pp1

namespace Perf {

namespace Hack {

struct ReturnCount;

struct ReturnPercentages;

struct LoopCount;

struct LoopCounts;

struct FunctionProducts;

struct FileLine;

struct FunctionCallers;

struct FunctionData;

} // namespace Hack

} // namespace Perf

namespace Omegaanalyser {

struct PolicyOncall;

struct OncallName;

struct OmegaPolicy;

struct OmegaEndpoint;

struct Node;

struct Method;

struct Function_;

struct EndpointOncall;

struct DependencyPathByCoreNode;

struct DependencyPath;

struct DependencyList;

struct Config;

struct Class_;

} // namespace Omegaanalyser

namespace Omega {

struct Oncall;

struct OmegaPolicy;

struct OmegaExecutionNode;

struct OmegaEntity;

struct OmegaEntityMetadata;

struct OmegaEndpoint;

struct OmegaBlock;

struct OmegaAction;

struct Name;

struct Method;

struct GraphNode;

struct Function_;

struct Enum_;

struct DependencyPathByEntity;

struct DependencyPath;

struct DependencyList;

struct Config;

struct Class_;

} // namespace Omega

namespace Monk {

struct Xid;

enum class PrivacySensitivityKind;

struct PiiLoggerXid;

struct HackPiiLoggerTraitXid;

struct HackPiiLoggerSetterXid;

struct HackPiiLoggerSetterCallXid;

struct HackPiiLoggerClassXid;

struct HackPiiLogCallXid;

struct HackPiiLog;

struct HackPiiFunc;

struct HackMethodByName;

struct HackLoggerMethod;

} // namespace Monk

namespace Lsif {

namespace Types {

struct ToolInfo;

} // namespace Types

} // namespace Lsif

namespace Scip {

struct Metadata;

} // namespace Scip

namespace Lsif {

namespace Types {

enum class SymbolKind;

} // namespace Types

} // namespace Lsif

namespace Scip {

struct EntityKind;

struct SymbolKind;

} // namespace Scip

namespace Lsif {

namespace Types {

struct RangeSpan;

struct ToSrcRange;

} // namespace Types

} // namespace Lsif

namespace Scip {

struct DefinitionLocation;

struct FileRange;

struct ReferenceLocation;

} // namespace Scip

namespace Lsif {

namespace Types {

enum class LanguageId;

} // namespace Types

} // namespace Lsif

namespace Scip {

struct FileLanguage;

struct TagDefinition;

} // namespace Scip

namespace Lsif {

namespace Types {

struct FromSrcRange;

} // namespace Types

struct SomeEntity;

struct Reference;

struct Range;

struct ProjectDocument;

struct Project;

struct PackageInformation;

struct NameLowerCase;

struct NameDefinition;

struct Name;

struct MonikerSymbolKind;

struct MonikerScheme;

enum class MonikerKind;

struct MonikerId;

struct MonikerDefinition;

struct Moniker;

struct Metadata;

struct Location;

struct HoverText;

struct HoverContent;

struct Entity;

struct EntityDefinition;

struct EntityKind;

struct EntityLocation;

struct EntityUses;

struct FileEntityXRefLocation;

struct ResolveLocation;

struct SearchByExactLocation;

struct SearchByExactLocationAndName;

struct SearchByMoniker;

struct SearchByName;

struct SearchNonLocalByLocation;

struct TagDefinition;

struct Document;

struct DefinitionUse;

struct DefinitionMoniker;

struct DefinitionLocation;

struct DefinitionKind;

struct DefinitionHover;

struct Definition;

struct Declaration;

} // namespace Lsif

namespace Kotlin {

namespace Alpha {

struct VariableParent;

struct VariableDeclaration;

struct TypeArg;

struct Type;

struct DeclarationLocation;

struct Declaration;

struct DeclarationFileLocation;

struct ExtendsDeclaration;

struct FileDeclarations;

struct MethodDeclaration;

struct ParentDeclaration;

} // namespace Alpha

} // namespace Kotlin

namespace Search {

namespace Kotlin {

struct SearchByQName;

} // namespace Kotlin

} // namespace Search

namespace Symbolid {

namespace Kotlin {

struct LookupDeclaration;

struct LookupMethodDeclaration;

} // namespace Kotlin

} // namespace Symbolid

namespace Kotlin {

namespace Alpha {

struct ContainsDeclaration;

struct ClassMember;

struct ClassDeclaration;

} // namespace Alpha

} // namespace Kotlin

namespace Javakotlin {

namespace Alpha {

struct Type;

struct QName;

struct Path;

struct NameLowerCase;

struct Name;

struct MethodName;

} // namespace Alpha

} // namespace Javakotlin

namespace Java {

namespace Alpha {

struct XRefTarget;

struct XRefFile;

struct XRef;

struct Wildcard;

struct TypeVar;

struct TypeParam;

struct TypeOfTypeArgs;

struct TypeArg;

struct PrimitiveType;

struct PackageDeclaration;

struct ObjectType;

enum class Modifier;

struct ParameterDeclaration;

struct InterfaceInheritance;

struct Inheritance;

struct ImportDeclaration;

struct FileXRefs;

struct ExecutableDefinition;

struct ExecutableDefnLocation;

struct LocalDeclaration;

struct Definition;

struct DefinitionLocation;

struct EnumDeclaration;

struct FieldDeclaration;

struct InterfaceDeclaration;

struct MethodDeclaration;

struct Declaration;

struct DeclarationAnnotations;

struct DeclarationComment;

struct DeclarationLocation;

struct DeclarationType;

struct DeclarationUses;

struct DeclarationXRefTarget;

struct ExtendedByDeclaration;

struct ExtendsDeclaration;

struct FileDeclarations;

struct ParentDeclaration;

struct QNameToDefinition;

struct XRefOfType;

struct XRefTargetDeclaration;

} // namespace Alpha

} // namespace Java

namespace Search {

namespace Java {

struct SearchByQName;

} // namespace Java

} // namespace Search

namespace Symbolid {

namespace Java {

struct LookupDeclaration;

struct LookupMethodDeclaration;

} // namespace Java

} // namespace Symbolid

namespace Java {

namespace Alpha {

struct DeclOfExecutableDefn;

struct DeclOfDefn;

struct ContainsDeclaration;

struct ConstructorDeclaration;

struct ClassDeclaration;

struct BaseType;

struct Type;

struct ArrayType;

struct Annotation;

struct AnnotatedClass;

} // namespace Alpha

} // namespace Java

namespace Indexer {

struct Config;

} // namespace Indexer

namespace Hs {

struct XRefTarget;

struct XReference;

struct XRef;

struct Type;

struct TargetUses;

struct SourceModule;

struct PackageId;

struct ModuleNameLowerCase;

struct ModuleName;

struct ModuleDefinitions;

struct Module;

struct FunctionNameLowerCase;

struct FunctionName;

struct FunctionDefinition;

struct FileXRefMap;

struct DefinitionNameLowerCase;

struct DefinitionName;

struct DefinitionEntity;

struct DefinitionLocation;

struct FileDefinition;

struct Definition;

struct Definition_1;

struct ClassNameLowerCase;

struct ClassName;

struct ClassInstance;

struct Class;

} // namespace Hs

namespace Haxlanalyser {

struct ThriftResponse;

struct ThriftFetch;

struct TestFile;

struct TallyName;

enum class TallyCounterType;

struct TallyConfig;

struct Tally;

struct TallyFetch;

struct TallyResponse;

struct SitevarFetch;

struct ScubaResponse;

struct ScribeResponse;

struct RestrictionResponse;

struct Response;

struct PolicyName;

struct Policy;

struct PiranhaResponse;

struct LogFeatureResponse;

struct LaserDataset;

struct JankyJSONResponse;

struct InputKey;

struct InputFetch;

struct HiveResponse;

struct Fetch;

struct Node;

struct FeatureSetFeature;

struct EndpointName;

struct Endpoint;

struct Edge;

struct ContextName;

struct Context;

struct ConfigeratorFetch;

struct ClassifierRead;

struct ClassifierFetch;

struct Call;

struct ACDCPropertyAccess;

struct ACDCProperty;

} // namespace Haxlanalyser

namespace Hackdependency {

struct name;

struct inheritance;

} // namespace Hackdependency

namespace Hack {

enum class Visibility;

enum class Variance;

struct UserAttribute;

struct TypedefDeclaration;

enum class TypeConstKind;

struct TypeConstDefinition;

struct Type;

struct TraitDeclaration;

struct StringLiteral;

enum class ReifyKind;

enum class ReadonlyKind;

struct QName;

struct PropertyDefinition;

struct Parameter;

struct Signature;

struct Occurrence;

struct NamespaceQName;

struct NamespaceDeclaration;

struct NameLowerCase;

struct Name;

struct ModuleMembership;

struct ModuleDefinition;

struct ModuleDeclaration;

struct MethodOverrides;

struct MethodOverridden;

struct MethodOccurrence;

struct InterfaceDeclaration;

struct IndexerInputsHash;

struct GlobalNamespaceAlias;

struct GlobalConstDefinition;

struct GlobalConstDeclaration;

struct FunctionDeclaration;

struct Enumerator;

struct EnumDefinition;

struct EnumDeclaration;

struct Definition;

struct Context_;

struct ContainerDeclaration;

struct ContainerDeclarationQName;

struct ContainerParent;

struct Declaration;

struct DeclarationComment;

struct DeclarationLocation;

struct DeclarationName;

struct DeclarationNamespace;

struct DeclarationSource;

struct DeclarationSpan;

struct DeclarationTarget;

struct FileDeclarations;

struct MemberCluster;

struct ModuleChild;

struct ModuleParent;

struct NamespaceMember;

struct XRefTarget;

struct TargetUses;

struct TargetUsesAbs;

struct XRef;

struct FileXRefs;

struct TypeInfo;

} // namespace Hack

namespace Monk {

struct HackCaller;

struct HackIsCaller;

} // namespace Monk

namespace Omega {

struct TargetNodeLocations;

} // namespace Omega

namespace Omegaanalyser {

struct ClassStaticMethodReferences;

struct TargetNodeLocations;

} // namespace Omegaanalyser

namespace Search {

namespace Hack {

struct SearchByName;

struct SearchFunctionInNamespace;

struct SearchGlobalConstInNamespace;

struct SearchInContainer;

struct SearchInContainerNoProperty;

struct SearchInContainerOrEnum;

struct SearchInContainerOrEnumNoProperty;

struct SearchInContext;

struct SearchInEnum;

struct SearchInNamespace;

struct SearchModule;

struct SearchNamespace;

struct SearchNamespacedDecl;

struct SearchPropertyInContainer;

struct SearchTypeInNamespace;

} // namespace Hack

} // namespace Search

namespace Hack {

struct InheritedMembers;

struct MethodDeclaration;

struct PropertyDeclaration;

struct TypeConstDeclaration;

struct ContainerChild;

enum class ConstraintKind;

struct Constraint;

struct TypeParameter;

struct FunctionDefinition;

struct InterfaceDefinition;

struct MethodDefinition;

struct TraitDefinition;

struct TypedefDefinition;

struct ClassDefinition;

struct ClassDeclaration;

struct ClassConstDefinition;

struct ClassConstDeclaration;

struct AttributeToDefinition;

struct AttributeToDeclaration;

struct AttributeHasParameter;

struct Argument;

struct CallArgument;

struct FileCall;

} // namespace Hack

namespace Graphql {

struct VariableDef;

struct Value;

struct UnionTypeDef;

struct SelectionSet;

struct ScalarTypeDef;

enum class OperationKind;

struct Operation;

struct ObjectTypeDef;

struct NameLowerCase;

struct InterfaceTypeDef;

struct InputValueDef;

struct InputObjectTypeDef;

struct InlineFragment;

struct FragmentSpread;

struct Fragment;

struct FieldDef;

struct Field;

struct EnumTypeDef;

enum class DirectiveDefLocation;

struct DirectiveDef;

struct Directive;

struct Declaration;

struct DeclarationLocation;

struct DeclarationName;

struct DeclarationUses;

struct FileDeclarations;

struct SearchByName;

struct XRef;

struct FileXRefs;

struct DeclHasName;

struct BelongToConfig;

struct Argument;

} // namespace Graphql

namespace Glean {

namespace Test {

struct nothingTest;

struct WrappedStringPair;

struct ViaStringPair;

struct Unbound2;

struct Unbound;

struct TreeToTree;

struct Tree;

struct Sum_;

struct StringPairBox;

struct StringPair;

struct StoredRevStringPairWithRev;

struct StoredRevStringPairWithA;

struct StoredRevStringPairSum;

struct StoredRevStringPair;

struct StoredDualStringPair;

struct SkipRevEdge;

struct SameString;

struct RevStringPairs;

struct RevStringPairRec;

struct RevStringPair;

struct RevRevStringPair;

struct RevEdge;

struct ReflStringPair;

struct RefRef;

struct Ref;

struct Qux;

struct NodePair;

struct Node;

struct Name;

struct MatchOneAlt;

struct LeftOr2;

struct LeftOr;

struct KeyValue;

struct IsThree;

struct IsParent;

struct IsGlean;

struct FooToFoo;

struct Foo;

struct Expr;

enum class Enum_;

struct Rec;

struct KitchenSink_1;

struct Predicate_1;

struct EmptyStoredStringPair;

struct EdgeWrapper;

struct EdgeSum;

struct Edge;

struct DualStringPair;

struct DerivedKeyValue2;

struct DerivedKeyValue;

struct Bar;

enum class KitchenSink_enum_;

struct KitchenSink;

struct Predicate_;

} // namespace Test

} // namespace Glean

namespace Gencode {

enum class GenCodeVariant;

struct GenCodeSignature;

struct GenCodeCommand;

struct GenCodeClass;

struct GenCodeBySource;

struct GenCode;

} // namespace Gencode

namespace Flow {

struct XRef;

struct TypeImportDeclaration;

struct TypeExport;

struct TypeDeclarationReference;

struct TypeDeclarationInfo;

struct TypeDeclaration;

struct Type;

struct StringToFileModule;

struct SourceOfTypeExport;

struct SourceOfExport;

struct SomeDeclaration;

struct SomeEntity;

} // namespace Flow

namespace Search {

namespace Flow {

struct FlowSearchByNameNonImport;

} // namespace Flow

} // namespace Search

namespace Flow {

struct SearchTypeByModuleExport;

struct SearchByNameModule;

struct SearchByName;

struct SearchByModule;

struct SearchByFileModule;

struct Range;

struct NameLowerCase;

struct Name;

struct ModuleTypeExport;

struct ModuleNameLowerCase;

struct ModuleLocationByFile;

struct ModuleLocation;

struct ModuleExport;

struct ModuleDoc;

struct ModuleContains;

struct ModuleComments;

struct Module;

struct MemberDeclarationReference;

struct MemberDeclarationInfo;

struct MemberDeclaration;

struct LocalDeclarationReference;

struct ImportDeclaration;

struct FlowXRefDeclInfo;

struct FlowTypeImportXRef;

struct FlowTypeExportLocation;

struct FlowTypeEntityImportUses;

struct FlowSameModule;

struct FlowModuleNamespaceXRef;

struct FlowImportXRef;

struct FlowExportLocation;

struct FlowEntityUsesAll;

struct FlowEntityImportUses;

struct FlowCompatibleExport;

struct FileXRef;

struct FileOfStringModule;

struct FileDeclaration;

struct Export;

struct Documentation;

struct DeclarationUses;

struct DeclarationSignature;

struct DeclarationNameSpan;

struct DeclarationLocation;

struct DeclarationInfo;

struct Declaration;

} // namespace Flow

namespace Fbthrift {

struct XRefTarget;

struct TypedConst;

struct TypedConstT;

struct UnionFieldVal;

struct UnionVal;

struct Target;

struct StructuredAnnotation;

struct StructFieldValValue;

struct StructFieldVal;

struct StructVal;

struct ServiceParent;

struct ServiceName;

struct ServiceInteractionFunctions;

struct ServiceDefinition;

struct ServiceChild;

struct SearchByName;

struct ResultSink;

enum class Qualifier;

struct QualName;

enum class PrimitiveType;

struct PackageName;

struct Package;

struct NamespaceValue;

struct NamespaceName;

struct Namespace;

enum class NamedKind;

struct NamedType;

struct NamedDecl;

struct NameLowerCase;

struct MapType;

struct Loc;

struct XRef;

struct KeyValue;

struct InteractionName;

struct InteractionDefinition;

struct IntegerLiteral;

struct Identifier;

struct FunctionName;

struct FloatLiteral;

struct Literal;

struct FileXRefs;

struct File;

struct FieldSpecification;

struct StructType;

struct UnqualField;

struct UnionType;

struct ExceptionVal;

struct ExceptionType;

struct ExceptionSpecName;

struct ExceptionSpecification;

struct ResultStream;

struct TypeDefException;

struct ExceptionName;

struct EnumerationType;

struct EnumValueDef;

struct EnumValue;

struct EnumVal;

struct DeclarationComment;

struct DeclarationFile;

struct DeclarationName;

struct DeclarationNameSpan;

struct DeclarationUses;

struct FileDeclaration;

struct FunctionDeclarationName;

} // namespace Fbthrift

namespace Hack {

struct HackToThrift;

struct ThriftToHack;

} // namespace Hack

namespace Fbthrift {

struct ContainerType;

struct TypeSpecification;

struct Constant;

} // namespace Fbthrift

namespace Erlang {

struct NameLowerCase;

struct Fqn;

struct FunctionDeclaration;

struct XRefViaFqn;

struct XRefsViaFqnByFile;

struct DeclarationComment;

struct Declaration;

struct DeclarationLocation;

struct DeclarationReference;

struct DeclarationToFqn;

struct DeclarationUses;

struct DeclarationWithFqn;

struct DeclarationsByFile;

struct SearchByName;

} // namespace Erlang

namespace Dyn {

enum class Usage;

struct ObserverIdentifier;

struct Observer;

struct Environment;

struct EntityDynamicReference;

} // namespace Dyn

namespace Digest {

struct Digest;

struct FileDigest;

} // namespace Digest

namespace Glass {

struct FileMetadata;

struct FileInfo;

} // namespace Glass

namespace Deadcode {

enum class GraphType;

struct GraphNodeByEntity;

struct GraphNode;

struct GraphInverseEdge;

struct GraphEntityByFile;

struct GraphEdge;

} // namespace Deadcode

namespace Cxx1 {

struct XRefVia;

struct UsingDirective;

struct UsingDeclaration;

enum class TypeAliasKind;

struct TypeAliasDeclaration;

struct Type;

struct TranslationUnitXRefs;

struct TranslationUnitTrace;

struct TranslationUnitIncludeTree;

struct Trace;

enum class RefQualifier;

struct RecordDerived;

struct PpEntity;

struct Parameter;

struct Signature;

struct PPDefineLocation;

struct ObjcSelectorSlot;

struct ObjcSelector;

enum class ObjcPropertyKind;

struct ObjcPropertyImplementation;

struct ObjcPropertyIVar;

struct ObjcMethodDefinition;

struct ObjcMethodDeclarationName;

struct ObjcInterfaceToImplementation;

struct ObjcImplements;

struct ObjcIVar;

struct ObjcContainerInheritance;

struct ObjcContainerDefinition;

struct ObjcContainerBase;

struct ObjcCategoryId;

struct ObjcContainerId;

struct ObjcContainerDeclaration;

struct ObjcMethodDeclaration;

struct ObjcPropertyDeclaration;

struct ObjContainerIdName;

struct NamespaceTarget;

struct NamespaceQName;

struct NamespaceDefinition;

struct NamespaceDeclarationName;

struct NamespaceDeclaration;

struct NamespaceAliasDeclaration;

struct Name;

struct MethodSignature;

struct MethodOverrides;

struct MethodOverridden;

struct MaybeIncludeTree;

enum class LocalVariableKind;

enum class LocalVariableAttribute;

struct LocalVariable;

struct IncludeTree;

struct IncludeTrace;

struct PPEvent;

struct PPTrace;

enum class GlobalVariableKind;

enum class GlobalVariableAttribute;

struct GlobalVariable;

struct FunctionDefinition;

struct FunctionDeclarationNameString;

struct FunctionDeclarationName;

struct FunctionDeclaration;

struct FunctionDeclAttribute;

struct FunctionAttribute;

struct From;

struct FileXRefs;

struct FilePPUseXRefs;

struct FilePPUseTraceXRefs;

struct FilePPTraceXRefs;

struct Field;

struct VariableKind;

struct VariableDeclaration;

struct EnumeratorInEnum;

struct Enumerator;

struct EnumDefinition;

struct EnumDeclaration;

struct DefinitionEntity;

struct DefnInRecord;

struct Declaration;

struct DeclarationComment;

struct DeclarationInTrace;

struct DeclarationLocationName;

struct DeclarationLocationNameSpan;

struct DeclarationNameSpan;

struct DeclarationSources;

struct DeclarationSrcRange;

struct DeclarationTargets;

struct DeclarationToUSR;

struct Declarations;

struct DefToBaseDecl;

struct Same;

struct USRToDeclaration;

struct XRefTarget;

struct FixedXRef;

struct FileXRefMap;

struct SpellingXRef;

struct TargetUses;

struct XRefIndirectTarget;

struct XRefTargets;

} // namespace Cxx1

namespace Search {

namespace Cxx {

struct GlobalDeclarationWithName;

} // namespace Cxx

} // namespace Search

namespace Symbolid {

namespace Cxx {

struct LookupNamespaceDeclaration;

} // namespace Cxx

} // namespace Symbolid

namespace Thrift {

struct Cpp2Item;

struct FromCpp2;

} // namespace Thrift

namespace Cxx1 {

struct DeclToFamily;

enum class DeclKind;

struct DeclInRecord;

struct DeclInObjcContainer;

struct DeclIdent;

struct DeclFamilyOf;

struct DeclFamily;

struct DeclByName;

struct CxxToThrift;

struct Attribute;

enum class Access;

struct RecordBase;

struct RecordDefinition;

} // namespace Cxx1

namespace Csharp {

enum class Variance;

enum class UnityPackageType;

struct UnityPackageToProject;

struct UnityPackage;

enum class UnityAssemblyType;

struct UnityProjectSource;

struct TypeParameter;

struct SourceFileToProject;

struct SolutionToProject;

struct Solution;

enum class RefKind;

struct ProjectToSourceFile;

struct ProjectToSolution;

struct ProjectSource;

struct Project;

struct Namespace;

struct NamedType;

struct NameLowerCase;

struct Name;

enum class MethodKind;

struct MethodInvocationExpression;

struct MemberAccessExpression;

struct MSBuildProjectSource;

struct Location;

struct MemberAccessLocation;

struct MethodInvocationLocation;

struct Implements;

struct FunctionPointerType;

struct FullName;

enum class Accessibility;

struct Class;

struct Interface;

struct Record;

struct Struct;

struct AType;

struct ArrayType;

struct Definition;

struct DefinitionLocation;

struct DefinitionLocationName;

struct FileDefinitions;

struct FileEntityXRefs;

struct SearchByName;

struct Field;

struct Local;

struct Method;

struct ObjectCreationLocation;

struct Parameter;

struct PointerType;

struct Property;

struct TypeLocation;

} // namespace Csharp

namespace Contbuild {

struct Owner;

struct IndexerName;

struct FileToContbuild;

enum class FailureReason;

struct IndexFailure;

struct ContbuildName;

struct ContbuildLocator;

struct ContbuildFbpkg;

} // namespace Contbuild

namespace Configerator {

struct ImportFilesStatement;

} // namespace Configerator

namespace Codexref {

struct SymbolName;

struct Location;

} // namespace Codexref

namespace Codemetrics {

struct CxxRecordReferenceTo;

struct CxxRecordReference;

} // namespace Codemetrics

namespace Codemarkup {

namespace Types {

enum class Visibility;

enum class SymbolKind;

} // namespace Types

} // namespace Codemarkup

namespace Codexref {

struct XRefDatum;

struct IncomingXRefs;

struct OutgoingXRefs;

} // namespace Codexref

namespace Codemarkup {

namespace Types {

struct SymbolInfo;

struct RangeSpan;

struct RangeSpanContains;

struct Modifiers;

enum class Modifier;

struct Location;

struct XRefLocation;

} // namespace Types

namespace Search {

enum class SearchCase;

} // namespace Search

namespace Scip {

struct LsifKindToKind;

} // namespace Scip

namespace Python {

struct NonImportPythonDeclarationKind;

struct NonImportPythonDeclarationInfo;

struct ConvertLabel;

} // namespace Python

namespace Pp {

struct PpIncludeXRefLocations;

} // namespace Pp

namespace Lsif {

struct LsifKindToKind;

} // namespace Lsif

namespace Hack {

enum class RequiredRelation;

struct HackEnumInheritedMembers;

struct FromHackVisibility;

} // namespace Hack

namespace Flow {

struct FlowDocumentationSpan;

struct FlowDeclarationDocumentation;

} // namespace Flow

namespace Cxx {

struct FromCxxVisibility;

struct CxxFileEntityXMapVariableXRefDeclLocations;

struct CxxDeclarationModifiers;

struct CxxDeclVisibility;

struct CxxDeclKind;

struct CxxDeclInfo;

struct CxxDataAvailable;

} // namespace Cxx

enum class SearchStyle;

enum class RelationType;

struct IndexedFile;

struct EntityDataAvailable;

} // namespace Codemarkup

namespace Code {

namespace Scip {

struct Entity;

} // namespace Scip

} // namespace Code

namespace Codemarkup {

namespace Scip {

struct EntityInfo;

struct ScipEntityLocation;

struct ScipEntityUses;

struct ScipFileEntityXRefLocations;

struct ScipResolveLocation;

} // namespace Scip

} // namespace Codemarkup

namespace Code {

namespace Quality {

struct Repository;

struct Range;

struct Producer;

struct Point;

struct Integration;

struct FlagType;

struct FlagName;

struct FlagInfo;

struct Detail;

struct Category;

} // namespace Quality

namespace Python {

struct Entity;

} // namespace Python

} // namespace Code

namespace Codemarkup {

namespace Python {

struct PythonContainsChildEntity;

struct PythonContainsParentEntity;

struct PythonEntityComments;

struct PythonEntityInfo;

struct PythonEntityKind;

struct PythonEntityLocation;

struct PythonEntityModuleName;

struct PythonEntityUses;

struct PythonExtendsChildEntity;

struct PythonExtendsParentEntity;

struct PythonFileEntityXRefLocations;

struct PythonModifiers;

struct PythonResolveLocation;

struct PythonVisibility;

} // namespace Python

} // namespace Codemarkup

namespace Code {

namespace Python {

struct Annotations;

} // namespace Python

} // namespace Code

namespace Codemarkup {

namespace Python {

struct PythonAnnotation;

} // namespace Python

} // namespace Codemarkup

namespace Code {

namespace Pp {

struct Entity;

} // namespace Pp

} // namespace Code

namespace Codemarkup {

namespace Pp {

struct PPEntityLocation;

struct PpEntityInfo;

struct PpEntityKind;

struct PpEntityTraceXRefLocations;

struct PpEntityUses;

struct PpFileEntityXRefLocations;

struct PpResolveLocation;

struct PpResolveTraceLocation;

} // namespace Pp

} // namespace Codemarkup

namespace Code {

namespace Lsif {

struct Entity;

} // namespace Lsif

} // namespace Code

namespace Codemarkup {

namespace Lsif {

struct EntityInfo;

struct LsifEntityLocation;

struct LsifEntityModuleName;

struct LsifEntityUses;

struct LsifFileEntityXRefLocations;

struct LsifResolveLocation;

} // namespace Lsif

} // namespace Codemarkup

namespace Code {

namespace Kotlin {

struct Entity;

} // namespace Kotlin

} // namespace Code

namespace Codemarkup {

namespace Kotlin {

struct KotlinContainsChildEntity;

struct KotlinContainsParentEntity;

struct KotlinEntityKind;

struct KotlinEntityLocation;

struct KotlinEntityUses;

struct KotlinExtendsParentEntity;

struct KotlinFileEntityXRefLocations;

struct KotlinResolveLocation;

} // namespace Kotlin

} // namespace Codemarkup

namespace Code {

namespace Java {

struct Entity;

} // namespace Java

} // namespace Code

namespace Codemarkup {

namespace Java {

struct JavaContainsChildEntity;

struct JavaContainsParentEntity;

struct JavaEntityDocumentation;

struct JavaEntityKind;

struct JavaEntityLocation;

struct JavaEntityUses;

struct JavaExtendsChildEntity;

struct JavaExtendsParentEntity;

struct JavaModifiers;

struct JavaResolveLocation;

struct JavaVisibility;

struct JavalFileEntityXRefLocations;

} // namespace Java

} // namespace Codemarkup

namespace Code {

namespace Java {

struct Annotations;

} // namespace Java

} // namespace Code

namespace Codemarkup {

namespace Java {

struct JavaAnnotation;

} // namespace Java

} // namespace Codemarkup

namespace Code {

namespace Hs {

struct Entity;

} // namespace Hs

} // namespace Code

namespace Codemarkup {

namespace Haskell {

struct HaskellEntityLocation;

struct HaskellEntityUses;

struct HaskellFileEntityXRefLocations;

struct HaskellResolveLocation;

} // namespace Haskell

} // namespace Codemarkup

namespace Search {

namespace Hs {

struct SearchByName;

} // namespace Hs

} // namespace Search

namespace Code {

namespace Hack {

struct Entity;

} // namespace Hack

} // namespace Code

namespace Codemarkup {

namespace Hack {

struct EntityHasHideFromDocsAttr;

struct HackContainsChildEntity;

struct HackContainsParentEntity;

struct HackEntityDocumentation;

struct HackEntityInfo;

struct HackEntityKind;

struct HackEntityLocation;

struct HackEntityModuleName;

struct HackEntitySource;

struct HackEntityUses;

struct HackExtendsChildEntity;

struct HackExtendsParentEntity;

struct HackExtendsParentEntityConcise;

struct HackFileEntityXRefLocations;

struct HackFileEntityXRefSpans;

struct HackModifiers;

struct HackRequiredConstraint;

struct HackResolveLocation;

struct HackVisibility;

} // namespace Hack

} // namespace Codemarkup

namespace Codemetrics {

struct HackReferencesFrom;

struct HackReferencesTo;

} // namespace Codemetrics

namespace Code {

namespace Hack {

struct Annotations;

} // namespace Hack

} // namespace Code

namespace Codemarkup {

namespace Hack {

struct HackAnnotation;

} // namespace Hack

} // namespace Codemarkup

namespace Code {

namespace Graphql {

struct Entity;

} // namespace Graphql

} // namespace Code

namespace Codemarkup {

namespace Graphql {

struct GraphQLEntityKind;

struct GraphQLEntityLocation;

struct GraphQLEntityUses;

struct GraphQLFileEntityXRefLocations;

struct GraphQLResolveLocation;

} // namespace Graphql

} // namespace Codemarkup

namespace Code {

namespace Flow {

struct Entity;

} // namespace Flow

} // namespace Code

namespace Codemarkup {

namespace Flow {

struct FlowContainsChildEntity;

struct FlowContainsParentEntity;

struct FlowEntityDocumentation;

struct FlowEntityKind;

struct FlowEntityLocation;

struct FlowEntityModuleName;

struct FlowEntityUses;

struct FlowFileEntityXRefLocations;

struct FlowFileImportDeclEntityXRefLocations;

struct FlowFileReferenceEntityXRefLocations;

struct FlowResolveLocation;

} // namespace Flow

} // namespace Codemarkup

namespace Code {

namespace Fbthrift {

struct Entity;

} // namespace Fbthrift

} // namespace Code

namespace Codemarkup {

namespace Fbthrift {

struct FbthriftEntityDocumentation;

struct ThriftContainsChildEntity;

struct ThriftContainsParentEntity;

struct ThriftEntityKind;

struct ThriftEntityLocation;

struct ThriftExtendsChildEntity;

struct ThriftExtendsParentEntity;

struct ThriftFileEntityXRefLocations;

struct ThriftResolveLocation;

} // namespace Fbthrift

} // namespace Codemarkup

namespace Code {

namespace Fbthrift {

struct Annotations;

} // namespace Fbthrift

namespace Erlang {

struct Entity;

} // namespace Erlang

} // namespace Code

namespace Codemarkup {

namespace Erlang {

struct ErlangEntityDocumentation;

struct ErlangEntityInfo;

struct ErlangEntityKind;

struct ErlangEntityLocation;

struct ErlangEntityUses;

struct ErlangFileEntityXRefLocations;

struct ErlangResolveLocation;

} // namespace Erlang

} // namespace Codemarkup

namespace Search {

namespace Erlang {

struct SearchByFQN;

struct SearchByName;

} // namespace Erlang

} // namespace Search

namespace Code {

namespace Cxx {

struct ObjcMethodEntity;

struct ObjcSelectorSlotEntity;

struct Definition;

struct Entity;

} // namespace Cxx

} // namespace Code

namespace Codemarkup {

namespace Cxx {

struct CxxContainsChildEntity;

struct CxxContainsParentEntity;

struct CxxDeclToDefXRefTargetLocation;

struct CxxDeclarationContainsChild;

struct CxxDeclarationContainsParent;

struct CxxDeclarationExtendsChild;

struct CxxDeclarationExtendsParent;

struct CxxDeclarationSource;

struct CxxDefToDeclFamilyXRefTargetLocation;

struct CxxEntityDocumentation;

struct CxxEntityInfo;

struct CxxEntityKind;

struct CxxEntityLocation;

struct CxxEntitySource;

struct CxxEntityUSR;

struct CxxEntityUses;

struct CxxExtendsChildEntity;

struct CxxExtendsParentEntity;

struct CxxFileEntitySpellingXRefLocations;

struct CxxFileEntityTraceDeclToDefXRefLocations;

struct CxxFileEntityXMapFixedXRefLocations;

struct CxxFileEntityXMapVariableXRefDeclToDefs;

struct CxxFileEntityXRefLocations;

struct CxxFindDefinitionOfEntity;

struct CxxModifiers;

struct CxxNamespaceDeclarationContainsChild;

struct CxxResolveDeclarationToEntity;

struct CxxResolveLocation;

struct CxxResolveTraceLocation;

struct CxxVisibility;

struct CxxXRefTargetLocation;

struct EntityToXRefTarget;

struct XRefTargetToEntity;

} // namespace Cxx

} // namespace Codemarkup

namespace Codemetrics {

struct CxxReferencesFrom;

struct CxxReferencesTo;

} // namespace Codemetrics

namespace Glean {

namespace Test {

struct Entity;

} // namespace Test

} // namespace Glean

namespace Search {

namespace Cxx {

struct EntityUses;

struct SearchBySelector;

} // namespace Cxx

} // namespace Search

namespace Symbolid {

namespace Cxx {

struct DefinitionOfDecl;

struct LookupNamespaceDefinition;

} // namespace Cxx

} // namespace Symbolid

namespace Codemarkup {

namespace Cxx {

struct CxxDefinitionContainsChild;

struct CxxDefinitionContainsParent;

struct CxxDefinitionExtendsChild;

struct CxxDefinitionExtendsParent;

struct CxxDefinitionModifiers;

struct CxxDefnVisibility;

struct CxxEntityDefinitionBase;

} // namespace Cxx

} // namespace Codemarkup

namespace Search {

namespace Cxx {

struct DeclIsDefn;

} // namespace Cxx

} // namespace Search

namespace Code {

namespace Cxx {

struct DeclToDef;

struct Annotations;

} // namespace Cxx

} // namespace Code

namespace Codemarkup {

namespace Cxx {

struct CxxAnnotation;

} // namespace Cxx

} // namespace Codemarkup

namespace Code {

namespace Csharp {

struct Entity;

} // namespace Csharp

} // namespace Code

namespace Codemarkup {

namespace Csharp {

struct CSharpEntityKind;

struct CSharpEntityLocation;

struct CSharpEntityUses;

struct CSharpFileEntityXRefLocations;

struct CSharpResolveLocation;

} // namespace Csharp

} // namespace Codemarkup

namespace Code {

namespace Compose {

struct CxxContainerChildSignatures;

} // namespace Compose

namespace Buck {

struct Entity;

} // namespace Buck

} // namespace Code

namespace Codemarkup {

namespace Buck {

struct BuckEntityKind;

struct BuckEntityLocation;

struct BuckEntityUses;

struct BuckFileEntityXRefLocations;

struct BuckResolveLocation;

} // namespace Buck

} // namespace Codemarkup

namespace Search {

namespace Buck {

struct SearchByFQN;

struct SearchDefinition;

struct SearchFile;

} // namespace Buck

} // namespace Search

namespace Code {

enum class Language;

struct EntityLanguageSCIP;

struct EntityLanguageLSIF;

struct Entity;

struct EntityLanguage;

struct IdlEntity;

} // namespace Code

namespace Codemarkup {

namespace Cxx {

struct CxxEntityIdl;

} // namespace Cxx

namespace Hack {

struct HackEntityIdl;

} // namespace Hack

} // namespace Codemarkup

namespace Code {

namespace Compose {

struct CxxSearchContainerKind;

} // namespace Compose

} // namespace Code

namespace Codemarkup {

struct ChildEntity;

struct ContainsChildEntity;

struct ContainsParentEntity;

struct EntityComments;

struct EntityIdl;

struct EntityInfo;

struct EntityIsDefinition;

struct EntityKind;

struct EntityLocation;

struct EntityModifiers;

struct EntityModuleName;

struct EntityReferences;

struct EntitySource;

struct EntityUses;

struct EntityVisibility;

struct ExtendsChildEntity;

struct ExtendsParentEntity;

struct ExtendsParentEntityConcise;

struct FileEntityDigest;

struct FileEntityInfos;

struct FileEntityKinds;

struct FileEntityLocations;

struct FileEntityXRefInfos;

struct FileEntityXRefKinds;

struct FileEntityXRefLocations;

struct FileEntityXRefRangeSpans;

struct FileEntityXRefSpans;

struct FindEntityDefinition;

struct ParentEntity;

struct SearchRelatedEntities;

struct ReferencingEntity;

struct ResolveLocation;

namespace Cxx {

struct CxxFileEntityIdl;

} // namespace Cxx

namespace Hack {

struct ConvertCallee;

struct ConvertCalleeForFileCall;

struct ConvertStaticType;

} // namespace Hack

namespace Search {

struct EntityLocationAndKind;

struct SearchByName;

struct SearchByScope;

} // namespace Search

} // namespace Codemarkup

namespace Codemetrics {

struct ReferencesFrom;

struct ReferencesTo;

} // namespace Codemetrics

namespace Deadcode {

struct GraphEntity;

} // namespace Deadcode

namespace Deletthis {

struct FileReverseDeps;

} // namespace Deletthis

namespace Dyn {

struct EntityUsage;

} // namespace Dyn

namespace Monk {

struct BestPiiFunc;

struct PiiCallerFunc;

struct PiiFunc;

} // namespace Monk

namespace Search {

namespace Code {

struct BuckSearchByLocalNameFact;

struct BuckSearchByLowerCaseName;

struct BuckSearchByName;

struct CSharpSearchByLowerCaseName;

struct CSharpSearchByName;

struct CxxSearchByLowerCaseName;

struct CxxSearchByLowerCaseScope;

struct CxxSearchByName;

struct CxxSearchByScope;

struct ErlangSearchByLowerCaseName;

struct ErlangSearchByName;

struct FbthriftSearchByNameFact;

struct FlowSearchByLowerCaseName;

struct FlowSearchByLowerCaseScope;

struct FlowSearchByName;

struct FlowSearchByNameWithFact;

struct FlowSearchByScope;

struct FlowSearchByScopeWithName;

struct GraphQLSearchByLowerCaseName;

struct GraphQLSearchByName;

struct HackSearchByLowerCaseName;

struct HackSearchByLowerCaseScope;

struct HackSearchByName;

struct HackSearchByNameWithName;

struct HackSearchByScope;

struct HackSearchByScopeWithName;

struct HsSearchByLowerCaseName;

struct HsSearchByName;

struct JavaSearchByLowerCaseName;

struct JavaSearchByLowerCaseScope;

struct JavaSearchByName;

struct JavaSearchByNameWithFact;

struct JavaSearchByScope;

struct JavaSearchByScopeWithName;

struct KotlinSearchByLowerCaseName;

struct KotlinSearchByLowerCaseScope;

struct KotlinSearchByName;

struct KotlinSearchByNameWithFact;

struct KotlinSearchByScope;

struct KotlinSearchByScopeWithName;

struct LsifSearchByLowerCaseName;

struct LsifSearchByName;

struct PpSearchByLowerCaseName;

struct PpSearchByMacroFact;

struct PpSearchByName;

struct PythonSearchByLocalNameFact;

struct PythonSearchByLowerCaseName;

struct PythonSearchByLowerCaseScope;

struct PythonSearchByName;

struct PythonSearchByScope;

struct PythonSearchByScopeWithName;

struct SearchByLowerCaseNameAndLanguage;

struct SearchByLowerCaseScope;

struct SearchByNameAndLanguage;

struct SearchByScope;

struct ThriftSearchByLowerCaseName;

struct ThriftSearchByName;

} // namespace Code

} // namespace Search

namespace Code {

struct Argument;

struct CallArgument;

} // namespace Code

namespace Codemarkup {

struct FileCall;

namespace Hack {

struct ConvertCallArguments;

struct ConvertMaybeCallArguments;

struct HackFileCall;

} // namespace Hack

namespace Python {

struct ConvertCallArguments;

struct PythonFileCall;

} // namespace Python

namespace Hack {

struct ConvertArgument;

} // namespace Hack

namespace Python {

struct ConvertArgument;

} // namespace Python

} // namespace Codemarkup

namespace Code {

struct Annotations;

} // namespace Code

namespace Codemarkup {

struct EntityToAnnotations;

} // namespace Codemarkup

namespace Code {

namespace Quality {

struct Position;

struct Location;

struct Issue;

} // namespace Quality

} // namespace Code

namespace Cxx1 {

struct FunctionName;

struct RecordKind;

struct RecordDeclaration;

struct Scope;

struct DeclarationScope;

struct FunctionQName;

struct QName;

} // namespace Cxx1

namespace Search {

namespace Code {

struct CxxSearchByNameAndScopeFact;

} // namespace Code

namespace Cxx {

struct QueryToScopeCase;

struct SearchByNameAndScope;

struct SearchByScope;

} // namespace Cxx

} // namespace Search

namespace Symbolid {

namespace Cxx {

struct LookupDeclaration;

struct LookupDefinition;

struct LookupEnumerator;

struct LookupFunctionDeclaration;

struct LookupFunctionDefinition;

struct LookupFunctionSignatureDeclaration;

struct LookupFunctionSignatureDefinition;

struct LookupFunctionSignatureQualifierDeclaration;

struct LookupFunctionSignatureQualifierDefinition;

} // namespace Cxx

} // namespace Symbolid

namespace Fbthrift {

struct ResultType;

struct FunctionSpecification;

} // namespace Fbthrift

namespace Thrift {

struct ResultType;

struct FunctionSpecification;

} // namespace Thrift

namespace Buckuses {

struct UsesOfTargetHeader;

struct UsesOfTarget;

} // namespace Buckuses

namespace Buck {

namespace Meta {

struct Oncall;

struct ModeType;

struct TargetModes;

struct LocatorOncall;

struct FileOncall;

} // namespace Meta

struct XRefDestination;

struct XRef;

struct Type;

struct TranslationUnit;

struct TargetUses;

struct TargetSourcesBaseModule;

struct TargetSources;

struct TargetOuts;

struct TargetOut;

struct TargetMode;

struct TargetLocation;

struct TargetLinkWhole;

struct TargetIndexerName;

struct TargetIndexer;

struct TargetHash;

struct TargetCall;

struct TargetByType;

struct TargetAttribute;

struct Target;

struct SourceFileLocation;

struct SearchByLocalName;

struct RuleKey;

struct Platform;

struct Owner;

struct OutsTarget;

struct OutputLabel;

struct OutTarget;

struct LocatorWithLabel;

struct LocatorReverseDeps;

struct LocatorReverseDep;

struct Locator;

struct LocalNameLowerCase;

struct LocalName;

struct Labels;

struct Label;

struct IndexerName;

struct FileXRefs;

struct FileToTarget;

struct FileTarget;

struct FileResolved;

struct FileEntity;

struct FileDefinition;

struct File;

struct FailureSources;

enum class FailureReason;

struct IndexFailureX;

struct DestinationUses;

struct Dependency;

struct TargetDependencies;

struct DefinitionLocation;

struct Definition;

struct Consumer;

struct CallArgument;

struct AttributeName;

struct AttributeMapping;

struct AttributeValue;

struct ArgumentMapping;

struct ArgumentValue;

} // namespace Buck

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Thrift::XRefTarget> {
  using Type = Sum<facebook::glean::cpp::schema::Thrift::File, facebook::glean::cpp::schema::Thrift::NamedDecl, facebook::glean::cpp::schema::Thrift::ExceptionName, facebook::glean::cpp::schema::Thrift::ServiceName, facebook::glean::cpp::schema::Thrift::Constant, facebook::glean::cpp::schema::Thrift::EnumValue, facebook::glean::cpp::schema::Thrift::FunctionName>;
};


namespace schema {

namespace Thrift {

struct XRefTarget {
  boost::variant<Alt<0, Fact<File>>, Alt<1, Fact<NamedDecl>>, Alt<2, Fact<ExceptionName>>, Alt<3, Fact<ServiceName>>, Alt<4, Fact<Constant>>, Alt<5, Fact<EnumValue>>, Alt<6, Fact<FunctionName>>> GLEAN_value;

  static XRefTarget include_(const Fact<File>& a) {
    return XRefTarget{Alt<0, Fact<File>>(a)};
  }
  static XRefTarget named(const Fact<NamedDecl>& a) {
    return XRefTarget{Alt<1, Fact<NamedDecl>>(a)};
  }
  static XRefTarget exception_(const Fact<ExceptionName>& a) {
    return XRefTarget{Alt<2, Fact<ExceptionName>>(a)};
  }
  static XRefTarget service_(const Fact<ServiceName>& a) {
    return XRefTarget{Alt<3, Fact<ServiceName>>(a)};
  }
  static XRefTarget constant(const Fact<Constant>& a) {
    return XRefTarget{Alt<4, Fact<Constant>>(a)};
  }
  static XRefTarget enumValue(const Fact<EnumValue>& a) {
    return XRefTarget{Alt<5, Fact<EnumValue>>(a)};
  }
  static XRefTarget function_(const Fact<FunctionName>& a) {
    return XRefTarget{Alt<6, Fact<FunctionName>>(a)};
  }

  bool operator==(const XRefTarget& other) const {
    return std::tie(GLEAN_value)
             == std::tie(other.GLEAN_value);
  }
  bool operator!=(const XRefTarget& other) const {
    return std::tie(GLEAN_value)
             != std::tie(other.GLEAN_value);
  }
  bool operator<(const XRefTarget& other) const {
    return std::tie(GLEAN_value)
             < std::tie(other.GLEAN_value);
  }
  bool operator<=(const XRefTarget& other) const {
    return std::tie(GLEAN_value)
             <= std::tie(other.GLEAN_value);
  }
  bool operator>(const XRefTarget& other) const {
    return std::tie(GLEAN_value)
             > std::tie(other.GLEAN_value);
  }
  bool operator>=(const XRefTarget& other) const {
    return std::tie(GLEAN_value)
             >= std::tie(other.GLEAN_value);
  }

  void outputRepr(Output<Repr<XRefTarget>> out) const {
    outputValue(out, GLEAN_value);
  }
}; // struct XRefTarget

} // namespace Thrift

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Thrift::TypedConst> {
  using Type = Sum<facebook::glean::cpp::schema::Thrift::Literal, facebook::glean::cpp::schema::Thrift::Constant>;
};


namespace schema {

namespace Thrift {

struct TypedConst {
  boost::variant<Alt<0, Fact<Literal>>, Alt<1, Fact<Constant>>> GLEAN_value;

  static TypedConst literal(const Fact<Literal>& a) {
    return TypedConst{Alt<0, Fact<Literal>>(a)};
  }
  static TypedConst identifier(const Fact<Constant>& a) {
    return TypedConst{Alt<1, Fact<Constant>>(a)};
  }

  bool operator==(const TypedConst& other) const {
    return std::tie(GLEAN_value)
             == std::tie(other.GLEAN_value);
  }
  bool operator!=(const TypedConst& other) const {
    return std::tie(GLEAN_value)
             != std::tie(other.GLEAN_value);
  }
  bool operator<(const TypedConst& other) const {
    return std::tie(GLEAN_value)
             < std::tie(other.GLEAN_value);
  }
  bool operator<=(const TypedConst& other) const {
    return std::tie(GLEAN_value)
             <= std::tie(other.GLEAN_value);
  }
  bool operator>(const TypedConst& other) const {
    return std::tie(GLEAN_value)
             > std::tie(other.GLEAN_value);
  }
  bool operator>=(const TypedConst& other) const {
    return std::tie(GLEAN_value)
             >= std::tie(other.GLEAN_value);
  }

  void outputRepr(Output<Repr<TypedConst>> out) const {
    outputValue(out, GLEAN_value);
  }
}; // struct TypedConst

} // namespace Thrift

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Thrift::TypedConstT> {
  using Type = Tuple<Repr<facebook::glean::cpp::schema::Thrift::TypedConst>, facebook::glean::cpp::schema::Thrift::TypeSpecification>;
};


namespace schema {

namespace Thrift {

struct TypedConstT {
  TypedConst const_;
  Fact<TypeSpecification> type_;

  bool operator==(const TypedConstT& other) const {
    return std::tie(const_,type_)
             == std::tie(other.const_,other.type_);
  }
  bool operator!=(const TypedConstT& other) const {
    return std::tie(const_,type_)
             != std::tie(other.const_,other.type_);
  }
  bool operator<(const TypedConstT& other) const {
    return std::tie(const_,type_)
             < std::tie(other.const_,other.type_);
  }
  bool operator<=(const TypedConstT& other) const {
    return std::tie(const_,type_)
             <= std::tie(other.const_,other.type_);
  }
  bool operator>(const TypedConstT& other) const {
    return std::tie(const_,type_)
             > std::tie(other.const_,other.type_);
  }
  bool operator>=(const TypedConstT& other) const {
    return std::tie(const_,type_)
             >= std::tie(other.const_,other.type_);
  }
  void outputRepr(Output<Repr<TypedConstT>> out) const {
    outputValue(out, std::make_tuple(const_, type_));
  }
}; // struct TypedConstT

} // namespace Thrift

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Thrift::UnionFieldVal> {
  using Type = Tuple<facebook::glean::cpp::schema::Thrift::Identifier, Repr<facebook::glean::cpp::schema::Thrift::TypedConstT>>;
};


namespace schema {

namespace Thrift {

struct UnionFieldVal {
  Fact<Identifier> name;
  TypedConstT value;

  bool operator==(const UnionFieldVal& other) const {
    return std::tie(name,value)
             == std::tie(other.name,other.value);
  }
  bool operator!=(const UnionFieldVal& other) const {
    return std::tie(name,value)
             != std::tie(other.name,other.value);
  }
  bool operator<(const UnionFieldVal& other) const {
    return std::tie(name,value)
             < std::tie(other.name,other.value);
  }
  bool operator<=(const UnionFieldVal& other) const {
    return std::tie(name,value)
             <= std::tie(other.name,other.value);
  }
  bool operator>(const UnionFieldVal& other) const {
    return std::tie(name,value)
             > std::tie(other.name,other.value);
  }
  bool operator>=(const UnionFieldVal& other) const {
    return std::tie(name,value)
             >= std::tie(other.name,other.value);
  }
  void outputRepr(Output<Repr<UnionFieldVal>> out) const {
    outputValue(out, std::make_tuple(name, value));
  }
}; // struct UnionFieldVal

struct UnionVal : Predicate<std::tuple<UnionFieldVal>> {
  static const char* GLEAN_name() {
    return "thrift.UnionVal";
  }

  static constexpr size_t GLEAN_version() {
     return 7;
  }
}; // struct UnionVal

struct TypeDefType : Predicate<std::tuple<Fact<QualName>, Fact<TypeSpecification>>> {
  static const char* GLEAN_name() {
    return "thrift.TypeDefType";
  }

  static constexpr size_t GLEAN_version() {
     return 7;
  }
}; // struct TypeDefType

struct ToPython : Predicate<std::tuple<Fact<File>, Fact<Lang>, std::vector<Fact<FromPython>>>> {
  static const char* GLEAN_name() {
    return "thrift.ToPython";
  }

  static constexpr size_t GLEAN_version() {
     return 7;
  }
}; // struct ToPython

struct ToHack : Predicate<std::tuple<Fact<File>, std::vector<Fact<FromHack>>>> {
  static const char* GLEAN_name() {
    return "thrift.ToHack";
  }

  static constexpr size_t GLEAN_version() {
     return 7;
  }
}; // struct ToHack

struct ToCpp2 : Predicate<std::tuple<Fact<File>, std::vector<Fact<FromCpp2>>>> {
  static const char* GLEAN_name() {
    return "thrift.ToCpp2";
  }

  static constexpr size_t GLEAN_version() {
     return 7;
  }
}; // struct ToCpp2

struct StructuredAnnotation : Predicate<std::tuple<Fact<TypeSpecification>, Fact<StructVal>>> {
  static const char* GLEAN_name() {
    return "thrift.StructuredAnnotation";
  }

  static constexpr size_t GLEAN_version() {
     return 7;
  }
}; // struct StructuredAnnotation

} // namespace Thrift

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Thrift::StructFieldValValue> {
  using Type = Sum<Repr<facebook::glean::cpp::schema::Thrift::TypedConstT>, facebook::glean::cpp::schema::Thrift::TypeSpecification, Repr<facebook::glean::cpp::schema::Thrift::TypedConstT>, Tuple<>>;
};


namespace schema {

namespace Thrift {

struct StructFieldValValue {
  boost::variant<Alt<0, TypedConstT>, Alt<1, Fact<TypeSpecification>>, Alt<2, TypedConstT>, Alt<3, std::tuple<>>> GLEAN_value;

  static StructFieldValValue val(const TypedConstT& a) {
    return StructFieldValValue{Alt<0, TypedConstT>(a)};
  }
  static StructFieldValValue default_(const Fact<TypeSpecification>& a) {
    return StructFieldValValue{Alt<1, Fact<TypeSpecification>>(a)};
  }
  static StructFieldValValue just(const TypedConstT& a) {
    return StructFieldValValue{Alt<2, TypedConstT>(a)};
  }
  static StructFieldValValue nothing() {
    return StructFieldValValue{Alt<3, std::tuple<>>(std::make_tuple())};
  }

  bool operator==(const StructFieldValValue& other) const {
    return std::tie(GLEAN_value)
             == std::tie(other.GLEAN_value);
  }
  bool operator!=(const StructFieldValValue& other) const {
    return std::tie(GLEAN_value)
             != std::tie(other.GLEAN_value);
  }
  bool operator<(const StructFieldValValue& other) const {
    return std::tie(GLEAN_value)
             < std::tie(other.GLEAN_value);
  }
  bool operator<=(const StructFieldValValue& other) const {
    return std::tie(GLEAN_value)
             <= std::tie(other.GLEAN_value);
  }
  bool operator>(const StructFieldValValue& other) const {
    return std::tie(GLEAN_value)
             > std::tie(other.GLEAN_value);
  }
  bool operator>=(const StructFieldValValue& other) const {
    return std::tie(GLEAN_value)
             >= std::tie(other.GLEAN_value);
  }

  void outputRepr(Output<Repr<StructFieldValValue>> out) const {
    outputValue(out, GLEAN_value);
  }
}; // struct StructFieldValValue

} // namespace Thrift

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Thrift::StructFieldVal> {
  using Type = Tuple<facebook::glean::cpp::schema::Thrift::Identifier, Repr<facebook::glean::cpp::schema::Thrift::StructFieldValValue>>;
};


namespace schema {

namespace Thrift {

struct StructFieldVal {
  Fact<Identifier> name;
  StructFieldValValue value;

  bool operator==(const StructFieldVal& other) const {
    return std::tie(name,value)
             == std::tie(other.name,other.value);
  }
  bool operator!=(const StructFieldVal& other) const {
    return std::tie(name,value)
             != std::tie(other.name,other.value);
  }
  bool operator<(const StructFieldVal& other) const {
    return std::tie(name,value)
             < std::tie(other.name,other.value);
  }
  bool operator<=(const StructFieldVal& other) const {
    return std::tie(name,value)
             <= std::tie(other.name,other.value);
  }
  bool operator>(const StructFieldVal& other) const {
    return std::tie(name,value)
             > std::tie(other.name,other.value);
  }
  bool operator>=(const StructFieldVal& other) const {
    return std::tie(name,value)
             >= std::tie(other.name,other.value);
  }
  void outputRepr(Output<Repr<StructFieldVal>> out) const {
    outputValue(out, std::make_tuple(name, value));
  }
}; // struct StructFieldVal

struct StructVal : Predicate<std::tuple<std::vector<StructFieldVal>>> {
  static const char* GLEAN_name() {
    return "thrift.StructVal";
  }

  static constexpr size_t GLEAN_version() {
     return 7;
  }
}; // struct StructVal

struct ServiceParent : Predicate<std::tuple<Fact<ServiceName>, Fact<ServiceName>>> {
  static const char* GLEAN_name() {
    return "thrift.ServiceParent";
  }

  static constexpr size_t GLEAN_version() {
     return 7;
  }
}; // struct ServiceParent

struct ServiceDefinition : Predicate<std::tuple<Fact<ServiceName>, std::vector<Fact<FunctionSpecification>>>> {
  static const char* GLEAN_name() {
    return "thrift.ServiceDefinition";
  }

  static constexpr size_t GLEAN_version() {
     return 7;
  }
}; // struct ServiceDefinition

struct ServiceChild : Predicate<std::tuple<Fact<ServiceName>, Fact<ServiceName>>> {
  static const char* GLEAN_name() {
    return "thrift.ServiceChild";
  }

  static constexpr size_t GLEAN_version() {
     return 7;
  }
}; // struct ServiceChild

struct SearchByName : Predicate<std::tuple<Fact<Identifier>, Fact<QualName>>> {
  static const char* GLEAN_name() {
    return "thrift.SearchByName";
  }

  static constexpr size_t GLEAN_version() {
     return 7;
  }
}; // struct SearchByName

} // namespace Thrift

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Thrift::Qualifier> {
  using Type = Enum<3>;
};


namespace schema {

namespace Thrift {

enum class Qualifier { default_, optional_, required_ };

struct QualName : Predicate<std::tuple<Fact<File>, Fact<Identifier>>> {
  static const char* GLEAN_name() {
    return "thrift.QualName";
  }

  static constexpr size_t GLEAN_version() {
     return 7;
  }
}; // struct QualName

struct PythonValue : Predicate<std::tuple<Fact<PythonName>, Fact<PythonModule>>> {
  static const char* GLEAN_name() {
    return "thrift.PythonValue";
  }

  static constexpr size_t GLEAN_version() {
     return 7;
  }
}; // struct PythonValue

struct PythonName : Predicate<std::string> {
  static const char* GLEAN_name() {
    return "thrift.PythonName";
  }

  static constexpr size_t GLEAN_version() {
     return 7;
  }
}; // struct PythonName

struct PythonModuleFile : Predicate<std::tuple<Fact<PythonModule>, Fact<facebook::glean::cpp::schema::Src::File>>> {
  static const char* GLEAN_name() {
    return "thrift.PythonModuleFile";
  }

  static constexpr size_t GLEAN_version() {
     return 7;
  }
}; // struct PythonModuleFile

struct PythonModuleContains : Predicate<std::tuple<Fact<PythonModule>, std::vector<Fact<PythonClass>>, std::vector<Fact<PythonFunction>>, std::vector<Fact<PythonValue>>>> {
  static const char* GLEAN_name() {
    return "thrift.PythonModuleContains";
  }

  static constexpr size_t GLEAN_version() {
     return 7;
  }
}; // struct PythonModuleContains

struct PythonModule : Predicate<Fact<PythonName>> {
  static const char* GLEAN_name() {
    return "thrift.PythonModule";
  }

  static constexpr size_t GLEAN_version() {
     return 7;
  }
}; // struct PythonModule

struct PythonMethod : Predicate<std::tuple<Fact<PythonName>, Fact<PythonClass>>> {
  static const char* GLEAN_name() {
    return "thrift.PythonMethod";
  }

  static constexpr size_t GLEAN_version() {
     return 7;
  }
}; // struct PythonMethod

} // namespace Thrift

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Thrift::PythonItem> {
  using Type = Sum<facebook::glean::cpp::schema::Src::File, facebook::glean::cpp::schema::Thrift::PythonModule, facebook::glean::cpp::schema::Thrift::PythonClass, facebook::glean::cpp::schema::Thrift::PythonMethod, facebook::glean::cpp::schema::Thrift::PythonField, facebook::glean::cpp::schema::Thrift::PythonFunction, facebook::glean::cpp::schema::Thrift::PythonValue>;
};


namespace schema {

namespace Thrift {

struct PythonItem {
  boost::variant<Alt<0, Fact<facebook::glean::cpp::schema::Src::File>>, Alt<1, Fact<PythonModule>>, Alt<2, Fact<PythonClass>>, Alt<3, Fact<PythonMethod>>, Alt<4, Fact<PythonField>>, Alt<5, Fact<PythonFunction>>, Alt<6, Fact<PythonValue>>> GLEAN_value;

  static PythonItem file(const Fact<facebook::glean::cpp::schema::Src::File>& a) {
    return PythonItem{Alt<0, Fact<facebook::glean::cpp::schema::Src::File>>(a)};
  }
  static PythonItem module(const Fact<PythonModule>& a) {
    return PythonItem{Alt<1, Fact<PythonModule>>(a)};
  }
  static PythonItem class_(const Fact<PythonClass>& a) {
    return PythonItem{Alt<2, Fact<PythonClass>>(a)};
  }
  static PythonItem method(const Fact<PythonMethod>& a) {
    return PythonItem{Alt<3, Fact<PythonMethod>>(a)};
  }
  static PythonItem field(const Fact<PythonField>& a) {
    return PythonItem{Alt<4, Fact<PythonField>>(a)};
  }
  static PythonItem function_(const Fact<PythonFunction>& a) {
    return PythonItem{Alt<5, Fact<PythonFunction>>(a)};
  }
  static PythonItem value(const Fact<PythonValue>& a) {
    return PythonItem{Alt<6, Fact<PythonValue>>(a)};
  }

  bool operator==(const PythonItem& other) const {
    return std::tie(GLEAN_value)
             == std::tie(other.GLEAN_value);
  }
  bool operator!=(const PythonItem& other) const {
    return std::tie(GLEAN_value)
             != std::tie(other.GLEAN_value);
  }
  bool operator<(const PythonItem& other) const {
    return std::tie(GLEAN_value)
             < std::tie(other.GLEAN_value);
  }
  bool operator<=(const PythonItem& other) const {
    return std::tie(GLEAN_value)
             <= std::tie(other.GLEAN_value);
  }
  bool operator>(const PythonItem& other) const {
    return std::tie(GLEAN_value)
             > std::tie(other.GLEAN_value);
  }
  bool operator>=(const PythonItem& other) const {
    return std::tie(GLEAN_value)
             >= std::tie(other.GLEAN_value);
  }

  void outputRepr(Output<Repr<PythonItem>> out) const {
    outputValue(out, GLEAN_value);
  }
}; // struct PythonItem

struct PythonFunction : Predicate<std::tuple<Fact<PythonName>, Fact<PythonModule>>> {
  static const char* GLEAN_name() {
    return "thrift.PythonFunction";
  }

  static constexpr size_t GLEAN_version() {
     return 7;
  }
}; // struct PythonFunction

struct PythonFileModule : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Src::File>, Fact<PythonModule>>> {
  static const char* GLEAN_name() {
    return "thrift.PythonFileModule";
  }

  static constexpr size_t GLEAN_version() {
     return 7;
  }
}; // struct PythonFileModule

struct PythonField : Predicate<std::tuple<Fact<PythonName>, Fact<PythonClass>>> {
  static const char* GLEAN_name() {
    return "thrift.PythonField";
  }

  static constexpr size_t GLEAN_version() {
     return 7;
  }
}; // struct PythonField

struct PythonClassContains : Predicate<std::tuple<Fact<PythonClass>, std::vector<Fact<PythonMethod>>, std::vector<Fact<PythonField>>>> {
  static const char* GLEAN_name() {
    return "thrift.PythonClassContains";
  }

  static constexpr size_t GLEAN_version() {
     return 7;
  }
}; // struct PythonClassContains

struct PythonClass : Predicate<std::tuple<Fact<PythonName>, Fact<PythonModule>>> {
  static const char* GLEAN_name() {
    return "thrift.PythonClass";
  }

  static constexpr size_t GLEAN_version() {
     return 7;
  }
}; // struct PythonClass

} // namespace Thrift

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Thrift::PrimitiveType> {
  using Type = Enum<9>;
};


namespace schema {

namespace Thrift {

enum class PrimitiveType { bool_, byte_, i16_, i32_, i64_, float_, double_, binary_, string_ };

struct OutputTarget : Predicate<std::tuple<Fact<CompileTarget>, Fact<facebook::glean::cpp::schema::Buck::Target>, Fact<facebook::glean::cpp::schema::Src::File>>> {
  static const char* GLEAN_name() {
    return "thrift.OutputTarget";
  }

  static constexpr size_t GLEAN_version() {
     return 7;
  }
}; // struct OutputTarget

struct NamespaceValue : Predicate<std::string> {
  static const char* GLEAN_name() {
    return "thrift.NamespaceValue";
  }

  static constexpr size_t GLEAN_version() {
     return 7;
  }
}; // struct NamespaceValue

struct NamespaceName : Predicate<std::string> {
  static const char* GLEAN_name() {
    return "thrift.NamespaceName";
  }

  static constexpr size_t GLEAN_version() {
     return 7;
  }
}; // struct NamespaceName

struct Namespace : Predicate<std::tuple<Fact<File>, Fact<NamespaceName>, Fact<NamespaceValue>, bool>> {
  static const char* GLEAN_name() {
    return "thrift.Namespace";
  }

  static constexpr size_t GLEAN_version() {
     return 7;
  }
}; // struct Namespace

} // namespace Thrift

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Thrift::NamedKind> {
  using Type = Enum<4>;
};


namespace schema {

namespace Thrift {

enum class NamedKind { typedef_, enum_, struct_, union_ };

} // namespace Thrift

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Thrift::NamedType> {
  using Type = Tuple<facebook::glean::cpp::schema::Thrift::QualName, Repr<facebook::glean::cpp::schema::Thrift::NamedKind>>;
};


namespace schema {

namespace Thrift {

struct NamedType {
  Fact<QualName> name;
  NamedKind kind;

  bool operator==(const NamedType& other) const {
    return std::tie(name,kind)
             == std::tie(other.name,other.kind);
  }
  bool operator!=(const NamedType& other) const {
    return std::tie(name,kind)
             != std::tie(other.name,other.kind);
  }
  bool operator<(const NamedType& other) const {
    return std::tie(name,kind)
             < std::tie(other.name,other.kind);
  }
  bool operator<=(const NamedType& other) const {
    return std::tie(name,kind)
             <= std::tie(other.name,other.kind);
  }
  bool operator>(const NamedType& other) const {
    return std::tie(name,kind)
             > std::tie(other.name,other.kind);
  }
  bool operator>=(const NamedType& other) const {
    return std::tie(name,kind)
             >= std::tie(other.name,other.kind);
  }
  void outputRepr(Output<Repr<NamedType>> out) const {
    outputValue(out, std::make_tuple(name, kind));
  }
}; // struct NamedType

struct NameLowerCase : Predicate<std::tuple<std::string, Fact<Identifier>>> {
  static const char* GLEAN_name() {
    return "thrift.NameLowerCase";
  }

  static constexpr size_t GLEAN_version() {
     return 7;
  }
}; // struct NameLowerCase

} // namespace Thrift

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Thrift::MapType> {
  using Type = Tuple<facebook::glean::cpp::schema::Thrift::TypeSpecification, facebook::glean::cpp::schema::Thrift::TypeSpecification>;
};


namespace schema {

namespace Thrift {

struct MapType {
  Fact<TypeSpecification> key_;
  Fact<TypeSpecification> value;

  bool operator==(const MapType& other) const {
    return std::tie(key_,value)
             == std::tie(other.key_,other.value);
  }
  bool operator!=(const MapType& other) const {
    return std::tie(key_,value)
             != std::tie(other.key_,other.value);
  }
  bool operator<(const MapType& other) const {
    return std::tie(key_,value)
             < std::tie(other.key_,other.value);
  }
  bool operator<=(const MapType& other) const {
    return std::tie(key_,value)
             <= std::tie(other.key_,other.value);
  }
  bool operator>(const MapType& other) const {
    return std::tie(key_,value)
             > std::tie(other.key_,other.value);
  }
  bool operator>=(const MapType& other) const {
    return std::tie(key_,value)
             >= std::tie(other.key_,other.value);
  }
  void outputRepr(Output<Repr<MapType>> out) const {
    outputValue(out, std::make_tuple(key_, value));
  }
}; // struct MapType

struct MangleLang : Predicate<std::string> {
  static const char* GLEAN_name() {
    return "thrift.MangleLang";
  }

  static constexpr size_t GLEAN_version() {
     return 7;
  }
}; // struct MangleLang

struct Mangle : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Scm::Commit>, Fact<facebook::glean::cpp::schema::Scm::Commit>, Fact<MangleLang>>> {
  static const char* GLEAN_name() {
    return "thrift.Mangle";
  }

  static constexpr size_t GLEAN_version() {
     return 7;
  }
}; // struct Mangle

} // namespace Thrift

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Thrift::Loc> {
  using Type = Tuple<Nat, Nat, Nat, Nat>;
};


namespace schema {

namespace Thrift {

struct Loc {
  uint64_t startLine;
  uint64_t startCol;
  uint64_t endLine;
  uint64_t endCol;

  bool operator==(const Loc& other) const {
    return std::tie(startLine,startCol,endLine,endCol)
             == std::tie(other.startLine,other.startCol,other.endLine,other.endCol);
  }
  bool operator!=(const Loc& other) const {
    return std::tie(startLine,startCol,endLine,endCol)
             != std::tie(other.startLine,other.startCol,other.endLine,other.endCol);
  }
  bool operator<(const Loc& other) const {
    return std::tie(startLine,startCol,endLine,endCol)
             < std::tie(other.startLine,other.startCol,other.endLine,other.endCol);
  }
  bool operator<=(const Loc& other) const {
    return std::tie(startLine,startCol,endLine,endCol)
             <= std::tie(other.startLine,other.startCol,other.endLine,other.endCol);
  }
  bool operator>(const Loc& other) const {
    return std::tie(startLine,startCol,endLine,endCol)
             > std::tie(other.startLine,other.startCol,other.endLine,other.endCol);
  }
  bool operator>=(const Loc& other) const {
    return std::tie(startLine,startCol,endLine,endCol)
             >= std::tie(other.startLine,other.startCol,other.endLine,other.endCol);
  }
  void outputRepr(Output<Repr<Loc>> out) const {
    outputValue(out, std::make_tuple(startLine, startCol, endLine, endCol));
  }
}; // struct Loc

struct NamedDecl : Predicate<std::tuple<NamedType, Loc>> {
  static const char* GLEAN_name() {
    return "thrift.NamedDecl";
  }

  static constexpr size_t GLEAN_version() {
     return 7;
  }
}; // struct NamedDecl

struct ServiceName : Predicate<std::tuple<Fact<QualName>, Loc>> {
  static const char* GLEAN_name() {
    return "thrift.ServiceName";
  }

  static constexpr size_t GLEAN_version() {
     return 7;
  }
}; // struct ServiceName

} // namespace Thrift

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Thrift::Target> {
  using Type = Tuple<Repr<facebook::glean::cpp::schema::Thrift::Loc>, Repr<facebook::glean::cpp::schema::Thrift::XRefTarget>>;
};


namespace schema {

namespace Thrift {

struct Target {
  Loc locTarget;
  XRefTarget target;

  bool operator==(const Target& other) const {
    return std::tie(locTarget,target)
             == std::tie(other.locTarget,other.target);
  }
  bool operator!=(const Target& other) const {
    return std::tie(locTarget,target)
             != std::tie(other.locTarget,other.target);
  }
  bool operator<(const Target& other) const {
    return std::tie(locTarget,target)
             < std::tie(other.locTarget,other.target);
  }
  bool operator<=(const Target& other) const {
    return std::tie(locTarget,target)
             <= std::tie(other.locTarget,other.target);
  }
  bool operator>(const Target& other) const {
    return std::tie(locTarget,target)
             > std::tie(other.locTarget,other.target);
  }
  bool operator>=(const Target& other) const {
    return std::tie(locTarget,target)
             >= std::tie(other.locTarget,other.target);
  }
  void outputRepr(Output<Repr<Target>> out) const {
    outputValue(out, std::make_tuple(locTarget, target));
  }
}; // struct Target

struct TargetX : Predicate<std::tuple<XRefTarget, Fact<File>, Loc>> {
  static const char* GLEAN_name() {
    return "thrift.TargetX";
  }

  static constexpr size_t GLEAN_version() {
     return 7;
  }
}; // struct TargetX

} // namespace Thrift

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Thrift::XRef> {
  using Type = Tuple<Repr<facebook::glean::cpp::schema::Thrift::Loc>, Repr<facebook::glean::cpp::schema::Thrift::XRefTarget>>;
};


namespace schema {

namespace Thrift {

struct XRef {
  Loc locRef;
  XRefTarget target;

  bool operator==(const XRef& other) const {
    return std::tie(locRef,target)
             == std::tie(other.locRef,other.target);
  }
  bool operator!=(const XRef& other) const {
    return std::tie(locRef,target)
             != std::tie(other.locRef,other.target);
  }
  bool operator<(const XRef& other) const {
    return std::tie(locRef,target)
             < std::tie(other.locRef,other.target);
  }
  bool operator<=(const XRef& other) const {
    return std::tie(locRef,target)
             <= std::tie(other.locRef,other.target);
  }
  bool operator>(const XRef& other) const {
    return std::tie(locRef,target)
             > std::tie(other.locRef,other.target);
  }
  bool operator>=(const XRef& other) const {
    return std::tie(locRef,target)
             >= std::tie(other.locRef,other.target);
  }
  void outputRepr(Output<Repr<XRef>> out) const {
    outputValue(out, std::make_tuple(locRef, target));
  }
}; // struct XRef

struct Lang : Predicate<std::string> {
  static const char* GLEAN_name() {
    return "thrift.Lang";
  }

  static constexpr size_t GLEAN_version() {
     return 7;
  }
}; // struct Lang

} // namespace Thrift

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Thrift::KeyValue> {
  using Type = Tuple<Repr<facebook::glean::cpp::schema::Thrift::TypedConst>, Repr<facebook::glean::cpp::schema::Thrift::TypedConst>>;
};


namespace schema {

namespace Thrift {

struct KeyValue {
  TypedConst key;
  TypedConst value;

  bool operator==(const KeyValue& other) const {
    return std::tie(key,value)
             == std::tie(other.key,other.value);
  }
  bool operator!=(const KeyValue& other) const {
    return std::tie(key,value)
             != std::tie(other.key,other.value);
  }
  bool operator<(const KeyValue& other) const {
    return std::tie(key,value)
             < std::tie(other.key,other.value);
  }
  bool operator<=(const KeyValue& other) const {
    return std::tie(key,value)
             <= std::tie(other.key,other.value);
  }
  bool operator>(const KeyValue& other) const {
    return std::tie(key,value)
             > std::tie(other.key,other.value);
  }
  bool operator>=(const KeyValue& other) const {
    return std::tie(key,value)
             >= std::tie(other.key,other.value);
  }
  void outputRepr(Output<Repr<KeyValue>> out) const {
    outputValue(out, std::make_tuple(key, value));
  }
}; // struct KeyValue

} // namespace Thrift

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Thrift::Item> {
  using Type = Sum<facebook::glean::cpp::schema::Thrift::File, facebook::glean::cpp::schema::Thrift::Namespace, facebook::glean::cpp::schema::Thrift::ServiceName, facebook::glean::cpp::schema::Thrift::FunctionName, facebook::glean::cpp::schema::Thrift::NamedDecl, facebook::glean::cpp::schema::Thrift::ExceptionName, facebook::glean::cpp::schema::Thrift::Constant, facebook::glean::cpp::schema::Thrift::EnumValue>;
};


namespace schema {

namespace Thrift {

struct Item {
  boost::variant<Alt<0, Fact<File>>, Alt<1, Fact<Namespace>>, Alt<2, Fact<ServiceName>>, Alt<3, Fact<FunctionName>>, Alt<4, Fact<NamedDecl>>, Alt<5, Fact<ExceptionName>>, Alt<6, Fact<Constant>>, Alt<7, Fact<EnumValue>>> GLEAN_value;

  static Item file(const Fact<File>& a) {
    return Item{Alt<0, Fact<File>>(a)};
  }
  static Item namespace_(const Fact<Namespace>& a) {
    return Item{Alt<1, Fact<Namespace>>(a)};
  }
  static Item service_(const Fact<ServiceName>& a) {
    return Item{Alt<2, Fact<ServiceName>>(a)};
  }
  static Item function_(const Fact<FunctionName>& a) {
    return Item{Alt<3, Fact<FunctionName>>(a)};
  }
  static Item decl(const Fact<NamedDecl>& a) {
    return Item{Alt<4, Fact<NamedDecl>>(a)};
  }
  static Item exception_(const Fact<ExceptionName>& a) {
    return Item{Alt<5, Fact<ExceptionName>>(a)};
  }
  static Item constant(const Fact<Constant>& a) {
    return Item{Alt<6, Fact<Constant>>(a)};
  }
  static Item enumValue(const Fact<EnumValue>& a) {
    return Item{Alt<7, Fact<EnumValue>>(a)};
  }

  bool operator==(const Item& other) const {
    return std::tie(GLEAN_value)
             == std::tie(other.GLEAN_value);
  }
  bool operator!=(const Item& other) const {
    return std::tie(GLEAN_value)
             != std::tie(other.GLEAN_value);
  }
  bool operator<(const Item& other) const {
    return std::tie(GLEAN_value)
             < std::tie(other.GLEAN_value);
  }
  bool operator<=(const Item& other) const {
    return std::tie(GLEAN_value)
             <= std::tie(other.GLEAN_value);
  }
  bool operator>(const Item& other) const {
    return std::tie(GLEAN_value)
             > std::tie(other.GLEAN_value);
  }
  bool operator>=(const Item& other) const {
    return std::tie(GLEAN_value)
             >= std::tie(other.GLEAN_value);
  }

  void outputRepr(Output<Repr<Item>> out) const {
    outputValue(out, GLEAN_value);
  }
}; // struct Item

} // namespace Thrift

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Thrift::IntegerLiteral> {
  using Type = Tuple<Bool, Nat>;
};


namespace schema {

namespace Thrift {

struct IntegerLiteral {
  bool isNonNegative;
  uint64_t absValue;

  bool operator==(const IntegerLiteral& other) const {
    return std::tie(isNonNegative,absValue)
             == std::tie(other.isNonNegative,other.absValue);
  }
  bool operator!=(const IntegerLiteral& other) const {
    return std::tie(isNonNegative,absValue)
             != std::tie(other.isNonNegative,other.absValue);
  }
  bool operator<(const IntegerLiteral& other) const {
    return std::tie(isNonNegative,absValue)
             < std::tie(other.isNonNegative,other.absValue);
  }
  bool operator<=(const IntegerLiteral& other) const {
    return std::tie(isNonNegative,absValue)
             <= std::tie(other.isNonNegative,other.absValue);
  }
  bool operator>(const IntegerLiteral& other) const {
    return std::tie(isNonNegative,absValue)
             > std::tie(other.isNonNegative,other.absValue);
  }
  bool operator>=(const IntegerLiteral& other) const {
    return std::tie(isNonNegative,absValue)
             >= std::tie(other.isNonNegative,other.absValue);
  }
  void outputRepr(Output<Repr<IntegerLiteral>> out) const {
    outputValue(out, std::make_tuple(isNonNegative, absValue));
  }
}; // struct IntegerLiteral

struct Includes : Predicate<std::tuple<Fact<File>, Fact<File>>> {
  static const char* GLEAN_name() {
    return "thrift.Includes";
  }

  static constexpr size_t GLEAN_version() {
     return 7;
  }
}; // struct Includes

struct IncludeStatement : Predicate<std::tuple<Fact<File>, Fact<File>, Loc>> {
  static const char* GLEAN_name() {
    return "thrift.IncludeStatement";
  }

  static constexpr size_t GLEAN_version() {
     return 7;
  }
}; // struct IncludeStatement

struct IncludeSplice : Predicate<std::string> {
  static const char* GLEAN_name() {
    return "thrift.IncludeSplice";
  }

  static constexpr size_t GLEAN_version() {
     return 7;
  }
}; // struct IncludeSplice

struct IncludeSpecial : Predicate<std::tuple<Fact<File>, std::string, Fact<IncludeSplice>>> {
  static const char* GLEAN_name() {
    return "thrift.IncludeSpecial";
  }

  static constexpr size_t GLEAN_version() {
     return 7;
  }
}; // struct IncludeSpecial

struct Identifier : Predicate<std::string> {
  static const char* GLEAN_name() {
    return "thrift.Identifier";
  }

  static constexpr size_t GLEAN_version() {
     return 7;
  }
}; // struct Identifier

} // namespace Thrift

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Thrift::HackRecordKind> {
  using Type = Enum<5>;
};


namespace schema {

namespace Thrift {

enum class HackRecordKind { class_, abstract_class, interface_, trait_, shape_ };

struct HackRecordContains : Predicate<std::tuple<Fact<HackRecord>, std::vector<Fact<HackMethod>>>> {
  static const char* GLEAN_name() {
    return "thrift.HackRecordContains";
  }

  static constexpr size_t GLEAN_version() {
     return 7;
  }
}; // struct HackRecordContains

struct HackRecord : Predicate<std::tuple<Fact<HackName>, HackRecordKind>> {
  static const char* GLEAN_name() {
    return "thrift.HackRecord";
  }

  static constexpr size_t GLEAN_version() {
     return 7;
  }
}; // struct HackRecord

struct HackName : Predicate<std::string> {
  static const char* GLEAN_name() {
    return "thrift.HackName";
  }

  static constexpr size_t GLEAN_version() {
     return 7;
  }
}; // struct HackName

struct HackMethod : Predicate<std::tuple<Fact<HackName>, Fact<HackRecord>>> {
  static const char* GLEAN_name() {
    return "thrift.HackMethod";
  }

  static constexpr size_t GLEAN_version() {
     return 7;
  }
}; // struct HackMethod

} // namespace Thrift

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Thrift::HackMapKind> {
  using Type = Enum<2>;
};


namespace schema {

namespace Thrift {

enum class HackMapKind { core, intern };

struct HackMap : Predicate<std::tuple<boost::variant<Alt<0, std::tuple<>>, Alt<1, Fact<facebook::glean::cpp::schema::Src::File>>>, Fact<facebook::glean::cpp::schema::Scm::RepoName>, std::string, HackMapKind, bool, bool, bool>> {
  static const char* GLEAN_name() {
    return "thrift.HackMap";
  }

  static constexpr size_t GLEAN_version() {
     return 7;
  }
}; // struct HackMap

} // namespace Thrift

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Thrift::HackKind> {
  using Type = Sum<facebook::glean::cpp::schema::Src::File, facebook::glean::cpp::schema::Thrift::HackRecord, facebook::glean::cpp::schema::Thrift::HackMethod, facebook::glean::cpp::schema::Thrift::HackName>;
};


namespace schema {

namespace Thrift {

struct HackKind {
  boost::variant<Alt<0, Fact<facebook::glean::cpp::schema::Src::File>>, Alt<1, Fact<HackRecord>>, Alt<2, Fact<HackMethod>>, Alt<3, Fact<HackName>>> GLEAN_value;

  static HackKind file(const Fact<facebook::glean::cpp::schema::Src::File>& a) {
    return HackKind{Alt<0, Fact<facebook::glean::cpp::schema::Src::File>>(a)};
  }
  static HackKind record(const Fact<HackRecord>& a) {
    return HackKind{Alt<1, Fact<HackRecord>>(a)};
  }
  static HackKind method(const Fact<HackMethod>& a) {
    return HackKind{Alt<2, Fact<HackMethod>>(a)};
  }
  static HackKind namespace_(const Fact<HackName>& a) {
    return HackKind{Alt<3, Fact<HackName>>(a)};
  }

  bool operator==(const HackKind& other) const {
    return std::tie(GLEAN_value)
             == std::tie(other.GLEAN_value);
  }
  bool operator!=(const HackKind& other) const {
    return std::tie(GLEAN_value)
             != std::tie(other.GLEAN_value);
  }
  bool operator<(const HackKind& other) const {
    return std::tie(GLEAN_value)
             < std::tie(other.GLEAN_value);
  }
  bool operator<=(const HackKind& other) const {
    return std::tie(GLEAN_value)
             <= std::tie(other.GLEAN_value);
  }
  bool operator>(const HackKind& other) const {
    return std::tie(GLEAN_value)
             > std::tie(other.GLEAN_value);
  }
  bool operator>=(const HackKind& other) const {
    return std::tie(GLEAN_value)
             >= std::tie(other.GLEAN_value);
  }

  void outputRepr(Output<Repr<HackKind>> out) const {
    outputValue(out, GLEAN_value);
  }
}; // struct HackKind

} // namespace Thrift

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Thrift::GenRole> {
  using Type = Enum<5>;
};


namespace schema {

namespace Thrift {

enum class GenRole { helper, server, client, type, constant };

struct FunctionName : Predicate<std::tuple<Fact<ServiceName>, Fact<Identifier>, Loc>> {
  static const char* GLEAN_name() {
    return "thrift.FunctionName";
  }

  static constexpr size_t GLEAN_version() {
     return 7;
  }
}; // struct FunctionName

struct FromPython : Predicate<std::tuple<PythonItem, Item, GenRole, Fact<Lang>>> {
  static const char* GLEAN_name() {
    return "thrift.FromPython";
  }

  static constexpr size_t GLEAN_version() {
     return 7;
  }
}; // struct FromPython

struct FromHack : Predicate<std::tuple<HackKind, Item, GenRole>> {
  static const char* GLEAN_name() {
    return "thrift.FromHack";
  }

  static constexpr size_t GLEAN_version() {
     return 7;
  }
}; // struct FromHack

} // namespace Thrift

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Thrift::FloatLiteral> {
  using Type = Tuple<Bool, Bool, Nat, Nat>;
};


namespace schema {

namespace Thrift {

struct FloatLiteral {
  bool isNaN;
  bool isPositive;
  uint64_t exponent;
  uint64_t significand;

  bool operator==(const FloatLiteral& other) const {
    return std::tie(isNaN,isPositive,exponent,significand)
             == std::tie(other.isNaN,other.isPositive,other.exponent,other.significand);
  }
  bool operator!=(const FloatLiteral& other) const {
    return std::tie(isNaN,isPositive,exponent,significand)
             != std::tie(other.isNaN,other.isPositive,other.exponent,other.significand);
  }
  bool operator<(const FloatLiteral& other) const {
    return std::tie(isNaN,isPositive,exponent,significand)
             < std::tie(other.isNaN,other.isPositive,other.exponent,other.significand);
  }
  bool operator<=(const FloatLiteral& other) const {
    return std::tie(isNaN,isPositive,exponent,significand)
             <= std::tie(other.isNaN,other.isPositive,other.exponent,other.significand);
  }
  bool operator>(const FloatLiteral& other) const {
    return std::tie(isNaN,isPositive,exponent,significand)
             > std::tie(other.isNaN,other.isPositive,other.exponent,other.significand);
  }
  bool operator>=(const FloatLiteral& other) const {
    return std::tie(isNaN,isPositive,exponent,significand)
             >= std::tie(other.isNaN,other.isPositive,other.exponent,other.significand);
  }
  void outputRepr(Output<Repr<FloatLiteral>> out) const {
    outputValue(out, std::make_tuple(isNaN, isPositive, exponent, significand));
  }
}; // struct FloatLiteral

struct Literal : Predicate<boost::variant<Alt<0, IntegerLiteral>, Alt<1, IntegerLiteral>, Alt<2, IntegerLiteral>, Alt<3, IntegerLiteral>, Alt<4, FloatLiteral>, Alt<5, FloatLiteral>, Alt<6, bool>, Alt<7, std::string>, Alt<8, std::vector<uint8_t>>, Alt<9, std::vector<TypedConst>>, Alt<10, std::vector<TypedConst>>, Alt<11, std::vector<TypedConst>>, Alt<12, std::vector<KeyValue>>, Alt<13, std::vector<KeyValue>>, Alt<14, Fact<Literal>>, Alt<15, Fact<StructVal>>, Alt<16, Fact<ExceptionVal>>, Alt<17, Fact<UnionVal>>, Alt<18, Fact<EnumVal>>>> {
  static const char* GLEAN_name() {
    return "thrift.Literal";
  }

  static constexpr size_t GLEAN_version() {
     return 7;
  }
}; // struct Literal

struct FileXRefs : Predicate<std::tuple<Fact<File>, std::vector<Target>, std::vector<XRef>>> {
  static const char* GLEAN_name() {
    return "thrift.FileXRefs";
  }

  static constexpr size_t GLEAN_version() {
     return 7;
  }
}; // struct FileXRefs

struct FileTarget : Predicate<std::tuple<Fact<File>, Fact<facebook::glean::cpp::schema::Buck::Target>>> {
  static const char* GLEAN_name() {
    return "thrift.FileTarget";
  }

  static constexpr size_t GLEAN_version() {
     return 7;
  }
}; // struct FileTarget

struct FileOutput : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Src::File>, Fact<OutputTarget>>> {
  static const char* GLEAN_name() {
    return "thrift.FileOutput";
  }

  static constexpr size_t GLEAN_version() {
     return 7;
  }
}; // struct FileOutput

struct FileError : Predicate<std::tuple<Fact<File>, std::string>> {
  static const char* GLEAN_name() {
    return "thrift.FileError";
  }

  static constexpr size_t GLEAN_version() {
     return 7;
  }
}; // struct FileError

struct File : Predicate<Fact<facebook::glean::cpp::schema::Src::File>> {
  static const char* GLEAN_name() {
    return "thrift.File";
  }

  static constexpr size_t GLEAN_version() {
     return 7;
  }
}; // struct File

using FieldId = IntegerLiteral;

} // namespace Thrift

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Thrift::FieldSpecification> {
  using Type = Tuple<Repr<facebook::glean::cpp::schema::Thrift::FieldId>, Repr<facebook::glean::cpp::schema::Thrift::Qualifier>, facebook::glean::cpp::schema::Thrift::TypeSpecification, facebook::glean::cpp::schema::Thrift::Identifier, Maybe<Repr<facebook::glean::cpp::schema::Thrift::TypedConst>>, Array<facebook::glean::cpp::schema::Thrift::StructuredAnnotation>>;
};


namespace schema {

namespace Thrift {

struct FieldSpecification {
  FieldId id;
  Qualifier qualifier;
  Fact<TypeSpecification> type_;
  Fact<Identifier> name;
  boost::variant<Alt<0, std::tuple<>>, Alt<1, TypedConst>> value;
  std::vector<Fact<StructuredAnnotation>> structuredAnnotations;

  bool operator==(const FieldSpecification& other) const {
    return std::tie(id,qualifier,type_,name,value,structuredAnnotations)
             == std::tie(other.id,other.qualifier,other.type_,other.name,other.value,other.structuredAnnotations);
  }
  bool operator!=(const FieldSpecification& other) const {
    return std::tie(id,qualifier,type_,name,value,structuredAnnotations)
             != std::tie(other.id,other.qualifier,other.type_,other.name,other.value,other.structuredAnnotations);
  }
  bool operator<(const FieldSpecification& other) const {
    return std::tie(id,qualifier,type_,name,value,structuredAnnotations)
             < std::tie(other.id,other.qualifier,other.type_,other.name,other.value,other.structuredAnnotations);
  }
  bool operator<=(const FieldSpecification& other) const {
    return std::tie(id,qualifier,type_,name,value,structuredAnnotations)
             <= std::tie(other.id,other.qualifier,other.type_,other.name,other.value,other.structuredAnnotations);
  }
  bool operator>(const FieldSpecification& other) const {
    return std::tie(id,qualifier,type_,name,value,structuredAnnotations)
             > std::tie(other.id,other.qualifier,other.type_,other.name,other.value,other.structuredAnnotations);
  }
  bool operator>=(const FieldSpecification& other) const {
    return std::tie(id,qualifier,type_,name,value,structuredAnnotations)
             >= std::tie(other.id,other.qualifier,other.type_,other.name,other.value,other.structuredAnnotations);
  }
  void outputRepr(Output<Repr<FieldSpecification>> out) const {
    outputValue(out, std::make_tuple(id, qualifier, type_, name, value, structuredAnnotations));
  }
}; // struct FieldSpecification

struct StructType : Predicate<std::tuple<Fact<QualName>, std::vector<FieldSpecification>, std::vector<Fact<StructuredAnnotation>>>> {
  static const char* GLEAN_name() {
    return "thrift.StructType";
  }

  static constexpr size_t GLEAN_version() {
     return 7;
  }
}; // struct StructType

} // namespace Thrift

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Thrift::UnqualField> {
  using Type = Tuple<Repr<facebook::glean::cpp::schema::Thrift::FieldId>, facebook::glean::cpp::schema::Thrift::TypeSpecification, facebook::glean::cpp::schema::Thrift::Identifier>;
};


namespace schema {

namespace Thrift {

struct UnqualField {
  FieldId id;
  Fact<TypeSpecification> type_;
  Fact<Identifier> name;

  bool operator==(const UnqualField& other) const {
    return std::tie(id,type_,name)
             == std::tie(other.id,other.type_,other.name);
  }
  bool operator!=(const UnqualField& other) const {
    return std::tie(id,type_,name)
             != std::tie(other.id,other.type_,other.name);
  }
  bool operator<(const UnqualField& other) const {
    return std::tie(id,type_,name)
             < std::tie(other.id,other.type_,other.name);
  }
  bool operator<=(const UnqualField& other) const {
    return std::tie(id,type_,name)
             <= std::tie(other.id,other.type_,other.name);
  }
  bool operator>(const UnqualField& other) const {
    return std::tie(id,type_,name)
             > std::tie(other.id,other.type_,other.name);
  }
  bool operator>=(const UnqualField& other) const {
    return std::tie(id,type_,name)
             >= std::tie(other.id,other.type_,other.name);
  }
  void outputRepr(Output<Repr<UnqualField>> out) const {
    outputValue(out, std::make_tuple(id, type_, name));
  }
}; // struct UnqualField

struct UnionType : Predicate<std::tuple<Fact<QualName>, std::vector<UnqualField>>> {
  static const char* GLEAN_name() {
    return "thrift.UnionType";
  }

  static constexpr size_t GLEAN_version() {
     return 7;
  }
}; // struct UnionType

using FbcodeLang = std::string;

struct ExceptionVal : Predicate<Fact<StructVal>> {
  static const char* GLEAN_name() {
    return "thrift.ExceptionVal";
  }

  static constexpr size_t GLEAN_version() {
     return 7;
  }
}; // struct ExceptionVal

struct ExceptionType : Predicate<std::tuple<Fact<QualName>, std::vector<FieldSpecification>, std::vector<Fact<StructuredAnnotation>>>> {
  static const char* GLEAN_name() {
    return "thrift.ExceptionType";
  }

  static constexpr size_t GLEAN_version() {
     return 7;
  }
}; // struct ExceptionType

} // namespace Thrift

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Thrift::ExceptionSpecName> {
  using Type = Sum<facebook::glean::cpp::schema::Thrift::ExceptionName, facebook::glean::cpp::schema::Thrift::TypeDefException>;
};


namespace schema {

namespace Thrift {

struct ExceptionSpecName {
  boost::variant<Alt<0, Fact<ExceptionName>>, Alt<1, Fact<TypeDefException>>> GLEAN_value;

  static ExceptionSpecName simple(const Fact<ExceptionName>& a) {
    return ExceptionSpecName{Alt<0, Fact<ExceptionName>>(a)};
  }
  static ExceptionSpecName typedef_(const Fact<TypeDefException>& a) {
    return ExceptionSpecName{Alt<1, Fact<TypeDefException>>(a)};
  }

  bool operator==(const ExceptionSpecName& other) const {
    return std::tie(GLEAN_value)
             == std::tie(other.GLEAN_value);
  }
  bool operator!=(const ExceptionSpecName& other) const {
    return std::tie(GLEAN_value)
             != std::tie(other.GLEAN_value);
  }
  bool operator<(const ExceptionSpecName& other) const {
    return std::tie(GLEAN_value)
             < std::tie(other.GLEAN_value);
  }
  bool operator<=(const ExceptionSpecName& other) const {
    return std::tie(GLEAN_value)
             <= std::tie(other.GLEAN_value);
  }
  bool operator>(const ExceptionSpecName& other) const {
    return std::tie(GLEAN_value)
             > std::tie(other.GLEAN_value);
  }
  bool operator>=(const ExceptionSpecName& other) const {
    return std::tie(GLEAN_value)
             >= std::tie(other.GLEAN_value);
  }

  void outputRepr(Output<Repr<ExceptionSpecName>> out) const {
    outputValue(out, GLEAN_value);
  }
}; // struct ExceptionSpecName

} // namespace Thrift

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Thrift::ExceptionSpecification> {
  using Type = Tuple<Repr<facebook::glean::cpp::schema::Thrift::FieldId>, Repr<facebook::glean::cpp::schema::Thrift::ExceptionSpecName>, facebook::glean::cpp::schema::Thrift::Identifier>;
};


namespace schema {

namespace Thrift {

struct ExceptionSpecification {
  FieldId id;
  ExceptionSpecName type_;
  Fact<Identifier> name;

  bool operator==(const ExceptionSpecification& other) const {
    return std::tie(id,type_,name)
             == std::tie(other.id,other.type_,other.name);
  }
  bool operator!=(const ExceptionSpecification& other) const {
    return std::tie(id,type_,name)
             != std::tie(other.id,other.type_,other.name);
  }
  bool operator<(const ExceptionSpecification& other) const {
    return std::tie(id,type_,name)
             < std::tie(other.id,other.type_,other.name);
  }
  bool operator<=(const ExceptionSpecification& other) const {
    return std::tie(id,type_,name)
             <= std::tie(other.id,other.type_,other.name);
  }
  bool operator>(const ExceptionSpecification& other) const {
    return std::tie(id,type_,name)
             > std::tie(other.id,other.type_,other.name);
  }
  bool operator>=(const ExceptionSpecification& other) const {
    return std::tie(id,type_,name)
             >= std::tie(other.id,other.type_,other.name);
  }
  void outputRepr(Output<Repr<ExceptionSpecification>> out) const {
    outputValue(out, std::make_tuple(id, type_, name));
  }
}; // struct ExceptionSpecification

} // namespace Thrift

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Thrift::ResultStream> {
  using Type = Tuple<Maybe<facebook::glean::cpp::schema::Thrift::TypeSpecification>, facebook::glean::cpp::schema::Thrift::TypeSpecification, Array<Repr<facebook::glean::cpp::schema::Thrift::ExceptionSpecification>>>;
};


namespace schema {

namespace Thrift {

struct ResultStream {
  boost::variant<Alt<0, std::tuple<>>, Alt<1, Fact<TypeSpecification>>> response;
  Fact<TypeSpecification> stream_;
  std::vector<ExceptionSpecification> throws_;

  bool operator==(const ResultStream& other) const {
    return std::tie(response,stream_,throws_)
             == std::tie(other.response,other.stream_,other.throws_);
  }
  bool operator!=(const ResultStream& other) const {
    return std::tie(response,stream_,throws_)
             != std::tie(other.response,other.stream_,other.throws_);
  }
  bool operator<(const ResultStream& other) const {
    return std::tie(response,stream_,throws_)
             < std::tie(other.response,other.stream_,other.throws_);
  }
  bool operator<=(const ResultStream& other) const {
    return std::tie(response,stream_,throws_)
             <= std::tie(other.response,other.stream_,other.throws_);
  }
  bool operator>(const ResultStream& other) const {
    return std::tie(response,stream_,throws_)
             > std::tie(other.response,other.stream_,other.throws_);
  }
  bool operator>=(const ResultStream& other) const {
    return std::tie(response,stream_,throws_)
             >= std::tie(other.response,other.stream_,other.throws_);
  }
  void outputRepr(Output<Repr<ResultStream>> out) const {
    outputValue(out, std::make_tuple(response, stream_, throws_));
  }
}; // struct ResultStream

struct TypeDefException : Predicate<std::tuple<Fact<NamedDecl>, ExceptionSpecName>> {
  static const char* GLEAN_name() {
    return "thrift.TypeDefException";
  }

  static constexpr size_t GLEAN_version() {
     return 7;
  }
}; // struct TypeDefException

struct ExceptionName : Predicate<std::tuple<Fact<QualName>, Loc>> {
  static const char* GLEAN_name() {
    return "thrift.ExceptionName";
  }

  static constexpr size_t GLEAN_version() {
     return 7;
  }
}; // struct ExceptionName

struct EnumerationType : Predicate<std::tuple<Fact<QualName>, std::vector<Fact<EnumValueDef>>>> {
  static const char* GLEAN_name() {
    return "thrift.EnumerationType";
  }

  static constexpr size_t GLEAN_version() {
     return 7;
  }
}; // struct EnumerationType

struct EnumValueDef : Predicate<std::tuple<Fact<EnumValue>, IntegerLiteral>> {
  static const char* GLEAN_name() {
    return "thrift.EnumValueDef";
  }

  static constexpr size_t GLEAN_version() {
     return 7;
  }
}; // struct EnumValueDef

struct EnumValue : Predicate<std::tuple<NamedType, Fact<Identifier>, Loc>> {
  static const char* GLEAN_name() {
    return "thrift.EnumValue";
  }

  static constexpr size_t GLEAN_version() {
     return 7;
  }
}; // struct EnumValue

struct EnumVal : Predicate<std::tuple<Fact<QualName>, Loc>> {
  static const char* GLEAN_name() {
    return "thrift.EnumVal";
  }

  static constexpr size_t GLEAN_version() {
     return 7;
  }
}; // struct EnumVal

using Declaration = XRefTarget;

struct DeclarationName : Predicate<std::tuple<Fact<QualName>, Declaration>> {
  static const char* GLEAN_name() {
    return "thrift.DeclarationName";
  }

  static constexpr size_t GLEAN_version() {
     return 7;
  }
}; // struct DeclarationName

struct DeclarationNameSpan : Predicate<std::tuple<Declaration, Fact<Identifier>, Fact<File>, Loc>> {
  static const char* GLEAN_name() {
    return "thrift.DeclarationNameSpan";
  }

  static constexpr size_t GLEAN_version() {
     return 7;
  }
}; // struct DeclarationNameSpan

struct FileDeclaration : Predicate<std::tuple<Fact<File>, Declaration>> {
  static const char* GLEAN_name() {
    return "thrift.FileDeclaration";
  }

  static constexpr size_t GLEAN_version() {
     return 7;
  }
}; // struct FileDeclaration

struct FunctionDeclarationName : Predicate<std::tuple<Fact<QualName>, Fact<Identifier>, Declaration>> {
  static const char* GLEAN_name() {
    return "thrift.FunctionDeclarationName";
  }

  static constexpr size_t GLEAN_version() {
     return 7;
  }
}; // struct FunctionDeclarationName

} // namespace Thrift

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Thrift::Cpp2ItemNamed> {
  using Type = Tuple<facebook::glean::cpp::schema::Src::File, String, String>;
};


namespace schema {

namespace Thrift {

struct Cpp2ItemNamed {
  Fact<facebook::glean::cpp::schema::Src::File> file;
  std::string kind;
  std::string name;

  bool operator==(const Cpp2ItemNamed& other) const {
    return std::tie(file,kind,name)
             == std::tie(other.file,other.kind,other.name);
  }
  bool operator!=(const Cpp2ItemNamed& other) const {
    return std::tie(file,kind,name)
             != std::tie(other.file,other.kind,other.name);
  }
  bool operator<(const Cpp2ItemNamed& other) const {
    return std::tie(file,kind,name)
             < std::tie(other.file,other.kind,other.name);
  }
  bool operator<=(const Cpp2ItemNamed& other) const {
    return std::tie(file,kind,name)
             <= std::tie(other.file,other.kind,other.name);
  }
  bool operator>(const Cpp2ItemNamed& other) const {
    return std::tie(file,kind,name)
             > std::tie(other.file,other.kind,other.name);
  }
  bool operator>=(const Cpp2ItemNamed& other) const {
    return std::tie(file,kind,name)
             >= std::tie(other.file,other.kind,other.name);
  }
  void outputRepr(Output<Repr<Cpp2ItemNamed>> out) const {
    outputValue(out, std::make_tuple(file, kind, name));
  }
}; // struct Cpp2ItemNamed

} // namespace Thrift

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Thrift::ContainerType> {
  using Type = Sum<facebook::glean::cpp::schema::Thrift::TypeSpecification, facebook::glean::cpp::schema::Thrift::TypeSpecification, Repr<facebook::glean::cpp::schema::Thrift::MapType>>;
};


namespace schema {

namespace Thrift {

struct ContainerType {
  boost::variant<Alt<0, Fact<TypeSpecification>>, Alt<1, Fact<TypeSpecification>>, Alt<2, MapType>> GLEAN_value;

  static ContainerType list_(const Fact<TypeSpecification>& a) {
    return ContainerType{Alt<0, Fact<TypeSpecification>>(a)};
  }
  static ContainerType set_(const Fact<TypeSpecification>& a) {
    return ContainerType{Alt<1, Fact<TypeSpecification>>(a)};
  }
  static ContainerType map_(const MapType& a) {
    return ContainerType{Alt<2, MapType>(a)};
  }

  bool operator==(const ContainerType& other) const {
    return std::tie(GLEAN_value)
             == std::tie(other.GLEAN_value);
  }
  bool operator!=(const ContainerType& other) const {
    return std::tie(GLEAN_value)
             != std::tie(other.GLEAN_value);
  }
  bool operator<(const ContainerType& other) const {
    return std::tie(GLEAN_value)
             < std::tie(other.GLEAN_value);
  }
  bool operator<=(const ContainerType& other) const {
    return std::tie(GLEAN_value)
             <= std::tie(other.GLEAN_value);
  }
  bool operator>(const ContainerType& other) const {
    return std::tie(GLEAN_value)
             > std::tie(other.GLEAN_value);
  }
  bool operator>=(const ContainerType& other) const {
    return std::tie(GLEAN_value)
             >= std::tie(other.GLEAN_value);
  }

  void outputRepr(Output<Repr<ContainerType>> out) const {
    outputValue(out, GLEAN_value);
  }
}; // struct ContainerType

struct TypeSpecification : Predicate<boost::variant<Alt<0, PrimitiveType>, Alt<1, ContainerType>, Alt<2, NamedType>>> {
  static const char* GLEAN_name() {
    return "thrift.TypeSpecification";
  }

  static constexpr size_t GLEAN_version() {
     return 7;
  }
}; // struct TypeSpecification

struct ConstantType : Predicate<std::tuple<Fact<QualName>, Fact<TypeSpecification>>> {
  static const char* GLEAN_name() {
    return "thrift.ConstantType";
  }

  static constexpr size_t GLEAN_version() {
     return 7;
  }
}; // struct ConstantType

struct Constant : Predicate<std::tuple<Fact<QualName>, Loc>> {
  static const char* GLEAN_name() {
    return "thrift.Constant";
  }

  static constexpr size_t GLEAN_version() {
     return 7;
  }
}; // struct Constant

struct CompileTarget : Predicate<std::tuple<Fact<FileTarget>, FbcodeLang, Fact<facebook::glean::cpp::schema::Buck::Target>>> {
  static const char* GLEAN_name() {
    return "thrift.CompileTarget";
  }

  static constexpr size_t GLEAN_version() {
     return 7;
  }
}; // struct CompileTarget

} // namespace Thrift

namespace Testinfra {

struct TestId : Predicate<uint64_t> {
  static const char* GLEAN_name() {
    return "testinfra.TestId";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct TestId

struct TaggedAssembly : Predicate<std::tuple<Fact<AssemblyId>, Fact<Tag>>> {
  static const char* GLEAN_name() {
    return "testinfra.TaggedAssembly";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct TaggedAssembly

struct Tag : Predicate<std::string> {
  static const char* GLEAN_name() {
    return "testinfra.Tag";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct Tag

} // namespace Testinfra

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Testinfra::OffsetSpan> {
  using Type = Tuple<Nat, Nat>;
};


namespace schema {

namespace Testinfra {

struct OffsetSpan {
  uint64_t offsetFromZero;
  uint64_t lengthAtLeastZero;

  bool operator==(const OffsetSpan& other) const {
    return std::tie(offsetFromZero,lengthAtLeastZero)
             == std::tie(other.offsetFromZero,other.lengthAtLeastZero);
  }
  bool operator!=(const OffsetSpan& other) const {
    return std::tie(offsetFromZero,lengthAtLeastZero)
             != std::tie(other.offsetFromZero,other.lengthAtLeastZero);
  }
  bool operator<(const OffsetSpan& other) const {
    return std::tie(offsetFromZero,lengthAtLeastZero)
             < std::tie(other.offsetFromZero,other.lengthAtLeastZero);
  }
  bool operator<=(const OffsetSpan& other) const {
    return std::tie(offsetFromZero,lengthAtLeastZero)
             <= std::tie(other.offsetFromZero,other.lengthAtLeastZero);
  }
  bool operator>(const OffsetSpan& other) const {
    return std::tie(offsetFromZero,lengthAtLeastZero)
             > std::tie(other.offsetFromZero,other.lengthAtLeastZero);
  }
  bool operator>=(const OffsetSpan& other) const {
    return std::tie(offsetFromZero,lengthAtLeastZero)
             >= std::tie(other.offsetFromZero,other.lengthAtLeastZero);
  }
  void outputRepr(Output<Repr<OffsetSpan>> out) const {
    outputValue(out, std::make_tuple(offsetFromZero, lengthAtLeastZero));
  }
}; // struct OffsetSpan

struct MeasuredFileOnly : Predicate<std::tuple<Fact<MeasuredFile>, Fact<facebook::glean::cpp::schema::Src::File>>> {
  static const char* GLEAN_name() {
    return "testinfra.MeasuredFileOnly";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct MeasuredFileOnly

struct MeasuredFile : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Src::File>, Fact<Assemblies>>> {
  static const char* GLEAN_name() {
    return "testinfra.MeasuredFile";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct MeasuredFile

} // namespace Testinfra

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Testinfra::HashAlgo> {
  using Type = Enum<3>;
};


namespace schema {

namespace Testinfra {

enum class HashAlgo { crc32, md5, sha1 };

struct Folder : Predicate<std::string> {
  static const char* GLEAN_name() {
    return "testinfra.Folder";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct Folder

} // namespace Testinfra

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Testinfra::FileLength> {
  using Type = Sum<Nat, Nat, Array<Nat>, Tuple<Nat, Nat>>;
};


namespace schema {

namespace Testinfra {

struct FileLength {
  boost::variant<Alt<0, uint64_t>, Alt<1, uint64_t>, Alt<2, std::vector<uint64_t>>, Alt<3, std::tuple<uint64_t, uint64_t>>> GLEAN_value;

  static FileLength lines(const uint64_t& a) {
    return FileLength{Alt<0, uint64_t>(a)};
  }
  static FileLength offset(const uint64_t& a) {
    return FileLength{Alt<1, uint64_t>(a)};
  }
  static FileLength lineOffsets(const std::vector<uint64_t>& a) {
    return FileLength{Alt<2, std::vector<uint64_t>>(a)};
  }
  static FileLength linesAndOffset(const uint64_t& lines, const uint64_t& offset) {
    return FileLength{Alt<3, std::tuple<uint64_t, uint64_t>>(std::make_tuple(lines, offset))};
  }

  bool operator==(const FileLength& other) const {
    return std::tie(GLEAN_value)
             == std::tie(other.GLEAN_value);
  }
  bool operator!=(const FileLength& other) const {
    return std::tie(GLEAN_value)
             != std::tie(other.GLEAN_value);
  }
  bool operator<(const FileLength& other) const {
    return std::tie(GLEAN_value)
             < std::tie(other.GLEAN_value);
  }
  bool operator<=(const FileLength& other) const {
    return std::tie(GLEAN_value)
             <= std::tie(other.GLEAN_value);
  }
  bool operator>(const FileLength& other) const {
    return std::tie(GLEAN_value)
             > std::tie(other.GLEAN_value);
  }
  bool operator>=(const FileLength& other) const {
    return std::tie(GLEAN_value)
             >= std::tie(other.GLEAN_value);
  }

  void outputRepr(Output<Repr<FileLength>> out) const {
    outputValue(out, GLEAN_value);
  }
}; // struct FileLength

} // namespace Testinfra

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Testinfra::FileHash> {
  using Type = Tuple<Repr<facebook::glean::cpp::schema::Testinfra::HashAlgo>, Nat>;
};


namespace schema {

namespace Testinfra {

struct FileHash {
  HashAlgo algo;
  uint64_t hash;

  bool operator==(const FileHash& other) const {
    return std::tie(algo,hash)
             == std::tie(other.algo,other.hash);
  }
  bool operator!=(const FileHash& other) const {
    return std::tie(algo,hash)
             != std::tie(other.algo,other.hash);
  }
  bool operator<(const FileHash& other) const {
    return std::tie(algo,hash)
             < std::tie(other.algo,other.hash);
  }
  bool operator<=(const FileHash& other) const {
    return std::tie(algo,hash)
             <= std::tie(other.algo,other.hash);
  }
  bool operator>(const FileHash& other) const {
    return std::tie(algo,hash)
             > std::tie(other.algo,other.hash);
  }
  bool operator>=(const FileHash& other) const {
    return std::tie(algo,hash)
             >= std::tie(other.algo,other.hash);
  }
  void outputRepr(Output<Repr<FileHash>> out) const {
    outputValue(out, std::make_tuple(algo, hash));
  }
}; // struct FileHash

struct FbId : Predicate<uint64_t> {
  static const char* GLEAN_name() {
    return "testinfra.FbId";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct FbId

struct DatabaseMetadataField : Predicate<std::string> {
  static const char* GLEAN_name() {
    return "testinfra.DatabaseMetadataField";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct DatabaseMetadataField

struct DatabaseMetadata : Predicate<std::tuple<std::string, std::string>> {
  static const char* GLEAN_name() {
    return "testinfra.DatabaseMetadata";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct DatabaseMetadata

struct CoveredOrLoadedFileTestIds : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Src::File>, Fact<TestId>>> {
  static const char* GLEAN_name() {
    return "testinfra.CoveredOrLoadedFileTestIds";
  }

  static constexpr size_t GLEAN_version() {
     return 5;
  }
}; // struct CoveredOrLoadedFileTestIds

struct CoveredFolder : Predicate<std::tuple<Fact<Folder>, std::vector<Fact<CoveredFolder>>, std::vector<Fact<CoveredFile>>>> {
  static const char* GLEAN_name() {
    return "testinfra.CoveredFolder";
  }

  static constexpr size_t GLEAN_version() {
     return 2;
  }
}; // struct CoveredFolder

struct CoveredFileTestIds : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Src::File>, Fact<TestId>>> {
  static const char* GLEAN_name() {
    return "testinfra.CoveredFileTestIds";
  }

  static constexpr size_t GLEAN_version() {
     return 5;
  }
}; // struct CoveredFileTestIds

struct CoveredFileTestIds_4 : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Src::File>, Fact<TestId>>> {
  static const char* GLEAN_name() {
    return "testinfra.CoveredFileTestIds";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct CoveredFileTestIds_4

struct CoveredFileOnly : Predicate<std::tuple<Fact<CoveredFile>, Fact<facebook::glean::cpp::schema::Src::File>>> {
  static const char* GLEAN_name() {
    return "testinfra.CoveredFileOnly";
  }

  static constexpr size_t GLEAN_version() {
     return 3;
  }
}; // struct CoveredFileOnly

struct CoveredFileByTagAndAssembly : Predicate<std::tuple<Fact<CoveredFile>, Fact<Tag>, Fact<AssemblyId>>> {
  static const char* GLEAN_name() {
    return "testinfra.CoveredFileByTagAndAssembly";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct CoveredFileByTagAndAssembly

struct CoveredFileByPushBlockingAssembly : Predicate<std::tuple<Fact<CoveredFile>, Fact<AssemblyId>>> {
  static const char* GLEAN_name() {
    return "testinfra.CoveredFileByPushBlockingAssembly";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct CoveredFileByPushBlockingAssembly

struct CoveredFileAssemblies : Predicate<std::tuple<Fact<CoveredFile>, Fact<Assemblies>>> {
  static const char* GLEAN_name() {
    return "testinfra.CoveredFileAssemblies";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct CoveredFileAssemblies

struct CoveredAssembly : Predicate<std::tuple<Fact<AssemblyId>, Fact<CoveredFolder>>> {
  static const char* GLEAN_name() {
    return "testinfra.CoveredAssembly";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct CoveredAssembly

} // namespace Testinfra

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Testinfra::CoverageRange> {
  using Type = Sum<Array<Repr<facebook::glean::cpp::schema::Testinfra::OffsetSpan>>, Array<Repr<facebook::glean::cpp::schema::Testinfra::OffsetSpan>>>;
};


namespace schema {

namespace Testinfra {

struct CoverageRange {
  boost::variant<Alt<0, std::vector<OffsetSpan>>, Alt<1, std::vector<OffsetSpan>>> GLEAN_value;

  static CoverageRange lineRanges(const std::vector<OffsetSpan>& a) {
    return CoverageRange{Alt<0, std::vector<OffsetSpan>>(a)};
  }
  static CoverageRange byteRanges(const std::vector<OffsetSpan>& a) {
    return CoverageRange{Alt<1, std::vector<OffsetSpan>>(a)};
  }

  bool operator==(const CoverageRange& other) const {
    return std::tie(GLEAN_value)
             == std::tie(other.GLEAN_value);
  }
  bool operator!=(const CoverageRange& other) const {
    return std::tie(GLEAN_value)
             != std::tie(other.GLEAN_value);
  }
  bool operator<(const CoverageRange& other) const {
    return std::tie(GLEAN_value)
             < std::tie(other.GLEAN_value);
  }
  bool operator<=(const CoverageRange& other) const {
    return std::tie(GLEAN_value)
             <= std::tie(other.GLEAN_value);
  }
  bool operator>(const CoverageRange& other) const {
    return std::tie(GLEAN_value)
             > std::tie(other.GLEAN_value);
  }
  bool operator>=(const CoverageRange& other) const {
    return std::tie(GLEAN_value)
             >= std::tie(other.GLEAN_value);
  }

  void outputRepr(Output<Repr<CoverageRange>> out) const {
    outputValue(out, GLEAN_value);
  }
}; // struct CoverageRange

struct FileMetadata_2 : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Src::File>, std::vector<FileHash>, boost::variant<Alt<0, std::tuple<>>, Alt<1, FileLength>>, boost::variant<Alt<0, std::tuple<>>, Alt<1, CoverageRange>>>> {
  static const char* GLEAN_name() {
    return "testinfra.FileMetadata";
  }

  static constexpr size_t GLEAN_version() {
     return 2;
  }
}; // struct FileMetadata_2

struct FileMetadata : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Src::File>, std::vector<FileHash>, boost::variant<Alt<0, std::tuple<>>, Alt<1, FileLength>>, boost::variant<Alt<0, std::tuple<>>, Alt<1, CoverageRange>>, boost::variant<Alt<0, std::tuple<>>, Alt<1, FileLength>>>> {
  static const char* GLEAN_name() {
    return "testinfra.FileMetadata";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct FileMetadata

} // namespace Testinfra

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Testinfra::CoverageGranularity> {
  using Type = Sum<Bool, Tuple<Repr<facebook::glean::cpp::schema::Testinfra::CoverageRange>, Maybe<Repr<facebook::glean::cpp::schema::Testinfra::CoverageRange>>>>;
};


namespace schema {

namespace Testinfra {

struct CoverageGranularity {
  boost::variant<Alt<0, bool>, Alt<1, std::tuple<CoverageRange, boost::variant<Alt<0, std::tuple<>>, Alt<1, CoverageRange>>>>> GLEAN_value;

  static CoverageGranularity file(const bool& a) {
    return CoverageGranularity{Alt<0, bool>(a)};
  }
  static CoverageGranularity range(const CoverageRange& coveredRanges, const boost::variant<Alt<0, std::tuple<>>, Alt<1, CoverageRange>>& uncoveredRanges) {
    return CoverageGranularity{Alt<1, std::tuple<CoverageRange, boost::variant<Alt<0, std::tuple<>>, Alt<1, CoverageRange>>>>(std::make_tuple(coveredRanges, uncoveredRanges))};
  }

  bool operator==(const CoverageGranularity& other) const {
    return std::tie(GLEAN_value)
             == std::tie(other.GLEAN_value);
  }
  bool operator!=(const CoverageGranularity& other) const {
    return std::tie(GLEAN_value)
             != std::tie(other.GLEAN_value);
  }
  bool operator<(const CoverageGranularity& other) const {
    return std::tie(GLEAN_value)
             < std::tie(other.GLEAN_value);
  }
  bool operator<=(const CoverageGranularity& other) const {
    return std::tie(GLEAN_value)
             <= std::tie(other.GLEAN_value);
  }
  bool operator>(const CoverageGranularity& other) const {
    return std::tie(GLEAN_value)
             > std::tie(other.GLEAN_value);
  }
  bool operator>=(const CoverageGranularity& other) const {
    return std::tie(GLEAN_value)
             >= std::tie(other.GLEAN_value);
  }

  void outputRepr(Output<Repr<CoverageGranularity>> out) const {
    outputValue(out, GLEAN_value);
  }
}; // struct CoverageGranularity

struct CoveredFile : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Src::File>, CoverageGranularity>> {
  static const char* GLEAN_name() {
    return "testinfra.CoveredFile";
  }

  static constexpr size_t GLEAN_version() {
     return 3;
  }
}; // struct CoveredFile

struct ContainsPushBlockingAssembly : Predicate<std::tuple<Fact<Assemblies>, Fact<AssemblyId>>> {
  static const char* GLEAN_name() {
    return "testinfra.ContainsPushBlockingAssembly";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct ContainsPushBlockingAssembly

struct AssemblyId : Predicate<boost::variant<Alt<0, Fact<TestId>>, Alt<1, Fact<FbId>>>> {
  static const char* GLEAN_name() {
    return "testinfra.AssemblyId";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct AssemblyId

struct AssemblyByTag : Predicate<std::tuple<Fact<Tag>, Fact<AssemblyId>>> {
  static const char* GLEAN_name() {
    return "testinfra.AssemblyByTag";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct AssemblyByTag

struct Assemblies : Predicate<std::vector<Fact<CoveredAssembly>>> {
  static const char* GLEAN_name() {
    return "testinfra.Assemblies";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct Assemblies

} // namespace Testinfra

namespace Sys {

struct Blob : Predicate<std::vector<uint8_t>> {
  static const char* GLEAN_name() {
    return "sys.Blob";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct Blob

} // namespace Sys

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Src::RelByteSpan> {
  using Type = Tuple<Nat, Nat>;
};


namespace schema {

namespace Src {

struct RelByteSpan {
  uint64_t offset;
  uint64_t length;

  bool operator==(const RelByteSpan& other) const {
    return std::tie(offset,length)
             == std::tie(other.offset,other.length);
  }
  bool operator!=(const RelByteSpan& other) const {
    return std::tie(offset,length)
             != std::tie(other.offset,other.length);
  }
  bool operator<(const RelByteSpan& other) const {
    return std::tie(offset,length)
             < std::tie(other.offset,other.length);
  }
  bool operator<=(const RelByteSpan& other) const {
    return std::tie(offset,length)
             <= std::tie(other.offset,other.length);
  }
  bool operator>(const RelByteSpan& other) const {
    return std::tie(offset,length)
             > std::tie(other.offset,other.length);
  }
  bool operator>=(const RelByteSpan& other) const {
    return std::tie(offset,length)
             >= std::tie(other.offset,other.length);
  }
  void outputRepr(Output<Repr<RelByteSpan>> out) const {
    outputValue(out, std::make_tuple(offset, length));
  }
}; // struct RelByteSpan

} // namespace Src

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Src::Range> {
  using Type = Tuple<facebook::glean::cpp::schema::Src::File, Nat, Nat, Nat, Nat>;
};


namespace schema {

namespace Src {

struct Range {
  Fact<File> file;
  uint64_t lineBegin;
  uint64_t columnBegin;
  uint64_t lineEnd;
  uint64_t columnEnd;

  bool operator==(const Range& other) const {
    return std::tie(file,lineBegin,columnBegin,lineEnd,columnEnd)
             == std::tie(other.file,other.lineBegin,other.columnBegin,other.lineEnd,other.columnEnd);
  }
  bool operator!=(const Range& other) const {
    return std::tie(file,lineBegin,columnBegin,lineEnd,columnEnd)
             != std::tie(other.file,other.lineBegin,other.columnBegin,other.lineEnd,other.columnEnd);
  }
  bool operator<(const Range& other) const {
    return std::tie(file,lineBegin,columnBegin,lineEnd,columnEnd)
             < std::tie(other.file,other.lineBegin,other.columnBegin,other.lineEnd,other.columnEnd);
  }
  bool operator<=(const Range& other) const {
    return std::tie(file,lineBegin,columnBegin,lineEnd,columnEnd)
             <= std::tie(other.file,other.lineBegin,other.columnBegin,other.lineEnd,other.columnEnd);
  }
  bool operator>(const Range& other) const {
    return std::tie(file,lineBegin,columnBegin,lineEnd,columnEnd)
             > std::tie(other.file,other.lineBegin,other.columnBegin,other.lineEnd,other.columnEnd);
  }
  bool operator>=(const Range& other) const {
    return std::tie(file,lineBegin,columnBegin,lineEnd,columnEnd)
             >= std::tie(other.file,other.lineBegin,other.columnBegin,other.lineEnd,other.columnEnd);
  }
  void outputRepr(Output<Repr<Range>> out) const {
    outputValue(out, std::make_tuple(file, lineBegin, columnBegin, lineEnd, columnEnd));
  }
}; // struct Range

struct RangeContains : Predicate<std::tuple<Range, Range>> {
  static const char* GLEAN_name() {
    return "src.RangeContains";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct RangeContains

} // namespace Src

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Src::PackedByteSpansGroup> {
  using Type = Tuple<Nat, Array<Nat>>;
};


namespace schema {

namespace Src {

struct PackedByteSpansGroup {
  uint64_t length;
  std::vector<uint64_t> offsets;

  bool operator==(const PackedByteSpansGroup& other) const {
    return std::tie(length,offsets)
             == std::tie(other.length,other.offsets);
  }
  bool operator!=(const PackedByteSpansGroup& other) const {
    return std::tie(length,offsets)
             != std::tie(other.length,other.offsets);
  }
  bool operator<(const PackedByteSpansGroup& other) const {
    return std::tie(length,offsets)
             < std::tie(other.length,other.offsets);
  }
  bool operator<=(const PackedByteSpansGroup& other) const {
    return std::tie(length,offsets)
             <= std::tie(other.length,other.offsets);
  }
  bool operator>(const PackedByteSpansGroup& other) const {
    return std::tie(length,offsets)
             > std::tie(other.length,other.offsets);
  }
  bool operator>=(const PackedByteSpansGroup& other) const {
    return std::tie(length,offsets)
             >= std::tie(other.length,other.offsets);
  }
  void outputRepr(Output<Repr<PackedByteSpansGroup>> out) const {
    outputValue(out, std::make_tuple(length, offsets));
  }
}; // struct PackedByteSpansGroup

using PackedByteSpans = std::vector<PackedByteSpansGroup>;

} // namespace Src

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Src::Loc> {
  using Type = Tuple<facebook::glean::cpp::schema::Src::File, Nat, Nat>;
};


namespace schema {

namespace Src {

struct Loc {
  Fact<File> file;
  uint64_t line;
  uint64_t column;

  bool operator==(const Loc& other) const {
    return std::tie(file,line,column)
             == std::tie(other.file,other.line,other.column);
  }
  bool operator!=(const Loc& other) const {
    return std::tie(file,line,column)
             != std::tie(other.file,other.line,other.column);
  }
  bool operator<(const Loc& other) const {
    return std::tie(file,line,column)
             < std::tie(other.file,other.line,other.column);
  }
  bool operator<=(const Loc& other) const {
    return std::tie(file,line,column)
             <= std::tie(other.file,other.line,other.column);
  }
  bool operator>(const Loc& other) const {
    return std::tie(file,line,column)
             > std::tie(other.file,other.line,other.column);
  }
  bool operator>=(const Loc& other) const {
    return std::tie(file,line,column)
             >= std::tie(other.file,other.line,other.column);
  }
  void outputRepr(Output<Repr<Loc>> out) const {
    outputValue(out, std::make_tuple(file, line, column));
  }
}; // struct Loc

} // namespace Src

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Src::Language> {
  using Type = Enum<11>;
};


namespace schema {

namespace Src {

enum class Language { Buck, C, Cpp, Hack, Haskell, ObjC, ObjCpp, Python, Thrift, Java, GraphQL };

} // namespace Src

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Src::IndexFailureReason> {
  using Type = Enum<4>;
};


namespace schema {

namespace Src {

enum class IndexFailureReason { CompileError, BuildSystemError, Unclassified, DiscoveryError };

struct IndexFailure : Predicate<std::tuple<Fact<File>, IndexFailureReason, std::string>> {
  static const char* GLEAN_name() {
    return "src.IndexFailure";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct IndexFailure

struct FileLines : Predicate<std::tuple<Fact<File>, std::vector<uint64_t>, bool, bool>> {
  static const char* GLEAN_name() {
    return "src.FileLines";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct FileLines

struct FileLanguage : Predicate<std::tuple<Fact<File>, Language>> {
  static const char* GLEAN_name() {
    return "src.FileLanguage";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct FileLanguage

struct FileDigest : Predicate<Fact<File>, std::string> {
  static const char* GLEAN_name() {
    return "src.FileDigest";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct FileDigest

struct File : Predicate<std::string> {
  static const char* GLEAN_name() {
    return "src.File";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct File

} // namespace Src

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Src::ByteSpan> {
  using Type = Tuple<Nat, Nat>;
};


namespace schema {

namespace Src {

struct ByteSpan {
  uint64_t start;
  uint64_t length;

  bool operator==(const ByteSpan& other) const {
    return std::tie(start,length)
             == std::tie(other.start,other.length);
  }
  bool operator!=(const ByteSpan& other) const {
    return std::tie(start,length)
             != std::tie(other.start,other.length);
  }
  bool operator<(const ByteSpan& other) const {
    return std::tie(start,length)
             < std::tie(other.start,other.length);
  }
  bool operator<=(const ByteSpan& other) const {
    return std::tie(start,length)
             <= std::tie(other.start,other.length);
  }
  bool operator>(const ByteSpan& other) const {
    return std::tie(start,length)
             > std::tie(other.start,other.length);
  }
  bool operator>=(const ByteSpan& other) const {
    return std::tie(start,length)
             >= std::tie(other.start,other.length);
  }
  void outputRepr(Output<Repr<ByteSpan>> out) const {
    outputValue(out, std::make_tuple(start, length));
  }
}; // struct ByteSpan

struct ByteSpanContains : Predicate<std::tuple<ByteSpan, ByteSpan>> {
  static const char* GLEAN_name() {
    return "src.ByteSpanContains";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct ByteSpanContains

} // namespace Src

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Src::FileLocation> {
  using Type = Tuple<facebook::glean::cpp::schema::Src::File, Repr<facebook::glean::cpp::schema::Src::ByteSpan>>;
};


namespace schema {

namespace Src {

struct FileLocation {
  Fact<File> file;
  ByteSpan span;

  bool operator==(const FileLocation& other) const {
    return std::tie(file,span)
             == std::tie(other.file,other.span);
  }
  bool operator!=(const FileLocation& other) const {
    return std::tie(file,span)
             != std::tie(other.file,other.span);
  }
  bool operator<(const FileLocation& other) const {
    return std::tie(file,span)
             < std::tie(other.file,other.span);
  }
  bool operator<=(const FileLocation& other) const {
    return std::tie(file,span)
             <= std::tie(other.file,other.span);
  }
  bool operator>(const FileLocation& other) const {
    return std::tie(file,span)
             > std::tie(other.file,other.span);
  }
  bool operator>=(const FileLocation& other) const {
    return std::tie(file,span)
             >= std::tie(other.file,other.span);
  }
  void outputRepr(Output<Repr<FileLocation>> out) const {
    outputValue(out, std::make_tuple(file, span));
  }
}; // struct FileLocation

} // namespace Src

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Src::ByteRange> {
  using Type = Tuple<Nat, Nat>;
};


namespace schema {

namespace Src {

struct ByteRange {
  uint64_t begin;
  uint64_t end;

  bool operator==(const ByteRange& other) const {
    return std::tie(begin,end)
             == std::tie(other.begin,other.end);
  }
  bool operator!=(const ByteRange& other) const {
    return std::tie(begin,end)
             != std::tie(other.begin,other.end);
  }
  bool operator<(const ByteRange& other) const {
    return std::tie(begin,end)
             < std::tie(other.begin,other.end);
  }
  bool operator<=(const ByteRange& other) const {
    return std::tie(begin,end)
             <= std::tie(other.begin,other.end);
  }
  bool operator>(const ByteRange& other) const {
    return std::tie(begin,end)
             > std::tie(other.begin,other.end);
  }
  bool operator>=(const ByteRange& other) const {
    return std::tie(begin,end)
             >= std::tie(other.begin,other.end);
  }
  void outputRepr(Output<Repr<ByteRange>> out) const {
    outputValue(out, std::make_tuple(begin, end));
  }
}; // struct ByteRange

} // namespace Src

namespace Spark {

namespace Ts {

struct VersionedCapability : Predicate<std::tuple<Fact<Capability>, Fact<CapabilityName>>> {
  static const char* GLEAN_name() {
    return "spark.ts.VersionedCapability";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct VersionedCapability

struct Version : Predicate<std::string> {
  static const char* GLEAN_name() {
    return "spark.ts.Version";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct Version

struct Type : Predicate<std::string> {
  static const char* GLEAN_name() {
    return "spark.ts.Type";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct Type

struct SymbolName : Predicate<std::tuple<Fact<Name>, Fact<SparkModule>>> {
  static const char* GLEAN_name() {
    return "spark.ts.SymbolName";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct SymbolName

} // namespace Ts

} // namespace Spark

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Spark::Ts::SymbolInfoDef> {
  using Type = Sum<facebook::glean::cpp::schema::Spark::Ts::AccessorInfo, facebook::glean::cpp::schema::Spark::Ts::ClassInfo, facebook::glean::cpp::schema::Spark::Ts::EnumInfo, facebook::glean::cpp::schema::Spark::Ts::EnumeratorInfo, facebook::glean::cpp::schema::Spark::Ts::MethodInfo, facebook::glean::cpp::schema::Spark::Ts::PropertyInfo>;
};


namespace schema {

namespace Spark {

namespace Ts {

struct SymbolInfoDef {
  boost::variant<Alt<0, Fact<AccessorInfo>>, Alt<1, Fact<ClassInfo>>, Alt<2, Fact<EnumInfo>>, Alt<3, Fact<EnumeratorInfo>>, Alt<4, Fact<MethodInfo>>, Alt<5, Fact<PropertyInfo>>> GLEAN_value;

  static SymbolInfoDef accessor(const Fact<AccessorInfo>& a) {
    return SymbolInfoDef{Alt<0, Fact<AccessorInfo>>(a)};
  }
  static SymbolInfoDef class_(const Fact<ClassInfo>& a) {
    return SymbolInfoDef{Alt<1, Fact<ClassInfo>>(a)};
  }
  static SymbolInfoDef enum_(const Fact<EnumInfo>& a) {
    return SymbolInfoDef{Alt<2, Fact<EnumInfo>>(a)};
  }
  static SymbolInfoDef enumerator(const Fact<EnumeratorInfo>& a) {
    return SymbolInfoDef{Alt<3, Fact<EnumeratorInfo>>(a)};
  }
  static SymbolInfoDef method(const Fact<MethodInfo>& a) {
    return SymbolInfoDef{Alt<4, Fact<MethodInfo>>(a)};
  }
  static SymbolInfoDef property(const Fact<PropertyInfo>& a) {
    return SymbolInfoDef{Alt<5, Fact<PropertyInfo>>(a)};
  }

  bool operator==(const SymbolInfoDef& other) const {
    return std::tie(GLEAN_value)
             == std::tie(other.GLEAN_value);
  }
  bool operator!=(const SymbolInfoDef& other) const {
    return std::tie(GLEAN_value)
             != std::tie(other.GLEAN_value);
  }
  bool operator<(const SymbolInfoDef& other) const {
    return std::tie(GLEAN_value)
             < std::tie(other.GLEAN_value);
  }
  bool operator<=(const SymbolInfoDef& other) const {
    return std::tie(GLEAN_value)
             <= std::tie(other.GLEAN_value);
  }
  bool operator>(const SymbolInfoDef& other) const {
    return std::tie(GLEAN_value)
             > std::tie(other.GLEAN_value);
  }
  bool operator>=(const SymbolInfoDef& other) const {
    return std::tie(GLEAN_value)
             >= std::tie(other.GLEAN_value);
  }

  void outputRepr(Output<Repr<SymbolInfoDef>> out) const {
    outputValue(out, GLEAN_value);
  }
}; // struct SymbolInfoDef

struct SymbolVersions : Predicate<std::tuple<SymbolInfoDef, boost::variant<Alt<0, std::tuple<>>, Alt<1, Fact<Version>>>, boost::variant<Alt<0, std::tuple<>>, Alt<1, Fact<Version>>>, boost::variant<Alt<0, std::tuple<>>, Alt<1, Fact<Version>>>>> {
  static const char* GLEAN_name() {
    return "spark.ts.SymbolVersions";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct SymbolVersions

struct SymbolCapabilities : Predicate<std::tuple<SymbolInfoDef, Fact<CapabilityName>>> {
  static const char* GLEAN_name() {
    return "spark.ts.SymbolCapabilities";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct SymbolCapabilities

} // namespace Ts

} // namespace Spark

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Spark::Ts::Symbol> {
  using Type = Sum<facebook::glean::cpp::schema::Spark::Ts::AccessorDecl, facebook::glean::cpp::schema::Spark::Ts::AccessorExtDecl, facebook::glean::cpp::schema::Spark::Ts::ClassDecl, facebook::glean::cpp::schema::Spark::Ts::EnumDecl, facebook::glean::cpp::schema::Spark::Ts::EnumeratorDecl, facebook::glean::cpp::schema::Spark::Ts::MethodDecl, facebook::glean::cpp::schema::Spark::Ts::MethodExtDecl, facebook::glean::cpp::schema::Spark::Ts::PropertyDecl, facebook::glean::cpp::schema::Spark::Ts::PropertyExtDecl>;
};


namespace schema {

namespace Spark {

namespace Ts {

struct Symbol {
  boost::variant<Alt<0, Fact<AccessorDecl>>, Alt<1, Fact<AccessorExtDecl>>, Alt<2, Fact<ClassDecl>>, Alt<3, Fact<EnumDecl>>, Alt<4, Fact<EnumeratorDecl>>, Alt<5, Fact<MethodDecl>>, Alt<6, Fact<MethodExtDecl>>, Alt<7, Fact<PropertyDecl>>, Alt<8, Fact<PropertyExtDecl>>> GLEAN_value;

  static Symbol accessor(const Fact<AccessorDecl>& a) {
    return Symbol{Alt<0, Fact<AccessorDecl>>(a)};
  }
  static Symbol accessorExt(const Fact<AccessorExtDecl>& a) {
    return Symbol{Alt<1, Fact<AccessorExtDecl>>(a)};
  }
  static Symbol class_(const Fact<ClassDecl>& a) {
    return Symbol{Alt<2, Fact<ClassDecl>>(a)};
  }
  static Symbol enum_(const Fact<EnumDecl>& a) {
    return Symbol{Alt<3, Fact<EnumDecl>>(a)};
  }
  static Symbol enumerator(const Fact<EnumeratorDecl>& a) {
    return Symbol{Alt<4, Fact<EnumeratorDecl>>(a)};
  }
  static Symbol method(const Fact<MethodDecl>& a) {
    return Symbol{Alt<5, Fact<MethodDecl>>(a)};
  }
  static Symbol methodExt(const Fact<MethodExtDecl>& a) {
    return Symbol{Alt<6, Fact<MethodExtDecl>>(a)};
  }
  static Symbol property(const Fact<PropertyDecl>& a) {
    return Symbol{Alt<7, Fact<PropertyDecl>>(a)};
  }
  static Symbol propertyExt(const Fact<PropertyExtDecl>& a) {
    return Symbol{Alt<8, Fact<PropertyExtDecl>>(a)};
  }

  bool operator==(const Symbol& other) const {
    return std::tie(GLEAN_value)
             == std::tie(other.GLEAN_value);
  }
  bool operator!=(const Symbol& other) const {
    return std::tie(GLEAN_value)
             != std::tie(other.GLEAN_value);
  }
  bool operator<(const Symbol& other) const {
    return std::tie(GLEAN_value)
             < std::tie(other.GLEAN_value);
  }
  bool operator<=(const Symbol& other) const {
    return std::tie(GLEAN_value)
             <= std::tie(other.GLEAN_value);
  }
  bool operator>(const Symbol& other) const {
    return std::tie(GLEAN_value)
             > std::tie(other.GLEAN_value);
  }
  bool operator>=(const Symbol& other) const {
    return std::tie(GLEAN_value)
             >= std::tie(other.GLEAN_value);
  }

  void outputRepr(Output<Repr<Symbol>> out) const {
    outputValue(out, GLEAN_value);
  }
}; // struct Symbol

struct SymbolInfo : Predicate<std::tuple<Symbol, SymbolInfoDef>> {
  static const char* GLEAN_name() {
    return "spark.ts.SymbolInfo";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct SymbolInfo

struct SymbolLocation : Predicate<std::tuple<Symbol, facebook::glean::cpp::schema::Src::FileLocation>> {
  static const char* GLEAN_name() {
    return "spark.ts.SymbolLocation";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct SymbolLocation

struct SymbolLocationInherited : Predicate<std::tuple<Symbol, Fact<Name>>> {
  static const char* GLEAN_name() {
    return "spark.ts.SymbolLocationInherited";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct SymbolLocationInherited

} // namespace Ts

} // namespace Spark

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Spark::Ts::SymbolXRef> {
  using Type = Tuple<Repr<facebook::glean::cpp::schema::Spark::Ts::Symbol>, Array<Repr<facebook::glean::cpp::schema::Src::RelByteSpan>>>;
};


namespace schema {

namespace Spark {

namespace Ts {

struct SymbolXRef {
  Symbol target;
  std::vector<facebook::glean::cpp::schema::Src::RelByteSpan> ranges;

  bool operator==(const SymbolXRef& other) const {
    return std::tie(target,ranges)
             == std::tie(other.target,other.ranges);
  }
  bool operator!=(const SymbolXRef& other) const {
    return std::tie(target,ranges)
             != std::tie(other.target,other.ranges);
  }
  bool operator<(const SymbolXRef& other) const {
    return std::tie(target,ranges)
             < std::tie(other.target,other.ranges);
  }
  bool operator<=(const SymbolXRef& other) const {
    return std::tie(target,ranges)
             <= std::tie(other.target,other.ranges);
  }
  bool operator>(const SymbolXRef& other) const {
    return std::tie(target,ranges)
             > std::tie(other.target,other.ranges);
  }
  bool operator>=(const SymbolXRef& other) const {
    return std::tie(target,ranges)
             >= std::tie(other.target,other.ranges);
  }
  void outputRepr(Output<Repr<SymbolXRef>> out) const {
    outputValue(out, std::make_tuple(target, ranges));
  }
}; // struct SymbolXRef

struct SparkModule : Predicate<std::tuple<Fact<Name>>> {
  static const char* GLEAN_name() {
    return "spark.ts.SparkModule";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct SparkModule

struct SignatureXRefs : Predicate<std::tuple<Fact<MethodInfo>, Fact<Signature>, std::vector<SymbolXRef>>> {
  static const char* GLEAN_name() {
    return "spark.ts.SignatureXRefs";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct SignatureXRefs

struct Signature : Predicate<std::tuple<Fact<Type>, Fact<Type>, std::vector<Fact<Type>>>> {
  static const char* GLEAN_name() {
    return "spark.ts.Signature";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct Signature

} // namespace Ts

} // namespace Spark

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Spark::Ts::ReleaseStatus> {
  using Type = Enum<4>;
};


namespace schema {

namespace Spark {

namespace Ts {

enum class ReleaseStatus { Beta, BetaCandidate, Prod, Dev };

struct SymbolStatus : Predicate<std::tuple<Symbol, ReleaseStatus>> {
  static const char* GLEAN_name() {
    return "spark.ts.SymbolStatus";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct SymbolStatus

struct PropertyExtDecl : Predicate<std::tuple<Fact<Name>, Fact<Name>>> {
  static const char* GLEAN_name() {
    return "spark.ts.PropertyExtDecl";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct PropertyExtDecl

} // namespace Ts

} // namespace Spark

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Spark::Ts::PropertyDeclaration> {
  using Type = Sum<facebook::glean::cpp::schema::Spark::Ts::PropertyDecl, facebook::glean::cpp::schema::Spark::Ts::PropertyExtDecl>;
};


namespace schema {

namespace Spark {

namespace Ts {

struct PropertyDeclaration {
  boost::variant<Alt<0, Fact<PropertyDecl>>, Alt<1, Fact<PropertyExtDecl>>> GLEAN_value;

  static PropertyDeclaration property(const Fact<PropertyDecl>& a) {
    return PropertyDeclaration{Alt<0, Fact<PropertyDecl>>(a)};
  }
  static PropertyDeclaration propertyExt(const Fact<PropertyExtDecl>& a) {
    return PropertyDeclaration{Alt<1, Fact<PropertyExtDecl>>(a)};
  }

  bool operator==(const PropertyDeclaration& other) const {
    return std::tie(GLEAN_value)
             == std::tie(other.GLEAN_value);
  }
  bool operator!=(const PropertyDeclaration& other) const {
    return std::tie(GLEAN_value)
             != std::tie(other.GLEAN_value);
  }
  bool operator<(const PropertyDeclaration& other) const {
    return std::tie(GLEAN_value)
             < std::tie(other.GLEAN_value);
  }
  bool operator<=(const PropertyDeclaration& other) const {
    return std::tie(GLEAN_value)
             <= std::tie(other.GLEAN_value);
  }
  bool operator>(const PropertyDeclaration& other) const {
    return std::tie(GLEAN_value)
             > std::tie(other.GLEAN_value);
  }
  bool operator>=(const PropertyDeclaration& other) const {
    return std::tie(GLEAN_value)
             >= std::tie(other.GLEAN_value);
  }

  void outputRepr(Output<Repr<PropertyDeclaration>> out) const {
    outputValue(out, GLEAN_value);
  }
}; // struct PropertyDeclaration

struct PropertyInfo : Predicate<std::tuple<PropertyDeclaration, boost::variant<Alt<0, std::tuple<>>, Alt<1, Fact<Doc>>>, Fact<Type>, bool>> {
  static const char* GLEAN_name() {
    return "spark.ts.PropertyInfo";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct PropertyInfo

struct Name : Predicate<std::string> {
  static const char* GLEAN_name() {
    return "spark.ts.Name";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct Name

struct ModuleSymbol : Predicate<std::tuple<Fact<SparkModule>, Symbol>> {
  static const char* GLEAN_name() {
    return "spark.ts.ModuleSymbol";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct ModuleSymbol

struct ModuleFiles : Predicate<std::tuple<Fact<SparkModule>, Fact<facebook::glean::cpp::schema::Src::File>>> {
  static const char* GLEAN_name() {
    return "spark.ts.ModuleFiles";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct ModuleFiles

struct ModuleExports : Predicate<std::tuple<Fact<SparkModule>, Symbol>> {
  static const char* GLEAN_name() {
    return "spark.ts.ModuleExports";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct ModuleExports

struct ModuleBase : Predicate<std::tuple<Fact<SparkModule>, Fact<ClassDecl>>> {
  static const char* GLEAN_name() {
    return "spark.ts.ModuleBase";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct ModuleBase

struct MethodExtDecl : Predicate<std::tuple<Fact<Name>, Fact<Name>>> {
  static const char* GLEAN_name() {
    return "spark.ts.MethodExtDecl";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct MethodExtDecl

} // namespace Ts

} // namespace Spark

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Spark::Ts::MethodDeclaration> {
  using Type = Sum<facebook::glean::cpp::schema::Spark::Ts::MethodDecl, facebook::glean::cpp::schema::Spark::Ts::MethodExtDecl>;
};


namespace schema {

namespace Spark {

namespace Ts {

struct MethodDeclaration {
  boost::variant<Alt<0, Fact<MethodDecl>>, Alt<1, Fact<MethodExtDecl>>> GLEAN_value;

  static MethodDeclaration method(const Fact<MethodDecl>& a) {
    return MethodDeclaration{Alt<0, Fact<MethodDecl>>(a)};
  }
  static MethodDeclaration methodExt(const Fact<MethodExtDecl>& a) {
    return MethodDeclaration{Alt<1, Fact<MethodExtDecl>>(a)};
  }

  bool operator==(const MethodDeclaration& other) const {
    return std::tie(GLEAN_value)
             == std::tie(other.GLEAN_value);
  }
  bool operator!=(const MethodDeclaration& other) const {
    return std::tie(GLEAN_value)
             != std::tie(other.GLEAN_value);
  }
  bool operator<(const MethodDeclaration& other) const {
    return std::tie(GLEAN_value)
             < std::tie(other.GLEAN_value);
  }
  bool operator<=(const MethodDeclaration& other) const {
    return std::tie(GLEAN_value)
             <= std::tie(other.GLEAN_value);
  }
  bool operator>(const MethodDeclaration& other) const {
    return std::tie(GLEAN_value)
             > std::tie(other.GLEAN_value);
  }
  bool operator>=(const MethodDeclaration& other) const {
    return std::tie(GLEAN_value)
             >= std::tie(other.GLEAN_value);
  }

  void outputRepr(Output<Repr<MethodDeclaration>> out) const {
    outputValue(out, GLEAN_value);
  }
}; // struct MethodDeclaration

struct MethodInfo : Predicate<std::tuple<MethodDeclaration, boost::variant<Alt<0, std::tuple<>>, Alt<1, Fact<Doc>>>, std::vector<Fact<Signature>>>> {
  static const char* GLEAN_name() {
    return "spark.ts.MethodInfo";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct MethodInfo

struct InheritsFrom : Predicate<std::tuple<Fact<ClassDecl>, std::vector<Fact<ClassDecl>>>> {
  static const char* GLEAN_name() {
    return "spark.ts.InheritsFrom";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct InheritsFrom

} // namespace Ts

} // namespace Spark

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Spark::Ts::ExtDecl> {
  using Type = Sum<facebook::glean::cpp::schema::Spark::Ts::AccessorExtDecl, facebook::glean::cpp::schema::Spark::Ts::MethodExtDecl, facebook::glean::cpp::schema::Spark::Ts::PropertyExtDecl>;
};


namespace schema {

namespace Spark {

namespace Ts {

struct ExtDecl {
  boost::variant<Alt<0, Fact<AccessorExtDecl>>, Alt<1, Fact<MethodExtDecl>>, Alt<2, Fact<PropertyExtDecl>>> GLEAN_value;

  static ExtDecl accessor(const Fact<AccessorExtDecl>& a) {
    return ExtDecl{Alt<0, Fact<AccessorExtDecl>>(a)};
  }
  static ExtDecl method(const Fact<MethodExtDecl>& a) {
    return ExtDecl{Alt<1, Fact<MethodExtDecl>>(a)};
  }
  static ExtDecl property(const Fact<PropertyExtDecl>& a) {
    return ExtDecl{Alt<2, Fact<PropertyExtDecl>>(a)};
  }

  bool operator==(const ExtDecl& other) const {
    return std::tie(GLEAN_value)
             == std::tie(other.GLEAN_value);
  }
  bool operator!=(const ExtDecl& other) const {
    return std::tie(GLEAN_value)
             != std::tie(other.GLEAN_value);
  }
  bool operator<(const ExtDecl& other) const {
    return std::tie(GLEAN_value)
             < std::tie(other.GLEAN_value);
  }
  bool operator<=(const ExtDecl& other) const {
    return std::tie(GLEAN_value)
             <= std::tie(other.GLEAN_value);
  }
  bool operator>(const ExtDecl& other) const {
    return std::tie(GLEAN_value)
             > std::tie(other.GLEAN_value);
  }
  bool operator>=(const ExtDecl& other) const {
    return std::tie(GLEAN_value)
             >= std::tie(other.GLEAN_value);
  }

  void outputRepr(Output<Repr<ExtDecl>> out) const {
    outputValue(out, GLEAN_value);
  }
}; // struct ExtDecl

struct ExtDeclScope : Predicate<std::tuple<ExtDecl, Fact<ClassDecl>>> {
  static const char* GLEAN_name() {
    return "spark.ts.ExtDeclScope";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct ExtDeclScope

struct ExampleCode : Predicate<std::string> {
  static const char* GLEAN_name() {
    return "spark.ts.ExampleCode";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct ExampleCode

struct EnumeratorInfo : Predicate<std::tuple<Fact<EnumeratorDecl>, boost::variant<Alt<0, std::tuple<>>, Alt<1, Fact<Doc>>>, boost::variant<Alt<0, std::tuple<>>, Alt<1, std::string>>>> {
  static const char* GLEAN_name() {
    return "spark.ts.EnumeratorInfo";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct EnumeratorInfo

struct EnumeratorDecl : Predicate<std::tuple<Fact<Name>, Fact<SparkModule>, Fact<EnumDecl>>> {
  static const char* GLEAN_name() {
    return "spark.ts.EnumeratorDecl";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct EnumeratorDecl

struct EnumInfo : Predicate<std::tuple<Fact<EnumDecl>, boost::variant<Alt<0, std::tuple<>>, Alt<1, Fact<Doc>>>, std::vector<Fact<EnumeratorDecl>>>> {
  static const char* GLEAN_name() {
    return "spark.ts.EnumInfo";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct EnumInfo

struct EnumDecl : Predicate<std::tuple<Fact<Name>, Fact<SparkModule>>> {
  static const char* GLEAN_name() {
    return "spark.ts.EnumDecl";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct EnumDecl

} // namespace Ts

} // namespace Spark

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Spark::Ts::DocumentType> {
  using Type = Enum<3>;
};


namespace schema {

namespace Spark {

namespace Ts {

enum class DocumentType { Effect, Block, Experience };

struct GatingInfo : Predicate<std::tuple<SymbolInfoDef, std::vector<DocumentType>, boost::variant<Alt<0, std::tuple<>>, Alt<1, Fact<ChangeKeyInfo>>>, std::vector<Fact<Capability>>>> {
  static const char* GLEAN_name() {
    return "spark.ts.GatingInfo";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct GatingInfo

struct DocXRefs : Predicate<std::tuple<SymbolInfoDef, std::vector<SymbolXRef>>> {
  static const char* GLEAN_name() {
    return "spark.ts.DocXRefs";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct DocXRefs

struct DocString : Predicate<std::tuple<SymbolInfoDef, Fact<Doc>>> {
  static const char* GLEAN_name() {
    return "spark.ts.DocString";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct DocString

struct DocLocationInherited : Predicate<std::tuple<Symbol, Fact<Name>>> {
  static const char* GLEAN_name() {
    return "spark.ts.DocLocationInherited";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct DocLocationInherited

struct DocLocation : Predicate<std::tuple<Symbol, facebook::glean::cpp::schema::Src::FileLocation>> {
  static const char* GLEAN_name() {
    return "spark.ts.DocLocation";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct DocLocation

struct Doc : Predicate<std::string> {
  static const char* GLEAN_name() {
    return "spark.ts.Doc";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct Doc

} // namespace Ts

} // namespace Spark

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Spark::Ts::Container> {
  using Type = Sum<facebook::glean::cpp::schema::Spark::Ts::ClassDecl>;
};


namespace schema {

namespace Spark {

namespace Ts {

struct Container {
  boost::variant<Alt<0, Fact<ClassDecl>>> GLEAN_value;

  static Container class_(const Fact<ClassDecl>& a) {
    return Container{Alt<0, Fact<ClassDecl>>(a)};
  }

  bool operator==(const Container& other) const {
    return std::tie(GLEAN_value)
             == std::tie(other.GLEAN_value);
  }
  bool operator!=(const Container& other) const {
    return std::tie(GLEAN_value)
             != std::tie(other.GLEAN_value);
  }
  bool operator<(const Container& other) const {
    return std::tie(GLEAN_value)
             < std::tie(other.GLEAN_value);
  }
  bool operator<=(const Container& other) const {
    return std::tie(GLEAN_value)
             <= std::tie(other.GLEAN_value);
  }
  bool operator>(const Container& other) const {
    return std::tie(GLEAN_value)
             > std::tie(other.GLEAN_value);
  }
  bool operator>=(const Container& other) const {
    return std::tie(GLEAN_value)
             >= std::tie(other.GLEAN_value);
  }

  void outputRepr(Output<Repr<Container>> out) const {
    outputValue(out, GLEAN_value);
  }
}; // struct Container

struct Contains : Predicate<std::tuple<Container, Symbol>> {
  static const char* GLEAN_name() {
    return "spark.ts.Contains";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct Contains

struct MethodDecl : Predicate<std::tuple<Fact<Name>, Fact<SparkModule>, Container>> {
  static const char* GLEAN_name() {
    return "spark.ts.MethodDecl";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct MethodDecl

struct PropertyDecl : Predicate<std::tuple<Fact<Name>, Fact<SparkModule>, Container>> {
  static const char* GLEAN_name() {
    return "spark.ts.PropertyDecl";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct PropertyDecl

struct ClassInfo : Predicate<std::tuple<Fact<ClassDecl>, bool, boost::variant<Alt<0, std::tuple<>>, Alt<1, Fact<Name>>>, boost::variant<Alt<0, std::tuple<>>, Alt<1, Fact<Doc>>>, boost::variant<Alt<0, std::tuple<>>, Alt<1, Fact<Type>>>, std::vector<Fact<ExampleCode>>, boost::variant<Alt<0, std::tuple<>>, Alt<1, Fact<ClassDecl>>>>> {
  static const char* GLEAN_name() {
    return "spark.ts.ClassInfo";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct ClassInfo

struct ClassDecl : Predicate<std::tuple<Fact<Name>, Fact<SparkModule>>> {
  static const char* GLEAN_name() {
    return "spark.ts.ClassDecl";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct ClassDecl

struct ChangeKeyVersion : Predicate<std::tuple<Fact<ChangeKey>, Fact<Version>>> {
  static const char* GLEAN_name() {
    return "spark.ts.ChangeKeyVersion";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct ChangeKeyVersion

struct ChangeKeyInfo : Predicate<std::tuple<boost::variant<Alt<0, std::tuple<>>, Alt<1, Fact<ChangeKey>>>, boost::variant<Alt<0, std::tuple<>>, Alt<1, Fact<ChangeKey>>>, boost::variant<Alt<0, std::tuple<>>, Alt<1, Fact<ChangeKey>>>>> {
  static const char* GLEAN_name() {
    return "spark.ts.ChangeKeyInfo";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct ChangeKeyInfo

struct ChangeKey : Predicate<std::string> {
  static const char* GLEAN_name() {
    return "spark.ts.ChangeKey";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct ChangeKey

struct CapabilityName : Predicate<std::string> {
  static const char* GLEAN_name() {
    return "spark.ts.CapabilityName";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct CapabilityName

} // namespace Ts

} // namespace Spark

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Spark::Ts::CapabilityConditionType> {
  using Type = Enum<2>;
};


namespace schema {

namespace Spark {

namespace Ts {

enum class CapabilityConditionType { CapabilityIf, CapabilityOr };

struct CapabilityConditionResult : Predicate<std::tuple<Fact<CapabilityCondition>, bool>> {
  static const char* GLEAN_name() {
    return "spark.ts.CapabilityConditionResult";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct CapabilityConditionResult

struct CapabilityCondition : Predicate<std::tuple<CapabilityConditionType, Fact<ChangeKey>>> {
  static const char* GLEAN_name() {
    return "spark.ts.CapabilityCondition";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct CapabilityCondition

struct Capability : Predicate<std::tuple<Fact<CapabilityName>, boost::variant<Alt<0, std::tuple<>>, Alt<1, Fact<CapabilityCondition>>>>> {
  static const char* GLEAN_name() {
    return "spark.ts.Capability";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct Capability

struct AccessorExtDecl : Predicate<std::tuple<Fact<Name>, Fact<Name>>> {
  static const char* GLEAN_name() {
    return "spark.ts.AccessorExtDecl";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct AccessorExtDecl

} // namespace Ts

} // namespace Spark

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Spark::Ts::AccessorDeclaration> {
  using Type = Sum<facebook::glean::cpp::schema::Spark::Ts::AccessorDecl, facebook::glean::cpp::schema::Spark::Ts::AccessorExtDecl>;
};


namespace schema {

namespace Spark {

namespace Ts {

struct AccessorDeclaration {
  boost::variant<Alt<0, Fact<AccessorDecl>>, Alt<1, Fact<AccessorExtDecl>>> GLEAN_value;

  static AccessorDeclaration accessor(const Fact<AccessorDecl>& a) {
    return AccessorDeclaration{Alt<0, Fact<AccessorDecl>>(a)};
  }
  static AccessorDeclaration accessorExt(const Fact<AccessorExtDecl>& a) {
    return AccessorDeclaration{Alt<1, Fact<AccessorExtDecl>>(a)};
  }

  bool operator==(const AccessorDeclaration& other) const {
    return std::tie(GLEAN_value)
             == std::tie(other.GLEAN_value);
  }
  bool operator!=(const AccessorDeclaration& other) const {
    return std::tie(GLEAN_value)
             != std::tie(other.GLEAN_value);
  }
  bool operator<(const AccessorDeclaration& other) const {
    return std::tie(GLEAN_value)
             < std::tie(other.GLEAN_value);
  }
  bool operator<=(const AccessorDeclaration& other) const {
    return std::tie(GLEAN_value)
             <= std::tie(other.GLEAN_value);
  }
  bool operator>(const AccessorDeclaration& other) const {
    return std::tie(GLEAN_value)
             > std::tie(other.GLEAN_value);
  }
  bool operator>=(const AccessorDeclaration& other) const {
    return std::tie(GLEAN_value)
             >= std::tie(other.GLEAN_value);
  }

  void outputRepr(Output<Repr<AccessorDeclaration>> out) const {
    outputValue(out, GLEAN_value);
  }
}; // struct AccessorDeclaration

struct AccessorInfo : Predicate<std::tuple<AccessorDeclaration, boost::variant<Alt<0, std::tuple<>>, Alt<1, Fact<Doc>>>, boost::variant<Alt<0, std::tuple<>>, Alt<1, Fact<Doc>>>, boost::variant<Alt<0, std::tuple<>>, Alt<1, Fact<Type>>>, boost::variant<Alt<0, std::tuple<>>, Alt<1, Fact<Type>>>>> {
  static const char* GLEAN_name() {
    return "spark.ts.AccessorInfo";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct AccessorInfo

struct AccessorDecl : Predicate<std::tuple<Fact<Name>, Fact<SparkModule>, Container>> {
  static const char* GLEAN_name() {
    return "spark.ts.AccessorDecl";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct AccessorDecl

} // namespace Ts

} // namespace Spark

namespace Search {

namespace Python {

struct QueryToScopeCase : Predicate<std::tuple<std::vector<std::string>, bool, boost::variant<Alt<0, std::tuple<>>, Alt<1, Fact<facebook::glean::cpp::schema::Python::SName>>>>> {
  static const char* GLEAN_name() {
    return "search.python.QueryToScopeCase";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct QueryToScopeCase

struct PythonNameCase : Predicate<std::tuple<bool, std::string, Fact<facebook::glean::cpp::schema::Python::Name>>> {
  static const char* GLEAN_name() {
    return "search.python.PythonNameCase";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct PythonNameCase

} // namespace Python

namespace Pp {

struct SearchByName : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Pp1::Macro>, Fact<facebook::glean::cpp::schema::Pp1::Define>>> {
  static const char* GLEAN_name() {
    return "search.pp.SearchByName";
  }

  static constexpr size_t GLEAN_version() {
     return 2;
  }
}; // struct SearchByName

struct SearchByName_1 : Predicate<std::tuple<std::string, Fact<facebook::glean::cpp::schema::Pp1::Define>>> {
  static const char* GLEAN_name() {
    return "search.pp.SearchByName";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct SearchByName_1

} // namespace Pp

namespace Java {

struct QueryToScopeCase : Predicate<std::tuple<std::vector<std::string>, bool, Fact<facebook::glean::cpp::schema::Javakotlin::Alpha::Path>>> {
  static const char* GLEAN_name() {
    return "search.java.QueryToScopeCase";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct QueryToScopeCase

struct NameCase : Predicate<std::tuple<bool, std::string, Fact<facebook::glean::cpp::schema::Javakotlin::Alpha::Name>>> {
  static const char* GLEAN_name() {
    return "search.java.NameCase";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct NameCase

} // namespace Java

namespace Hack {

struct QueryToScopeCase : Predicate<std::tuple<std::vector<std::string>, bool, Fact<facebook::glean::cpp::schema::Hack::Name>, boost::variant<Alt<0, std::tuple<>>, Alt<1, Fact<facebook::glean::cpp::schema::Hack::NamespaceQName>>>>> {
  static const char* GLEAN_name() {
    return "search.hack.QueryToScopeCase";
  }

  static constexpr size_t GLEAN_version() {
     return 7;
  }
}; // struct QueryToScopeCase

struct HackNameCase : Predicate<std::tuple<bool, std::string, Fact<facebook::glean::cpp::schema::Hack::Name>>> {
  static const char* GLEAN_name() {
    return "search.hack.HackNameCase";
  }

  static constexpr size_t GLEAN_version() {
     return 7;
  }
}; // struct HackNameCase

struct HackInAutoImportedNamespace : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Hack::Name>, boost::variant<Alt<0, std::tuple<>>, Alt<1, Fact<facebook::glean::cpp::schema::Hack::NamespaceQName>>>>> {
  static const char* GLEAN_name() {
    return "search.hack.HackInAutoImportedNamespace";
  }

  static constexpr size_t GLEAN_version() {
     return 7;
  }
}; // struct HackInAutoImportedNamespace

} // namespace Hack

namespace Flow {

struct TypeDeclarationAsDeclaration : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Flow::TypeDeclaration>, Fact<facebook::glean::cpp::schema::Flow::Declaration>>> {
  static const char* GLEAN_name() {
    return "search.flow.TypeDeclarationAsDeclaration";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct TypeDeclarationAsDeclaration

struct QueryToScopeCase : Predicate<std::tuple<std::vector<std::string>, bool, boost::variant<Alt<0, std::tuple<>>, Alt<1, Fact<facebook::glean::cpp::schema::Flow::Module>>>>> {
  static const char* GLEAN_name() {
    return "search.flow.QueryToScopeCase";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct QueryToScopeCase

struct FlowModuleNameCase : Predicate<std::tuple<bool, std::string, Fact<facebook::glean::cpp::schema::Flow::Module>>> {
  static const char* GLEAN_name() {
    return "search.flow.FlowModuleNameCase";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct FlowModuleNameCase

} // namespace Flow

namespace Cxx {

struct QueryToQNameCase : Predicate<std::tuple<std::vector<std::string>, bool, Fact<facebook::glean::cpp::schema::Cxx1::QName>>> {
  static const char* GLEAN_name() {
    return "search.cxx.QueryToQNameCase";
  }

  static constexpr size_t GLEAN_version() {
     return 5;
  }
}; // struct QueryToQNameCase

struct QueryToNSQNameCase : Predicate<std::tuple<std::vector<std::string>, bool, Fact<facebook::glean::cpp::schema::Cxx1::NamespaceQName>>> {
  static const char* GLEAN_name() {
    return "search.cxx.QueryToNSQNameCase";
  }

  static constexpr size_t GLEAN_version() {
     return 5;
  }
}; // struct QueryToNSQNameCase

struct CxxNameCase : Predicate<std::tuple<bool, std::string, Fact<facebook::glean::cpp::schema::Cxx1::Name>>> {
  static const char* GLEAN_name() {
    return "search.cxx.CxxNameCase";
  }

  static constexpr size_t GLEAN_version() {
     return 5;
  }
}; // struct CxxNameCase

} // namespace Cxx

} // namespace Search

namespace Scm {

struct Timestamp : Predicate<uint64_t> {
  static const char* GLEAN_name() {
    return "scm.Timestamp";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct Timestamp

struct Rev : Predicate<std::string> {
  static const char* GLEAN_name() {
    return "scm.Rev";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct Rev

struct RepoType : Predicate<std::string> {
  static const char* GLEAN_name() {
    return "scm.RepoType";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct RepoType

struct RepoName : Predicate<std::string> {
  static const char* GLEAN_name() {
    return "scm.RepoName";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct RepoName

struct Repo : Predicate<std::tuple<Fact<RepoName>, Fact<RepoType>>> {
  static const char* GLEAN_name() {
    return "scm.Repo";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct Repo

struct Commit : Predicate<std::tuple<Fact<Repo>, Fact<Rev>, Fact<Timestamp>>> {
  static const char* GLEAN_name() {
    return "scm.Commit";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct Commit

} // namespace Scm

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Scip::TextEncoding> {
  using Type = Enum<3>;
};


namespace schema {

namespace Scip {

enum class TextEncoding { UnspecifiedTextEncoding, UTF8, UTF16 };

struct SymbolName : Predicate<std::tuple<Fact<Symbol>, Fact<LocalName>>> {
  static const char* GLEAN_name() {
    return "scip.SymbolName";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct SymbolName

struct SymbolDocumentation : Predicate<std::tuple<Fact<Symbol>, Fact<Documentation>>> {
  static const char* GLEAN_name() {
    return "scip.SymbolDocumentation";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct SymbolDocumentation

struct Symbol : Predicate<std::string> {
  static const char* GLEAN_name() {
    return "scip.Symbol";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct Symbol

} // namespace Scip

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Scip::SomeEntity> {
  using Type = Tuple<facebook::glean::cpp::schema::Scip::Definition>;
};


namespace schema {

namespace Scip {

struct SomeEntity {
  Fact<Definition> defn;

  bool operator==(const SomeEntity& other) const {
    return std::tie(defn)
             == std::tie(other.defn);
  }
  bool operator!=(const SomeEntity& other) const {
    return std::tie(defn)
             != std::tie(other.defn);
  }
  bool operator<(const SomeEntity& other) const {
    return std::tie(defn)
             < std::tie(other.defn);
  }
  bool operator<=(const SomeEntity& other) const {
    return std::tie(defn)
             <= std::tie(other.defn);
  }
  bool operator>(const SomeEntity& other) const {
    return std::tie(defn)
             > std::tie(other.defn);
  }
  bool operator>=(const SomeEntity& other) const {
    return std::tie(defn)
             >= std::tie(other.defn);
  }
  void outputRepr(Output<Repr<SomeEntity>> out) const {
    outputValue(out, std::make_tuple(defn));
  }
}; // struct SomeEntity

struct ReferenceTarget : Predicate<std::tuple<Fact<Reference>, Fact<Definition>>> {
  static const char* GLEAN_name() {
    return "scip.ReferenceTarget";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct ReferenceTarget

struct Reference : Predicate<std::tuple<Fact<Symbol>, Fact<FileRange>>> {
  static const char* GLEAN_name() {
    return "scip.Reference";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct Reference

} // namespace Scip

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Scip::ProtocolVersion> {
  using Type = Enum<1>;
};


namespace schema {

namespace Scip {

enum class ProtocolVersion { UnspecifiedProtocolVersion };

} // namespace Scip

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Scip::Location> {
  using Type = Tuple<facebook::glean::cpp::schema::Src::File, Repr<facebook::glean::cpp::schema::Src::Range>, String>;
};


namespace schema {

namespace Scip {

struct Location {
  Fact<facebook::glean::cpp::schema::Src::File> file;
  facebook::glean::cpp::schema::Src::Range location;
  std::string name;

  bool operator==(const Location& other) const {
    return std::tie(file,location,name)
             == std::tie(other.file,other.location,other.name);
  }
  bool operator!=(const Location& other) const {
    return std::tie(file,location,name)
             != std::tie(other.file,other.location,other.name);
  }
  bool operator<(const Location& other) const {
    return std::tie(file,location,name)
             < std::tie(other.file,other.location,other.name);
  }
  bool operator<=(const Location& other) const {
    return std::tie(file,location,name)
             <= std::tie(other.file,other.location,other.name);
  }
  bool operator>(const Location& other) const {
    return std::tie(file,location,name)
             > std::tie(other.file,other.location,other.name);
  }
  bool operator>=(const Location& other) const {
    return std::tie(file,location,name)
             >= std::tie(other.file,other.location,other.name);
  }
  void outputRepr(Output<Repr<Location>> out) const {
    outputValue(out, std::make_tuple(file, location, name));
  }
}; // struct Location

struct LocalName : Predicate<std::string> {
  static const char* GLEAN_name() {
    return "scip.LocalName";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct LocalName

} // namespace Scip

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Scip::Entity> {
  using Type = Sum<Repr<facebook::glean::cpp::schema::Scip::SomeEntity>, Repr<facebook::glean::cpp::schema::Scip::SomeEntity>, Repr<facebook::glean::cpp::schema::Scip::SomeEntity>>;
};


namespace schema {

namespace Scip {

struct Entity {
  boost::variant<Alt<0, SomeEntity>, Alt<1, SomeEntity>, Alt<2, SomeEntity>> GLEAN_value;

  static Entity rust(const SomeEntity& a) {
    return Entity{Alt<0, SomeEntity>(a)};
  }
  static Entity go(const SomeEntity& a) {
    return Entity{Alt<1, SomeEntity>(a)};
  }
  static Entity typescript(const SomeEntity& a) {
    return Entity{Alt<2, SomeEntity>(a)};
  }

  bool operator==(const Entity& other) const {
    return std::tie(GLEAN_value)
             == std::tie(other.GLEAN_value);
  }
  bool operator!=(const Entity& other) const {
    return std::tie(GLEAN_value)
             != std::tie(other.GLEAN_value);
  }
  bool operator<(const Entity& other) const {
    return std::tie(GLEAN_value)
             < std::tie(other.GLEAN_value);
  }
  bool operator<=(const Entity& other) const {
    return std::tie(GLEAN_value)
             <= std::tie(other.GLEAN_value);
  }
  bool operator>(const Entity& other) const {
    return std::tie(GLEAN_value)
             > std::tie(other.GLEAN_value);
  }
  bool operator>=(const Entity& other) const {
    return std::tie(GLEAN_value)
             >= std::tie(other.GLEAN_value);
  }

  void outputRepr(Output<Repr<Entity>> out) const {
    outputValue(out, GLEAN_value);
  }
}; // struct Entity

struct EntityDefinition : Predicate<std::tuple<Entity, Fact<Definition>>> {
  static const char* GLEAN_name() {
    return "scip.EntityDefinition";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct EntityDefinition

struct EntityLocation : Predicate<std::tuple<Entity, Location>> {
  static const char* GLEAN_name() {
    return "scip.EntityLocation";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct EntityLocation

struct EntityUses : Predicate<std::tuple<Entity, Fact<facebook::glean::cpp::schema::Src::File>, facebook::glean::cpp::schema::Src::Range>> {
  static const char* GLEAN_name() {
    return "scip.EntityUses";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct EntityUses

struct FileEntityXRefLocation : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Src::File>, facebook::glean::cpp::schema::Src::Range, Location, Entity>> {
  static const char* GLEAN_name() {
    return "scip.FileEntityXRefLocation";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct FileEntityXRefLocation

struct ResolveLocation : Predicate<std::tuple<Location, Entity>> {
  static const char* GLEAN_name() {
    return "scip.ResolveLocation";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct ResolveLocation

struct SearchBySymbol : Predicate<std::tuple<Fact<Symbol>, Entity>> {
  static const char* GLEAN_name() {
    return "scip.SearchBySymbol";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct SearchBySymbol

struct Documentation : Predicate<std::string> {
  static const char* GLEAN_name() {
    return "scip.Documentation";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct Documentation

struct DefinitionUses : Predicate<std::tuple<Fact<Definition>, Fact<Reference>>> {
  static const char* GLEAN_name() {
    return "scip.DefinitionUses";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct DefinitionUses

struct DefinitionName : Predicate<std::tuple<Fact<Definition>, Fact<LocalName>>> {
  static const char* GLEAN_name() {
    return "scip.DefinitionName";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct DefinitionName

struct DefinitionDocumentation : Predicate<std::tuple<Fact<Definition>, Fact<Documentation>>> {
  static const char* GLEAN_name() {
    return "scip.DefinitionDocumentation";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct DefinitionDocumentation

struct Definition : Predicate<std::tuple<Fact<Symbol>, Fact<FileRange>>> {
  static const char* GLEAN_name() {
    return "scip.Definition";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct Definition

} // namespace Scip

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Python::XRefViaName> {
  using Type = Tuple<facebook::glean::cpp::schema::Python::Name, Repr<facebook::glean::cpp::schema::Src::ByteSpan>>;
};


namespace schema {

namespace Python {

struct XRefViaName {
  Fact<Name> target;
  facebook::glean::cpp::schema::Src::ByteSpan source;

  bool operator==(const XRefViaName& other) const {
    return std::tie(target,source)
             == std::tie(other.target,other.source);
  }
  bool operator!=(const XRefViaName& other) const {
    return std::tie(target,source)
             != std::tie(other.target,other.source);
  }
  bool operator<(const XRefViaName& other) const {
    return std::tie(target,source)
             < std::tie(other.target,other.source);
  }
  bool operator<=(const XRefViaName& other) const {
    return std::tie(target,source)
             <= std::tie(other.target,other.source);
  }
  bool operator>(const XRefViaName& other) const {
    return std::tie(target,source)
             > std::tie(other.target,other.source);
  }
  bool operator>=(const XRefViaName& other) const {
    return std::tie(target,source)
             >= std::tie(other.target,other.source);
  }
  void outputRepr(Output<Repr<XRefViaName>> out) const {
    outputValue(out, std::make_tuple(target, source));
  }
}; // struct XRefViaName

struct XRefsViaNameByFile : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Src::File>, std::vector<XRefViaName>>> {
  static const char* GLEAN_name() {
    return "python.XRefsViaNameByFile";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct XRefsViaNameByFile

struct VariableDeclaration : Predicate<std::tuple<Fact<Name>>> {
  static const char* GLEAN_name() {
    return "python.VariableDeclaration";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct VariableDeclaration

struct VariableBySName : Predicate<Fact<SName>, Fact<VariableDeclaration>> {
  static const char* GLEAN_name() {
    return "python.VariableBySName";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct VariableBySName

} // namespace Python

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Python::TypeInfo> {
  using Type = Tuple<facebook::glean::cpp::schema::Python::Type, Array<Repr<facebook::glean::cpp::schema::Python::XRefViaName>>>;
};


namespace schema {

namespace Python {

struct TypeInfo {
  Fact<Type> displayType;
  std::vector<XRefViaName> xrefs;

  bool operator==(const TypeInfo& other) const {
    return std::tie(displayType,xrefs)
             == std::tie(other.displayType,other.xrefs);
  }
  bool operator!=(const TypeInfo& other) const {
    return std::tie(displayType,xrefs)
             != std::tie(other.displayType,other.xrefs);
  }
  bool operator<(const TypeInfo& other) const {
    return std::tie(displayType,xrefs)
             < std::tie(other.displayType,other.xrefs);
  }
  bool operator<=(const TypeInfo& other) const {
    return std::tie(displayType,xrefs)
             <= std::tie(other.displayType,other.xrefs);
  }
  bool operator>(const TypeInfo& other) const {
    return std::tie(displayType,xrefs)
             > std::tie(other.displayType,other.xrefs);
  }
  bool operator>=(const TypeInfo& other) const {
    return std::tie(displayType,xrefs)
             >= std::tie(other.displayType,other.xrefs);
  }
  void outputRepr(Output<Repr<TypeInfo>> out) const {
    outputValue(out, std::make_tuple(displayType, xrefs));
  }
}; // struct TypeInfo

struct Type : Predicate<std::string> {
  static const char* GLEAN_name() {
    return "python.Type";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct Type

struct StringLiteral : Predicate<std::string> {
  static const char* GLEAN_name() {
    return "python.StringLiteral";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct StringLiteral

struct SNameToName : Predicate<Fact<SName>, Fact<Name>> {
  static const char* GLEAN_name() {
    return "python.SNameToName";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct SNameToName

struct SName : Predicate<std::tuple<Fact<Name>, boost::variant<Alt<0, std::tuple<>>, Alt<1, Fact<SName>>>>> {
  static const char* GLEAN_name() {
    return "python.SName";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct SName

struct ResolveOriginalName : Predicate<std::tuple<Fact<Name>, Fact<Name>>> {
  static const char* GLEAN_name() {
    return "python.ResolveOriginalName";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct ResolveOriginalName

} // namespace Python

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Python::Parameter> {
  using Type = Tuple<facebook::glean::cpp::schema::Python::Name, Maybe<Repr<facebook::glean::cpp::schema::Python::TypeInfo>>, Maybe<String>>;
};


namespace schema {

namespace Python {

struct Parameter {
  Fact<Name> name;
  boost::variant<Alt<0, std::tuple<>>, Alt<1, TypeInfo>> typeInfo;
  boost::variant<Alt<0, std::tuple<>>, Alt<1, std::string>> value;

  bool operator==(const Parameter& other) const {
    return std::tie(name,typeInfo,value)
             == std::tie(other.name,other.typeInfo,other.value);
  }
  bool operator!=(const Parameter& other) const {
    return std::tie(name,typeInfo,value)
             != std::tie(other.name,other.typeInfo,other.value);
  }
  bool operator<(const Parameter& other) const {
    return std::tie(name,typeInfo,value)
             < std::tie(other.name,other.typeInfo,other.value);
  }
  bool operator<=(const Parameter& other) const {
    return std::tie(name,typeInfo,value)
             <= std::tie(other.name,other.typeInfo,other.value);
  }
  bool operator>(const Parameter& other) const {
    return std::tie(name,typeInfo,value)
             > std::tie(other.name,other.typeInfo,other.value);
  }
  bool operator>=(const Parameter& other) const {
    return std::tie(name,typeInfo,value)
             >= std::tie(other.name,other.typeInfo,other.value);
  }
  void outputRepr(Output<Repr<Parameter>> out) const {
    outputValue(out, std::make_tuple(name, typeInfo, value));
  }
}; // struct Parameter

struct NameToSName : Predicate<Fact<Name>, Fact<SName>> {
  static const char* GLEAN_name() {
    return "python.NameToSName";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct NameToSName

struct Name : Predicate<std::string> {
  static const char* GLEAN_name() {
    return "python.Name";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct Name

struct ModuleDefinition : Predicate<std::tuple<Fact<Module>>> {
  static const char* GLEAN_name() {
    return "python.ModuleDefinition";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct ModuleDefinition

struct ModuleBySName : Predicate<Fact<SName>, Fact<Module>> {
  static const char* GLEAN_name() {
    return "python.ModuleBySName";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct ModuleBySName

struct Module : Predicate<std::tuple<Fact<Name>>> {
  static const char* GLEAN_name() {
    return "python.Module";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct Module

struct MethodWithLocalName : Predicate<std::tuple<Fact<ClassDeclaration>, Fact<Name>, Fact<FunctionDeclaration>>> {
  static const char* GLEAN_name() {
    return "python.MethodWithLocalName";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct MethodWithLocalName

struct MethodOverrides : Predicate<std::tuple<Fact<FunctionDeclaration>, Fact<FunctionDeclaration>>> {
  static const char* GLEAN_name() {
    return "python.MethodOverrides";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct MethodOverrides

struct MethodOverriden : Predicate<std::tuple<Fact<FunctionDeclaration>, Fact<FunctionDeclaration>>> {
  static const char* GLEAN_name() {
    return "python.MethodOverriden";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct MethodOverriden

struct LocalNameLowerCase : Predicate<std::tuple<std::string, Fact<LocalName>>> {
  static const char* GLEAN_name() {
    return "python.LocalNameLowerCase";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct LocalNameLowerCase

struct LocalName : Predicate<std::string> {
  static const char* GLEAN_name() {
    return "python.LocalName";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct LocalName

struct ImportStatementByAsSName : Predicate<std::tuple<Fact<SName>, Fact<ImportStatement>>> {
  static const char* GLEAN_name() {
    return "python.ImportStatementByAsSName";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct ImportStatementByAsSName

struct ImportStatementByAsName : Predicate<std::tuple<Fact<Name>, Fact<ImportStatement>>> {
  static const char* GLEAN_name() {
    return "python.ImportStatementByAsName";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct ImportStatementByAsName

struct ImportStatement : Predicate<std::tuple<Fact<Name>, Fact<Name>>> {
  static const char* GLEAN_name() {
    return "python.ImportStatement";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct ImportStatement

struct ImportStarsByFile : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Src::File>, facebook::glean::cpp::schema::Src::ByteSpan, Fact<ImportStarStatement>>> {
  static const char* GLEAN_name() {
    return "python.ImportStarsByFile";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct ImportStarsByFile

struct ImportStarStatement : Predicate<std::tuple<Fact<Name>, Fact<Module>>> {
  static const char* GLEAN_name() {
    return "python.ImportStarStatement";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct ImportStarStatement

struct ImportStarLocation : Predicate<std::tuple<Fact<ImportStarStatement>, Fact<facebook::glean::cpp::schema::Src::File>, facebook::glean::cpp::schema::Src::ByteSpan>> {
  static const char* GLEAN_name() {
    return "python.ImportStarLocation";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct ImportStarLocation

struct FunctionDeclaration : Predicate<std::tuple<Fact<Name>>> {
  static const char* GLEAN_name() {
    return "python.FunctionDeclaration";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct FunctionDeclaration

struct FunctionBySName : Predicate<Fact<SName>, Fact<FunctionDeclaration>> {
  static const char* GLEAN_name() {
    return "python.FunctionBySName";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct FunctionBySName

struct DerivedClassToBase : Predicate<std::tuple<Fact<ClassDeclaration>, Fact<ClassDeclaration>>> {
  static const char* GLEAN_name() {
    return "python.DerivedClassToBase";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct DerivedClassToBase

} // namespace Python

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Python::Definition> {
  using Type = Sum<facebook::glean::cpp::schema::Python::ClassDefinition, facebook::glean::cpp::schema::Python::FunctionDefinition, facebook::glean::cpp::schema::Python::VariableDefinition, facebook::glean::cpp::schema::Python::ModuleDefinition>;
};


namespace schema {

namespace Python {

struct Definition {
  boost::variant<Alt<0, Fact<ClassDefinition>>, Alt<1, Fact<FunctionDefinition>>, Alt<2, Fact<VariableDefinition>>, Alt<3, Fact<ModuleDefinition>>> GLEAN_value;

  static Definition cls(const Fact<ClassDefinition>& a) {
    return Definition{Alt<0, Fact<ClassDefinition>>(a)};
  }
  static Definition func(const Fact<FunctionDefinition>& a) {
    return Definition{Alt<1, Fact<FunctionDefinition>>(a)};
  }
  static Definition variable(const Fact<VariableDefinition>& a) {
    return Definition{Alt<2, Fact<VariableDefinition>>(a)};
  }
  static Definition module(const Fact<ModuleDefinition>& a) {
    return Definition{Alt<3, Fact<ModuleDefinition>>(a)};
  }

  bool operator==(const Definition& other) const {
    return std::tie(GLEAN_value)
             == std::tie(other.GLEAN_value);
  }
  bool operator!=(const Definition& other) const {
    return std::tie(GLEAN_value)
             != std::tie(other.GLEAN_value);
  }
  bool operator<(const Definition& other) const {
    return std::tie(GLEAN_value)
             < std::tie(other.GLEAN_value);
  }
  bool operator<=(const Definition& other) const {
    return std::tie(GLEAN_value)
             <= std::tie(other.GLEAN_value);
  }
  bool operator>(const Definition& other) const {
    return std::tie(GLEAN_value)
             > std::tie(other.GLEAN_value);
  }
  bool operator>=(const Definition& other) const {
    return std::tie(GLEAN_value)
             >= std::tie(other.GLEAN_value);
  }

  void outputRepr(Output<Repr<Definition>> out) const {
    outputValue(out, GLEAN_value);
  }
}; // struct Definition

struct DefinitionLocation : Predicate<std::tuple<Definition, Fact<facebook::glean::cpp::schema::Src::File>, facebook::glean::cpp::schema::Src::ByteSpan>> {
  static const char* GLEAN_name() {
    return "python.DefinitionLocation";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct DefinitionLocation

struct DefinitionsByFile : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Src::File>, facebook::glean::cpp::schema::Src::ByteSpan, Definition>> {
  static const char* GLEAN_name() {
    return "python.DefinitionsByFile";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct DefinitionsByFile

struct IsTopLevelDefinition : Predicate<Definition> {
  static const char* GLEAN_name() {
    return "python.IsTopLevelDefinition";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct IsTopLevelDefinition

using Decorator = std::string;

} // namespace Python

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Python::DeclarationContainer> {
  using Type = Sum<facebook::glean::cpp::schema::Python::Module, facebook::glean::cpp::schema::Python::ClassDeclaration, facebook::glean::cpp::schema::Python::FunctionDeclaration>;
};


namespace schema {

namespace Python {

struct DeclarationContainer {
  boost::variant<Alt<0, Fact<Module>>, Alt<1, Fact<ClassDeclaration>>, Alt<2, Fact<FunctionDeclaration>>> GLEAN_value;

  static DeclarationContainer module(const Fact<Module>& a) {
    return DeclarationContainer{Alt<0, Fact<Module>>(a)};
  }
  static DeclarationContainer cls(const Fact<ClassDeclaration>& a) {
    return DeclarationContainer{Alt<1, Fact<ClassDeclaration>>(a)};
  }
  static DeclarationContainer func(const Fact<FunctionDeclaration>& a) {
    return DeclarationContainer{Alt<2, Fact<FunctionDeclaration>>(a)};
  }

  bool operator==(const DeclarationContainer& other) const {
    return std::tie(GLEAN_value)
             == std::tie(other.GLEAN_value);
  }
  bool operator!=(const DeclarationContainer& other) const {
    return std::tie(GLEAN_value)
             != std::tie(other.GLEAN_value);
  }
  bool operator<(const DeclarationContainer& other) const {
    return std::tie(GLEAN_value)
             < std::tie(other.GLEAN_value);
  }
  bool operator<=(const DeclarationContainer& other) const {
    return std::tie(GLEAN_value)
             <= std::tie(other.GLEAN_value);
  }
  bool operator>(const DeclarationContainer& other) const {
    return std::tie(GLEAN_value)
             > std::tie(other.GLEAN_value);
  }
  bool operator>=(const DeclarationContainer& other) const {
    return std::tie(GLEAN_value)
             >= std::tie(other.GLEAN_value);
  }

  void outputRepr(Output<Repr<DeclarationContainer>> out) const {
    outputValue(out, GLEAN_value);
  }
}; // struct DeclarationContainer

struct FunctionDefinition : Predicate<std::tuple<Fact<FunctionDeclaration>, bool, boost::variant<Alt<0, std::tuple<>>, Alt<1, TypeInfo>>, std::vector<Parameter>, boost::variant<Alt<0, std::tuple<>>, Alt<1, std::vector<Parameter>>>, boost::variant<Alt<0, std::tuple<>>, Alt<1, std::vector<Parameter>>>, boost::variant<Alt<0, std::tuple<>>, Alt<1, Parameter>>, boost::variant<Alt<0, std::tuple<>>, Alt<1, Parameter>>, boost::variant<Alt<0, std::tuple<>>, Alt<1, std::vector<Decorator>>>, boost::variant<Alt<0, std::tuple<>>, Alt<1, DeclarationContainer>>>> {
  static const char* GLEAN_name() {
    return "python.FunctionDefinition";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct FunctionDefinition

struct VariableDefinition : Predicate<std::tuple<Fact<VariableDeclaration>, boost::variant<Alt<0, std::tuple<>>, Alt<1, TypeInfo>>, boost::variant<Alt<0, std::tuple<>>, Alt<1, DeclarationContainer>>>> {
  static const char* GLEAN_name() {
    return "python.VariableDefinition";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct VariableDefinition

} // namespace Python

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Python::Declaration> {
  using Type = Sum<facebook::glean::cpp::schema::Python::ClassDeclaration, facebook::glean::cpp::schema::Python::FunctionDeclaration, facebook::glean::cpp::schema::Python::VariableDeclaration, facebook::glean::cpp::schema::Python::ImportStatement, facebook::glean::cpp::schema::Python::Module>;
};


namespace schema {

namespace Python {

struct Declaration {
  boost::variant<Alt<0, Fact<ClassDeclaration>>, Alt<1, Fact<FunctionDeclaration>>, Alt<2, Fact<VariableDeclaration>>, Alt<3, Fact<ImportStatement>>, Alt<4, Fact<Module>>> GLEAN_value;

  static Declaration cls(const Fact<ClassDeclaration>& a) {
    return Declaration{Alt<0, Fact<ClassDeclaration>>(a)};
  }
  static Declaration func(const Fact<FunctionDeclaration>& a) {
    return Declaration{Alt<1, Fact<FunctionDeclaration>>(a)};
  }
  static Declaration variable(const Fact<VariableDeclaration>& a) {
    return Declaration{Alt<2, Fact<VariableDeclaration>>(a)};
  }
  static Declaration imp(const Fact<ImportStatement>& a) {
    return Declaration{Alt<3, Fact<ImportStatement>>(a)};
  }
  static Declaration module(const Fact<Module>& a) {
    return Declaration{Alt<4, Fact<Module>>(a)};
  }

  bool operator==(const Declaration& other) const {
    return std::tie(GLEAN_value)
             == std::tie(other.GLEAN_value);
  }
  bool operator!=(const Declaration& other) const {
    return std::tie(GLEAN_value)
             != std::tie(other.GLEAN_value);
  }
  bool operator<(const Declaration& other) const {
    return std::tie(GLEAN_value)
             < std::tie(other.GLEAN_value);
  }
  bool operator<=(const Declaration& other) const {
    return std::tie(GLEAN_value)
             <= std::tie(other.GLEAN_value);
  }
  bool operator>(const Declaration& other) const {
    return std::tie(GLEAN_value)
             > std::tie(other.GLEAN_value);
  }
  bool operator>=(const Declaration& other) const {
    return std::tie(GLEAN_value)
             >= std::tie(other.GLEAN_value);
  }

  void outputRepr(Output<Repr<Declaration>> out) const {
    outputValue(out, GLEAN_value);
  }
}; // struct Declaration

struct DeclarationDefinition : Predicate<std::tuple<Declaration, Definition>> {
  static const char* GLEAN_name() {
    return "python.DeclarationDefinition";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct DeclarationDefinition

struct DeclarationDocstring : Predicate<std::tuple<Declaration, facebook::glean::cpp::schema::Src::ByteSpan, std::string>> {
  static const char* GLEAN_name() {
    return "python.DeclarationDocstring";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct DeclarationDocstring

struct DeclarationLocation : Predicate<std::tuple<Declaration, Fact<facebook::glean::cpp::schema::Src::File>, facebook::glean::cpp::schema::Src::ByteSpan>> {
  static const char* GLEAN_name() {
    return "python.DeclarationLocation";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct DeclarationLocation

struct DeclarationReference : Predicate<std::tuple<Declaration, Declaration>> {
  static const char* GLEAN_name() {
    return "python.DeclarationReference";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct DeclarationReference

struct DeclarationToName : Predicate<Declaration, Fact<Name>> {
  static const char* GLEAN_name() {
    return "python.DeclarationToName";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct DeclarationToName

struct DeclarationUses : Predicate<std::tuple<Declaration, Fact<facebook::glean::cpp::schema::Src::File>, facebook::glean::cpp::schema::Src::ByteSpan>> {
  static const char* GLEAN_name() {
    return "python.DeclarationUses";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct DeclarationUses

struct DeclarationWithLocalName : Predicate<std::tuple<Fact<Name>, Declaration>> {
  static const char* GLEAN_name() {
    return "python.DeclarationWithLocalName";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct DeclarationWithLocalName

struct DeclarationWithName : Predicate<std::tuple<Fact<Name>, Declaration>> {
  static const char* GLEAN_name() {
    return "python.DeclarationWithName";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct DeclarationWithName

struct DeclarationWithSName : Predicate<std::tuple<Fact<SName>, Declaration>> {
  static const char* GLEAN_name() {
    return "python.DeclarationWithSName";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct DeclarationWithSName

struct DeclarationsByFile : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Src::File>, facebook::glean::cpp::schema::Src::ByteSpan, Declaration>> {
  static const char* GLEAN_name() {
    return "python.DeclarationsByFile";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct DeclarationsByFile

struct DefinitionDeclaration : Predicate<std::tuple<Definition, Declaration>> {
  static const char* GLEAN_name() {
    return "python.DefinitionDeclaration";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct DefinitionDeclaration

} // namespace Python

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Python::DirectXRef> {
  using Type = Tuple<Repr<facebook::glean::cpp::schema::Python::Declaration>, Repr<facebook::glean::cpp::schema::Src::ByteSpan>>;
};


namespace schema {

namespace Python {

struct DirectXRef {
  Declaration target;
  facebook::glean::cpp::schema::Src::ByteSpan source;

  bool operator==(const DirectXRef& other) const {
    return std::tie(target,source)
             == std::tie(other.target,other.source);
  }
  bool operator!=(const DirectXRef& other) const {
    return std::tie(target,source)
             != std::tie(other.target,other.source);
  }
  bool operator<(const DirectXRef& other) const {
    return std::tie(target,source)
             < std::tie(other.target,other.source);
  }
  bool operator<=(const DirectXRef& other) const {
    return std::tie(target,source)
             <= std::tie(other.target,other.source);
  }
  bool operator>(const DirectXRef& other) const {
    return std::tie(target,source)
             > std::tie(other.target,other.source);
  }
  bool operator>=(const DirectXRef& other) const {
    return std::tie(target,source)
             >= std::tie(other.target,other.source);
  }
  void outputRepr(Output<Repr<DirectXRef>> out) const {
    outputValue(out, std::make_tuple(target, source));
  }
}; // struct DirectXRef

struct DirectXRefsByFile : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Src::File>, DirectXRef>> {
  static const char* GLEAN_name() {
    return "python.DirectXRefsByFile";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct DirectXRefsByFile

struct IsAbstract : Predicate<Declaration> {
  static const char* GLEAN_name() {
    return "python.IsAbstract";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct IsAbstract

struct IsTopLevelDeclaration : Predicate<Declaration> {
  static const char* GLEAN_name() {
    return "python.IsTopLevelDeclaration";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct IsTopLevelDeclaration

struct NonImportDeclaration : Predicate<Declaration> {
  static const char* GLEAN_name() {
    return "python.NonImportDeclaration";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct NonImportDeclaration

struct SNameWithDeclaration : Predicate<std::tuple<Declaration, Fact<SName>>> {
  static const char* GLEAN_name() {
    return "python.SNameWithDeclaration";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct SNameWithDeclaration

struct SearchByLocalName : Predicate<std::tuple<Fact<LocalName>, Declaration>> {
  static const char* GLEAN_name() {
    return "python.SearchByLocalName";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct SearchByLocalName

struct Contains : Predicate<std::tuple<Declaration, Declaration>> {
  static const char* GLEAN_name() {
    return "python.Contains";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct Contains

struct ContainingTopLevelDeclaration : Predicate<std::tuple<Declaration, Declaration>> {
  static const char* GLEAN_name() {
    return "python.ContainingTopLevelDeclaration";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct ContainingTopLevelDeclaration

struct ContainedByTopLevelDeclaration : Predicate<std::tuple<Declaration, Declaration>> {
  static const char* GLEAN_name() {
    return "python.ContainedByTopLevelDeclaration";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct ContainedByTopLevelDeclaration

struct ContainedBy : Predicate<std::tuple<Declaration, Declaration>> {
  static const char* GLEAN_name() {
    return "python.ContainedBy";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct ContainedBy

struct ClassDefinition : Predicate<std::tuple<Fact<ClassDeclaration>, boost::variant<Alt<0, std::tuple<>>, Alt<1, std::vector<Fact<ClassDeclaration>>>>, boost::variant<Alt<0, std::tuple<>>, Alt<1, std::vector<Parameter>>>, boost::variant<Alt<0, std::tuple<>>, Alt<1, std::vector<Decorator>>>, boost::variant<Alt<0, std::tuple<>>, Alt<1, DeclarationContainer>>>> {
  static const char* GLEAN_name() {
    return "python.ClassDefinition";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct ClassDefinition

struct ClassDeclaration : Predicate<std::tuple<Fact<Name>, boost::variant<Alt<0, std::tuple<>>, Alt<1, std::vector<Fact<Name>>>>>> {
  static const char* GLEAN_name() {
    return "python.ClassDeclaration";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct ClassDeclaration

struct ClassBySName : Predicate<Fact<SName>, Fact<ClassDeclaration>> {
  static const char* GLEAN_name() {
    return "python.ClassBySName";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct ClassBySName

struct CalleeToCaller : Predicate<std::tuple<Fact<Name>, Fact<Name>>> {
  static const char* GLEAN_name() {
    return "python.CalleeToCaller";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct CalleeToCaller

struct BaseClassToDerived : Predicate<std::tuple<Fact<ClassDeclaration>, Fact<ClassDeclaration>>> {
  static const char* GLEAN_name() {
    return "python.BaseClassToDerived";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct BaseClassToDerived

} // namespace Python

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Python::Argument> {
  using Type = Sum<facebook::glean::cpp::schema::Python::StringLiteral>;
};


namespace schema {

namespace Python {

struct Argument {
  boost::variant<Alt<0, Fact<StringLiteral>>> GLEAN_value;

  static Argument lit(const Fact<StringLiteral>& a) {
    return Argument{Alt<0, Fact<StringLiteral>>(a)};
  }

  bool operator==(const Argument& other) const {
    return std::tie(GLEAN_value)
             == std::tie(other.GLEAN_value);
  }
  bool operator!=(const Argument& other) const {
    return std::tie(GLEAN_value)
             != std::tie(other.GLEAN_value);
  }
  bool operator<(const Argument& other) const {
    return std::tie(GLEAN_value)
             < std::tie(other.GLEAN_value);
  }
  bool operator<=(const Argument& other) const {
    return std::tie(GLEAN_value)
             <= std::tie(other.GLEAN_value);
  }
  bool operator>(const Argument& other) const {
    return std::tie(GLEAN_value)
             > std::tie(other.GLEAN_value);
  }
  bool operator>=(const Argument& other) const {
    return std::tie(GLEAN_value)
             >= std::tie(other.GLEAN_value);
  }

  void outputRepr(Output<Repr<Argument>> out) const {
    outputValue(out, GLEAN_value);
  }
}; // struct Argument

} // namespace Python

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Python::CallArgument> {
  using Type = Tuple<Maybe<facebook::glean::cpp::schema::Python::Name>, Repr<facebook::glean::cpp::schema::Src::ByteSpan>, Maybe<Repr<facebook::glean::cpp::schema::Python::Argument>>>;
};


namespace schema {

namespace Python {

struct CallArgument {
  boost::variant<Alt<0, std::tuple<>>, Alt<1, Fact<Name>>> label;
  facebook::glean::cpp::schema::Src::ByteSpan span;
  boost::variant<Alt<0, std::tuple<>>, Alt<1, Argument>> argument;

  bool operator==(const CallArgument& other) const {
    return std::tie(label,span,argument)
             == std::tie(other.label,other.span,other.argument);
  }
  bool operator!=(const CallArgument& other) const {
    return std::tie(label,span,argument)
             != std::tie(other.label,other.span,other.argument);
  }
  bool operator<(const CallArgument& other) const {
    return std::tie(label,span,argument)
             < std::tie(other.label,other.span,other.argument);
  }
  bool operator<=(const CallArgument& other) const {
    return std::tie(label,span,argument)
             <= std::tie(other.label,other.span,other.argument);
  }
  bool operator>(const CallArgument& other) const {
    return std::tie(label,span,argument)
             > std::tie(other.label,other.span,other.argument);
  }
  bool operator>=(const CallArgument& other) const {
    return std::tie(label,span,argument)
             >= std::tie(other.label,other.span,other.argument);
  }
  void outputRepr(Output<Repr<CallArgument>> out) const {
    outputValue(out, std::make_tuple(label, span, argument));
  }
}; // struct CallArgument

struct FileCall : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Src::File>, facebook::glean::cpp::schema::Src::ByteSpan, std::vector<CallArgument>>> {
  static const char* GLEAN_name() {
    return "python.FileCall";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct FileCall

} // namespace Python

namespace Pp1 {

struct Use : Predicate<std::tuple<Fact<Macro>, boost::variant<Alt<0, std::tuple<>>, Alt<1, facebook::glean::cpp::schema::Src::Loc>>, bool, facebook::glean::cpp::schema::Src::Range, facebook::glean::cpp::schema::Src::ByteSpan>> {
  static const char* GLEAN_name() {
    return "pp1.Use";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct Use

struct Undef : Predicate<std::tuple<Fact<Macro>, facebook::glean::cpp::schema::Src::Range>> {
  static const char* GLEAN_name() {
    return "pp1.Undef";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct Undef

struct Macro : Predicate<std::string> {
  static const char* GLEAN_name() {
    return "pp1.Macro";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct Macro

struct Include : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Src::File>, facebook::glean::cpp::schema::Src::Range, facebook::glean::cpp::schema::Src::ByteSpan>> {
  static const char* GLEAN_name() {
    return "pp1.Include";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct Include

struct DefineUse : Predicate<std::tuple<Fact<Define>, Fact<Use>>> {
  static const char* GLEAN_name() {
    return "pp1.DefineUse";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct DefineUse

struct Define : Predicate<std::tuple<Fact<Macro>, facebook::glean::cpp::schema::Src::Range>> {
  static const char* GLEAN_name() {
    return "pp1.Define";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct Define

} // namespace Pp1

namespace Perf {

namespace Hack {

using ScaledMillion = uint64_t;

} // namespace Hack

} // namespace Perf

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Perf::Hack::ReturnCount> {
  using Type = Tuple<Nat, Nat>;
};


namespace schema {

namespace Perf {

namespace Hack {

struct ReturnCount {
  uint64_t line_number;
  uint64_t exit_sample_count;

  bool operator==(const ReturnCount& other) const {
    return std::tie(line_number,exit_sample_count)
             == std::tie(other.line_number,other.exit_sample_count);
  }
  bool operator!=(const ReturnCount& other) const {
    return std::tie(line_number,exit_sample_count)
             != std::tie(other.line_number,other.exit_sample_count);
  }
  bool operator<(const ReturnCount& other) const {
    return std::tie(line_number,exit_sample_count)
             < std::tie(other.line_number,other.exit_sample_count);
  }
  bool operator<=(const ReturnCount& other) const {
    return std::tie(line_number,exit_sample_count)
             <= std::tie(other.line_number,other.exit_sample_count);
  }
  bool operator>(const ReturnCount& other) const {
    return std::tie(line_number,exit_sample_count)
             > std::tie(other.line_number,other.exit_sample_count);
  }
  bool operator>=(const ReturnCount& other) const {
    return std::tie(line_number,exit_sample_count)
             >= std::tie(other.line_number,other.exit_sample_count);
  }
  void outputRepr(Output<Repr<ReturnCount>> out) const {
    outputValue(out, std::make_tuple(line_number, exit_sample_count));
  }
}; // struct ReturnCount

struct ReturnPercentages : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Src::File>, std::string, uint64_t, std::vector<ReturnCount>>> {
  static const char* GLEAN_name() {
    return "perf.hack.ReturnPercentages";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct ReturnPercentages

} // namespace Hack

} // namespace Perf

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Perf::Hack::LoopCount> {
  using Type = Tuple<Nat, Nat, Nat>;
};


namespace schema {

namespace Perf {

namespace Hack {

struct LoopCount {
  uint64_t line_number;
  uint64_t num_iterations;
  uint64_t count;

  bool operator==(const LoopCount& other) const {
    return std::tie(line_number,num_iterations,count)
             == std::tie(other.line_number,other.num_iterations,other.count);
  }
  bool operator!=(const LoopCount& other) const {
    return std::tie(line_number,num_iterations,count)
             != std::tie(other.line_number,other.num_iterations,other.count);
  }
  bool operator<(const LoopCount& other) const {
    return std::tie(line_number,num_iterations,count)
             < std::tie(other.line_number,other.num_iterations,other.count);
  }
  bool operator<=(const LoopCount& other) const {
    return std::tie(line_number,num_iterations,count)
             <= std::tie(other.line_number,other.num_iterations,other.count);
  }
  bool operator>(const LoopCount& other) const {
    return std::tie(line_number,num_iterations,count)
             > std::tie(other.line_number,other.num_iterations,other.count);
  }
  bool operator>=(const LoopCount& other) const {
    return std::tie(line_number,num_iterations,count)
             >= std::tie(other.line_number,other.num_iterations,other.count);
  }
  void outputRepr(Output<Repr<LoopCount>> out) const {
    outputValue(out, std::make_tuple(line_number, num_iterations, count));
  }
}; // struct LoopCount

struct LoopCounts : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Src::File>, std::vector<LoopCount>>> {
  static const char* GLEAN_name() {
    return "perf.hack.LoopCounts";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct LoopCounts

} // namespace Hack

} // namespace Perf

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Perf::Hack::FunctionProducts> {
  using Type = Tuple<String, Repr<facebook::glean::cpp::schema::Perf::Hack::ScaledMillion>>;
};


namespace schema {

namespace Perf {

namespace Hack {

struct FunctionProducts {
  std::string product_name;
  ScaledMillion product_call_percent;

  bool operator==(const FunctionProducts& other) const {
    return std::tie(product_name,product_call_percent)
             == std::tie(other.product_name,other.product_call_percent);
  }
  bool operator!=(const FunctionProducts& other) const {
    return std::tie(product_name,product_call_percent)
             != std::tie(other.product_name,other.product_call_percent);
  }
  bool operator<(const FunctionProducts& other) const {
    return std::tie(product_name,product_call_percent)
             < std::tie(other.product_name,other.product_call_percent);
  }
  bool operator<=(const FunctionProducts& other) const {
    return std::tie(product_name,product_call_percent)
             <= std::tie(other.product_name,other.product_call_percent);
  }
  bool operator>(const FunctionProducts& other) const {
    return std::tie(product_name,product_call_percent)
             > std::tie(other.product_name,other.product_call_percent);
  }
  bool operator>=(const FunctionProducts& other) const {
    return std::tie(product_name,product_call_percent)
             >= std::tie(other.product_name,other.product_call_percent);
  }
  void outputRepr(Output<Repr<FunctionProducts>> out) const {
    outputValue(out, std::make_tuple(product_name, product_call_percent));
  }
}; // struct FunctionProducts

using FunctionName = std::string;

using FullName = std::string;

} // namespace Hack

} // namespace Perf

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Perf::Hack::FileLine> {
  using Type = Tuple<facebook::glean::cpp::schema::Src::File, Nat>;
};


namespace schema {

namespace Perf {

namespace Hack {

struct FileLine {
  Fact<facebook::glean::cpp::schema::Src::File> file;
  uint64_t line;

  bool operator==(const FileLine& other) const {
    return std::tie(file,line)
             == std::tie(other.file,other.line);
  }
  bool operator!=(const FileLine& other) const {
    return std::tie(file,line)
             != std::tie(other.file,other.line);
  }
  bool operator<(const FileLine& other) const {
    return std::tie(file,line)
             < std::tie(other.file,other.line);
  }
  bool operator<=(const FileLine& other) const {
    return std::tie(file,line)
             <= std::tie(other.file,other.line);
  }
  bool operator>(const FileLine& other) const {
    return std::tie(file,line)
             > std::tie(other.file,other.line);
  }
  bool operator>=(const FileLine& other) const {
    return std::tie(file,line)
             >= std::tie(other.file,other.line);
  }
  void outputRepr(Output<Repr<FileLine>> out) const {
    outputValue(out, std::make_tuple(file, line));
  }
}; // struct FileLine

} // namespace Hack

} // namespace Perf

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Perf::Hack::FunctionCallers> {
  using Type = Tuple<String, Repr<facebook::glean::cpp::schema::Perf::Hack::FileLine>, Repr<facebook::glean::cpp::schema::Perf::Hack::ScaledMillion>>;
};


namespace schema {

namespace Perf {

namespace Hack {

struct FunctionCallers {
  std::string caller_name;
  FileLine caller_location;
  ScaledMillion caller_call_percent;

  bool operator==(const FunctionCallers& other) const {
    return std::tie(caller_name,caller_location,caller_call_percent)
             == std::tie(other.caller_name,other.caller_location,other.caller_call_percent);
  }
  bool operator!=(const FunctionCallers& other) const {
    return std::tie(caller_name,caller_location,caller_call_percent)
             != std::tie(other.caller_name,other.caller_location,other.caller_call_percent);
  }
  bool operator<(const FunctionCallers& other) const {
    return std::tie(caller_name,caller_location,caller_call_percent)
             < std::tie(other.caller_name,other.caller_location,other.caller_call_percent);
  }
  bool operator<=(const FunctionCallers& other) const {
    return std::tie(caller_name,caller_location,caller_call_percent)
             <= std::tie(other.caller_name,other.caller_location,other.caller_call_percent);
  }
  bool operator>(const FunctionCallers& other) const {
    return std::tie(caller_name,caller_location,caller_call_percent)
             > std::tie(other.caller_name,other.caller_location,other.caller_call_percent);
  }
  bool operator>=(const FunctionCallers& other) const {
    return std::tie(caller_name,caller_location,caller_call_percent)
             >= std::tie(other.caller_name,other.caller_location,other.caller_call_percent);
  }
  void outputRepr(Output<Repr<FunctionCallers>> out) const {
    outputValue(out, std::make_tuple(caller_name, caller_location, caller_call_percent));
  }
}; // struct FunctionCallers

struct FunctionData : Predicate<std::tuple<FileLine, FunctionName, FullName, ScaledMillion, ScaledMillion, ScaledMillion, uint64_t, std::vector<FunctionCallers>, std::vector<FunctionProducts>>> {
  static const char* GLEAN_name() {
    return "perf.hack.FunctionData";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct FunctionData

} // namespace Hack

} // namespace Perf

namespace Omegaanalyser {

struct PolicyOncall : Predicate<std::tuple<Fact<OmegaPolicy>, Fact<OncallName>>> {
  static const char* GLEAN_name() {
    return "omegaanalyser.PolicyOncall";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct PolicyOncall

struct OncallName : Predicate<std::string> {
  static const char* GLEAN_name() {
    return "omegaanalyser.OncallName";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct OncallName

struct OmegaPolicy : Predicate<std::string> {
  static const char* GLEAN_name() {
    return "omegaanalyser.OmegaPolicy";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct OmegaPolicy

struct OmegaEndpoint : Predicate<std::string> {
  static const char* GLEAN_name() {
    return "omegaanalyser.OmegaEndpoint";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct OmegaEndpoint

} // namespace Omegaanalyser

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Omegaanalyser::Node> {
  using Type = Sum<facebook::glean::cpp::schema::Omegaanalyser::Class_, facebook::glean::cpp::schema::Omegaanalyser::Method, facebook::glean::cpp::schema::Omegaanalyser::Function_, facebook::glean::cpp::schema::Omegaanalyser::Config>;
};


namespace schema {

namespace Omegaanalyser {

struct Node {
  boost::variant<Alt<0, Fact<Class_>>, Alt<1, Fact<Method>>, Alt<2, Fact<Function_>>, Alt<3, Fact<Config>>> GLEAN_value;

  static Node class_(const Fact<Class_>& a) {
    return Node{Alt<0, Fact<Class_>>(a)};
  }
  static Node method(const Fact<Method>& a) {
    return Node{Alt<1, Fact<Method>>(a)};
  }
  static Node function_(const Fact<Function_>& a) {
    return Node{Alt<2, Fact<Function_>>(a)};
  }
  static Node config(const Fact<Config>& a) {
    return Node{Alt<3, Fact<Config>>(a)};
  }

  bool operator==(const Node& other) const {
    return std::tie(GLEAN_value)
             == std::tie(other.GLEAN_value);
  }
  bool operator!=(const Node& other) const {
    return std::tie(GLEAN_value)
             != std::tie(other.GLEAN_value);
  }
  bool operator<(const Node& other) const {
    return std::tie(GLEAN_value)
             < std::tie(other.GLEAN_value);
  }
  bool operator<=(const Node& other) const {
    return std::tie(GLEAN_value)
             <= std::tie(other.GLEAN_value);
  }
  bool operator>(const Node& other) const {
    return std::tie(GLEAN_value)
             > std::tie(other.GLEAN_value);
  }
  bool operator>=(const Node& other) const {
    return std::tie(GLEAN_value)
             >= std::tie(other.GLEAN_value);
  }

  void outputRepr(Output<Repr<Node>> out) const {
    outputValue(out, GLEAN_value);
  }
}; // struct Node

struct Method : Predicate<std::string> {
  static const char* GLEAN_name() {
    return "omegaanalyser.Method";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct Method

struct Function_ : Predicate<std::string> {
  static const char* GLEAN_name() {
    return "omegaanalyser.Function_";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct Function_

struct EndpointOncall : Predicate<std::tuple<Fact<OmegaEndpoint>, Fact<OncallName>>> {
  static const char* GLEAN_name() {
    return "omegaanalyser.EndpointOncall";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct EndpointOncall

struct DependencyPathByCoreNode : Predicate<std::tuple<Fact<OmegaEndpoint>, Node, std::vector<Node>>> {
  static const char* GLEAN_name() {
    return "omegaanalyser.DependencyPathByCoreNode";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct DependencyPathByCoreNode

struct DependencyPath : Predicate<std::tuple<Node, Fact<OmegaEndpoint>, std::vector<Node>>> {
  static const char* GLEAN_name() {
    return "omegaanalyser.DependencyPath";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct DependencyPath

struct DependencyList : Predicate<std::tuple<Node, std::vector<Fact<OmegaEndpoint>>>> {
  static const char* GLEAN_name() {
    return "omegaanalyser.DependencyList";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct DependencyList

struct Config : Predicate<std::string> {
  static const char* GLEAN_name() {
    return "omegaanalyser.Config";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct Config

struct Class_ : Predicate<std::string> {
  static const char* GLEAN_name() {
    return "omegaanalyser.Class_";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct Class_

} // namespace Omegaanalyser

namespace Omega {

struct Oncall : Predicate<std::tuple<Fact<Name>>> {
  static const char* GLEAN_name() {
    return "omega.Oncall";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct Oncall

struct OmegaPolicy : Predicate<std::tuple<Fact<Class_>>> {
  static const char* GLEAN_name() {
    return "omega.OmegaPolicy";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct OmegaPolicy

struct OmegaExecutionNode : Predicate<std::tuple<Fact<Class_>>> {
  static const char* GLEAN_name() {
    return "omega.OmegaExecutionNode";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct OmegaExecutionNode

} // namespace Omega

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Omega::OmegaEntity> {
  using Type = Sum<facebook::glean::cpp::schema::Omega::OmegaEndpoint, facebook::glean::cpp::schema::Omega::OmegaPolicy, facebook::glean::cpp::schema::Omega::OmegaAction, facebook::glean::cpp::schema::Omega::OmegaBlock, facebook::glean::cpp::schema::Omega::OmegaExecutionNode>;
};


namespace schema {

namespace Omega {

struct OmegaEntity {
  boost::variant<Alt<0, Fact<OmegaEndpoint>>, Alt<1, Fact<OmegaPolicy>>, Alt<2, Fact<OmegaAction>>, Alt<3, Fact<OmegaBlock>>, Alt<4, Fact<OmegaExecutionNode>>> GLEAN_value;

  static OmegaEntity endpoint(const Fact<OmegaEndpoint>& a) {
    return OmegaEntity{Alt<0, Fact<OmegaEndpoint>>(a)};
  }
  static OmegaEntity policy(const Fact<OmegaPolicy>& a) {
    return OmegaEntity{Alt<1, Fact<OmegaPolicy>>(a)};
  }
  static OmegaEntity action(const Fact<OmegaAction>& a) {
    return OmegaEntity{Alt<2, Fact<OmegaAction>>(a)};
  }
  static OmegaEntity block(const Fact<OmegaBlock>& a) {
    return OmegaEntity{Alt<3, Fact<OmegaBlock>>(a)};
  }
  static OmegaEntity executionNode(const Fact<OmegaExecutionNode>& a) {
    return OmegaEntity{Alt<4, Fact<OmegaExecutionNode>>(a)};
  }

  bool operator==(const OmegaEntity& other) const {
    return std::tie(GLEAN_value)
             == std::tie(other.GLEAN_value);
  }
  bool operator!=(const OmegaEntity& other) const {
    return std::tie(GLEAN_value)
             != std::tie(other.GLEAN_value);
  }
  bool operator<(const OmegaEntity& other) const {
    return std::tie(GLEAN_value)
             < std::tie(other.GLEAN_value);
  }
  bool operator<=(const OmegaEntity& other) const {
    return std::tie(GLEAN_value)
             <= std::tie(other.GLEAN_value);
  }
  bool operator>(const OmegaEntity& other) const {
    return std::tie(GLEAN_value)
             > std::tie(other.GLEAN_value);
  }
  bool operator>=(const OmegaEntity& other) const {
    return std::tie(GLEAN_value)
             >= std::tie(other.GLEAN_value);
  }

  void outputRepr(Output<Repr<OmegaEntity>> out) const {
    outputValue(out, GLEAN_value);
  }
}; // struct OmegaEntity

struct OmegaEntityMetadata : Predicate<std::tuple<OmegaEntity, boost::variant<Alt<0, std::tuple<>>, Alt<1, Fact<Oncall>>>, bool, bool>> {
  static const char* GLEAN_name() {
    return "omega.OmegaEntityMetadata";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct OmegaEntityMetadata

struct OmegaEndpoint : Predicate<std::tuple<Fact<Class_>>> {
  static const char* GLEAN_name() {
    return "omega.OmegaEndpoint";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct OmegaEndpoint

struct OmegaBlock : Predicate<std::tuple<Fact<Class_>>> {
  static const char* GLEAN_name() {
    return "omega.OmegaBlock";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct OmegaBlock

struct OmegaAction : Predicate<std::tuple<Fact<Class_>>> {
  static const char* GLEAN_name() {
    return "omega.OmegaAction";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct OmegaAction

struct Name : Predicate<std::string> {
  static const char* GLEAN_name() {
    return "omega.Name";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct Name

struct Method : Predicate<std::tuple<Fact<Name>>> {
  static const char* GLEAN_name() {
    return "omega.Method";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct Method

} // namespace Omega

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Omega::GraphNode> {
  using Type = Sum<facebook::glean::cpp::schema::Omega::Class_, facebook::glean::cpp::schema::Omega::Function_, facebook::glean::cpp::schema::Omega::Method, facebook::glean::cpp::schema::Omega::Enum_, facebook::glean::cpp::schema::Omega::Config>;
};


namespace schema {

namespace Omega {

struct GraphNode {
  boost::variant<Alt<0, Fact<Class_>>, Alt<1, Fact<Function_>>, Alt<2, Fact<Method>>, Alt<3, Fact<Enum_>>, Alt<4, Fact<Config>>> GLEAN_value;

  static GraphNode class_(const Fact<Class_>& a) {
    return GraphNode{Alt<0, Fact<Class_>>(a)};
  }
  static GraphNode function_(const Fact<Function_>& a) {
    return GraphNode{Alt<1, Fact<Function_>>(a)};
  }
  static GraphNode method(const Fact<Method>& a) {
    return GraphNode{Alt<2, Fact<Method>>(a)};
  }
  static GraphNode enum_(const Fact<Enum_>& a) {
    return GraphNode{Alt<3, Fact<Enum_>>(a)};
  }
  static GraphNode config(const Fact<Config>& a) {
    return GraphNode{Alt<4, Fact<Config>>(a)};
  }

  bool operator==(const GraphNode& other) const {
    return std::tie(GLEAN_value)
             == std::tie(other.GLEAN_value);
  }
  bool operator!=(const GraphNode& other) const {
    return std::tie(GLEAN_value)
             != std::tie(other.GLEAN_value);
  }
  bool operator<(const GraphNode& other) const {
    return std::tie(GLEAN_value)
             < std::tie(other.GLEAN_value);
  }
  bool operator<=(const GraphNode& other) const {
    return std::tie(GLEAN_value)
             <= std::tie(other.GLEAN_value);
  }
  bool operator>(const GraphNode& other) const {
    return std::tie(GLEAN_value)
             > std::tie(other.GLEAN_value);
  }
  bool operator>=(const GraphNode& other) const {
    return std::tie(GLEAN_value)
             >= std::tie(other.GLEAN_value);
  }

  void outputRepr(Output<Repr<GraphNode>> out) const {
    outputValue(out, GLEAN_value);
  }
}; // struct GraphNode

struct Function_ : Predicate<std::tuple<Fact<Name>>> {
  static const char* GLEAN_name() {
    return "omega.Function_";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct Function_

struct Enum_ : Predicate<std::tuple<Fact<Name>>> {
  static const char* GLEAN_name() {
    return "omega.Enum_";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct Enum_

struct DependencyPathByEntity : Predicate<std::tuple<OmegaEntity, GraphNode, std::vector<GraphNode>>> {
  static const char* GLEAN_name() {
    return "omega.DependencyPathByEntity";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct DependencyPathByEntity

struct DependencyPath : Predicate<std::tuple<GraphNode, OmegaEntity, std::vector<GraphNode>>> {
  static const char* GLEAN_name() {
    return "omega.DependencyPath";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct DependencyPath

struct DependencyList : Predicate<std::tuple<GraphNode, std::vector<OmegaEntity>>> {
  static const char* GLEAN_name() {
    return "omega.DependencyList";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct DependencyList

struct Config : Predicate<std::tuple<Fact<Name>>> {
  static const char* GLEAN_name() {
    return "omega.Config";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct Config

struct Class_ : Predicate<std::tuple<Fact<Name>>> {
  static const char* GLEAN_name() {
    return "omega.Class_";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct Class_

} // namespace Omega

namespace Monk {

struct Xid : Predicate<std::string> {
  static const char* GLEAN_name() {
    return "monk.Xid";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct Xid

} // namespace Monk

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Monk::PrivacySensitivityKind> {
  using Type = Enum<1>;
};


namespace schema {

namespace Monk {

enum class PrivacySensitivityKind { LoggerCall };

struct PiiLoggerXid : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Hack::Name>, Fact<Xid>>> {
  static const char* GLEAN_name() {
    return "monk.PiiLoggerXid";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct PiiLoggerXid

struct HackPiiLoggerTraitXid : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Hack::TraitDeclaration>, Fact<Xid>>> {
  static const char* GLEAN_name() {
    return "monk.HackPiiLoggerTraitXid";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct HackPiiLoggerTraitXid

struct HackPiiLoggerSetterXid : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Hack::MethodDeclaration>, Fact<Xid>>> {
  static const char* GLEAN_name() {
    return "monk.HackPiiLoggerSetterXid";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct HackPiiLoggerSetterXid

struct HackPiiLoggerSetterCallXid : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Src::File>, facebook::glean::cpp::schema::Src::ByteSpan, Fact<facebook::glean::cpp::schema::Hack::MethodDeclaration>, Fact<Xid>>> {
  static const char* GLEAN_name() {
    return "monk.HackPiiLoggerSetterCallXid";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct HackPiiLoggerSetterCallXid

struct HackPiiLoggerClassXid : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Hack::ClassDeclaration>, Fact<Xid>>> {
  static const char* GLEAN_name() {
    return "monk.HackPiiLoggerClassXid";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct HackPiiLoggerClassXid

struct HackPiiLogCallXid : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Src::File>, facebook::glean::cpp::schema::Src::ByteSpan, Fact<facebook::glean::cpp::schema::Hack::MethodDeclaration>, Fact<facebook::glean::cpp::schema::Hack::ClassDeclaration>, Fact<Xid>>> {
  static const char* GLEAN_name() {
    return "monk.HackPiiLogCallXid";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct HackPiiLogCallXid

struct HackPiiLog : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Hack::MethodDeclaration>, Fact<facebook::glean::cpp::schema::Hack::ClassDeclaration>, Fact<Xid>>> {
  static const char* GLEAN_name() {
    return "monk.HackPiiLog";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct HackPiiLog

struct HackPiiFunc : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Hack::MethodDeclaration>, boost::variant<Alt<0, std::tuple<>>, Alt<1, Fact<facebook::glean::cpp::schema::Hack::ClassDeclaration>>>, Fact<Xid>, PrivacySensitivityKind>> {
  static const char* GLEAN_name() {
    return "monk.HackPiiFunc";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct HackPiiFunc

struct HackMethodByName : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Hack::Name>, Fact<facebook::glean::cpp::schema::Hack::Name>, Fact<facebook::glean::cpp::schema::Hack::MethodDeclaration>>> {
  static const char* GLEAN_name() {
    return "monk.HackMethodByName";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct HackMethodByName

struct HackLoggerMethod : Predicate<Fact<facebook::glean::cpp::schema::Hack::MethodDeclaration>> {
  static const char* GLEAN_name() {
    return "monk.HackLoggerMethod";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct HackLoggerMethod

} // namespace Monk

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Lsif::Types::ToolInfo> {
  using Type = Tuple<String, Array<String>, Maybe<String>>;
};


namespace schema {

namespace Lsif {

namespace Types {

struct ToolInfo {
  std::string toolName;
  std::vector<std::string> toolArgs;
  boost::variant<Alt<0, std::tuple<>>, Alt<1, std::string>> version;

  bool operator==(const ToolInfo& other) const {
    return std::tie(toolName,toolArgs,version)
             == std::tie(other.toolName,other.toolArgs,other.version);
  }
  bool operator!=(const ToolInfo& other) const {
    return std::tie(toolName,toolArgs,version)
             != std::tie(other.toolName,other.toolArgs,other.version);
  }
  bool operator<(const ToolInfo& other) const {
    return std::tie(toolName,toolArgs,version)
             < std::tie(other.toolName,other.toolArgs,other.version);
  }
  bool operator<=(const ToolInfo& other) const {
    return std::tie(toolName,toolArgs,version)
             <= std::tie(other.toolName,other.toolArgs,other.version);
  }
  bool operator>(const ToolInfo& other) const {
    return std::tie(toolName,toolArgs,version)
             > std::tie(other.toolName,other.toolArgs,other.version);
  }
  bool operator>=(const ToolInfo& other) const {
    return std::tie(toolName,toolArgs,version)
             >= std::tie(other.toolName,other.toolArgs,other.version);
  }
  void outputRepr(Output<Repr<ToolInfo>> out) const {
    outputValue(out, std::make_tuple(toolName, toolArgs, version));
  }
}; // struct ToolInfo

} // namespace Types

} // namespace Lsif

namespace Scip {

struct Metadata : Predicate<std::tuple<ProtocolVersion, boost::variant<Alt<0, std::tuple<>>, Alt<1, facebook::glean::cpp::schema::Lsif::Types::ToolInfo>>, std::string, TextEncoding>> {
  static const char* GLEAN_name() {
    return "scip.Metadata";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct Metadata

} // namespace Scip

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Lsif::Types::SymbolKind> {
  using Type = Enum<27>;
};


namespace schema {

namespace Lsif {

namespace Types {

enum class SymbolKind { File, Module, Namespace, Package, Class_, Method, Property, Field, Constructor, Enum_, Interface, Function, Variable, Constant, String, Number, Boolean, Array_, Object_, Key, Null, EnumMember, Struct, Event, Operator, TypeParameter, Unknown };

} // namespace Types

} // namespace Lsif

namespace Scip {

struct EntityKind : Predicate<std::tuple<Entity, facebook::glean::cpp::schema::Lsif::Types::SymbolKind>> {
  static const char* GLEAN_name() {
    return "scip.EntityKind";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct EntityKind

struct SymbolKind : Predicate<std::tuple<Fact<Symbol>, facebook::glean::cpp::schema::Lsif::Types::SymbolKind>> {
  static const char* GLEAN_name() {
    return "scip.SymbolKind";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct SymbolKind

} // namespace Scip

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Lsif::Types::RangeSpan> {
  using Type = Tuple<Nat, Nat, Nat, Nat>;
};


namespace schema {

namespace Lsif {

namespace Types {

struct RangeSpan {
  uint64_t lineBegin;
  uint64_t columnBegin;
  uint64_t lineEnd;
  uint64_t columnEnd;

  bool operator==(const RangeSpan& other) const {
    return std::tie(lineBegin,columnBegin,lineEnd,columnEnd)
             == std::tie(other.lineBegin,other.columnBegin,other.lineEnd,other.columnEnd);
  }
  bool operator!=(const RangeSpan& other) const {
    return std::tie(lineBegin,columnBegin,lineEnd,columnEnd)
             != std::tie(other.lineBegin,other.columnBegin,other.lineEnd,other.columnEnd);
  }
  bool operator<(const RangeSpan& other) const {
    return std::tie(lineBegin,columnBegin,lineEnd,columnEnd)
             < std::tie(other.lineBegin,other.columnBegin,other.lineEnd,other.columnEnd);
  }
  bool operator<=(const RangeSpan& other) const {
    return std::tie(lineBegin,columnBegin,lineEnd,columnEnd)
             <= std::tie(other.lineBegin,other.columnBegin,other.lineEnd,other.columnEnd);
  }
  bool operator>(const RangeSpan& other) const {
    return std::tie(lineBegin,columnBegin,lineEnd,columnEnd)
             > std::tie(other.lineBegin,other.columnBegin,other.lineEnd,other.columnEnd);
  }
  bool operator>=(const RangeSpan& other) const {
    return std::tie(lineBegin,columnBegin,lineEnd,columnEnd)
             >= std::tie(other.lineBegin,other.columnBegin,other.lineEnd,other.columnEnd);
  }
  void outputRepr(Output<Repr<RangeSpan>> out) const {
    outputValue(out, std::make_tuple(lineBegin, columnBegin, lineEnd, columnEnd));
  }
}; // struct RangeSpan

struct ToSrcRange : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Src::File>, RangeSpan, facebook::glean::cpp::schema::Src::Range>> {
  static const char* GLEAN_name() {
    return "lsif.types.ToSrcRange";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct ToSrcRange

} // namespace Types

} // namespace Lsif

namespace Scip {

struct DefinitionLocation : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Src::File>, facebook::glean::cpp::schema::Lsif::Types::RangeSpan, Fact<Definition>>> {
  static const char* GLEAN_name() {
    return "scip.DefinitionLocation";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct DefinitionLocation

struct FileRange : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Src::File>, facebook::glean::cpp::schema::Lsif::Types::RangeSpan>> {
  static const char* GLEAN_name() {
    return "scip.FileRange";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct FileRange

struct ReferenceLocation : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Src::File>, facebook::glean::cpp::schema::Lsif::Types::RangeSpan, Fact<Reference>>> {
  static const char* GLEAN_name() {
    return "scip.ReferenceLocation";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct ReferenceLocation

} // namespace Scip

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Lsif::Types::LanguageId> {
  using Type = Enum<59>;
};


namespace schema {

namespace Lsif {

namespace Types {

enum class LanguageId { ABAP, WindowsBat, BibTeX, Clojure, Coffeescript, C, Cpp, CSharp, CSS, Diff, Dart, Dockerfile, Elixir, Erlang, FSharp, Git, Go, Groovy, Handlebars, Haskell, HTML, Ini, Java, JavaScript, JavaScriptReact, JSON, LaTeX, Less, Lua, Makefile, Markdown, ObjectiveC, ObjectiveCpp, Perl, Perl6, PHP, Powershell, Pug, Python, R, Razor, Ruby, Rust, SCSS, Scala, ShaderLab, Shell, SQL, Swift, TypeScript, TypeScriptReact, TeX, VisualBasic, XML, XSL, YAML, UnknownLanguage, Kotlin, OCaml };

} // namespace Types

} // namespace Lsif

namespace Scip {

struct FileLanguage : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Src::File>, facebook::glean::cpp::schema::Lsif::Types::LanguageId>> {
  static const char* GLEAN_name() {
    return "scip.FileLanguage";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct FileLanguage

struct TagDefinition : Predicate<std::tuple<facebook::glean::cpp::schema::Lsif::Types::LanguageId, Fact<Definition>, Entity>> {
  static const char* GLEAN_name() {
    return "scip.TagDefinition";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct TagDefinition

} // namespace Scip

namespace Lsif {

namespace Types {

struct FromSrcRange : Predicate<std::tuple<facebook::glean::cpp::schema::Src::Range, Fact<facebook::glean::cpp::schema::Src::File>, RangeSpan>> {
  static const char* GLEAN_name() {
    return "lsif.types.FromSrcRange";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct FromSrcRange

} // namespace Types

} // namespace Lsif

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Lsif::SomeEntity> {
  using Type = Sum<facebook::glean::cpp::schema::Lsif::Declaration, facebook::glean::cpp::schema::Lsif::DefinitionMoniker>;
};


namespace schema {

namespace Lsif {

struct SomeEntity {
  boost::variant<Alt<0, Fact<Declaration>>, Alt<1, Fact<DefinitionMoniker>>> GLEAN_value;

  static SomeEntity decl(const Fact<Declaration>& a) {
    return SomeEntity{Alt<0, Fact<Declaration>>(a)};
  }
  static SomeEntity defn(const Fact<DefinitionMoniker>& a) {
    return SomeEntity{Alt<1, Fact<DefinitionMoniker>>(a)};
  }

  bool operator==(const SomeEntity& other) const {
    return std::tie(GLEAN_value)
             == std::tie(other.GLEAN_value);
  }
  bool operator!=(const SomeEntity& other) const {
    return std::tie(GLEAN_value)
             != std::tie(other.GLEAN_value);
  }
  bool operator<(const SomeEntity& other) const {
    return std::tie(GLEAN_value)
             < std::tie(other.GLEAN_value);
  }
  bool operator<=(const SomeEntity& other) const {
    return std::tie(GLEAN_value)
             <= std::tie(other.GLEAN_value);
  }
  bool operator>(const SomeEntity& other) const {
    return std::tie(GLEAN_value)
             > std::tie(other.GLEAN_value);
  }
  bool operator>=(const SomeEntity& other) const {
    return std::tie(GLEAN_value)
             >= std::tie(other.GLEAN_value);
  }

  void outputRepr(Output<Repr<SomeEntity>> out) const {
    outputValue(out, GLEAN_value);
  }
}; // struct SomeEntity

struct Reference : Predicate<std::tuple<Fact<Document>, Fact<Range>, Fact<Definition>>> {
  static const char* GLEAN_name() {
    return "lsif.Reference";
  }

  static constexpr size_t GLEAN_version() {
     return 2;
  }
}; // struct Reference

struct Range : Predicate<std::tuple<facebook::glean::cpp::schema::Lsif::Types::RangeSpan, boost::variant<Alt<0, std::tuple<>>, Alt<1, facebook::glean::cpp::schema::Lsif::Types::RangeSpan>>, Fact<Name>>> {
  static const char* GLEAN_name() {
    return "lsif.Range";
  }

  static constexpr size_t GLEAN_version() {
     return 2;
  }
}; // struct Range

struct ProjectDocument : Predicate<std::tuple<Fact<Document>, Fact<Project>>> {
  static const char* GLEAN_name() {
    return "lsif.ProjectDocument";
  }

  static constexpr size_t GLEAN_version() {
     return 2;
  }
}; // struct ProjectDocument

struct Project : Predicate<std::tuple<facebook::glean::cpp::schema::Lsif::Types::LanguageId>> {
  static const char* GLEAN_name() {
    return "lsif.Project";
  }

  static constexpr size_t GLEAN_version() {
     return 2;
  }
}; // struct Project

struct PackageInformation : Predicate<std::tuple<std::string, std::string, std::string>> {
  static const char* GLEAN_name() {
    return "lsif.PackageInformation";
  }

  static constexpr size_t GLEAN_version() {
     return 2;
  }
}; // struct PackageInformation

struct NameLowerCase : Predicate<std::tuple<std::string, Fact<Name>>> {
  static const char* GLEAN_name() {
    return "lsif.NameLowerCase";
  }

  static constexpr size_t GLEAN_version() {
     return 2;
  }
}; // struct NameLowerCase

struct NameDefinition : Predicate<std::tuple<Fact<Name>, Fact<DefinitionMoniker>>> {
  static const char* GLEAN_name() {
    return "lsif.NameDefinition";
  }

  static constexpr size_t GLEAN_version() {
     return 2;
  }
}; // struct NameDefinition

struct Name : Predicate<std::string> {
  static const char* GLEAN_name() {
    return "lsif.Name";
  }

  static constexpr size_t GLEAN_version() {
     return 2;
  }
}; // struct Name

struct MonikerSymbolKind : Predicate<std::tuple<Fact<Moniker>, facebook::glean::cpp::schema::Lsif::Types::SymbolKind>> {
  static const char* GLEAN_name() {
    return "lsif.MonikerSymbolKind";
  }

  static constexpr size_t GLEAN_version() {
     return 2;
  }
}; // struct MonikerSymbolKind

struct MonikerScheme : Predicate<std::string> {
  static const char* GLEAN_name() {
    return "lsif.MonikerScheme";
  }

  static constexpr size_t GLEAN_version() {
     return 2;
  }
}; // struct MonikerScheme

} // namespace Lsif

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Lsif::MonikerKind> {
  using Type = Enum<4>;
};


namespace schema {

namespace Lsif {

enum class MonikerKind { Export, Local, Import, Implementation };

struct MonikerId : Predicate<std::string> {
  static const char* GLEAN_name() {
    return "lsif.MonikerId";
  }

  static constexpr size_t GLEAN_version() {
     return 2;
  }
}; // struct MonikerId

struct MonikerDefinition : Predicate<std::tuple<Fact<MonikerId>, Fact<Moniker>, Fact<Definition>>> {
  static const char* GLEAN_name() {
    return "lsif.MonikerDefinition";
  }

  static constexpr size_t GLEAN_version() {
     return 2;
  }
}; // struct MonikerDefinition

struct Moniker : Predicate<std::tuple<MonikerKind, Fact<MonikerScheme>, Fact<MonikerId>>> {
  static const char* GLEAN_name() {
    return "lsif.Moniker";
  }

  static constexpr size_t GLEAN_version() {
     return 2;
  }
}; // struct Moniker

struct Metadata : Predicate<std::tuple<std::string, std::string, boost::variant<Alt<0, std::tuple<>>, Alt<1, facebook::glean::cpp::schema::Lsif::Types::ToolInfo>>>> {
  static const char* GLEAN_name() {
    return "lsif.Metadata";
  }

  static constexpr size_t GLEAN_version() {
     return 2;
  }
}; // struct Metadata

} // namespace Lsif

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Lsif::Location> {
  using Type = Tuple<String, facebook::glean::cpp::schema::Src::File, Repr<facebook::glean::cpp::schema::Src::Range>>;
};


namespace schema {

namespace Lsif {

struct Location {
  std::string name;
  Fact<facebook::glean::cpp::schema::Src::File> file;
  facebook::glean::cpp::schema::Src::Range location;

  bool operator==(const Location& other) const {
    return std::tie(name,file,location)
             == std::tie(other.name,other.file,other.location);
  }
  bool operator!=(const Location& other) const {
    return std::tie(name,file,location)
             != std::tie(other.name,other.file,other.location);
  }
  bool operator<(const Location& other) const {
    return std::tie(name,file,location)
             < std::tie(other.name,other.file,other.location);
  }
  bool operator<=(const Location& other) const {
    return std::tie(name,file,location)
             <= std::tie(other.name,other.file,other.location);
  }
  bool operator>(const Location& other) const {
    return std::tie(name,file,location)
             > std::tie(other.name,other.file,other.location);
  }
  bool operator>=(const Location& other) const {
    return std::tie(name,file,location)
             >= std::tie(other.name,other.file,other.location);
  }
  void outputRepr(Output<Repr<Location>> out) const {
    outputValue(out, std::make_tuple(name, file, location));
  }
}; // struct Location

struct HoverText : Predicate<std::string> {
  static const char* GLEAN_name() {
    return "lsif.HoverText";
  }

  static constexpr size_t GLEAN_version() {
     return 2;
  }
}; // struct HoverText

struct HoverContent : Predicate<std::tuple<Fact<HoverText>, facebook::glean::cpp::schema::Lsif::Types::LanguageId>> {
  static const char* GLEAN_name() {
    return "lsif.HoverContent";
  }

  static constexpr size_t GLEAN_version() {
     return 2;
  }
}; // struct HoverContent

} // namespace Lsif

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Lsif::Entity> {
  using Type = Sum<Repr<facebook::glean::cpp::schema::Lsif::SomeEntity>, Repr<facebook::glean::cpp::schema::Lsif::SomeEntity>, Repr<facebook::glean::cpp::schema::Lsif::SomeEntity>, Repr<facebook::glean::cpp::schema::Lsif::SomeEntity>, Repr<facebook::glean::cpp::schema::Lsif::SomeEntity>, Repr<facebook::glean::cpp::schema::Lsif::SomeEntity>, Repr<facebook::glean::cpp::schema::Lsif::SomeEntity>, Repr<facebook::glean::cpp::schema::Lsif::SomeEntity>, Repr<facebook::glean::cpp::schema::Lsif::SomeEntity>, Repr<facebook::glean::cpp::schema::Lsif::SomeEntity>, Repr<facebook::glean::cpp::schema::Lsif::SomeEntity>, Repr<facebook::glean::cpp::schema::Lsif::SomeEntity>>;
};


namespace schema {

namespace Lsif {

struct Entity {
  boost::variant<Alt<0, SomeEntity>, Alt<1, SomeEntity>, Alt<2, SomeEntity>, Alt<3, SomeEntity>, Alt<4, SomeEntity>, Alt<5, SomeEntity>, Alt<6, SomeEntity>, Alt<7, SomeEntity>, Alt<8, SomeEntity>, Alt<9, SomeEntity>, Alt<10, SomeEntity>, Alt<11, SomeEntity>> GLEAN_value;

  static Entity erlang(const SomeEntity& a) {
    return Entity{Alt<0, SomeEntity>(a)};
  }
  static Entity fsharp(const SomeEntity& a) {
    return Entity{Alt<1, SomeEntity>(a)};
  }
  static Entity go(const SomeEntity& a) {
    return Entity{Alt<2, SomeEntity>(a)};
  }
  static Entity haskell(const SomeEntity& a) {
    return Entity{Alt<3, SomeEntity>(a)};
  }
  static Entity java(const SomeEntity& a) {
    return Entity{Alt<4, SomeEntity>(a)};
  }
  static Entity kotlin(const SomeEntity& a) {
    return Entity{Alt<5, SomeEntity>(a)};
  }
  static Entity ocaml(const SomeEntity& a) {
    return Entity{Alt<6, SomeEntity>(a)};
  }
  static Entity python(const SomeEntity& a) {
    return Entity{Alt<7, SomeEntity>(a)};
  }
  static Entity rust(const SomeEntity& a) {
    return Entity{Alt<8, SomeEntity>(a)};
  }
  static Entity scala(const SomeEntity& a) {
    return Entity{Alt<9, SomeEntity>(a)};
  }
  static Entity swift(const SomeEntity& a) {
    return Entity{Alt<10, SomeEntity>(a)};
  }
  static Entity typescript(const SomeEntity& a) {
    return Entity{Alt<11, SomeEntity>(a)};
  }

  bool operator==(const Entity& other) const {
    return std::tie(GLEAN_value)
             == std::tie(other.GLEAN_value);
  }
  bool operator!=(const Entity& other) const {
    return std::tie(GLEAN_value)
             != std::tie(other.GLEAN_value);
  }
  bool operator<(const Entity& other) const {
    return std::tie(GLEAN_value)
             < std::tie(other.GLEAN_value);
  }
  bool operator<=(const Entity& other) const {
    return std::tie(GLEAN_value)
             <= std::tie(other.GLEAN_value);
  }
  bool operator>(const Entity& other) const {
    return std::tie(GLEAN_value)
             > std::tie(other.GLEAN_value);
  }
  bool operator>=(const Entity& other) const {
    return std::tie(GLEAN_value)
             >= std::tie(other.GLEAN_value);
  }

  void outputRepr(Output<Repr<Entity>> out) const {
    outputValue(out, GLEAN_value);
  }
}; // struct Entity

struct EntityDefinition : Predicate<std::tuple<Entity, Fact<DefinitionMoniker>>> {
  static const char* GLEAN_name() {
    return "lsif.EntityDefinition";
  }

  static constexpr size_t GLEAN_version() {
     return 2;
  }
}; // struct EntityDefinition

struct EntityKind : Predicate<std::tuple<Entity, facebook::glean::cpp::schema::Lsif::Types::SymbolKind>> {
  static const char* GLEAN_name() {
    return "lsif.EntityKind";
  }

  static constexpr size_t GLEAN_version() {
     return 2;
  }
}; // struct EntityKind

struct EntityLocation : Predicate<std::tuple<Entity, Location>> {
  static const char* GLEAN_name() {
    return "lsif.EntityLocation";
  }

  static constexpr size_t GLEAN_version() {
     return 2;
  }
}; // struct EntityLocation

struct EntityUses : Predicate<std::tuple<Entity, Fact<facebook::glean::cpp::schema::Src::File>, facebook::glean::cpp::schema::Src::Range>> {
  static const char* GLEAN_name() {
    return "lsif.EntityUses";
  }

  static constexpr size_t GLEAN_version() {
     return 2;
  }
}; // struct EntityUses

struct FileEntityXRefLocation : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Src::File>, facebook::glean::cpp::schema::Src::Range, Location, Entity>> {
  static const char* GLEAN_name() {
    return "lsif.FileEntityXRefLocation";
  }

  static constexpr size_t GLEAN_version() {
     return 2;
  }
}; // struct FileEntityXRefLocation

struct ResolveLocation : Predicate<std::tuple<Location, Entity>> {
  static const char* GLEAN_name() {
    return "lsif.ResolveLocation";
  }

  static constexpr size_t GLEAN_version() {
     return 2;
  }
}; // struct ResolveLocation

struct SearchByExactLocation : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Src::File>, facebook::glean::cpp::schema::Lsif::Types::RangeSpan, Entity>> {
  static const char* GLEAN_name() {
    return "lsif.SearchByExactLocation";
  }

  static constexpr size_t GLEAN_version() {
     return 2;
  }
}; // struct SearchByExactLocation

struct SearchByExactLocationAndName : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Src::File>, Fact<Name>, facebook::glean::cpp::schema::Lsif::Types::RangeSpan, Entity>> {
  static const char* GLEAN_name() {
    return "lsif.SearchByExactLocationAndName";
  }

  static constexpr size_t GLEAN_version() {
     return 2;
  }
}; // struct SearchByExactLocationAndName

struct SearchByMoniker : Predicate<std::tuple<Fact<MonikerId>, Entity>> {
  static const char* GLEAN_name() {
    return "lsif.SearchByMoniker";
  }

  static constexpr size_t GLEAN_version() {
     return 2;
  }
}; // struct SearchByMoniker

struct SearchByName : Predicate<std::tuple<Fact<Name>, Entity>> {
  static const char* GLEAN_name() {
    return "lsif.SearchByName";
  }

  static constexpr size_t GLEAN_version() {
     return 2;
  }
}; // struct SearchByName

struct SearchNonLocalByLocation : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Src::File>, Fact<Name>, Entity>> {
  static const char* GLEAN_name() {
    return "lsif.SearchNonLocalByLocation";
  }

  static constexpr size_t GLEAN_version() {
     return 2;
  }
}; // struct SearchNonLocalByLocation

struct TagDefinition : Predicate<std::tuple<facebook::glean::cpp::schema::Lsif::Types::LanguageId, Fact<DefinitionMoniker>, Entity>> {
  static const char* GLEAN_name() {
    return "lsif.TagDefinition";
  }

  static constexpr size_t GLEAN_version() {
     return 2;
  }
}; // struct TagDefinition

struct Document : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Src::File>, facebook::glean::cpp::schema::Lsif::Types::LanguageId>> {
  static const char* GLEAN_name() {
    return "lsif.Document";
  }

  static constexpr size_t GLEAN_version() {
     return 2;
  }
}; // struct Document

struct DefinitionUse : Predicate<std::tuple<Fact<Definition>, Fact<Document>, Fact<Range>>> {
  static const char* GLEAN_name() {
    return "lsif.DefinitionUse";
  }

  static constexpr size_t GLEAN_version() {
     return 2;
  }
}; // struct DefinitionUse

struct DefinitionMoniker : Predicate<std::tuple<Fact<Definition>, boost::variant<Alt<0, std::tuple<>>, Alt<1, Fact<Moniker>>>>> {
  static const char* GLEAN_name() {
    return "lsif.DefinitionMoniker";
  }

  static constexpr size_t GLEAN_version() {
     return 2;
  }
}; // struct DefinitionMoniker

struct DefinitionLocation : Predicate<std::tuple<Fact<Definition>, Location>> {
  static const char* GLEAN_name() {
    return "lsif.DefinitionLocation";
  }

  static constexpr size_t GLEAN_version() {
     return 2;
  }
}; // struct DefinitionLocation

struct DefinitionKind : Predicate<std::tuple<Fact<Definition>, facebook::glean::cpp::schema::Lsif::Types::SymbolKind>> {
  static const char* GLEAN_name() {
    return "lsif.DefinitionKind";
  }

  static constexpr size_t GLEAN_version() {
     return 2;
  }
}; // struct DefinitionKind

struct DefinitionHover : Predicate<std::tuple<Fact<Definition>, Fact<HoverContent>>> {
  static const char* GLEAN_name() {
    return "lsif.DefinitionHover";
  }

  static constexpr size_t GLEAN_version() {
     return 2;
  }
}; // struct DefinitionHover

struct Definition : Predicate<std::tuple<Fact<Document>, Fact<Range>>> {
  static const char* GLEAN_name() {
    return "lsif.Definition";
  }

  static constexpr size_t GLEAN_version() {
     return 2;
  }
}; // struct Definition

struct Declaration : Predicate<std::tuple<Fact<Document>, Fact<Range>>> {
  static const char* GLEAN_name() {
    return "lsif.Declaration";
  }

  static constexpr size_t GLEAN_version() {
     return 2;
  }
}; // struct Declaration

} // namespace Lsif

namespace Kotlin {

namespace Alpha {

struct VariableParent : Predicate<std::tuple<Fact<VariableDeclaration>, Fact<MethodDeclaration>>> {
  static const char* GLEAN_name() {
    return "kotlin.alpha.VariableParent";
  }

  static constexpr size_t GLEAN_version() {
     return 2;
  }
}; // struct VariableParent

struct VariableDeclaration : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Javakotlin::Alpha::QName>, Fact<Type>, Fact<DeclarationLocation>>> {
  static const char* GLEAN_name() {
    return "kotlin.alpha.VariableDeclaration";
  }

  static constexpr size_t GLEAN_version() {
     return 2;
  }
}; // struct VariableDeclaration

struct TypeArg : Predicate<std::tuple<Fact<Type>>> {
  static const char* GLEAN_name() {
    return "kotlin.alpha.TypeArg";
  }

  static constexpr size_t GLEAN_version() {
     return 2;
  }
}; // struct TypeArg

struct Type : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Javakotlin::Alpha::Type>, boost::variant<Alt<0, std::tuple<>>, Alt<1, Fact<DeclarationLocation>>>, std::vector<Fact<TypeArg>>, bool>> {
  static const char* GLEAN_name() {
    return "kotlin.alpha.Type";
  }

  static constexpr size_t GLEAN_version() {
     return 2;
  }
}; // struct Type

struct DeclarationLocation : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Src::File>, facebook::glean::cpp::schema::Src::ByteSpan>> {
  static const char* GLEAN_name() {
    return "kotlin.alpha.DeclarationLocation";
  }

  static constexpr size_t GLEAN_version() {
     return 2;
  }
}; // struct DeclarationLocation

} // namespace Alpha

} // namespace Kotlin

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Kotlin::Alpha::Declaration> {
  using Type = Sum<facebook::glean::cpp::schema::Kotlin::Alpha::ClassDeclaration, facebook::glean::cpp::schema::Kotlin::Alpha::MethodDeclaration, facebook::glean::cpp::schema::Kotlin::Alpha::VariableDeclaration>;
};


namespace schema {

namespace Kotlin {

namespace Alpha {

struct Declaration {
  boost::variant<Alt<0, Fact<ClassDeclaration>>, Alt<1, Fact<MethodDeclaration>>, Alt<2, Fact<VariableDeclaration>>> GLEAN_value;

  static Declaration class_(const Fact<ClassDeclaration>& a) {
    return Declaration{Alt<0, Fact<ClassDeclaration>>(a)};
  }
  static Declaration method(const Fact<MethodDeclaration>& a) {
    return Declaration{Alt<1, Fact<MethodDeclaration>>(a)};
  }
  static Declaration variable(const Fact<VariableDeclaration>& a) {
    return Declaration{Alt<2, Fact<VariableDeclaration>>(a)};
  }

  bool operator==(const Declaration& other) const {
    return std::tie(GLEAN_value)
             == std::tie(other.GLEAN_value);
  }
  bool operator!=(const Declaration& other) const {
    return std::tie(GLEAN_value)
             != std::tie(other.GLEAN_value);
  }
  bool operator<(const Declaration& other) const {
    return std::tie(GLEAN_value)
             < std::tie(other.GLEAN_value);
  }
  bool operator<=(const Declaration& other) const {
    return std::tie(GLEAN_value)
             <= std::tie(other.GLEAN_value);
  }
  bool operator>(const Declaration& other) const {
    return std::tie(GLEAN_value)
             > std::tie(other.GLEAN_value);
  }
  bool operator>=(const Declaration& other) const {
    return std::tie(GLEAN_value)
             >= std::tie(other.GLEAN_value);
  }

  void outputRepr(Output<Repr<Declaration>> out) const {
    outputValue(out, GLEAN_value);
  }
}; // struct Declaration

struct DeclarationFileLocation : Predicate<std::tuple<Declaration, Fact<facebook::glean::cpp::schema::Src::File>, facebook::glean::cpp::schema::Src::ByteSpan, std::string>> {
  static const char* GLEAN_name() {
    return "kotlin.alpha.DeclarationFileLocation";
  }

  static constexpr size_t GLEAN_version() {
     return 2;
  }
}; // struct DeclarationFileLocation

struct ExtendsDeclaration : Predicate<std::tuple<Declaration, Declaration>> {
  static const char* GLEAN_name() {
    return "kotlin.alpha.ExtendsDeclaration";
  }

  static constexpr size_t GLEAN_version() {
     return 2;
  }
}; // struct ExtendsDeclaration

struct FileDeclarations : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Src::File>, Declaration>> {
  static const char* GLEAN_name() {
    return "kotlin.alpha.FileDeclarations";
  }

  static constexpr size_t GLEAN_version() {
     return 2;
  }
}; // struct FileDeclarations

struct MethodDeclaration : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Javakotlin::Alpha::MethodName>, std::vector<Fact<VariableDeclaration>>, boost::variant<Alt<0, std::tuple<>>, Alt<1, Fact<Type>>>, facebook::glean::cpp::schema::Src::Loc, boost::variant<Alt<0, std::tuple<>>, Alt<1, Fact<DeclarationLocation>>>, boost::variant<Alt<0, std::tuple<>>, Alt<1, Declaration>>>> {
  static const char* GLEAN_name() {
    return "kotlin.alpha.MethodDeclaration";
  }

  static constexpr size_t GLEAN_version() {
     return 2;
  }
}; // struct MethodDeclaration

struct ParentDeclaration : Predicate<std::tuple<Declaration, Declaration>> {
  static const char* GLEAN_name() {
    return "kotlin.alpha.ParentDeclaration";
  }

  static constexpr size_t GLEAN_version() {
     return 2;
  }
}; // struct ParentDeclaration

} // namespace Alpha

} // namespace Kotlin

namespace Search {

namespace Kotlin {

struct SearchByQName : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Javakotlin::Alpha::QName>, facebook::glean::cpp::schema::Kotlin::Alpha::Declaration>> {
  static const char* GLEAN_name() {
    return "search.kotlin.SearchByQName";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct SearchByQName

} // namespace Kotlin

} // namespace Search

namespace Symbolid {

namespace Kotlin {

struct LookupDeclaration : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Javakotlin::Alpha::QName>, facebook::glean::cpp::schema::Kotlin::Alpha::Declaration>> {
  static const char* GLEAN_name() {
    return "symbolid.kotlin.LookupDeclaration";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct LookupDeclaration

struct LookupMethodDeclaration : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Javakotlin::Alpha::MethodName>, facebook::glean::cpp::schema::Kotlin::Alpha::Declaration>> {
  static const char* GLEAN_name() {
    return "symbolid.kotlin.LookupMethodDeclaration";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct LookupMethodDeclaration

} // namespace Kotlin

} // namespace Symbolid

namespace Kotlin {

namespace Alpha {

struct ContainsDeclaration : Predicate<std::tuple<Declaration, Declaration>> {
  static const char* GLEAN_name() {
    return "kotlin.alpha.ContainsDeclaration";
  }

  static constexpr size_t GLEAN_version() {
     return 2;
  }
}; // struct ContainsDeclaration

struct ClassMember : Predicate<std::tuple<Fact<ClassDeclaration>, Fact<MethodDeclaration>>> {
  static const char* GLEAN_name() {
    return "kotlin.alpha.ClassMember";
  }

  static constexpr size_t GLEAN_version() {
     return 2;
  }
}; // struct ClassMember

struct ClassDeclaration : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Javakotlin::Alpha::QName>, std::vector<Fact<facebook::glean::cpp::schema::Javakotlin::Alpha::QName>>, Fact<DeclarationLocation>>> {
  static const char* GLEAN_name() {
    return "kotlin.alpha.ClassDeclaration";
  }

  static constexpr size_t GLEAN_version() {
     return 2;
  }
}; // struct ClassDeclaration

} // namespace Alpha

} // namespace Kotlin

namespace Javakotlin {

namespace Alpha {

struct Type : Predicate<boost::variant<Alt<0, std::string>, Alt<1, Fact<Path>>, Alt<2, Fact<Type>>>> {
  static const char* GLEAN_name() {
    return "javakotlin.alpha.Type";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct Type

struct QName : Predicate<std::tuple<Fact<Name>, Fact<Path>>> {
  static const char* GLEAN_name() {
    return "javakotlin.alpha.QName";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct QName

struct Path : Predicate<std::tuple<Fact<Name>, boost::variant<Alt<0, std::tuple<>>, Alt<1, Fact<Path>>>>> {
  static const char* GLEAN_name() {
    return "javakotlin.alpha.Path";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct Path

struct NameLowerCase : Predicate<std::tuple<std::string, Fact<Name>>> {
  static const char* GLEAN_name() {
    return "javakotlin.alpha.NameLowerCase";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct NameLowerCase

struct Name : Predicate<std::string> {
  static const char* GLEAN_name() {
    return "javakotlin.alpha.Name";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct Name

struct MethodName : Predicate<std::tuple<Fact<QName>, std::vector<Fact<Type>>>> {
  static const char* GLEAN_name() {
    return "javakotlin.alpha.MethodName";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct MethodName

} // namespace Alpha

} // namespace Javakotlin

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Java::Alpha::XRefTarget> {
  using Type = Sum<facebook::glean::cpp::schema::Javakotlin::Alpha::QName, facebook::glean::cpp::schema::Javakotlin::Alpha::MethodName, facebook::glean::cpp::schema::Javakotlin::Alpha::MethodName, facebook::glean::cpp::schema::Javakotlin::Alpha::QName>;
};


namespace schema {

namespace Java {

namespace Alpha {

struct XRefTarget {
  boost::variant<Alt<0, Fact<facebook::glean::cpp::schema::Javakotlin::Alpha::QName>>, Alt<1, Fact<facebook::glean::cpp::schema::Javakotlin::Alpha::MethodName>>, Alt<2, Fact<facebook::glean::cpp::schema::Javakotlin::Alpha::MethodName>>, Alt<3, Fact<facebook::glean::cpp::schema::Javakotlin::Alpha::QName>>> GLEAN_value;

  static XRefTarget definition_(const Fact<facebook::glean::cpp::schema::Javakotlin::Alpha::QName>& a) {
    return XRefTarget{Alt<0, Fact<facebook::glean::cpp::schema::Javakotlin::Alpha::QName>>(a)};
  }
  static XRefTarget ctor_(const Fact<facebook::glean::cpp::schema::Javakotlin::Alpha::MethodName>& a) {
    return XRefTarget{Alt<1, Fact<facebook::glean::cpp::schema::Javakotlin::Alpha::MethodName>>(a)};
  }
  static XRefTarget method_(const Fact<facebook::glean::cpp::schema::Javakotlin::Alpha::MethodName>& a) {
    return XRefTarget{Alt<2, Fact<facebook::glean::cpp::schema::Javakotlin::Alpha::MethodName>>(a)};
  }
  static XRefTarget field_(const Fact<facebook::glean::cpp::schema::Javakotlin::Alpha::QName>& a) {
    return XRefTarget{Alt<3, Fact<facebook::glean::cpp::schema::Javakotlin::Alpha::QName>>(a)};
  }

  bool operator==(const XRefTarget& other) const {
    return std::tie(GLEAN_value)
             == std::tie(other.GLEAN_value);
  }
  bool operator!=(const XRefTarget& other) const {
    return std::tie(GLEAN_value)
             != std::tie(other.GLEAN_value);
  }
  bool operator<(const XRefTarget& other) const {
    return std::tie(GLEAN_value)
             < std::tie(other.GLEAN_value);
  }
  bool operator<=(const XRefTarget& other) const {
    return std::tie(GLEAN_value)
             <= std::tie(other.GLEAN_value);
  }
  bool operator>(const XRefTarget& other) const {
    return std::tie(GLEAN_value)
             > std::tie(other.GLEAN_value);
  }
  bool operator>=(const XRefTarget& other) const {
    return std::tie(GLEAN_value)
             >= std::tie(other.GLEAN_value);
  }

  void outputRepr(Output<Repr<XRefTarget>> out) const {
    outputValue(out, GLEAN_value);
  }
}; // struct XRefTarget

struct XRefFile : Predicate<std::tuple<Fact<XRef>, Fact<facebook::glean::cpp::schema::Src::File>>> {
  static const char* GLEAN_name() {
    return "java.alpha.XRefFile";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct XRefFile

struct XRef : Predicate<std::tuple<XRefTarget, std::vector<facebook::glean::cpp::schema::Src::ByteSpan>>> {
  static const char* GLEAN_name() {
    return "java.alpha.XRef";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct XRef

} // namespace Alpha

} // namespace Java

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Java::Alpha::Wildcard> {
  using Type = Sum<facebook::glean::cpp::schema::Java::Alpha::Type, facebook::glean::cpp::schema::Java::Alpha::Type, Bool>;
};


namespace schema {

namespace Java {

namespace Alpha {

struct Wildcard {
  boost::variant<Alt<0, Fact<Type>>, Alt<1, Fact<Type>>, Alt<2, bool>> GLEAN_value;

  static Wildcard extends_(const Fact<Type>& a) {
    return Wildcard{Alt<0, Fact<Type>>(a)};
  }
  static Wildcard super_(const Fact<Type>& a) {
    return Wildcard{Alt<1, Fact<Type>>(a)};
  }
  static Wildcard unbounded(const bool& a) {
    return Wildcard{Alt<2, bool>(a)};
  }

  bool operator==(const Wildcard& other) const {
    return std::tie(GLEAN_value)
             == std::tie(other.GLEAN_value);
  }
  bool operator!=(const Wildcard& other) const {
    return std::tie(GLEAN_value)
             != std::tie(other.GLEAN_value);
  }
  bool operator<(const Wildcard& other) const {
    return std::tie(GLEAN_value)
             < std::tie(other.GLEAN_value);
  }
  bool operator<=(const Wildcard& other) const {
    return std::tie(GLEAN_value)
             <= std::tie(other.GLEAN_value);
  }
  bool operator>(const Wildcard& other) const {
    return std::tie(GLEAN_value)
             > std::tie(other.GLEAN_value);
  }
  bool operator>=(const Wildcard& other) const {
    return std::tie(GLEAN_value)
             >= std::tie(other.GLEAN_value);
  }

  void outputRepr(Output<Repr<Wildcard>> out) const {
    outputValue(out, GLEAN_value);
  }
}; // struct Wildcard

struct TypeVar : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Javakotlin::Alpha::Name>, facebook::glean::cpp::schema::Src::ByteSpan>> {
  static const char* GLEAN_name() {
    return "java.alpha.TypeVar";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct TypeVar

struct TypeParam : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Javakotlin::Alpha::Name>, std::vector<Fact<Type>>, facebook::glean::cpp::schema::Src::ByteSpan>> {
  static const char* GLEAN_name() {
    return "java.alpha.TypeParam";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct TypeParam

struct TypeOfTypeArgs : Predicate<std::tuple<Fact<Type>, Fact<Type>>> {
  static const char* GLEAN_name() {
    return "java.alpha.TypeOfTypeArgs";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct TypeOfTypeArgs

struct TypeArg : Predicate<boost::variant<Alt<0, Fact<Type>>, Alt<1, Wildcard>>> {
  static const char* GLEAN_name() {
    return "java.alpha.TypeArg";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct TypeArg

struct PrimitiveType : Predicate<std::tuple<std::string>> {
  static const char* GLEAN_name() {
    return "java.alpha.PrimitiveType";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct PrimitiveType

struct PackageDeclaration : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Javakotlin::Alpha::Name>, std::vector<Fact<Annotation>>, boost::variant<Alt<0, std::tuple<>>, Alt<1, Fact<facebook::glean::cpp::schema::Javakotlin::Alpha::Path>>>, facebook::glean::cpp::schema::Src::ByteSpan>> {
  static const char* GLEAN_name() {
    return "java.alpha.PackageDeclaration";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct PackageDeclaration

struct ObjectType : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Javakotlin::Alpha::QName>, facebook::glean::cpp::schema::Src::ByteSpan>> {
  static const char* GLEAN_name() {
    return "java.alpha.ObjectType";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct ObjectType

} // namespace Alpha

} // namespace Java

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Java::Alpha::Modifier> {
  using Type = Enum<12>;
};


namespace schema {

namespace Java {

namespace Alpha {

enum class Modifier { abstract_, default_, final_, native_, private_, protected_, public_, static_, strictfp_, synchronized_, transient_, volatile_ };

struct ParameterDeclaration : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Javakotlin::Alpha::QName>, Fact<Type>, std::vector<Fact<Annotation>>, std::vector<Modifier>, facebook::glean::cpp::schema::Src::ByteSpan>> {
  static const char* GLEAN_name() {
    return "java.alpha.ParameterDeclaration";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct ParameterDeclaration

struct InterfaceInheritance : Predicate<std::tuple<Fact<Type>, Fact<ClassDeclaration>>> {
  static const char* GLEAN_name() {
    return "java.alpha.InterfaceInheritance";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct InterfaceInheritance

struct Inheritance : Predicate<std::tuple<Fact<Type>, Fact<ClassDeclaration>>> {
  static const char* GLEAN_name() {
    return "java.alpha.Inheritance";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct Inheritance

struct ImportDeclaration : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Javakotlin::Alpha::Name>, bool, boost::variant<Alt<0, std::tuple<>>, Alt<1, std::string>>, Fact<facebook::glean::cpp::schema::Javakotlin::Alpha::Path>, facebook::glean::cpp::schema::Src::ByteSpan>> {
  static const char* GLEAN_name() {
    return "java.alpha.ImportDeclaration";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct ImportDeclaration

struct FileXRefs : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Src::File>, std::vector<Fact<XRef>>>> {
  static const char* GLEAN_name() {
    return "java.alpha.FileXRefs";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct FileXRefs

} // namespace Alpha

} // namespace Java

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Java::Alpha::ExecutableDefinition> {
  using Type = Sum<facebook::glean::cpp::schema::Java::Alpha::ConstructorDeclaration, facebook::glean::cpp::schema::Java::Alpha::MethodDeclaration>;
};


namespace schema {

namespace Java {

namespace Alpha {

struct ExecutableDefinition {
  boost::variant<Alt<0, Fact<ConstructorDeclaration>>, Alt<1, Fact<MethodDeclaration>>> GLEAN_value;

  static ExecutableDefinition constructor(const Fact<ConstructorDeclaration>& a) {
    return ExecutableDefinition{Alt<0, Fact<ConstructorDeclaration>>(a)};
  }
  static ExecutableDefinition method(const Fact<MethodDeclaration>& a) {
    return ExecutableDefinition{Alt<1, Fact<MethodDeclaration>>(a)};
  }

  bool operator==(const ExecutableDefinition& other) const {
    return std::tie(GLEAN_value)
             == std::tie(other.GLEAN_value);
  }
  bool operator!=(const ExecutableDefinition& other) const {
    return std::tie(GLEAN_value)
             != std::tie(other.GLEAN_value);
  }
  bool operator<(const ExecutableDefinition& other) const {
    return std::tie(GLEAN_value)
             < std::tie(other.GLEAN_value);
  }
  bool operator<=(const ExecutableDefinition& other) const {
    return std::tie(GLEAN_value)
             <= std::tie(other.GLEAN_value);
  }
  bool operator>(const ExecutableDefinition& other) const {
    return std::tie(GLEAN_value)
             > std::tie(other.GLEAN_value);
  }
  bool operator>=(const ExecutableDefinition& other) const {
    return std::tie(GLEAN_value)
             >= std::tie(other.GLEAN_value);
  }

  void outputRepr(Output<Repr<ExecutableDefinition>> out) const {
    outputValue(out, GLEAN_value);
  }
}; // struct ExecutableDefinition

struct ExecutableDefnLocation : Predicate<std::tuple<ExecutableDefinition, std::string, Fact<facebook::glean::cpp::schema::Src::File>, facebook::glean::cpp::schema::Src::ByteSpan>> {
  static const char* GLEAN_name() {
    return "java.alpha.ExecutableDefnLocation";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct ExecutableDefnLocation

struct LocalDeclaration : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Javakotlin::Alpha::QName>, Fact<Type>, std::vector<Fact<Annotation>>, std::vector<Modifier>, ExecutableDefinition, facebook::glean::cpp::schema::Src::ByteSpan>> {
  static const char* GLEAN_name() {
    return "java.alpha.LocalDeclaration";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct LocalDeclaration

} // namespace Alpha

} // namespace Java

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Java::Alpha::Definition> {
  using Type = Sum<facebook::glean::cpp::schema::Java::Alpha::ClassDeclaration, facebook::glean::cpp::schema::Java::Alpha::InterfaceDeclaration, facebook::glean::cpp::schema::Java::Alpha::EnumDeclaration>;
};


namespace schema {

namespace Java {

namespace Alpha {

struct Definition {
  boost::variant<Alt<0, Fact<ClassDeclaration>>, Alt<1, Fact<InterfaceDeclaration>>, Alt<2, Fact<EnumDeclaration>>> GLEAN_value;

  static Definition class_(const Fact<ClassDeclaration>& a) {
    return Definition{Alt<0, Fact<ClassDeclaration>>(a)};
  }
  static Definition interface_(const Fact<InterfaceDeclaration>& a) {
    return Definition{Alt<1, Fact<InterfaceDeclaration>>(a)};
  }
  static Definition enum_(const Fact<EnumDeclaration>& a) {
    return Definition{Alt<2, Fact<EnumDeclaration>>(a)};
  }

  bool operator==(const Definition& other) const {
    return std::tie(GLEAN_value)
             == std::tie(other.GLEAN_value);
  }
  bool operator!=(const Definition& other) const {
    return std::tie(GLEAN_value)
             != std::tie(other.GLEAN_value);
  }
  bool operator<(const Definition& other) const {
    return std::tie(GLEAN_value)
             < std::tie(other.GLEAN_value);
  }
  bool operator<=(const Definition& other) const {
    return std::tie(GLEAN_value)
             <= std::tie(other.GLEAN_value);
  }
  bool operator>(const Definition& other) const {
    return std::tie(GLEAN_value)
             > std::tie(other.GLEAN_value);
  }
  bool operator>=(const Definition& other) const {
    return std::tie(GLEAN_value)
             >= std::tie(other.GLEAN_value);
  }

  void outputRepr(Output<Repr<Definition>> out) const {
    outputValue(out, GLEAN_value);
  }
}; // struct Definition

struct DefinitionLocation : Predicate<std::tuple<Definition, std::string, Fact<facebook::glean::cpp::schema::Src::File>, facebook::glean::cpp::schema::Src::ByteSpan>> {
  static const char* GLEAN_name() {
    return "java.alpha.DefinitionLocation";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct DefinitionLocation

struct EnumDeclaration : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Javakotlin::Alpha::QName>, std::vector<Fact<Annotation>>, std::vector<Modifier>, std::vector<Fact<Type>>, boost::variant<Alt<0, std::tuple<>>, Alt<1, Definition>>, facebook::glean::cpp::schema::Src::ByteSpan, Fact<facebook::glean::cpp::schema::Src::File>>> {
  static const char* GLEAN_name() {
    return "java.alpha.EnumDeclaration";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct EnumDeclaration

struct FieldDeclaration : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Javakotlin::Alpha::QName>, Fact<Type>, std::vector<Fact<Annotation>>, std::vector<Modifier>, Definition, facebook::glean::cpp::schema::Src::ByteSpan>> {
  static const char* GLEAN_name() {
    return "java.alpha.FieldDeclaration";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct FieldDeclaration

struct InterfaceDeclaration : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Javakotlin::Alpha::QName>, std::vector<Fact<Annotation>>, std::vector<Modifier>, std::vector<Fact<Type>>, boost::variant<Alt<0, std::tuple<>>, Alt<1, Definition>>, std::vector<Fact<TypeParam>>, facebook::glean::cpp::schema::Src::ByteSpan, Fact<facebook::glean::cpp::schema::Src::File>>> {
  static const char* GLEAN_name() {
    return "java.alpha.InterfaceDeclaration";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct InterfaceDeclaration

struct MethodDeclaration : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Javakotlin::Alpha::MethodName>, std::vector<Fact<ParameterDeclaration>>, Fact<Type>, std::vector<Fact<Annotation>>, std::vector<Modifier>, std::vector<Fact<TypeParam>>, std::vector<Fact<Type>>, Definition, facebook::glean::cpp::schema::Src::ByteSpan>> {
  static const char* GLEAN_name() {
    return "java.alpha.MethodDeclaration";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct MethodDeclaration

} // namespace Alpha

} // namespace Java

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Java::Alpha::Declaration> {
  using Type = Sum<facebook::glean::cpp::schema::Java::Alpha::ParameterDeclaration, facebook::glean::cpp::schema::Java::Alpha::LocalDeclaration, facebook::glean::cpp::schema::Java::Alpha::FieldDeclaration, facebook::glean::cpp::schema::Java::Alpha::ConstructorDeclaration, facebook::glean::cpp::schema::Java::Alpha::MethodDeclaration, facebook::glean::cpp::schema::Java::Alpha::InterfaceDeclaration, facebook::glean::cpp::schema::Java::Alpha::ClassDeclaration, facebook::glean::cpp::schema::Java::Alpha::EnumDeclaration>;
};


namespace schema {

namespace Java {

namespace Alpha {

struct Declaration {
  boost::variant<Alt<0, Fact<ParameterDeclaration>>, Alt<1, Fact<LocalDeclaration>>, Alt<2, Fact<FieldDeclaration>>, Alt<3, Fact<ConstructorDeclaration>>, Alt<4, Fact<MethodDeclaration>>, Alt<5, Fact<InterfaceDeclaration>>, Alt<6, Fact<ClassDeclaration>>, Alt<7, Fact<EnumDeclaration>>> GLEAN_value;

  static Declaration param(const Fact<ParameterDeclaration>& a) {
    return Declaration{Alt<0, Fact<ParameterDeclaration>>(a)};
  }
  static Declaration local(const Fact<LocalDeclaration>& a) {
    return Declaration{Alt<1, Fact<LocalDeclaration>>(a)};
  }
  static Declaration field(const Fact<FieldDeclaration>& a) {
    return Declaration{Alt<2, Fact<FieldDeclaration>>(a)};
  }
  static Declaration ctor(const Fact<ConstructorDeclaration>& a) {
    return Declaration{Alt<3, Fact<ConstructorDeclaration>>(a)};
  }
  static Declaration method(const Fact<MethodDeclaration>& a) {
    return Declaration{Alt<4, Fact<MethodDeclaration>>(a)};
  }
  static Declaration interface_(const Fact<InterfaceDeclaration>& a) {
    return Declaration{Alt<5, Fact<InterfaceDeclaration>>(a)};
  }
  static Declaration class_(const Fact<ClassDeclaration>& a) {
    return Declaration{Alt<6, Fact<ClassDeclaration>>(a)};
  }
  static Declaration enum_(const Fact<EnumDeclaration>& a) {
    return Declaration{Alt<7, Fact<EnumDeclaration>>(a)};
  }

  bool operator==(const Declaration& other) const {
    return std::tie(GLEAN_value)
             == std::tie(other.GLEAN_value);
  }
  bool operator!=(const Declaration& other) const {
    return std::tie(GLEAN_value)
             != std::tie(other.GLEAN_value);
  }
  bool operator<(const Declaration& other) const {
    return std::tie(GLEAN_value)
             < std::tie(other.GLEAN_value);
  }
  bool operator<=(const Declaration& other) const {
    return std::tie(GLEAN_value)
             <= std::tie(other.GLEAN_value);
  }
  bool operator>(const Declaration& other) const {
    return std::tie(GLEAN_value)
             > std::tie(other.GLEAN_value);
  }
  bool operator>=(const Declaration& other) const {
    return std::tie(GLEAN_value)
             >= std::tie(other.GLEAN_value);
  }

  void outputRepr(Output<Repr<Declaration>> out) const {
    outputValue(out, GLEAN_value);
  }
}; // struct Declaration

struct DeclarationAnnotations : Predicate<std::tuple<Declaration, std::vector<Fact<Annotation>>>> {
  static const char* GLEAN_name() {
    return "java.alpha.DeclarationAnnotations";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct DeclarationAnnotations

struct DeclarationComment : Predicate<std::tuple<Declaration, Fact<facebook::glean::cpp::schema::Src::File>, facebook::glean::cpp::schema::Src::ByteSpan>> {
  static const char* GLEAN_name() {
    return "java.alpha.DeclarationComment";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct DeclarationComment

struct DeclarationLocation : Predicate<std::tuple<Declaration, std::string, Fact<facebook::glean::cpp::schema::Src::File>, facebook::glean::cpp::schema::Src::ByteSpan>> {
  static const char* GLEAN_name() {
    return "java.alpha.DeclarationLocation";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct DeclarationLocation

struct DeclarationType : Predicate<std::tuple<Declaration, Fact<Type>>> {
  static const char* GLEAN_name() {
    return "java.alpha.DeclarationType";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct DeclarationType

struct DeclarationUses : Predicate<std::tuple<Declaration, Fact<facebook::glean::cpp::schema::Src::File>, std::vector<facebook::glean::cpp::schema::Src::ByteSpan>>> {
  static const char* GLEAN_name() {
    return "java.alpha.DeclarationUses";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct DeclarationUses

struct DeclarationXRefTarget : Predicate<std::tuple<Declaration, XRefTarget>> {
  static const char* GLEAN_name() {
    return "java.alpha.DeclarationXRefTarget";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct DeclarationXRefTarget

struct ExtendedByDeclaration : Predicate<std::tuple<Declaration, Declaration>> {
  static const char* GLEAN_name() {
    return "java.alpha.ExtendedByDeclaration";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct ExtendedByDeclaration

struct ExtendsDeclaration : Predicate<std::tuple<Declaration, Declaration>> {
  static const char* GLEAN_name() {
    return "java.alpha.ExtendsDeclaration";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct ExtendsDeclaration

struct FileDeclarations : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Src::File>, Declaration>> {
  static const char* GLEAN_name() {
    return "java.alpha.FileDeclarations";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct FileDeclarations

struct ParentDeclaration : Predicate<std::tuple<Declaration, Declaration>> {
  static const char* GLEAN_name() {
    return "java.alpha.ParentDeclaration";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct ParentDeclaration

struct QNameToDefinition : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Javakotlin::Alpha::QName>, Declaration>> {
  static const char* GLEAN_name() {
    return "java.alpha.QNameToDefinition";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct QNameToDefinition

struct XRefOfType : Predicate<std::tuple<Fact<Type>, Declaration, facebook::glean::cpp::schema::Src::ByteSpan>> {
  static const char* GLEAN_name() {
    return "java.alpha.XRefOfType";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct XRefOfType

struct XRefTargetDeclaration : Predicate<std::tuple<XRefTarget, Declaration>> {
  static const char* GLEAN_name() {
    return "java.alpha.XRefTargetDeclaration";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct XRefTargetDeclaration

} // namespace Alpha

} // namespace Java

namespace Search {

namespace Java {

struct SearchByQName : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Javakotlin::Alpha::QName>, facebook::glean::cpp::schema::Java::Alpha::Declaration>> {
  static const char* GLEAN_name() {
    return "search.java.SearchByQName";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct SearchByQName

} // namespace Java

} // namespace Search

namespace Symbolid {

namespace Java {

struct LookupDeclaration : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Javakotlin::Alpha::QName>, facebook::glean::cpp::schema::Java::Alpha::Declaration>> {
  static const char* GLEAN_name() {
    return "symbolid.java.LookupDeclaration";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct LookupDeclaration

struct LookupMethodDeclaration : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Javakotlin::Alpha::MethodName>, facebook::glean::cpp::schema::Java::Alpha::Declaration>> {
  static const char* GLEAN_name() {
    return "symbolid.java.LookupMethodDeclaration";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct LookupMethodDeclaration

} // namespace Java

} // namespace Symbolid

namespace Java {

namespace Alpha {

struct DeclOfExecutableDefn : Predicate<std::tuple<ExecutableDefinition, Declaration>> {
  static const char* GLEAN_name() {
    return "java.alpha.DeclOfExecutableDefn";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct DeclOfExecutableDefn

struct DeclOfDefn : Predicate<std::tuple<Definition, Declaration>> {
  static const char* GLEAN_name() {
    return "java.alpha.DeclOfDefn";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct DeclOfDefn

struct ContainsDeclaration : Predicate<std::tuple<Declaration, Declaration>> {
  static const char* GLEAN_name() {
    return "java.alpha.ContainsDeclaration";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct ContainsDeclaration

struct ConstructorDeclaration : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Javakotlin::Alpha::MethodName>, std::vector<Fact<ParameterDeclaration>>, std::vector<Fact<Annotation>>, std::vector<Modifier>, std::vector<Fact<TypeParam>>, std::vector<Fact<Type>>, Definition, facebook::glean::cpp::schema::Src::ByteSpan>> {
  static const char* GLEAN_name() {
    return "java.alpha.ConstructorDeclaration";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct ConstructorDeclaration

struct ClassDeclaration : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Javakotlin::Alpha::QName>, std::vector<Modifier>, boost::variant<Alt<0, std::tuple<>>, Alt<1, Fact<Type>>>, std::vector<Fact<Type>>, std::vector<Fact<Annotation>>, boost::variant<Alt<0, std::tuple<>>, Alt<1, Definition>>, std::vector<Fact<TypeParam>>, facebook::glean::cpp::schema::Src::ByteSpan, Fact<facebook::glean::cpp::schema::Src::File>>> {
  static const char* GLEAN_name() {
    return "java.alpha.ClassDeclaration";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct ClassDeclaration

} // namespace Alpha

} // namespace Java

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Java::Alpha::BaseType> {
  using Type = Sum<facebook::glean::cpp::schema::Java::Alpha::ObjectType, facebook::glean::cpp::schema::Java::Alpha::PrimitiveType, facebook::glean::cpp::schema::Java::Alpha::TypeVar, facebook::glean::cpp::schema::Java::Alpha::ArrayType>;
};


namespace schema {

namespace Java {

namespace Alpha {

struct BaseType {
  boost::variant<Alt<0, Fact<ObjectType>>, Alt<1, Fact<PrimitiveType>>, Alt<2, Fact<TypeVar>>, Alt<3, Fact<ArrayType>>> GLEAN_value;

  static BaseType object(const Fact<ObjectType>& a) {
    return BaseType{Alt<0, Fact<ObjectType>>(a)};
  }
  static BaseType primitive(const Fact<PrimitiveType>& a) {
    return BaseType{Alt<1, Fact<PrimitiveType>>(a)};
  }
  static BaseType variable(const Fact<TypeVar>& a) {
    return BaseType{Alt<2, Fact<TypeVar>>(a)};
  }
  static BaseType array(const Fact<ArrayType>& a) {
    return BaseType{Alt<3, Fact<ArrayType>>(a)};
  }

  bool operator==(const BaseType& other) const {
    return std::tie(GLEAN_value)
             == std::tie(other.GLEAN_value);
  }
  bool operator!=(const BaseType& other) const {
    return std::tie(GLEAN_value)
             != std::tie(other.GLEAN_value);
  }
  bool operator<(const BaseType& other) const {
    return std::tie(GLEAN_value)
             < std::tie(other.GLEAN_value);
  }
  bool operator<=(const BaseType& other) const {
    return std::tie(GLEAN_value)
             <= std::tie(other.GLEAN_value);
  }
  bool operator>(const BaseType& other) const {
    return std::tie(GLEAN_value)
             > std::tie(other.GLEAN_value);
  }
  bool operator>=(const BaseType& other) const {
    return std::tie(GLEAN_value)
             >= std::tie(other.GLEAN_value);
  }

  void outputRepr(Output<Repr<BaseType>> out) const {
    outputValue(out, GLEAN_value);
  }
}; // struct BaseType

struct Type : Predicate<std::tuple<BaseType, std::vector<Fact<TypeArg>>, Fact<facebook::glean::cpp::schema::Javakotlin::Alpha::Type>, facebook::glean::cpp::schema::Src::ByteSpan>> {
  static const char* GLEAN_name() {
    return "java.alpha.Type";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct Type

struct ArrayType : Predicate<std::tuple<Fact<Type>, facebook::glean::cpp::schema::Src::ByteSpan>> {
  static const char* GLEAN_name() {
    return "java.alpha.ArrayType";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct ArrayType

struct Annotation : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Javakotlin::Alpha::QName>, Fact<facebook::glean::cpp::schema::Javakotlin::Alpha::MethodName>, boost::variant<Alt<0, std::tuple<>>, Alt<1, std::string>>, facebook::glean::cpp::schema::Src::ByteSpan>> {
  static const char* GLEAN_name() {
    return "java.alpha.Annotation";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct Annotation

struct AnnotatedClass : Predicate<std::tuple<Fact<Annotation>, Fact<ClassDeclaration>>> {
  static const char* GLEAN_name() {
    return "java.alpha.AnnotatedClass";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct AnnotatedClass

} // namespace Alpha

} // namespace Java

namespace Indexer {

struct Config : Predicate<std::string, std::string> {
  static const char* GLEAN_name() {
    return "indexer.Config";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct Config

} // namespace Indexer

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Hs::XRefTarget> {
  using Type = Sum<facebook::glean::cpp::schema::Hs::DefinitionName, facebook::glean::cpp::schema::Hs::ClassName, facebook::glean::cpp::schema::Hs::ModuleName>;
};


namespace schema {

namespace Hs {

struct XRefTarget {
  boost::variant<Alt<0, Fact<DefinitionName>>, Alt<1, Fact<ClassName>>, Alt<2, Fact<ModuleName>>> GLEAN_value;

  static XRefTarget definition(const Fact<DefinitionName>& a) {
    return XRefTarget{Alt<0, Fact<DefinitionName>>(a)};
  }
  static XRefTarget typeclass(const Fact<ClassName>& a) {
    return XRefTarget{Alt<1, Fact<ClassName>>(a)};
  }
  static XRefTarget hs_module(const Fact<ModuleName>& a) {
    return XRefTarget{Alt<2, Fact<ModuleName>>(a)};
  }

  bool operator==(const XRefTarget& other) const {
    return std::tie(GLEAN_value)
             == std::tie(other.GLEAN_value);
  }
  bool operator!=(const XRefTarget& other) const {
    return std::tie(GLEAN_value)
             != std::tie(other.GLEAN_value);
  }
  bool operator<(const XRefTarget& other) const {
    return std::tie(GLEAN_value)
             < std::tie(other.GLEAN_value);
  }
  bool operator<=(const XRefTarget& other) const {
    return std::tie(GLEAN_value)
             <= std::tie(other.GLEAN_value);
  }
  bool operator>(const XRefTarget& other) const {
    return std::tie(GLEAN_value)
             > std::tie(other.GLEAN_value);
  }
  bool operator>=(const XRefTarget& other) const {
    return std::tie(GLEAN_value)
             >= std::tie(other.GLEAN_value);
  }

  void outputRepr(Output<Repr<XRefTarget>> out) const {
    outputValue(out, GLEAN_value);
  }
}; // struct XRefTarget

} // namespace Hs

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Hs::XReference> {
  using Type = Tuple<Repr<facebook::glean::cpp::schema::Hs::XRefTarget>, Array<Repr<facebook::glean::cpp::schema::Src::ByteSpan>>>;
};


namespace schema {

namespace Hs {

struct XReference {
  XRefTarget target;
  std::vector<facebook::glean::cpp::schema::Src::ByteSpan> spans;

  bool operator==(const XReference& other) const {
    return std::tie(target,spans)
             == std::tie(other.target,other.spans);
  }
  bool operator!=(const XReference& other) const {
    return std::tie(target,spans)
             != std::tie(other.target,other.spans);
  }
  bool operator<(const XReference& other) const {
    return std::tie(target,spans)
             < std::tie(other.target,other.spans);
  }
  bool operator<=(const XReference& other) const {
    return std::tie(target,spans)
             <= std::tie(other.target,other.spans);
  }
  bool operator>(const XReference& other) const {
    return std::tie(target,spans)
             > std::tie(other.target,other.spans);
  }
  bool operator>=(const XReference& other) const {
    return std::tie(target,spans)
             >= std::tie(other.target,other.spans);
  }
  void outputRepr(Output<Repr<XReference>> out) const {
    outputValue(out, std::make_tuple(target, spans));
  }
}; // struct XReference

struct XRef : Predicate<std::tuple<facebook::glean::cpp::schema::Src::FileLocation, XRefTarget>> {
  static const char* GLEAN_name() {
    return "hs.XRef";
  }

  static constexpr size_t GLEAN_version() {
     return 2;
  }
}; // struct XRef

struct Type : Predicate<std::string> {
  static const char* GLEAN_name() {
    return "hs.Type";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct Type

struct TargetUses : Predicate<std::tuple<Fact<Definition>, Fact<facebook::glean::cpp::schema::Src::File>, std::vector<facebook::glean::cpp::schema::Src::ByteSpan>>> {
  static const char* GLEAN_name() {
    return "hs.TargetUses";
  }

  static constexpr size_t GLEAN_version() {
     return 2;
  }
}; // struct TargetUses

struct SourceModule : Predicate<std::tuple<Fact<ModuleName>, Fact<facebook::glean::cpp::schema::Src::File>>> {
  static const char* GLEAN_name() {
    return "hs.SourceModule";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct SourceModule

struct PackageId : Predicate<std::string> {
  static const char* GLEAN_name() {
    return "hs.PackageId";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct PackageId

struct ModuleNameLowerCase : Predicate<std::tuple<std::string, Fact<ModuleName>>> {
  static const char* GLEAN_name() {
    return "hs.ModuleNameLowerCase";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct ModuleNameLowerCase

struct ModuleName : Predicate<std::string> {
  static const char* GLEAN_name() {
    return "hs.ModuleName";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct ModuleName

struct ModuleDefinitions : Predicate<std::tuple<Fact<Module>, std::vector<Fact<FunctionDefinition>>>> {
  static const char* GLEAN_name() {
    return "hs.ModuleDefinitions";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct ModuleDefinitions

struct Module : Predicate<std::tuple<Fact<PackageId>, Fact<ModuleName>, Fact<facebook::glean::cpp::schema::Src::File>>> {
  static const char* GLEAN_name() {
    return "hs.Module";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct Module

struct FunctionNameLowerCase : Predicate<std::tuple<std::string, Fact<FunctionName>>> {
  static const char* GLEAN_name() {
    return "hs.FunctionNameLowerCase";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct FunctionNameLowerCase

struct FunctionName : Predicate<std::string> {
  static const char* GLEAN_name() {
    return "hs.FunctionName";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct FunctionName

struct FunctionDefinition : Predicate<std::tuple<Fact<FunctionName>, facebook::glean::cpp::schema::Src::Range>> {
  static const char* GLEAN_name() {
    return "hs.FunctionDefinition";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct FunctionDefinition

struct FileXRefMap : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Src::File>, std::vector<XReference>>> {
  static const char* GLEAN_name() {
    return "hs.FileXRefMap";
  }

  static constexpr size_t GLEAN_version() {
     return 2;
  }
}; // struct FileXRefMap

struct DefinitionNameLowerCase : Predicate<std::tuple<std::string, Fact<DefinitionName>>> {
  static const char* GLEAN_name() {
    return "hs.DefinitionNameLowerCase";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct DefinitionNameLowerCase

struct DefinitionName : Predicate<std::string> {
  static const char* GLEAN_name() {
    return "hs.DefinitionName";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct DefinitionName

} // namespace Hs

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Hs::DefinitionEntity> {
  using Type = Sum<facebook::glean::cpp::schema::Hs::Definition, facebook::glean::cpp::schema::Hs::FunctionDefinition, facebook::glean::cpp::schema::Hs::Class>;
};


namespace schema {

namespace Hs {

struct DefinitionEntity {
  boost::variant<Alt<0, Fact<Definition>>, Alt<1, Fact<FunctionDefinition>>, Alt<2, Fact<Class>>> GLEAN_value;

  static DefinitionEntity definition(const Fact<Definition>& a) {
    return DefinitionEntity{Alt<0, Fact<Definition>>(a)};
  }
  static DefinitionEntity function_(const Fact<FunctionDefinition>& a) {
    return DefinitionEntity{Alt<1, Fact<FunctionDefinition>>(a)};
  }
  static DefinitionEntity class_(const Fact<Class>& a) {
    return DefinitionEntity{Alt<2, Fact<Class>>(a)};
  }

  bool operator==(const DefinitionEntity& other) const {
    return std::tie(GLEAN_value)
             == std::tie(other.GLEAN_value);
  }
  bool operator!=(const DefinitionEntity& other) const {
    return std::tie(GLEAN_value)
             != std::tie(other.GLEAN_value);
  }
  bool operator<(const DefinitionEntity& other) const {
    return std::tie(GLEAN_value)
             < std::tie(other.GLEAN_value);
  }
  bool operator<=(const DefinitionEntity& other) const {
    return std::tie(GLEAN_value)
             <= std::tie(other.GLEAN_value);
  }
  bool operator>(const DefinitionEntity& other) const {
    return std::tie(GLEAN_value)
             > std::tie(other.GLEAN_value);
  }
  bool operator>=(const DefinitionEntity& other) const {
    return std::tie(GLEAN_value)
             >= std::tie(other.GLEAN_value);
  }

  void outputRepr(Output<Repr<DefinitionEntity>> out) const {
    outputValue(out, GLEAN_value);
  }
}; // struct DefinitionEntity

struct DefinitionLocation : Predicate<std::tuple<DefinitionEntity, std::string, facebook::glean::cpp::schema::Src::FileLocation>> {
  static const char* GLEAN_name() {
    return "hs.DefinitionLocation";
  }

  static constexpr size_t GLEAN_version() {
     return 2;
  }
}; // struct DefinitionLocation

struct FileDefinition : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Src::File>, DefinitionEntity>> {
  static const char* GLEAN_name() {
    return "hs.FileDefinition";
  }

  static constexpr size_t GLEAN_version() {
     return 2;
  }
}; // struct FileDefinition

struct Definition : Predicate<std::tuple<Fact<DefinitionName>, facebook::glean::cpp::schema::Src::FileLocation>> {
  static const char* GLEAN_name() {
    return "hs.Definition";
  }

  static constexpr size_t GLEAN_version() {
     return 2;
  }
}; // struct Definition

struct Definition_1 : Predicate<std::tuple<Fact<DefinitionName>, facebook::glean::cpp::schema::Src::Range>> {
  static const char* GLEAN_name() {
    return "hs.Definition";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct Definition_1

struct ClassNameLowerCase : Predicate<std::tuple<std::string, Fact<ClassName>>> {
  static const char* GLEAN_name() {
    return "hs.ClassNameLowerCase";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct ClassNameLowerCase

struct ClassName : Predicate<std::string> {
  static const char* GLEAN_name() {
    return "hs.ClassName";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct ClassName

struct ClassInstance : Predicate<std::tuple<Fact<ClassName>, Fact<Type>, facebook::glean::cpp::schema::Src::Range>> {
  static const char* GLEAN_name() {
    return "hs.ClassInstance";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct ClassInstance

struct Class : Predicate<std::tuple<Fact<ClassName>, facebook::glean::cpp::schema::Src::Range>> {
  static const char* GLEAN_name() {
    return "hs.Class";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct Class

} // namespace Hs

namespace Haxlanalyser {

struct ThriftResponse : Predicate<std::string> {
  static const char* GLEAN_name() {
    return "haxlanalyser.ThriftResponse";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct ThriftResponse

struct ThriftFetch : Predicate<std::string> {
  static const char* GLEAN_name() {
    return "haxlanalyser.ThriftFetch";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct ThriftFetch

struct TestFile : Predicate<Fact<facebook::glean::cpp::schema::Src::File>> {
  static const char* GLEAN_name() {
    return "haxlanalyser.TestFile";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct TestFile

struct TallyName : Predicate<std::string> {
  static const char* GLEAN_name() {
    return "haxlanalyser.TallyName";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct TallyName

} // namespace Haxlanalyser

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Haxlanalyser::TallyCounterType> {
  using Type = Enum<9>;
};


namespace schema {

namespace Haxlanalyser {

enum class TallyCounterType { counter, uniqueCounter, topK, quantiles, uniqueQuantiles, firstN, lastN, moments, infiniteCounter };

struct TallyConfig : Predicate<std::tuple<Fact<TallyName>, facebook::glean::cpp::schema::Src::Loc>> {
  static const char* GLEAN_name() {
    return "haxlanalyser.TallyConfig";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct TallyConfig

} // namespace Haxlanalyser

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Haxlanalyser::Tally> {
  using Type = Tuple<String, Repr<facebook::glean::cpp::schema::Haxlanalyser::TallyCounterType>>;
};


namespace schema {

namespace Haxlanalyser {

struct Tally {
  std::string name;
  TallyCounterType type;

  bool operator==(const Tally& other) const {
    return std::tie(name,type)
             == std::tie(other.name,other.type);
  }
  bool operator!=(const Tally& other) const {
    return std::tie(name,type)
             != std::tie(other.name,other.type);
  }
  bool operator<(const Tally& other) const {
    return std::tie(name,type)
             < std::tie(other.name,other.type);
  }
  bool operator<=(const Tally& other) const {
    return std::tie(name,type)
             <= std::tie(other.name,other.type);
  }
  bool operator>(const Tally& other) const {
    return std::tie(name,type)
             > std::tie(other.name,other.type);
  }
  bool operator>=(const Tally& other) const {
    return std::tie(name,type)
             >= std::tie(other.name,other.type);
  }
  void outputRepr(Output<Repr<Tally>> out) const {
    outputValue(out, std::make_tuple(name, type));
  }
}; // struct Tally

struct TallyFetch : Predicate<Tally> {
  static const char* GLEAN_name() {
    return "haxlanalyser.TallyFetch";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct TallyFetch

struct TallyResponse : Predicate<Tally> {
  static const char* GLEAN_name() {
    return "haxlanalyser.TallyResponse";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct TallyResponse

struct SitevarFetch : Predicate<std::string> {
  static const char* GLEAN_name() {
    return "haxlanalyser.SitevarFetch";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct SitevarFetch

struct ScubaResponse : Predicate<std::string> {
  static const char* GLEAN_name() {
    return "haxlanalyser.ScubaResponse";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct ScubaResponse

struct ScribeResponse : Predicate<std::string> {
  static const char* GLEAN_name() {
    return "haxlanalyser.ScribeResponse";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct ScribeResponse

struct RestrictionResponse : Predicate<uint64_t> {
  static const char* GLEAN_name() {
    return "haxlanalyser.RestrictionResponse";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct RestrictionResponse

} // namespace Haxlanalyser

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Haxlanalyser::Response> {
  using Type = Sum<facebook::glean::cpp::schema::Haxlanalyser::JankyJSONResponse, facebook::glean::cpp::schema::Haxlanalyser::ScubaResponse, facebook::glean::cpp::schema::Haxlanalyser::ThriftResponse, facebook::glean::cpp::schema::Haxlanalyser::PiranhaResponse, facebook::glean::cpp::schema::Haxlanalyser::TallyResponse, facebook::glean::cpp::schema::Haxlanalyser::LogFeatureResponse, facebook::glean::cpp::schema::Haxlanalyser::RestrictionResponse, facebook::glean::cpp::schema::Haxlanalyser::HiveResponse, facebook::glean::cpp::schema::Haxlanalyser::ScribeResponse>;
};


namespace schema {

namespace Haxlanalyser {

struct Response {
  boost::variant<Alt<0, Fact<JankyJSONResponse>>, Alt<1, Fact<ScubaResponse>>, Alt<2, Fact<ThriftResponse>>, Alt<3, Fact<PiranhaResponse>>, Alt<4, Fact<TallyResponse>>, Alt<5, Fact<LogFeatureResponse>>, Alt<6, Fact<RestrictionResponse>>, Alt<7, Fact<HiveResponse>>, Alt<8, Fact<ScribeResponse>>> GLEAN_value;

  static Response janky_json(const Fact<JankyJSONResponse>& a) {
    return Response{Alt<0, Fact<JankyJSONResponse>>(a)};
  }
  static Response scuba(const Fact<ScubaResponse>& a) {
    return Response{Alt<1, Fact<ScubaResponse>>(a)};
  }
  static Response thrift(const Fact<ThriftResponse>& a) {
    return Response{Alt<2, Fact<ThriftResponse>>(a)};
  }
  static Response piranha(const Fact<PiranhaResponse>& a) {
    return Response{Alt<3, Fact<PiranhaResponse>>(a)};
  }
  static Response tally(const Fact<TallyResponse>& a) {
    return Response{Alt<4, Fact<TallyResponse>>(a)};
  }
  static Response log_feature(const Fact<LogFeatureResponse>& a) {
    return Response{Alt<5, Fact<LogFeatureResponse>>(a)};
  }
  static Response restriction(const Fact<RestrictionResponse>& a) {
    return Response{Alt<6, Fact<RestrictionResponse>>(a)};
  }
  static Response hive(const Fact<HiveResponse>& a) {
    return Response{Alt<7, Fact<HiveResponse>>(a)};
  }
  static Response scribe(const Fact<ScribeResponse>& a) {
    return Response{Alt<8, Fact<ScribeResponse>>(a)};
  }

  bool operator==(const Response& other) const {
    return std::tie(GLEAN_value)
             == std::tie(other.GLEAN_value);
  }
  bool operator!=(const Response& other) const {
    return std::tie(GLEAN_value)
             != std::tie(other.GLEAN_value);
  }
  bool operator<(const Response& other) const {
    return std::tie(GLEAN_value)
             < std::tie(other.GLEAN_value);
  }
  bool operator<=(const Response& other) const {
    return std::tie(GLEAN_value)
             <= std::tie(other.GLEAN_value);
  }
  bool operator>(const Response& other) const {
    return std::tie(GLEAN_value)
             > std::tie(other.GLEAN_value);
  }
  bool operator>=(const Response& other) const {
    return std::tie(GLEAN_value)
             >= std::tie(other.GLEAN_value);
  }

  void outputRepr(Output<Repr<Response>> out) const {
    outputValue(out, GLEAN_value);
  }
}; // struct Response

struct PolicyName : Predicate<std::string> {
  static const char* GLEAN_name() {
    return "haxlanalyser.PolicyName";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct PolicyName

struct Policy : Predicate<std::tuple<Fact<PolicyName>, facebook::glean::cpp::schema::Src::Loc>> {
  static const char* GLEAN_name() {
    return "haxlanalyser.Policy";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct Policy

struct PiranhaResponse : Predicate<uint64_t> {
  static const char* GLEAN_name() {
    return "haxlanalyser.PiranhaResponse";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct PiranhaResponse

struct LogFeatureResponse : Predicate<std::string> {
  static const char* GLEAN_name() {
    return "haxlanalyser.LogFeatureResponse";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct LogFeatureResponse

struct LaserDataset : Predicate<std::string> {
  static const char* GLEAN_name() {
    return "haxlanalyser.LaserDataset";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct LaserDataset

struct JankyJSONResponse : Predicate<std::string> {
  static const char* GLEAN_name() {
    return "haxlanalyser.JankyJSONResponse";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct JankyJSONResponse

struct InputKey : Predicate<std::string> {
  static const char* GLEAN_name() {
    return "haxlanalyser.InputKey";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct InputKey

struct InputFetch : Predicate<std::tuple<Fact<InputKey>, facebook::glean::cpp::schema::Src::Loc>> {
  static const char* GLEAN_name() {
    return "haxlanalyser.InputFetch";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct InputFetch

struct HiveResponse : Predicate<std::string> {
  static const char* GLEAN_name() {
    return "haxlanalyser.HiveResponse";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct HiveResponse

} // namespace Haxlanalyser

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Haxlanalyser::Fetch> {
  using Type = Sum<facebook::glean::cpp::schema::Haxlanalyser::ThriftFetch, facebook::glean::cpp::schema::Haxlanalyser::ConfigeratorFetch, facebook::glean::cpp::schema::Haxlanalyser::TallyFetch, facebook::glean::cpp::schema::Haxlanalyser::ClassifierFetch, facebook::glean::cpp::schema::Haxlanalyser::SitevarFetch>;
};


namespace schema {

namespace Haxlanalyser {

struct Fetch {
  boost::variant<Alt<0, Fact<ThriftFetch>>, Alt<1, Fact<ConfigeratorFetch>>, Alt<2, Fact<TallyFetch>>, Alt<3, Fact<ClassifierFetch>>, Alt<4, Fact<SitevarFetch>>> GLEAN_value;

  static Fetch thrift(const Fact<ThriftFetch>& a) {
    return Fetch{Alt<0, Fact<ThriftFetch>>(a)};
  }
  static Fetch configerator(const Fact<ConfigeratorFetch>& a) {
    return Fetch{Alt<1, Fact<ConfigeratorFetch>>(a)};
  }
  static Fetch tally(const Fact<TallyFetch>& a) {
    return Fetch{Alt<2, Fact<TallyFetch>>(a)};
  }
  static Fetch classifier(const Fact<ClassifierFetch>& a) {
    return Fetch{Alt<3, Fact<ClassifierFetch>>(a)};
  }
  static Fetch sitevar(const Fact<SitevarFetch>& a) {
    return Fetch{Alt<4, Fact<SitevarFetch>>(a)};
  }

  bool operator==(const Fetch& other) const {
    return std::tie(GLEAN_value)
             == std::tie(other.GLEAN_value);
  }
  bool operator!=(const Fetch& other) const {
    return std::tie(GLEAN_value)
             != std::tie(other.GLEAN_value);
  }
  bool operator<(const Fetch& other) const {
    return std::tie(GLEAN_value)
             < std::tie(other.GLEAN_value);
  }
  bool operator<=(const Fetch& other) const {
    return std::tie(GLEAN_value)
             <= std::tie(other.GLEAN_value);
  }
  bool operator>(const Fetch& other) const {
    return std::tie(GLEAN_value)
             > std::tie(other.GLEAN_value);
  }
  bool operator>=(const Fetch& other) const {
    return std::tie(GLEAN_value)
             >= std::tie(other.GLEAN_value);
  }

  void outputRepr(Output<Repr<Fetch>> out) const {
    outputValue(out, GLEAN_value);
  }
}; // struct Fetch

} // namespace Haxlanalyser

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Haxlanalyser::Node> {
  using Type = Sum<facebook::glean::cpp::schema::Hs::SourceModule, facebook::glean::cpp::schema::Hs::DefinitionName, facebook::glean::cpp::schema::Hs::ClassName, facebook::glean::cpp::schema::Hs::ClassInstance, facebook::glean::cpp::schema::Haxlanalyser::Context, facebook::glean::cpp::schema::Haxlanalyser::Policy, facebook::glean::cpp::schema::Haxlanalyser::TallyConfig, facebook::glean::cpp::schema::Haxlanalyser::Endpoint, facebook::glean::cpp::schema::Haxlanalyser::ACDCProperty, facebook::glean::cpp::schema::Haxlanalyser::InputFetch, Repr<facebook::glean::cpp::schema::Haxlanalyser::Response>, Repr<facebook::glean::cpp::schema::Haxlanalyser::Fetch>, facebook::glean::cpp::schema::Haxlanalyser::ClassifierRead, facebook::glean::cpp::schema::Haxlanalyser::LaserDataset, facebook::glean::cpp::schema::Haxlanalyser::TestFile, facebook::glean::cpp::schema::Haxlanalyser::Call, facebook::glean::cpp::schema::Haxlanalyser::ACDCPropertyAccess, facebook::glean::cpp::schema::Haxlanalyser::FeatureSetFeature>;
};


namespace schema {

namespace Haxlanalyser {

struct Node {
  boost::variant<Alt<0, Fact<facebook::glean::cpp::schema::Hs::SourceModule>>, Alt<1, Fact<facebook::glean::cpp::schema::Hs::DefinitionName>>, Alt<2, Fact<facebook::glean::cpp::schema::Hs::ClassName>>, Alt<3, Fact<facebook::glean::cpp::schema::Hs::ClassInstance>>, Alt<4, Fact<Context>>, Alt<5, Fact<Policy>>, Alt<6, Fact<TallyConfig>>, Alt<7, Fact<Endpoint>>, Alt<8, Fact<ACDCProperty>>, Alt<9, Fact<InputFetch>>, Alt<10, Response>, Alt<11, Fetch>, Alt<12, Fact<ClassifierRead>>, Alt<13, Fact<LaserDataset>>, Alt<14, Fact<TestFile>>, Alt<15, Fact<Call>>, Alt<16, Fact<ACDCPropertyAccess>>, Alt<17, Fact<FeatureSetFeature>>> GLEAN_value;

  static Node hs_module(const Fact<facebook::glean::cpp::schema::Hs::SourceModule>& a) {
    return Node{Alt<0, Fact<facebook::glean::cpp::schema::Hs::SourceModule>>(a)};
  }
  static Node definition(const Fact<facebook::glean::cpp::schema::Hs::DefinitionName>& a) {
    return Node{Alt<1, Fact<facebook::glean::cpp::schema::Hs::DefinitionName>>(a)};
  }
  static Node typeclass(const Fact<facebook::glean::cpp::schema::Hs::ClassName>& a) {
    return Node{Alt<2, Fact<facebook::glean::cpp::schema::Hs::ClassName>>(a)};
  }
  static Node class_instance(const Fact<facebook::glean::cpp::schema::Hs::ClassInstance>& a) {
    return Node{Alt<3, Fact<facebook::glean::cpp::schema::Hs::ClassInstance>>(a)};
  }
  static Node context(const Fact<Context>& a) {
    return Node{Alt<4, Fact<Context>>(a)};
  }
  static Node policy(const Fact<Policy>& a) {
    return Node{Alt<5, Fact<Policy>>(a)};
  }
  static Node tally(const Fact<TallyConfig>& a) {
    return Node{Alt<6, Fact<TallyConfig>>(a)};
  }
  static Node endpoint(const Fact<Endpoint>& a) {
    return Node{Alt<7, Fact<Endpoint>>(a)};
  }
  static Node acdc(const Fact<ACDCProperty>& a) {
    return Node{Alt<8, Fact<ACDCProperty>>(a)};
  }
  static Node input_fetch(const Fact<InputFetch>& a) {
    return Node{Alt<9, Fact<InputFetch>>(a)};
  }
  static Node response(const Response& a) {
    return Node{Alt<10, Response>(a)};
  }
  static Node fetch(const Fetch& a) {
    return Node{Alt<11, Fetch>(a)};
  }
  static Node classifier_read(const Fact<ClassifierRead>& a) {
    return Node{Alt<12, Fact<ClassifierRead>>(a)};
  }
  static Node laser_dataset(const Fact<LaserDataset>& a) {
    return Node{Alt<13, Fact<LaserDataset>>(a)};
  }
  static Node test_file(const Fact<TestFile>& a) {
    return Node{Alt<14, Fact<TestFile>>(a)};
  }
  static Node call(const Fact<Call>& a) {
    return Node{Alt<15, Fact<Call>>(a)};
  }
  static Node acdc_access(const Fact<ACDCPropertyAccess>& a) {
    return Node{Alt<16, Fact<ACDCPropertyAccess>>(a)};
  }
  static Node feature(const Fact<FeatureSetFeature>& a) {
    return Node{Alt<17, Fact<FeatureSetFeature>>(a)};
  }

  bool operator==(const Node& other) const {
    return std::tie(GLEAN_value)
             == std::tie(other.GLEAN_value);
  }
  bool operator!=(const Node& other) const {
    return std::tie(GLEAN_value)
             != std::tie(other.GLEAN_value);
  }
  bool operator<(const Node& other) const {
    return std::tie(GLEAN_value)
             < std::tie(other.GLEAN_value);
  }
  bool operator<=(const Node& other) const {
    return std::tie(GLEAN_value)
             <= std::tie(other.GLEAN_value);
  }
  bool operator>(const Node& other) const {
    return std::tie(GLEAN_value)
             > std::tie(other.GLEAN_value);
  }
  bool operator>=(const Node& other) const {
    return std::tie(GLEAN_value)
             >= std::tie(other.GLEAN_value);
  }

  void outputRepr(Output<Repr<Node>> out) const {
    outputValue(out, GLEAN_value);
  }
}; // struct Node

struct FeatureSetFeature : Predicate<std::string> {
  static const char* GLEAN_name() {
    return "haxlanalyser.FeatureSetFeature";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct FeatureSetFeature

struct EndpointName : Predicate<std::string> {
  static const char* GLEAN_name() {
    return "haxlanalyser.EndpointName";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct EndpointName

struct Endpoint : Predicate<std::tuple<Fact<EndpointName>, facebook::glean::cpp::schema::Src::Loc>> {
  static const char* GLEAN_name() {
    return "haxlanalyser.Endpoint";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct Endpoint

struct Edge : Predicate<std::tuple<Node, Node>> {
  static const char* GLEAN_name() {
    return "haxlanalyser.Edge";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct Edge

struct ContextName : Predicate<std::string> {
  static const char* GLEAN_name() {
    return "haxlanalyser.ContextName";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct ContextName

struct Context : Predicate<std::tuple<Fact<ContextName>, facebook::glean::cpp::schema::Src::Loc>> {
  static const char* GLEAN_name() {
    return "haxlanalyser.Context";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct Context

struct ConfigeratorFetch : Predicate<std::string> {
  static const char* GLEAN_name() {
    return "haxlanalyser.ConfigeratorFetch";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct ConfigeratorFetch

struct ClassifierRead : Predicate<std::string> {
  static const char* GLEAN_name() {
    return "haxlanalyser.ClassifierRead";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct ClassifierRead

struct ClassifierFetch : Predicate<std::string> {
  static const char* GLEAN_name() {
    return "haxlanalyser.ClassifierFetch";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct ClassifierFetch

struct Call : Predicate<std::tuple<std::string, std::string, facebook::glean::cpp::schema::Src::Loc>> {
  static const char* GLEAN_name() {
    return "haxlanalyser.Call";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct Call

struct ACDCPropertyAccess : Predicate<std::string> {
  static const char* GLEAN_name() {
    return "haxlanalyser.ACDCPropertyAccess";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct ACDCPropertyAccess

struct ACDCProperty : Predicate<std::tuple<std::string, facebook::glean::cpp::schema::Src::Loc>> {
  static const char* GLEAN_name() {
    return "haxlanalyser.ACDCProperty";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct ACDCProperty

} // namespace Haxlanalyser

namespace Hackdependency {

struct name : Predicate<std::string> {
  static const char* GLEAN_name() {
    return "hackdependency.name";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct name

struct inheritance : Predicate<std::tuple<Fact<name>, Fact<name>>> {
  static const char* GLEAN_name() {
    return "hackdependency.inheritance";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct inheritance

} // namespace Hackdependency

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Hack::Visibility> {
  using Type = Enum<4>;
};


namespace schema {

namespace Hack {

enum class Visibility { Private, Protected, Public, Internal };

} // namespace Hack

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Hack::Variance> {
  using Type = Enum<3>;
};


namespace schema {

namespace Hack {

enum class Variance { Contravariant, Covariant, Invariant };

struct UserAttribute : Predicate<std::tuple<Fact<Name>, std::vector<std::string>, boost::variant<Alt<0, std::tuple<>>, Alt<1, Fact<QName>>>>> {
  static const char* GLEAN_name() {
    return "hack.UserAttribute";
  }

  static constexpr size_t GLEAN_version() {
     return 6;
  }
}; // struct UserAttribute

struct TypedefDeclaration : Predicate<std::tuple<Fact<QName>>> {
  static const char* GLEAN_name() {
    return "hack.TypedefDeclaration";
  }

  static constexpr size_t GLEAN_version() {
     return 6;
  }
}; // struct TypedefDeclaration

} // namespace Hack

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Hack::TypeConstKind> {
  using Type = Enum<3>;
};


namespace schema {

namespace Hack {

enum class TypeConstKind { Abstract, Concrete, PartiallyAbstract };

struct TypeConstDefinition : Predicate<std::tuple<Fact<TypeConstDeclaration>, boost::variant<Alt<0, std::tuple<>>, Alt<1, Fact<Type>>>, TypeConstKind, std::vector<Fact<UserAttribute>>>> {
  static const char* GLEAN_name() {
    return "hack.TypeConstDefinition";
  }

  static constexpr size_t GLEAN_version() {
     return 6;
  }
}; // struct TypeConstDefinition

struct Type : Predicate<std::string> {
  static const char* GLEAN_name() {
    return "hack.Type";
  }

  static constexpr size_t GLEAN_version() {
     return 6;
  }
}; // struct Type

struct TraitDeclaration : Predicate<std::tuple<Fact<QName>>> {
  static const char* GLEAN_name() {
    return "hack.TraitDeclaration";
  }

  static constexpr size_t GLEAN_version() {
     return 6;
  }
}; // struct TraitDeclaration

struct StringLiteral : Predicate<std::string> {
  static const char* GLEAN_name() {
    return "hack.StringLiteral";
  }

  static constexpr size_t GLEAN_version() {
     return 6;
  }
}; // struct StringLiteral

} // namespace Hack

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Hack::ReifyKind> {
  using Type = Enum<3>;
};


namespace schema {

namespace Hack {

enum class ReifyKind { Erased, Reified, SoftReified };

} // namespace Hack

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Hack::ReadonlyKind> {
  using Type = Enum<1>;
};


namespace schema {

namespace Hack {

enum class ReadonlyKind { Readonly };

struct QName : Predicate<std::tuple<Fact<Name>, boost::variant<Alt<0, std::tuple<>>, Alt<1, Fact<NamespaceQName>>>>> {
  static const char* GLEAN_name() {
    return "hack.QName";
  }

  static constexpr size_t GLEAN_version() {
     return 6;
  }
}; // struct QName

struct PropertyDefinition : Predicate<std::tuple<Fact<PropertyDeclaration>, boost::variant<Alt<0, std::tuple<>>, Alt<1, Fact<Type>>>, Visibility, bool, bool, bool, std::vector<Fact<UserAttribute>>>> {
  static const char* GLEAN_name() {
    return "hack.PropertyDefinition";
  }

  static constexpr size_t GLEAN_version() {
     return 6;
  }
}; // struct PropertyDefinition

} // namespace Hack

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Hack::Parameter> {
  using Type = Tuple<facebook::glean::cpp::schema::Hack::Name, Maybe<facebook::glean::cpp::schema::Hack::Type>, Bool, Bool, Maybe<String>, Array<facebook::glean::cpp::schema::Hack::UserAttribute>, Maybe<facebook::glean::cpp::schema::Hack::TypeInfo>, Maybe<Repr<facebook::glean::cpp::schema::Hack::ReadonlyKind>>>;
};


namespace schema {

namespace Hack {

struct Parameter {
  Fact<Name> name;
  boost::variant<Alt<0, std::tuple<>>, Alt<1, Fact<Type>>> type;
  bool isInout;
  bool isVariadic;
  boost::variant<Alt<0, std::tuple<>>, Alt<1, std::string>> defaultValue;
  std::vector<Fact<UserAttribute>> attributes;
  boost::variant<Alt<0, std::tuple<>>, Alt<1, Fact<TypeInfo>>> typeInfo;
  boost::variant<Alt<0, std::tuple<>>, Alt<1, ReadonlyKind>> readonly;

  bool operator==(const Parameter& other) const {
    return std::tie(name,type,isInout,isVariadic,defaultValue,attributes,typeInfo,readonly)
             == std::tie(other.name,other.type,other.isInout,other.isVariadic,other.defaultValue,other.attributes,other.typeInfo,other.readonly);
  }
  bool operator!=(const Parameter& other) const {
    return std::tie(name,type,isInout,isVariadic,defaultValue,attributes,typeInfo,readonly)
             != std::tie(other.name,other.type,other.isInout,other.isVariadic,other.defaultValue,other.attributes,other.typeInfo,other.readonly);
  }
  bool operator<(const Parameter& other) const {
    return std::tie(name,type,isInout,isVariadic,defaultValue,attributes,typeInfo,readonly)
             < std::tie(other.name,other.type,other.isInout,other.isVariadic,other.defaultValue,other.attributes,other.typeInfo,other.readonly);
  }
  bool operator<=(const Parameter& other) const {
    return std::tie(name,type,isInout,isVariadic,defaultValue,attributes,typeInfo,readonly)
             <= std::tie(other.name,other.type,other.isInout,other.isVariadic,other.defaultValue,other.attributes,other.typeInfo,other.readonly);
  }
  bool operator>(const Parameter& other) const {
    return std::tie(name,type,isInout,isVariadic,defaultValue,attributes,typeInfo,readonly)
             > std::tie(other.name,other.type,other.isInout,other.isVariadic,other.defaultValue,other.attributes,other.typeInfo,other.readonly);
  }
  bool operator>=(const Parameter& other) const {
    return std::tie(name,type,isInout,isVariadic,defaultValue,attributes,typeInfo,readonly)
             >= std::tie(other.name,other.type,other.isInout,other.isVariadic,other.defaultValue,other.attributes,other.typeInfo,other.readonly);
  }
  void outputRepr(Output<Repr<Parameter>> out) const {
    outputValue(out, std::make_tuple(name, type, isInout, isVariadic, defaultValue, attributes, typeInfo, readonly));
  }
}; // struct Parameter

struct Signature : Predicate<std::tuple<boost::variant<Alt<0, std::tuple<>>, Alt<1, Fact<Type>>>, std::vector<Parameter>, boost::variant<Alt<0, std::tuple<>>, Alt<1, std::vector<Fact<Context_>>>>, boost::variant<Alt<0, std::tuple<>>, Alt<1, Fact<TypeInfo>>>>> {
  static const char* GLEAN_name() {
    return "hack.Signature";
  }

  static constexpr size_t GLEAN_version() {
     return 6;
  }
}; // struct Signature

} // namespace Hack

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Hack::Occurrence> {
  using Type = Sum<facebook::glean::cpp::schema::Hack::MethodOccurrence>;
};


namespace schema {

namespace Hack {

struct Occurrence {
  boost::variant<Alt<0, Fact<MethodOccurrence>>> GLEAN_value;

  static Occurrence method(const Fact<MethodOccurrence>& a) {
    return Occurrence{Alt<0, Fact<MethodOccurrence>>(a)};
  }

  bool operator==(const Occurrence& other) const {
    return std::tie(GLEAN_value)
             == std::tie(other.GLEAN_value);
  }
  bool operator!=(const Occurrence& other) const {
    return std::tie(GLEAN_value)
             != std::tie(other.GLEAN_value);
  }
  bool operator<(const Occurrence& other) const {
    return std::tie(GLEAN_value)
             < std::tie(other.GLEAN_value);
  }
  bool operator<=(const Occurrence& other) const {
    return std::tie(GLEAN_value)
             <= std::tie(other.GLEAN_value);
  }
  bool operator>(const Occurrence& other) const {
    return std::tie(GLEAN_value)
             > std::tie(other.GLEAN_value);
  }
  bool operator>=(const Occurrence& other) const {
    return std::tie(GLEAN_value)
             >= std::tie(other.GLEAN_value);
  }

  void outputRepr(Output<Repr<Occurrence>> out) const {
    outputValue(out, GLEAN_value);
  }
}; // struct Occurrence

struct NamespaceQName : Predicate<std::tuple<Fact<Name>, boost::variant<Alt<0, std::tuple<>>, Alt<1, Fact<NamespaceQName>>>>> {
  static const char* GLEAN_name() {
    return "hack.NamespaceQName";
  }

  static constexpr size_t GLEAN_version() {
     return 6;
  }
}; // struct NamespaceQName

struct NamespaceDeclaration : Predicate<std::tuple<Fact<NamespaceQName>>> {
  static const char* GLEAN_name() {
    return "hack.NamespaceDeclaration";
  }

  static constexpr size_t GLEAN_version() {
     return 6;
  }
}; // struct NamespaceDeclaration

struct NameLowerCase : Predicate<std::tuple<std::string, Fact<Name>>> {
  static const char* GLEAN_name() {
    return "hack.NameLowerCase";
  }

  static constexpr size_t GLEAN_version() {
     return 6;
  }
}; // struct NameLowerCase

struct Name : Predicate<std::string> {
  static const char* GLEAN_name() {
    return "hack.Name";
  }

  static constexpr size_t GLEAN_version() {
     return 6;
  }
}; // struct Name

} // namespace Hack

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Hack::ModuleMembership> {
  using Type = Tuple<facebook::glean::cpp::schema::Hack::ModuleDeclaration, Bool>;
};


namespace schema {

namespace Hack {

struct ModuleMembership {
  Fact<ModuleDeclaration> declaration;
  bool internal;

  bool operator==(const ModuleMembership& other) const {
    return std::tie(declaration,internal)
             == std::tie(other.declaration,other.internal);
  }
  bool operator!=(const ModuleMembership& other) const {
    return std::tie(declaration,internal)
             != std::tie(other.declaration,other.internal);
  }
  bool operator<(const ModuleMembership& other) const {
    return std::tie(declaration,internal)
             < std::tie(other.declaration,other.internal);
  }
  bool operator<=(const ModuleMembership& other) const {
    return std::tie(declaration,internal)
             <= std::tie(other.declaration,other.internal);
  }
  bool operator>(const ModuleMembership& other) const {
    return std::tie(declaration,internal)
             > std::tie(other.declaration,other.internal);
  }
  bool operator>=(const ModuleMembership& other) const {
    return std::tie(declaration,internal)
             >= std::tie(other.declaration,other.internal);
  }
  void outputRepr(Output<Repr<ModuleMembership>> out) const {
    outputValue(out, std::make_tuple(declaration, internal));
  }
}; // struct ModuleMembership

struct ModuleDefinition : Predicate<std::tuple<Fact<ModuleDeclaration>, std::vector<Fact<UserAttribute>>>> {
  static const char* GLEAN_name() {
    return "hack.ModuleDefinition";
  }

  static constexpr size_t GLEAN_version() {
     return 6;
  }
}; // struct ModuleDefinition

struct ModuleDeclaration : Predicate<std::tuple<Fact<Name>>> {
  static const char* GLEAN_name() {
    return "hack.ModuleDeclaration";
  }

  static constexpr size_t GLEAN_version() {
     return 6;
  }
}; // struct ModuleDeclaration

struct MethodOverrides : Predicate<std::tuple<Fact<MethodDeclaration>, Fact<MethodDeclaration>, boost::variant<Alt<0, std::tuple<>>, Alt<1, bool>>>> {
  static const char* GLEAN_name() {
    return "hack.MethodOverrides";
  }

  static constexpr size_t GLEAN_version() {
     return 6;
  }
}; // struct MethodOverrides

struct MethodOverridden : Predicate<std::tuple<Fact<MethodDeclaration>, Fact<MethodDeclaration>, boost::variant<Alt<0, std::tuple<>>, Alt<1, bool>>>> {
  static const char* GLEAN_name() {
    return "hack.MethodOverridden";
  }

  static constexpr size_t GLEAN_version() {
     return 6;
  }
}; // struct MethodOverridden

struct MethodOccurrence : Predicate<std::tuple<Fact<Name>, boost::variant<Alt<0, std::tuple<>>, Alt<1, Fact<Name>>>>> {
  static const char* GLEAN_name() {
    return "hack.MethodOccurrence";
  }

  static constexpr size_t GLEAN_version() {
     return 6;
  }
}; // struct MethodOccurrence

struct InterfaceDeclaration : Predicate<std::tuple<Fact<QName>>> {
  static const char* GLEAN_name() {
    return "hack.InterfaceDeclaration";
  }

  static constexpr size_t GLEAN_version() {
     return 6;
  }
}; // struct InterfaceDeclaration

struct IndexerInputsHash : Predicate<std::string, std::vector<uint8_t>> {
  static const char* GLEAN_name() {
    return "hack.IndexerInputsHash";
  }

  static constexpr size_t GLEAN_version() {
     return 6;
  }
}; // struct IndexerInputsHash

struct GlobalNamespaceAlias : Predicate<std::tuple<Fact<Name>, Fact<NamespaceQName>>> {
  static const char* GLEAN_name() {
    return "hack.GlobalNamespaceAlias";
  }

  static constexpr size_t GLEAN_version() {
     return 6;
  }
}; // struct GlobalNamespaceAlias

struct GlobalConstDefinition : Predicate<std::tuple<Fact<GlobalConstDeclaration>, boost::variant<Alt<0, std::tuple<>>, Alt<1, Fact<Type>>>, std::string>> {
  static const char* GLEAN_name() {
    return "hack.GlobalConstDefinition";
  }

  static constexpr size_t GLEAN_version() {
     return 6;
  }
}; // struct GlobalConstDefinition

struct GlobalConstDeclaration : Predicate<std::tuple<Fact<QName>>> {
  static const char* GLEAN_name() {
    return "hack.GlobalConstDeclaration";
  }

  static constexpr size_t GLEAN_version() {
     return 6;
  }
}; // struct GlobalConstDeclaration

struct FunctionDeclaration : Predicate<std::tuple<Fact<QName>>> {
  static const char* GLEAN_name() {
    return "hack.FunctionDeclaration";
  }

  static constexpr size_t GLEAN_version() {
     return 6;
  }
}; // struct FunctionDeclaration

struct Enumerator : Predicate<std::tuple<Fact<Name>, Fact<EnumDeclaration>>> {
  static const char* GLEAN_name() {
    return "hack.Enumerator";
  }

  static constexpr size_t GLEAN_version() {
     return 6;
  }
}; // struct Enumerator

struct EnumDefinition : Predicate<std::tuple<Fact<EnumDeclaration>, Fact<Type>, boost::variant<Alt<0, std::tuple<>>, Alt<1, Fact<Type>>>, std::vector<Fact<Enumerator>>, std::vector<Fact<UserAttribute>>, std::vector<Fact<EnumDeclaration>>, bool, boost::variant<Alt<0, std::tuple<>>, Alt<1, ModuleMembership>>>> {
  static const char* GLEAN_name() {
    return "hack.EnumDefinition";
  }

  static constexpr size_t GLEAN_version() {
     return 6;
  }
}; // struct EnumDefinition

struct EnumDeclaration : Predicate<std::tuple<Fact<QName>>> {
  static const char* GLEAN_name() {
    return "hack.EnumDeclaration";
  }

  static constexpr size_t GLEAN_version() {
     return 6;
  }
}; // struct EnumDeclaration

} // namespace Hack

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Hack::Definition> {
  using Type = Sum<facebook::glean::cpp::schema::Hack::ClassDefinition, facebook::glean::cpp::schema::Hack::ClassConstDefinition, facebook::glean::cpp::schema::Hack::EnumDefinition, facebook::glean::cpp::schema::Hack::FunctionDefinition, facebook::glean::cpp::schema::Hack::GlobalConstDefinition, facebook::glean::cpp::schema::Hack::InterfaceDefinition, facebook::glean::cpp::schema::Hack::TraitDefinition, facebook::glean::cpp::schema::Hack::MethodDefinition, facebook::glean::cpp::schema::Hack::PropertyDefinition, facebook::glean::cpp::schema::Hack::TypeConstDefinition, facebook::glean::cpp::schema::Hack::TypedefDefinition, facebook::glean::cpp::schema::Hack::ModuleDefinition>;
};


namespace schema {

namespace Hack {

struct Definition {
  boost::variant<Alt<0, Fact<ClassDefinition>>, Alt<1, Fact<ClassConstDefinition>>, Alt<2, Fact<EnumDefinition>>, Alt<3, Fact<FunctionDefinition>>, Alt<4, Fact<GlobalConstDefinition>>, Alt<5, Fact<InterfaceDefinition>>, Alt<6, Fact<TraitDefinition>>, Alt<7, Fact<MethodDefinition>>, Alt<8, Fact<PropertyDefinition>>, Alt<9, Fact<TypeConstDefinition>>, Alt<10, Fact<TypedefDefinition>>, Alt<11, Fact<ModuleDefinition>>> GLEAN_value;

  static Definition class_(const Fact<ClassDefinition>& a) {
    return Definition{Alt<0, Fact<ClassDefinition>>(a)};
  }
  static Definition classConst(const Fact<ClassConstDefinition>& a) {
    return Definition{Alt<1, Fact<ClassConstDefinition>>(a)};
  }
  static Definition enum_(const Fact<EnumDefinition>& a) {
    return Definition{Alt<2, Fact<EnumDefinition>>(a)};
  }
  static Definition function_(const Fact<FunctionDefinition>& a) {
    return Definition{Alt<3, Fact<FunctionDefinition>>(a)};
  }
  static Definition globalConst(const Fact<GlobalConstDefinition>& a) {
    return Definition{Alt<4, Fact<GlobalConstDefinition>>(a)};
  }
  static Definition interface_(const Fact<InterfaceDefinition>& a) {
    return Definition{Alt<5, Fact<InterfaceDefinition>>(a)};
  }
  static Definition trait(const Fact<TraitDefinition>& a) {
    return Definition{Alt<6, Fact<TraitDefinition>>(a)};
  }
  static Definition method(const Fact<MethodDefinition>& a) {
    return Definition{Alt<7, Fact<MethodDefinition>>(a)};
  }
  static Definition property_(const Fact<PropertyDefinition>& a) {
    return Definition{Alt<8, Fact<PropertyDefinition>>(a)};
  }
  static Definition typeConst(const Fact<TypeConstDefinition>& a) {
    return Definition{Alt<9, Fact<TypeConstDefinition>>(a)};
  }
  static Definition typedef_(const Fact<TypedefDefinition>& a) {
    return Definition{Alt<10, Fact<TypedefDefinition>>(a)};
  }
  static Definition module(const Fact<ModuleDefinition>& a) {
    return Definition{Alt<11, Fact<ModuleDefinition>>(a)};
  }

  bool operator==(const Definition& other) const {
    return std::tie(GLEAN_value)
             == std::tie(other.GLEAN_value);
  }
  bool operator!=(const Definition& other) const {
    return std::tie(GLEAN_value)
             != std::tie(other.GLEAN_value);
  }
  bool operator<(const Definition& other) const {
    return std::tie(GLEAN_value)
             < std::tie(other.GLEAN_value);
  }
  bool operator<=(const Definition& other) const {
    return std::tie(GLEAN_value)
             <= std::tie(other.GLEAN_value);
  }
  bool operator>(const Definition& other) const {
    return std::tie(GLEAN_value)
             > std::tie(other.GLEAN_value);
  }
  bool operator>=(const Definition& other) const {
    return std::tie(GLEAN_value)
             >= std::tie(other.GLEAN_value);
  }

  void outputRepr(Output<Repr<Definition>> out) const {
    outputValue(out, GLEAN_value);
  }
}; // struct Definition

struct Context_ : Predicate<std::string> {
  static const char* GLEAN_name() {
    return "hack.Context_";
  }

  static constexpr size_t GLEAN_version() {
     return 6;
  }
}; // struct Context_

} // namespace Hack

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Hack::ContainerDeclaration> {
  using Type = Sum<facebook::glean::cpp::schema::Hack::ClassDeclaration, facebook::glean::cpp::schema::Hack::EnumDeclaration, facebook::glean::cpp::schema::Hack::InterfaceDeclaration, facebook::glean::cpp::schema::Hack::TraitDeclaration>;
};


namespace schema {

namespace Hack {

struct ContainerDeclaration {
  boost::variant<Alt<0, Fact<ClassDeclaration>>, Alt<1, Fact<EnumDeclaration>>, Alt<2, Fact<InterfaceDeclaration>>, Alt<3, Fact<TraitDeclaration>>> GLEAN_value;

  static ContainerDeclaration class_(const Fact<ClassDeclaration>& a) {
    return ContainerDeclaration{Alt<0, Fact<ClassDeclaration>>(a)};
  }
  static ContainerDeclaration enum_(const Fact<EnumDeclaration>& a) {
    return ContainerDeclaration{Alt<1, Fact<EnumDeclaration>>(a)};
  }
  static ContainerDeclaration interface_(const Fact<InterfaceDeclaration>& a) {
    return ContainerDeclaration{Alt<2, Fact<InterfaceDeclaration>>(a)};
  }
  static ContainerDeclaration trait(const Fact<TraitDeclaration>& a) {
    return ContainerDeclaration{Alt<3, Fact<TraitDeclaration>>(a)};
  }

  bool operator==(const ContainerDeclaration& other) const {
    return std::tie(GLEAN_value)
             == std::tie(other.GLEAN_value);
  }
  bool operator!=(const ContainerDeclaration& other) const {
    return std::tie(GLEAN_value)
             != std::tie(other.GLEAN_value);
  }
  bool operator<(const ContainerDeclaration& other) const {
    return std::tie(GLEAN_value)
             < std::tie(other.GLEAN_value);
  }
  bool operator<=(const ContainerDeclaration& other) const {
    return std::tie(GLEAN_value)
             <= std::tie(other.GLEAN_value);
  }
  bool operator>(const ContainerDeclaration& other) const {
    return std::tie(GLEAN_value)
             > std::tie(other.GLEAN_value);
  }
  bool operator>=(const ContainerDeclaration& other) const {
    return std::tie(GLEAN_value)
             >= std::tie(other.GLEAN_value);
  }

  void outputRepr(Output<Repr<ContainerDeclaration>> out) const {
    outputValue(out, GLEAN_value);
  }
}; // struct ContainerDeclaration

struct ContainerDeclarationQName : Predicate<ContainerDeclaration, Fact<QName>> {
  static const char* GLEAN_name() {
    return "hack.ContainerDeclarationQName";
  }

  static constexpr size_t GLEAN_version() {
     return 6;
  }
}; // struct ContainerDeclarationQName

struct ContainerParent : Predicate<std::tuple<ContainerDeclaration, ContainerDeclaration>> {
  static const char* GLEAN_name() {
    return "hack.ContainerParent";
  }

  static constexpr size_t GLEAN_version() {
     return 6;
  }
}; // struct ContainerParent

} // namespace Hack

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Hack::Declaration> {
  using Type = Sum<facebook::glean::cpp::schema::Hack::ClassConstDeclaration, Repr<facebook::glean::cpp::schema::Hack::ContainerDeclaration>, facebook::glean::cpp::schema::Hack::Enumerator, facebook::glean::cpp::schema::Hack::FunctionDeclaration, facebook::glean::cpp::schema::Hack::GlobalConstDeclaration, facebook::glean::cpp::schema::Hack::NamespaceDeclaration, facebook::glean::cpp::schema::Hack::MethodDeclaration, facebook::glean::cpp::schema::Hack::PropertyDeclaration, facebook::glean::cpp::schema::Hack::TypeConstDeclaration, facebook::glean::cpp::schema::Hack::TypedefDeclaration, facebook::glean::cpp::schema::Hack::ModuleDeclaration>;
};


namespace schema {

namespace Hack {

struct Declaration {
  boost::variant<Alt<0, Fact<ClassConstDeclaration>>, Alt<1, ContainerDeclaration>, Alt<2, Fact<Enumerator>>, Alt<3, Fact<FunctionDeclaration>>, Alt<4, Fact<GlobalConstDeclaration>>, Alt<5, Fact<NamespaceDeclaration>>, Alt<6, Fact<MethodDeclaration>>, Alt<7, Fact<PropertyDeclaration>>, Alt<8, Fact<TypeConstDeclaration>>, Alt<9, Fact<TypedefDeclaration>>, Alt<10, Fact<ModuleDeclaration>>> GLEAN_value;

  static Declaration classConst(const Fact<ClassConstDeclaration>& a) {
    return Declaration{Alt<0, Fact<ClassConstDeclaration>>(a)};
  }
  static Declaration container(const ContainerDeclaration& a) {
    return Declaration{Alt<1, ContainerDeclaration>(a)};
  }
  static Declaration enumerator(const Fact<Enumerator>& a) {
    return Declaration{Alt<2, Fact<Enumerator>>(a)};
  }
  static Declaration function_(const Fact<FunctionDeclaration>& a) {
    return Declaration{Alt<3, Fact<FunctionDeclaration>>(a)};
  }
  static Declaration globalConst(const Fact<GlobalConstDeclaration>& a) {
    return Declaration{Alt<4, Fact<GlobalConstDeclaration>>(a)};
  }
  static Declaration namespace_(const Fact<NamespaceDeclaration>& a) {
    return Declaration{Alt<5, Fact<NamespaceDeclaration>>(a)};
  }
  static Declaration method(const Fact<MethodDeclaration>& a) {
    return Declaration{Alt<6, Fact<MethodDeclaration>>(a)};
  }
  static Declaration property_(const Fact<PropertyDeclaration>& a) {
    return Declaration{Alt<7, Fact<PropertyDeclaration>>(a)};
  }
  static Declaration typeConst(const Fact<TypeConstDeclaration>& a) {
    return Declaration{Alt<8, Fact<TypeConstDeclaration>>(a)};
  }
  static Declaration typedef_(const Fact<TypedefDeclaration>& a) {
    return Declaration{Alt<9, Fact<TypedefDeclaration>>(a)};
  }
  static Declaration module(const Fact<ModuleDeclaration>& a) {
    return Declaration{Alt<10, Fact<ModuleDeclaration>>(a)};
  }

  bool operator==(const Declaration& other) const {
    return std::tie(GLEAN_value)
             == std::tie(other.GLEAN_value);
  }
  bool operator!=(const Declaration& other) const {
    return std::tie(GLEAN_value)
             != std::tie(other.GLEAN_value);
  }
  bool operator<(const Declaration& other) const {
    return std::tie(GLEAN_value)
             < std::tie(other.GLEAN_value);
  }
  bool operator<=(const Declaration& other) const {
    return std::tie(GLEAN_value)
             <= std::tie(other.GLEAN_value);
  }
  bool operator>(const Declaration& other) const {
    return std::tie(GLEAN_value)
             > std::tie(other.GLEAN_value);
  }
  bool operator>=(const Declaration& other) const {
    return std::tie(GLEAN_value)
             >= std::tie(other.GLEAN_value);
  }

  void outputRepr(Output<Repr<Declaration>> out) const {
    outputValue(out, GLEAN_value);
  }
}; // struct Declaration

struct DeclarationComment : Predicate<std::tuple<Declaration, Fact<facebook::glean::cpp::schema::Src::File>, facebook::glean::cpp::schema::Src::ByteSpan>> {
  static const char* GLEAN_name() {
    return "hack.DeclarationComment";
  }

  static constexpr size_t GLEAN_version() {
     return 6;
  }
}; // struct DeclarationComment

struct DeclarationLocation : Predicate<std::tuple<Declaration, Fact<facebook::glean::cpp::schema::Src::File>, facebook::glean::cpp::schema::Src::ByteSpan>> {
  static const char* GLEAN_name() {
    return "hack.DeclarationLocation";
  }

  static constexpr size_t GLEAN_version() {
     return 6;
  }
}; // struct DeclarationLocation

struct DeclarationName : Predicate<Declaration, Fact<Name>> {
  static const char* GLEAN_name() {
    return "hack.DeclarationName";
  }

  static constexpr size_t GLEAN_version() {
     return 6;
  }
}; // struct DeclarationName

struct DeclarationNamespace : Predicate<std::tuple<Declaration, Fact<NamespaceQName>>> {
  static const char* GLEAN_name() {
    return "hack.DeclarationNamespace";
  }

  static constexpr size_t GLEAN_version() {
     return 6;
  }
}; // struct DeclarationNamespace

struct DeclarationSource : Predicate<std::tuple<Declaration, Declaration>> {
  static const char* GLEAN_name() {
    return "hack.DeclarationSource";
  }

  static constexpr size_t GLEAN_version() {
     return 6;
  }
}; // struct DeclarationSource

struct DeclarationSpan : Predicate<std::tuple<Declaration, Fact<facebook::glean::cpp::schema::Src::File>, facebook::glean::cpp::schema::Src::ByteSpan>> {
  static const char* GLEAN_name() {
    return "hack.DeclarationSpan";
  }

  static constexpr size_t GLEAN_version() {
     return 6;
  }
}; // struct DeclarationSpan

struct DeclarationTarget : Predicate<std::tuple<Declaration, Declaration>> {
  static const char* GLEAN_name() {
    return "hack.DeclarationTarget";
  }

  static constexpr size_t GLEAN_version() {
     return 6;
  }
}; // struct DeclarationTarget

struct FileDeclarations : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Src::File>, std::vector<Declaration>>> {
  static const char* GLEAN_name() {
    return "hack.FileDeclarations";
  }

  static constexpr size_t GLEAN_version() {
     return 6;
  }
}; // struct FileDeclarations

struct MemberCluster : Predicate<std::tuple<std::vector<Declaration>>> {
  static const char* GLEAN_name() {
    return "hack.MemberCluster";
  }

  static constexpr size_t GLEAN_version() {
     return 6;
  }
}; // struct MemberCluster

struct ModuleChild : Predicate<std::tuple<Fact<ModuleDeclaration>, Declaration>> {
  static const char* GLEAN_name() {
    return "hack.ModuleChild";
  }

  static constexpr size_t GLEAN_version() {
     return 6;
  }
}; // struct ModuleChild

struct ModuleParent : Predicate<std::tuple<Declaration, Fact<ModuleDeclaration>>> {
  static const char* GLEAN_name() {
    return "hack.ModuleParent";
  }

  static constexpr size_t GLEAN_version() {
     return 6;
  }
}; // struct ModuleParent

struct NamespaceMember : Predicate<std::tuple<Fact<NamespaceQName>, Declaration>> {
  static const char* GLEAN_name() {
    return "hack.NamespaceMember";
  }

  static constexpr size_t GLEAN_version() {
     return 6;
  }
}; // struct NamespaceMember

} // namespace Hack

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Hack::XRefTarget> {
  using Type = Sum<Repr<facebook::glean::cpp::schema::Hack::Declaration>, Repr<facebook::glean::cpp::schema::Hack::Occurrence>>;
};


namespace schema {

namespace Hack {

struct XRefTarget {
  boost::variant<Alt<0, Declaration>, Alt<1, Occurrence>> GLEAN_value;

  static XRefTarget declaration(const Declaration& a) {
    return XRefTarget{Alt<0, Declaration>(a)};
  }
  static XRefTarget occurrence(const Occurrence& a) {
    return XRefTarget{Alt<1, Occurrence>(a)};
  }

  bool operator==(const XRefTarget& other) const {
    return std::tie(GLEAN_value)
             == std::tie(other.GLEAN_value);
  }
  bool operator!=(const XRefTarget& other) const {
    return std::tie(GLEAN_value)
             != std::tie(other.GLEAN_value);
  }
  bool operator<(const XRefTarget& other) const {
    return std::tie(GLEAN_value)
             < std::tie(other.GLEAN_value);
  }
  bool operator<=(const XRefTarget& other) const {
    return std::tie(GLEAN_value)
             <= std::tie(other.GLEAN_value);
  }
  bool operator>(const XRefTarget& other) const {
    return std::tie(GLEAN_value)
             > std::tie(other.GLEAN_value);
  }
  bool operator>=(const XRefTarget& other) const {
    return std::tie(GLEAN_value)
             >= std::tie(other.GLEAN_value);
  }

  void outputRepr(Output<Repr<XRefTarget>> out) const {
    outputValue(out, GLEAN_value);
  }
}; // struct XRefTarget

struct TargetUses : Predicate<std::tuple<XRefTarget, Fact<facebook::glean::cpp::schema::Src::File>, std::vector<facebook::glean::cpp::schema::Src::RelByteSpan>>> {
  static const char* GLEAN_name() {
    return "hack.TargetUses";
  }

  static constexpr size_t GLEAN_version() {
     return 6;
  }
}; // struct TargetUses

struct TargetUsesAbs : Predicate<std::tuple<XRefTarget, Fact<facebook::glean::cpp::schema::Src::File>, std::vector<facebook::glean::cpp::schema::Src::ByteSpan>>> {
  static const char* GLEAN_name() {
    return "hack.TargetUsesAbs";
  }

  static constexpr size_t GLEAN_version() {
     return 6;
  }
}; // struct TargetUsesAbs

} // namespace Hack

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Hack::XRef> {
  using Type = Tuple<Repr<facebook::glean::cpp::schema::Hack::XRefTarget>, Array<Repr<facebook::glean::cpp::schema::Src::RelByteSpan>>>;
};


namespace schema {

namespace Hack {

struct XRef {
  XRefTarget target;
  std::vector<facebook::glean::cpp::schema::Src::RelByteSpan> ranges;

  bool operator==(const XRef& other) const {
    return std::tie(target,ranges)
             == std::tie(other.target,other.ranges);
  }
  bool operator!=(const XRef& other) const {
    return std::tie(target,ranges)
             != std::tie(other.target,other.ranges);
  }
  bool operator<(const XRef& other) const {
    return std::tie(target,ranges)
             < std::tie(other.target,other.ranges);
  }
  bool operator<=(const XRef& other) const {
    return std::tie(target,ranges)
             <= std::tie(other.target,other.ranges);
  }
  bool operator>(const XRef& other) const {
    return std::tie(target,ranges)
             > std::tie(other.target,other.ranges);
  }
  bool operator>=(const XRef& other) const {
    return std::tie(target,ranges)
             >= std::tie(other.target,other.ranges);
  }
  void outputRepr(Output<Repr<XRef>> out) const {
    outputValue(out, std::make_tuple(target, ranges));
  }
}; // struct XRef

struct FileXRefs : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Src::File>, std::vector<XRef>>> {
  static const char* GLEAN_name() {
    return "hack.FileXRefs";
  }

  static constexpr size_t GLEAN_version() {
     return 6;
  }
}; // struct FileXRefs

struct TypeInfo : Predicate<std::tuple<Fact<Type>, std::vector<XRef>>> {
  static const char* GLEAN_name() {
    return "hack.TypeInfo";
  }

  static constexpr size_t GLEAN_version() {
     return 6;
  }
}; // struct TypeInfo

} // namespace Hack

namespace Monk {

struct HackCaller : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Src::File>, facebook::glean::cpp::schema::Src::ByteSpan, facebook::glean::cpp::schema::Hack::Declaration>> {
  static const char* GLEAN_name() {
    return "monk.HackCaller";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct HackCaller

struct HackIsCaller : Predicate<facebook::glean::cpp::schema::Hack::Declaration> {
  static const char* GLEAN_name() {
    return "monk.HackIsCaller";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct HackIsCaller

} // namespace Monk

namespace Omega {

struct TargetNodeLocations : Predicate<std::tuple<facebook::glean::cpp::schema::Hack::Declaration, facebook::glean::cpp::schema::Hack::Declaration, Fact<facebook::glean::cpp::schema::Src::File>, facebook::glean::cpp::schema::Src::ByteSpan>> {
  static const char* GLEAN_name() {
    return "omega.TargetNodeLocations";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct TargetNodeLocations

} // namespace Omega

namespace Omegaanalyser {

struct ClassStaticMethodReferences : Predicate<std::tuple<facebook::glean::cpp::schema::Hack::Declaration, Fact<facebook::glean::cpp::schema::Hack::ClassDeclaration>, std::vector<facebook::glean::cpp::schema::Src::ByteSpan>, std::vector<facebook::glean::cpp::schema::Src::ByteSpan>>> {
  static const char* GLEAN_name() {
    return "omegaanalyser.ClassStaticMethodReferences";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct ClassStaticMethodReferences

struct TargetNodeLocations : Predicate<std::tuple<facebook::glean::cpp::schema::Hack::Declaration, facebook::glean::cpp::schema::Hack::Declaration, Fact<facebook::glean::cpp::schema::Src::File>, facebook::glean::cpp::schema::Src::ByteSpan>> {
  static const char* GLEAN_name() {
    return "omegaanalyser.TargetNodeLocations";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct TargetNodeLocations

} // namespace Omegaanalyser

namespace Search {

namespace Hack {

struct SearchByName : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Hack::Name>, facebook::glean::cpp::schema::Hack::Declaration>> {
  static const char* GLEAN_name() {
    return "search.hack.SearchByName";
  }

  static constexpr size_t GLEAN_version() {
     return 7;
  }
}; // struct SearchByName

struct SearchFunctionInNamespace : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Hack::Name>, boost::variant<Alt<0, std::tuple<>>, Alt<1, Fact<facebook::glean::cpp::schema::Hack::NamespaceQName>>>, facebook::glean::cpp::schema::Hack::Declaration>> {
  static const char* GLEAN_name() {
    return "search.hack.SearchFunctionInNamespace";
  }

  static constexpr size_t GLEAN_version() {
     return 7;
  }
}; // struct SearchFunctionInNamespace

struct SearchGlobalConstInNamespace : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Hack::Name>, boost::variant<Alt<0, std::tuple<>>, Alt<1, Fact<facebook::glean::cpp::schema::Hack::NamespaceQName>>>, facebook::glean::cpp::schema::Hack::Declaration>> {
  static const char* GLEAN_name() {
    return "search.hack.SearchGlobalConstInNamespace";
  }

  static constexpr size_t GLEAN_version() {
     return 7;
  }
}; // struct SearchGlobalConstInNamespace

struct SearchInContainer : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Hack::Name>, Fact<facebook::glean::cpp::schema::Hack::Name>, boost::variant<Alt<0, std::tuple<>>, Alt<1, Fact<facebook::glean::cpp::schema::Hack::NamespaceQName>>>, facebook::glean::cpp::schema::Hack::Declaration>> {
  static const char* GLEAN_name() {
    return "search.hack.SearchInContainer";
  }

  static constexpr size_t GLEAN_version() {
     return 7;
  }
}; // struct SearchInContainer

struct SearchInContainerNoProperty : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Hack::Name>, Fact<facebook::glean::cpp::schema::Hack::Name>, boost::variant<Alt<0, std::tuple<>>, Alt<1, Fact<facebook::glean::cpp::schema::Hack::NamespaceQName>>>, facebook::glean::cpp::schema::Hack::Declaration>> {
  static const char* GLEAN_name() {
    return "search.hack.SearchInContainerNoProperty";
  }

  static constexpr size_t GLEAN_version() {
     return 7;
  }
}; // struct SearchInContainerNoProperty

struct SearchInContainerOrEnum : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Hack::Name>, Fact<facebook::glean::cpp::schema::Hack::Name>, boost::variant<Alt<0, std::tuple<>>, Alt<1, Fact<facebook::glean::cpp::schema::Hack::NamespaceQName>>>, facebook::glean::cpp::schema::Hack::Declaration>> {
  static const char* GLEAN_name() {
    return "search.hack.SearchInContainerOrEnum";
  }

  static constexpr size_t GLEAN_version() {
     return 7;
  }
}; // struct SearchInContainerOrEnum

struct SearchInContainerOrEnumNoProperty : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Hack::Name>, Fact<facebook::glean::cpp::schema::Hack::Name>, boost::variant<Alt<0, std::tuple<>>, Alt<1, Fact<facebook::glean::cpp::schema::Hack::NamespaceQName>>>, facebook::glean::cpp::schema::Hack::Declaration>> {
  static const char* GLEAN_name() {
    return "search.hack.SearchInContainerOrEnumNoProperty";
  }

  static constexpr size_t GLEAN_version() {
     return 7;
  }
}; // struct SearchInContainerOrEnumNoProperty

struct SearchInContext : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Hack::Name>, Fact<facebook::glean::cpp::schema::Hack::Name>, boost::variant<Alt<0, std::tuple<>>, Alt<1, Fact<facebook::glean::cpp::schema::Hack::NamespaceQName>>>, facebook::glean::cpp::schema::Hack::Declaration>> {
  static const char* GLEAN_name() {
    return "search.hack.SearchInContext";
  }

  static constexpr size_t GLEAN_version() {
     return 7;
  }
}; // struct SearchInContext

struct SearchInEnum : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Hack::Name>, Fact<facebook::glean::cpp::schema::Hack::Name>, boost::variant<Alt<0, std::tuple<>>, Alt<1, Fact<facebook::glean::cpp::schema::Hack::NamespaceQName>>>, facebook::glean::cpp::schema::Hack::Declaration>> {
  static const char* GLEAN_name() {
    return "search.hack.SearchInEnum";
  }

  static constexpr size_t GLEAN_version() {
     return 7;
  }
}; // struct SearchInEnum

struct SearchInNamespace : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Hack::Name>, boost::variant<Alt<0, std::tuple<>>, Alt<1, Fact<facebook::glean::cpp::schema::Hack::NamespaceQName>>>, facebook::glean::cpp::schema::Hack::Declaration>> {
  static const char* GLEAN_name() {
    return "search.hack.SearchInNamespace";
  }

  static constexpr size_t GLEAN_version() {
     return 7;
  }
}; // struct SearchInNamespace

struct SearchModule : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Hack::Name>, facebook::glean::cpp::schema::Hack::Declaration>> {
  static const char* GLEAN_name() {
    return "search.hack.SearchModule";
  }

  static constexpr size_t GLEAN_version() {
     return 7;
  }
}; // struct SearchModule

struct SearchNamespace : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Hack::Name>, boost::variant<Alt<0, std::tuple<>>, Alt<1, Fact<facebook::glean::cpp::schema::Hack::NamespaceQName>>>, facebook::glean::cpp::schema::Hack::Declaration>> {
  static const char* GLEAN_name() {
    return "search.hack.SearchNamespace";
  }

  static constexpr size_t GLEAN_version() {
     return 7;
  }
}; // struct SearchNamespace

struct SearchNamespacedDecl : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Hack::Name>, boost::variant<Alt<0, std::tuple<>>, Alt<1, Fact<facebook::glean::cpp::schema::Hack::NamespaceQName>>>, facebook::glean::cpp::schema::Hack::Declaration>> {
  static const char* GLEAN_name() {
    return "search.hack.SearchNamespacedDecl";
  }

  static constexpr size_t GLEAN_version() {
     return 7;
  }
}; // struct SearchNamespacedDecl

struct SearchPropertyInContainer : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Hack::Name>, Fact<facebook::glean::cpp::schema::Hack::Name>, boost::variant<Alt<0, std::tuple<>>, Alt<1, Fact<facebook::glean::cpp::schema::Hack::NamespaceQName>>>, facebook::glean::cpp::schema::Hack::Declaration>> {
  static const char* GLEAN_name() {
    return "search.hack.SearchPropertyInContainer";
  }

  static constexpr size_t GLEAN_version() {
     return 7;
  }
}; // struct SearchPropertyInContainer

struct SearchTypeInNamespace : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Hack::Name>, boost::variant<Alt<0, std::tuple<>>, Alt<1, Fact<facebook::glean::cpp::schema::Hack::NamespaceQName>>>, facebook::glean::cpp::schema::Hack::Declaration>> {
  static const char* GLEAN_name() {
    return "search.hack.SearchTypeInNamespace";
  }

  static constexpr size_t GLEAN_version() {
     return 7;
  }
}; // struct SearchTypeInNamespace

} // namespace Hack

} // namespace Search

namespace Hack {

struct InheritedMembers : Predicate<std::tuple<ContainerDeclaration, std::vector<Fact<MemberCluster>>>> {
  static const char* GLEAN_name() {
    return "hack.InheritedMembers";
  }

  static constexpr size_t GLEAN_version() {
     return 6;
  }
}; // struct InheritedMembers

struct MethodDeclaration : Predicate<std::tuple<Fact<Name>, ContainerDeclaration>> {
  static const char* GLEAN_name() {
    return "hack.MethodDeclaration";
  }

  static constexpr size_t GLEAN_version() {
     return 6;
  }
}; // struct MethodDeclaration

struct PropertyDeclaration : Predicate<std::tuple<Fact<Name>, ContainerDeclaration>> {
  static const char* GLEAN_name() {
    return "hack.PropertyDeclaration";
  }

  static constexpr size_t GLEAN_version() {
     return 6;
  }
}; // struct PropertyDeclaration

struct TypeConstDeclaration : Predicate<std::tuple<Fact<Name>, ContainerDeclaration>> {
  static const char* GLEAN_name() {
    return "hack.TypeConstDeclaration";
  }

  static constexpr size_t GLEAN_version() {
     return 6;
  }
}; // struct TypeConstDeclaration

struct ContainerChild : Predicate<std::tuple<ContainerDeclaration, ContainerDeclaration>> {
  static const char* GLEAN_name() {
    return "hack.ContainerChild";
  }

  static constexpr size_t GLEAN_version() {
     return 6;
  }
}; // struct ContainerChild

} // namespace Hack

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Hack::ConstraintKind> {
  using Type = Enum<3>;
};


namespace schema {

namespace Hack {

enum class ConstraintKind { As, Equal, Super };

} // namespace Hack

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Hack::Constraint> {
  using Type = Tuple<Repr<facebook::glean::cpp::schema::Hack::ConstraintKind>, facebook::glean::cpp::schema::Hack::Type>;
};


namespace schema {

namespace Hack {

struct Constraint {
  ConstraintKind constraintKind;
  Fact<Type> type;

  bool operator==(const Constraint& other) const {
    return std::tie(constraintKind,type)
             == std::tie(other.constraintKind,other.type);
  }
  bool operator!=(const Constraint& other) const {
    return std::tie(constraintKind,type)
             != std::tie(other.constraintKind,other.type);
  }
  bool operator<(const Constraint& other) const {
    return std::tie(constraintKind,type)
             < std::tie(other.constraintKind,other.type);
  }
  bool operator<=(const Constraint& other) const {
    return std::tie(constraintKind,type)
             <= std::tie(other.constraintKind,other.type);
  }
  bool operator>(const Constraint& other) const {
    return std::tie(constraintKind,type)
             > std::tie(other.constraintKind,other.type);
  }
  bool operator>=(const Constraint& other) const {
    return std::tie(constraintKind,type)
             >= std::tie(other.constraintKind,other.type);
  }
  void outputRepr(Output<Repr<Constraint>> out) const {
    outputValue(out, std::make_tuple(constraintKind, type));
  }
}; // struct Constraint

} // namespace Hack

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Hack::TypeParameter> {
  using Type = Tuple<facebook::glean::cpp::schema::Hack::Name, Repr<facebook::glean::cpp::schema::Hack::Variance>, Repr<facebook::glean::cpp::schema::Hack::ReifyKind>, Array<Repr<facebook::glean::cpp::schema::Hack::Constraint>>, Array<facebook::glean::cpp::schema::Hack::UserAttribute>>;
};


namespace schema {

namespace Hack {

struct TypeParameter {
  Fact<Name> name;
  Variance variance;
  ReifyKind reifyKind;
  std::vector<Constraint> constraints;
  std::vector<Fact<UserAttribute>> attributes;

  bool operator==(const TypeParameter& other) const {
    return std::tie(name,variance,reifyKind,constraints,attributes)
             == std::tie(other.name,other.variance,other.reifyKind,other.constraints,other.attributes);
  }
  bool operator!=(const TypeParameter& other) const {
    return std::tie(name,variance,reifyKind,constraints,attributes)
             != std::tie(other.name,other.variance,other.reifyKind,other.constraints,other.attributes);
  }
  bool operator<(const TypeParameter& other) const {
    return std::tie(name,variance,reifyKind,constraints,attributes)
             < std::tie(other.name,other.variance,other.reifyKind,other.constraints,other.attributes);
  }
  bool operator<=(const TypeParameter& other) const {
    return std::tie(name,variance,reifyKind,constraints,attributes)
             <= std::tie(other.name,other.variance,other.reifyKind,other.constraints,other.attributes);
  }
  bool operator>(const TypeParameter& other) const {
    return std::tie(name,variance,reifyKind,constraints,attributes)
             > std::tie(other.name,other.variance,other.reifyKind,other.constraints,other.attributes);
  }
  bool operator>=(const TypeParameter& other) const {
    return std::tie(name,variance,reifyKind,constraints,attributes)
             >= std::tie(other.name,other.variance,other.reifyKind,other.constraints,other.attributes);
  }
  void outputRepr(Output<Repr<TypeParameter>> out) const {
    outputValue(out, std::make_tuple(name, variance, reifyKind, constraints, attributes));
  }
}; // struct TypeParameter

struct FunctionDefinition : Predicate<std::tuple<Fact<FunctionDeclaration>, Fact<Signature>, bool, std::vector<Fact<UserAttribute>>, std::vector<TypeParameter>, boost::variant<Alt<0, std::tuple<>>, Alt<1, ModuleMembership>>, boost::variant<Alt<0, std::tuple<>>, Alt<1, ReadonlyKind>>>> {
  static const char* GLEAN_name() {
    return "hack.FunctionDefinition";
  }

  static constexpr size_t GLEAN_version() {
     return 6;
  }
}; // struct FunctionDefinition

struct InterfaceDefinition : Predicate<std::tuple<Fact<InterfaceDeclaration>, std::vector<Declaration>, std::vector<Fact<InterfaceDeclaration>>, std::vector<Fact<UserAttribute>>, std::vector<TypeParameter>, std::vector<Fact<ClassDeclaration>>, boost::variant<Alt<0, std::tuple<>>, Alt<1, ModuleMembership>>>> {
  static const char* GLEAN_name() {
    return "hack.InterfaceDefinition";
  }

  static constexpr size_t GLEAN_version() {
     return 6;
  }
}; // struct InterfaceDefinition

struct MethodDefinition : Predicate<std::tuple<Fact<MethodDeclaration>, Fact<Signature>, Visibility, bool, bool, bool, bool, std::vector<Fact<UserAttribute>>, std::vector<TypeParameter>, boost::variant<Alt<0, std::tuple<>>, Alt<1, bool>>, boost::variant<Alt<0, std::tuple<>>, Alt<1, ReadonlyKind>>>> {
  static const char* GLEAN_name() {
    return "hack.MethodDefinition";
  }

  static constexpr size_t GLEAN_version() {
     return 6;
  }
}; // struct MethodDefinition

struct TraitDefinition : Predicate<std::tuple<Fact<TraitDeclaration>, std::vector<Declaration>, std::vector<Fact<InterfaceDeclaration>>, std::vector<Fact<TraitDeclaration>>, std::vector<Fact<UserAttribute>>, std::vector<TypeParameter>, std::vector<Fact<ClassDeclaration>>, std::vector<Fact<InterfaceDeclaration>>, boost::variant<Alt<0, std::tuple<>>, Alt<1, ModuleMembership>>, boost::variant<Alt<0, std::tuple<>>, Alt<1, std::vector<Fact<ClassDeclaration>>>>>> {
  static const char* GLEAN_name() {
    return "hack.TraitDefinition";
  }

  static constexpr size_t GLEAN_version() {
     return 6;
  }
}; // struct TraitDefinition

struct TypedefDefinition : Predicate<std::tuple<Fact<TypedefDeclaration>, bool, std::vector<Fact<UserAttribute>>, std::vector<TypeParameter>, boost::variant<Alt<0, std::tuple<>>, Alt<1, ModuleMembership>>>> {
  static const char* GLEAN_name() {
    return "hack.TypedefDefinition";
  }

  static constexpr size_t GLEAN_version() {
     return 6;
  }
}; // struct TypedefDefinition

struct ClassDefinition : Predicate<std::tuple<Fact<ClassDeclaration>, bool, bool, std::vector<Declaration>, boost::variant<Alt<0, std::tuple<>>, Alt<1, Fact<ClassDeclaration>>>, std::vector<Fact<InterfaceDeclaration>>, std::vector<Fact<TraitDeclaration>>, std::vector<Fact<UserAttribute>>, std::vector<TypeParameter>, boost::variant<Alt<0, std::tuple<>>, Alt<1, ModuleMembership>>>> {
  static const char* GLEAN_name() {
    return "hack.ClassDefinition";
  }

  static constexpr size_t GLEAN_version() {
     return 6;
  }
}; // struct ClassDefinition

struct ClassDeclaration : Predicate<std::tuple<Fact<QName>>> {
  static const char* GLEAN_name() {
    return "hack.ClassDeclaration";
  }

  static constexpr size_t GLEAN_version() {
     return 6;
  }
}; // struct ClassDeclaration

struct ClassConstDefinition : Predicate<std::tuple<Fact<ClassConstDeclaration>, boost::variant<Alt<0, std::tuple<>>, Alt<1, Fact<Type>>>, boost::variant<Alt<0, std::tuple<>>, Alt<1, std::string>>>> {
  static const char* GLEAN_name() {
    return "hack.ClassConstDefinition";
  }

  static constexpr size_t GLEAN_version() {
     return 6;
  }
}; // struct ClassConstDefinition

struct ClassConstDeclaration : Predicate<std::tuple<Fact<Name>, ContainerDeclaration>> {
  static const char* GLEAN_name() {
    return "hack.ClassConstDeclaration";
  }

  static constexpr size_t GLEAN_version() {
     return 6;
  }
}; // struct ClassConstDeclaration

struct AttributeToDefinition : Predicate<std::tuple<Fact<UserAttribute>, Definition>> {
  static const char* GLEAN_name() {
    return "hack.AttributeToDefinition";
  }

  static constexpr size_t GLEAN_version() {
     return 6;
  }
}; // struct AttributeToDefinition

struct AttributeToDeclaration : Predicate<std::tuple<Fact<UserAttribute>, Declaration, Fact<facebook::glean::cpp::schema::Src::File>>> {
  static const char* GLEAN_name() {
    return "hack.AttributeToDeclaration";
  }

  static constexpr size_t GLEAN_version() {
     return 6;
  }
}; // struct AttributeToDeclaration

struct AttributeHasParameter : Predicate<std::tuple<Fact<Name>, std::string, Fact<UserAttribute>>> {
  static const char* GLEAN_name() {
    return "hack.AttributeHasParameter";
  }

  static constexpr size_t GLEAN_version() {
     return 6;
  }
}; // struct AttributeHasParameter

} // namespace Hack

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Hack::Argument> {
  using Type = Sum<facebook::glean::cpp::schema::Hack::StringLiteral, Repr<facebook::glean::cpp::schema::Hack::XRefTarget>>;
};


namespace schema {

namespace Hack {

struct Argument {
  boost::variant<Alt<0, Fact<StringLiteral>>, Alt<1, XRefTarget>> GLEAN_value;

  static Argument lit(const Fact<StringLiteral>& a) {
    return Argument{Alt<0, Fact<StringLiteral>>(a)};
  }
  static Argument xref(const XRefTarget& a) {
    return Argument{Alt<1, XRefTarget>(a)};
  }

  bool operator==(const Argument& other) const {
    return std::tie(GLEAN_value)
             == std::tie(other.GLEAN_value);
  }
  bool operator!=(const Argument& other) const {
    return std::tie(GLEAN_value)
             != std::tie(other.GLEAN_value);
  }
  bool operator<(const Argument& other) const {
    return std::tie(GLEAN_value)
             < std::tie(other.GLEAN_value);
  }
  bool operator<=(const Argument& other) const {
    return std::tie(GLEAN_value)
             <= std::tie(other.GLEAN_value);
  }
  bool operator>(const Argument& other) const {
    return std::tie(GLEAN_value)
             > std::tie(other.GLEAN_value);
  }
  bool operator>=(const Argument& other) const {
    return std::tie(GLEAN_value)
             >= std::tie(other.GLEAN_value);
  }

  void outputRepr(Output<Repr<Argument>> out) const {
    outputValue(out, GLEAN_value);
  }
}; // struct Argument

} // namespace Hack

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Hack::CallArgument> {
  using Type = Tuple<Repr<facebook::glean::cpp::schema::Src::RelByteSpan>, Maybe<Repr<facebook::glean::cpp::schema::Hack::Argument>>>;
};


namespace schema {

namespace Hack {

struct CallArgument {
  facebook::glean::cpp::schema::Src::RelByteSpan span;
  boost::variant<Alt<0, std::tuple<>>, Alt<1, Argument>> argument;

  bool operator==(const CallArgument& other) const {
    return std::tie(span,argument)
             == std::tie(other.span,other.argument);
  }
  bool operator!=(const CallArgument& other) const {
    return std::tie(span,argument)
             != std::tie(other.span,other.argument);
  }
  bool operator<(const CallArgument& other) const {
    return std::tie(span,argument)
             < std::tie(other.span,other.argument);
  }
  bool operator<=(const CallArgument& other) const {
    return std::tie(span,argument)
             <= std::tie(other.span,other.argument);
  }
  bool operator>(const CallArgument& other) const {
    return std::tie(span,argument)
             > std::tie(other.span,other.argument);
  }
  bool operator>=(const CallArgument& other) const {
    return std::tie(span,argument)
             >= std::tie(other.span,other.argument);
  }
  void outputRepr(Output<Repr<CallArgument>> out) const {
    outputValue(out, std::make_tuple(span, argument));
  }
}; // struct CallArgument

struct FileCall : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Src::File>, facebook::glean::cpp::schema::Src::ByteSpan, std::vector<CallArgument>, boost::variant<Alt<0, std::tuple<>>, Alt<1, XRefTarget>>, boost::variant<Alt<0, std::tuple<>>, Alt<1, CallArgument>>, boost::variant<Alt<0, std::tuple<>>, Alt<1, Declaration>>, std::vector<XRefTarget>>> {
  static const char* GLEAN_name() {
    return "hack.FileCall";
  }

  static constexpr size_t GLEAN_version() {
     return 6;
  }
}; // struct FileCall

} // namespace Hack

namespace Graphql {

struct VariableDef : Predicate<std::tuple<Fact<Value>, Fact<Value>, std::vector<Fact<Directive>>, boost::variant<Alt<0, std::tuple<>>, Alt<1, Fact<Value>>>>> {
  static const char* GLEAN_name() {
    return "graphql.VariableDef";
  }

  static constexpr size_t GLEAN_version() {
     return 3;
  }
}; // struct VariableDef

struct Value : Predicate<std::string> {
  static const char* GLEAN_name() {
    return "graphql.Value";
  }

  static constexpr size_t GLEAN_version() {
     return 3;
  }
}; // struct Value

struct UnionTypeDef : Predicate<std::tuple<Fact<Value>, std::vector<Fact<Value>>, std::vector<Fact<Directive>>>> {
  static const char* GLEAN_name() {
    return "graphql.UnionTypeDef";
  }

  static constexpr size_t GLEAN_version() {
     return 3;
  }
}; // struct UnionTypeDef

} // namespace Graphql

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Graphql::SelectionSet> {
  using Type = Tuple<Array<facebook::glean::cpp::schema::Graphql::Field>, Array<facebook::glean::cpp::schema::Graphql::InlineFragment>, Array<facebook::glean::cpp::schema::Graphql::FragmentSpread>>;
};


namespace schema {

namespace Graphql {

struct SelectionSet {
  std::vector<Fact<Field>> fields;
  std::vector<Fact<InlineFragment>> inlineFragments;
  std::vector<Fact<FragmentSpread>> fragmentSpreads;

  bool operator==(const SelectionSet& other) const {
    return std::tie(fields,inlineFragments,fragmentSpreads)
             == std::tie(other.fields,other.inlineFragments,other.fragmentSpreads);
  }
  bool operator!=(const SelectionSet& other) const {
    return std::tie(fields,inlineFragments,fragmentSpreads)
             != std::tie(other.fields,other.inlineFragments,other.fragmentSpreads);
  }
  bool operator<(const SelectionSet& other) const {
    return std::tie(fields,inlineFragments,fragmentSpreads)
             < std::tie(other.fields,other.inlineFragments,other.fragmentSpreads);
  }
  bool operator<=(const SelectionSet& other) const {
    return std::tie(fields,inlineFragments,fragmentSpreads)
             <= std::tie(other.fields,other.inlineFragments,other.fragmentSpreads);
  }
  bool operator>(const SelectionSet& other) const {
    return std::tie(fields,inlineFragments,fragmentSpreads)
             > std::tie(other.fields,other.inlineFragments,other.fragmentSpreads);
  }
  bool operator>=(const SelectionSet& other) const {
    return std::tie(fields,inlineFragments,fragmentSpreads)
             >= std::tie(other.fields,other.inlineFragments,other.fragmentSpreads);
  }
  void outputRepr(Output<Repr<SelectionSet>> out) const {
    outputValue(out, std::make_tuple(fields, inlineFragments, fragmentSpreads));
  }
}; // struct SelectionSet

struct ScalarTypeDef : Predicate<std::tuple<Fact<Value>, std::vector<Fact<Directive>>>> {
  static const char* GLEAN_name() {
    return "graphql.ScalarTypeDef";
  }

  static constexpr size_t GLEAN_version() {
     return 3;
  }
}; // struct ScalarTypeDef

} // namespace Graphql

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Graphql::OperationKind> {
  using Type = Enum<3>;
};


namespace schema {

namespace Graphql {

enum class OperationKind { QUERY, MUTATION, SUBSCRIPTION };

struct Operation : Predicate<std::tuple<Fact<Value>, OperationKind, std::vector<Fact<Directive>>, std::vector<Fact<VariableDef>>, SelectionSet, facebook::glean::cpp::schema::Src::FileLocation>> {
  static const char* GLEAN_name() {
    return "graphql.Operation";
  }

  static constexpr size_t GLEAN_version() {
     return 3;
  }
}; // struct Operation

struct ObjectTypeDef : Predicate<std::tuple<Fact<Value>, std::vector<Fact<Value>>, std::vector<Fact<FieldDef>>, std::vector<Fact<Directive>>>> {
  static const char* GLEAN_name() {
    return "graphql.ObjectTypeDef";
  }

  static constexpr size_t GLEAN_version() {
     return 3;
  }
}; // struct ObjectTypeDef

using Name = Fact<Value>;

struct NameLowerCase : Predicate<std::tuple<std::string, Name>> {
  static const char* GLEAN_name() {
    return "graphql.NameLowerCase";
  }

  static constexpr size_t GLEAN_version() {
     return 3;
  }
}; // struct NameLowerCase

struct InterfaceTypeDef : Predicate<std::tuple<Fact<Value>, std::vector<Fact<FieldDef>>, std::vector<Fact<Directive>>>> {
  static const char* GLEAN_name() {
    return "graphql.InterfaceTypeDef";
  }

  static constexpr size_t GLEAN_version() {
     return 3;
  }
}; // struct InterfaceTypeDef

struct InputValueDef : Predicate<std::tuple<Fact<Value>, Fact<Value>, std::vector<Fact<Directive>>, boost::variant<Alt<0, std::tuple<>>, Alt<1, Fact<Value>>>>> {
  static const char* GLEAN_name() {
    return "graphql.InputValueDef";
  }

  static constexpr size_t GLEAN_version() {
     return 3;
  }
}; // struct InputValueDef

struct InputObjectTypeDef : Predicate<std::tuple<Fact<Value>, std::vector<Fact<InputValueDef>>, std::vector<Fact<Directive>>>> {
  static const char* GLEAN_name() {
    return "graphql.InputObjectTypeDef";
  }

  static constexpr size_t GLEAN_version() {
     return 3;
  }
}; // struct InputObjectTypeDef

struct InlineFragment : Predicate<std::tuple<Fact<Value>, std::vector<Fact<Directive>>, SelectionSet, boost::variant<Alt<0, std::tuple<>>, Alt<1, Fact<Value>>>>> {
  static const char* GLEAN_name() {
    return "graphql.InlineFragment";
  }

  static constexpr size_t GLEAN_version() {
     return 3;
  }
}; // struct InlineFragment

struct FragmentSpread : Predicate<std::tuple<Fact<Value>, facebook::glean::cpp::schema::Src::FileLocation, std::vector<Fact<Argument>>, std::vector<Fact<Directive>>>> {
  static const char* GLEAN_name() {
    return "graphql.FragmentSpread";
  }

  static constexpr size_t GLEAN_version() {
     return 3;
  }
}; // struct FragmentSpread

struct Fragment : Predicate<std::tuple<Fact<Value>, Fact<Value>, std::vector<Fact<VariableDef>>, std::vector<Fact<Directive>>, SelectionSet, facebook::glean::cpp::schema::Src::FileLocation>> {
  static const char* GLEAN_name() {
    return "graphql.Fragment";
  }

  static constexpr size_t GLEAN_version() {
     return 3;
  }
}; // struct Fragment

struct FieldDef : Predicate<std::tuple<Fact<Value>, Fact<Value>, std::vector<Fact<InputValueDef>>, std::vector<Fact<Directive>>>> {
  static const char* GLEAN_name() {
    return "graphql.FieldDef";
  }

  static constexpr size_t GLEAN_version() {
     return 3;
  }
}; // struct FieldDef

struct Field : Predicate<std::tuple<Fact<Value>, Fact<Value>, std::vector<Fact<Directive>>, SelectionSet, std::vector<Fact<Argument>>, boost::variant<Alt<0, std::tuple<>>, Alt<1, Fact<Value>>>, facebook::glean::cpp::schema::Src::FileLocation>> {
  static const char* GLEAN_name() {
    return "graphql.Field";
  }

  static constexpr size_t GLEAN_version() {
     return 3;
  }
}; // struct Field

struct EnumTypeDef : Predicate<std::tuple<Fact<Value>, std::vector<Fact<Value>>, std::vector<Fact<Directive>>>> {
  static const char* GLEAN_name() {
    return "graphql.EnumTypeDef";
  }

  static constexpr size_t GLEAN_version() {
     return 3;
  }
}; // struct EnumTypeDef

} // namespace Graphql

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Graphql::DirectiveDefLocation> {
  using Type = Enum<18>;
};


namespace schema {

namespace Graphql {

enum class DirectiveDefLocation { QUERY, MUTATION, SUBSCRIPTION, FIELD, FRAGMENT_DEFINITION, FRAGMENT_SPREAD, INLINE_FRAGMENT, SCHEMA, SCALAR, OBJECT, FIELD_DEFINITION, ARGUMENT_DEFINITION, INTERFACE, UNION, ENUM, ENUM_VALUE, INPUT_OBJECT, INPUT_FIELD_DEFINITION };

struct DirectiveDef : Predicate<std::tuple<Fact<Value>, std::vector<Fact<InputValueDef>>, std::vector<DirectiveDefLocation>>> {
  static const char* GLEAN_name() {
    return "graphql.DirectiveDef";
  }

  static constexpr size_t GLEAN_version() {
     return 3;
  }
}; // struct DirectiveDef

struct Directive : Predicate<std::tuple<Fact<Value>, std::vector<Fact<Argument>>>> {
  static const char* GLEAN_name() {
    return "graphql.Directive";
  }

  static constexpr size_t GLEAN_version() {
     return 3;
  }
}; // struct Directive

} // namespace Graphql

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Graphql::Declaration> {
  using Type = Sum<facebook::glean::cpp::schema::Graphql::Operation, facebook::glean::cpp::schema::Graphql::Fragment, facebook::glean::cpp::schema::Graphql::FieldDef, facebook::glean::cpp::schema::Graphql::EnumTypeDef, facebook::glean::cpp::schema::Graphql::DirectiveDef>;
};


namespace schema {

namespace Graphql {

struct Declaration {
  boost::variant<Alt<0, Fact<Operation>>, Alt<1, Fact<Fragment>>, Alt<2, Fact<FieldDef>>, Alt<3, Fact<EnumTypeDef>>, Alt<4, Fact<DirectiveDef>>> GLEAN_value;

  static Declaration operation_(const Fact<Operation>& a) {
    return Declaration{Alt<0, Fact<Operation>>(a)};
  }
  static Declaration fragment_(const Fact<Fragment>& a) {
    return Declaration{Alt<1, Fact<Fragment>>(a)};
  }
  static Declaration field_(const Fact<FieldDef>& a) {
    return Declaration{Alt<2, Fact<FieldDef>>(a)};
  }
  static Declaration enum_(const Fact<EnumTypeDef>& a) {
    return Declaration{Alt<3, Fact<EnumTypeDef>>(a)};
  }
  static Declaration directive_(const Fact<DirectiveDef>& a) {
    return Declaration{Alt<4, Fact<DirectiveDef>>(a)};
  }

  bool operator==(const Declaration& other) const {
    return std::tie(GLEAN_value)
             == std::tie(other.GLEAN_value);
  }
  bool operator!=(const Declaration& other) const {
    return std::tie(GLEAN_value)
             != std::tie(other.GLEAN_value);
  }
  bool operator<(const Declaration& other) const {
    return std::tie(GLEAN_value)
             < std::tie(other.GLEAN_value);
  }
  bool operator<=(const Declaration& other) const {
    return std::tie(GLEAN_value)
             <= std::tie(other.GLEAN_value);
  }
  bool operator>(const Declaration& other) const {
    return std::tie(GLEAN_value)
             > std::tie(other.GLEAN_value);
  }
  bool operator>=(const Declaration& other) const {
    return std::tie(GLEAN_value)
             >= std::tie(other.GLEAN_value);
  }

  void outputRepr(Output<Repr<Declaration>> out) const {
    outputValue(out, GLEAN_value);
  }
}; // struct Declaration

struct DeclarationLocation : Predicate<std::tuple<Declaration, Fact<facebook::glean::cpp::schema::Src::File>, facebook::glean::cpp::schema::Src::ByteSpan>> {
  static const char* GLEAN_name() {
    return "graphql.DeclarationLocation";
  }

  static constexpr size_t GLEAN_version() {
     return 3;
  }
}; // struct DeclarationLocation

struct DeclarationName : Predicate<Declaration, Fact<Value>> {
  static const char* GLEAN_name() {
    return "graphql.DeclarationName";
  }

  static constexpr size_t GLEAN_version() {
     return 3;
  }
}; // struct DeclarationName

struct DeclarationUses : Predicate<std::tuple<Declaration, Fact<facebook::glean::cpp::schema::Src::File>, facebook::glean::cpp::schema::Src::ByteSpan>> {
  static const char* GLEAN_name() {
    return "graphql.DeclarationUses";
  }

  static constexpr size_t GLEAN_version() {
     return 3;
  }
}; // struct DeclarationUses

struct FileDeclarations : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Src::File>, facebook::glean::cpp::schema::Src::ByteSpan, Declaration>> {
  static const char* GLEAN_name() {
    return "graphql.FileDeclarations";
  }

  static constexpr size_t GLEAN_version() {
     return 3;
  }
}; // struct FileDeclarations

struct SearchByName : Predicate<std::tuple<Name, Declaration>> {
  static const char* GLEAN_name() {
    return "graphql.SearchByName";
  }

  static constexpr size_t GLEAN_version() {
     return 3;
  }
}; // struct SearchByName

} // namespace Graphql

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Graphql::XRef> {
  using Type = Tuple<Repr<facebook::glean::cpp::schema::Graphql::Declaration>, Repr<facebook::glean::cpp::schema::Src::ByteSpan>>;
};


namespace schema {

namespace Graphql {

struct XRef {
  Declaration decl;
  facebook::glean::cpp::schema::Src::ByteSpan span;

  bool operator==(const XRef& other) const {
    return std::tie(decl,span)
             == std::tie(other.decl,other.span);
  }
  bool operator!=(const XRef& other) const {
    return std::tie(decl,span)
             != std::tie(other.decl,other.span);
  }
  bool operator<(const XRef& other) const {
    return std::tie(decl,span)
             < std::tie(other.decl,other.span);
  }
  bool operator<=(const XRef& other) const {
    return std::tie(decl,span)
             <= std::tie(other.decl,other.span);
  }
  bool operator>(const XRef& other) const {
    return std::tie(decl,span)
             > std::tie(other.decl,other.span);
  }
  bool operator>=(const XRef& other) const {
    return std::tie(decl,span)
             >= std::tie(other.decl,other.span);
  }
  void outputRepr(Output<Repr<XRef>> out) const {
    outputValue(out, std::make_tuple(decl, span));
  }
}; // struct XRef

struct FileXRefs : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Src::File>, XRef>> {
  static const char* GLEAN_name() {
    return "graphql.FileXRefs";
  }

  static constexpr size_t GLEAN_version() {
     return 3;
  }
}; // struct FileXRefs

struct DeclHasName : Predicate<std::tuple<Declaration, Fact<Value>>> {
  static const char* GLEAN_name() {
    return "graphql.DeclHasName";
  }

  static constexpr size_t GLEAN_version() {
     return 3;
  }
}; // struct DeclHasName

struct BelongToConfig : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Src::File>, Fact<Value>>> {
  static const char* GLEAN_name() {
    return "graphql.BelongToConfig";
  }

  static constexpr size_t GLEAN_version() {
     return 3;
  }
}; // struct BelongToConfig

struct Argument : Predicate<std::tuple<Fact<Value>, Fact<Value>>> {
  static const char* GLEAN_name() {
    return "graphql.Argument";
  }

  static constexpr size_t GLEAN_version() {
     return 3;
  }
}; // struct Argument

} // namespace Graphql

namespace Glean {

namespace Test {

struct nothingTest : Predicate<std::tuple<boost::variant<Alt<0, std::tuple<>>, Alt<1, std::string>>, uint64_t>> {
  static const char* GLEAN_name() {
    return "glean.test.nothingTest";
  }

  static constexpr size_t GLEAN_version() {
     return 5;
  }
}; // struct nothingTest

} // namespace Test

} // namespace Glean

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Glean::Test::WrappedStringPair> {
  using Type = Tuple<facebook::glean::cpp::schema::Glean::Test::StringPair>;
};


namespace schema {

namespace Glean {

namespace Test {

struct WrappedStringPair {
  Fact<StringPair> wrapped;

  bool operator==(const WrappedStringPair& other) const {
    return std::tie(wrapped)
             == std::tie(other.wrapped);
  }
  bool operator!=(const WrappedStringPair& other) const {
    return std::tie(wrapped)
             != std::tie(other.wrapped);
  }
  bool operator<(const WrappedStringPair& other) const {
    return std::tie(wrapped)
             < std::tie(other.wrapped);
  }
  bool operator<=(const WrappedStringPair& other) const {
    return std::tie(wrapped)
             <= std::tie(other.wrapped);
  }
  bool operator>(const WrappedStringPair& other) const {
    return std::tie(wrapped)
             > std::tie(other.wrapped);
  }
  bool operator>=(const WrappedStringPair& other) const {
    return std::tie(wrapped)
             >= std::tie(other.wrapped);
  }
  void outputRepr(Output<Repr<WrappedStringPair>> out) const {
    outputValue(out, std::make_tuple(wrapped));
  }
}; // struct WrappedStringPair

struct ViaStringPair : Predicate<std::tuple<std::string, std::string>> {
  static const char* GLEAN_name() {
    return "glean.test.ViaStringPair";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct ViaStringPair

struct Unbound2 : Predicate<std::tuple<std::string, std::string>> {
  static const char* GLEAN_name() {
    return "glean.test.Unbound2";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct Unbound2

struct Unbound : Predicate<std::tuple<std::string, std::string>> {
  static const char* GLEAN_name() {
    return "glean.test.Unbound";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct Unbound

struct TreeToTree : Predicate<Fact<Tree>, Fact<Tree>> {
  static const char* GLEAN_name() {
    return "glean.test.TreeToTree";
  }

  static constexpr size_t GLEAN_version() {
     return 5;
  }
}; // struct TreeToTree

struct Tree : Predicate<std::tuple<Fact<Node>, boost::variant<Alt<0, std::tuple<>>, Alt<1, Fact<Tree>>>, boost::variant<Alt<0, std::tuple<>>, Alt<1, Fact<Tree>>>>> {
  static const char* GLEAN_name() {
    return "glean.test.Tree";
  }

  static constexpr size_t GLEAN_version() {
     return 5;
  }
}; // struct Tree

} // namespace Test

} // namespace Glean

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Glean::Test::Sum_> {
  using Type = Sum<Byte, Nat, Bool>;
};


namespace schema {

namespace Glean {

namespace Test {

struct Sum_ {
  boost::variant<Alt<0, uint8_t>, Alt<1, uint64_t>, Alt<2, bool>> GLEAN_value;

  static Sum_ mon(const uint8_t& a) {
    return Sum_{Alt<0, uint8_t>(a)};
  }
  static Sum_ tue(const uint64_t& a) {
    return Sum_{Alt<1, uint64_t>(a)};
  }
  static Sum_ wed(const bool& a) {
    return Sum_{Alt<2, bool>(a)};
  }

  bool operator==(const Sum_& other) const {
    return std::tie(GLEAN_value)
             == std::tie(other.GLEAN_value);
  }
  bool operator!=(const Sum_& other) const {
    return std::tie(GLEAN_value)
             != std::tie(other.GLEAN_value);
  }
  bool operator<(const Sum_& other) const {
    return std::tie(GLEAN_value)
             < std::tie(other.GLEAN_value);
  }
  bool operator<=(const Sum_& other) const {
    return std::tie(GLEAN_value)
             <= std::tie(other.GLEAN_value);
  }
  bool operator>(const Sum_& other) const {
    return std::tie(GLEAN_value)
             > std::tie(other.GLEAN_value);
  }
  bool operator>=(const Sum_& other) const {
    return std::tie(GLEAN_value)
             >= std::tie(other.GLEAN_value);
  }

  void outputRepr(Output<Repr<Sum_>> out) const {
    outputValue(out, GLEAN_value);
  }
}; // struct Sum_

struct StringPairBox : Predicate<std::tuple<Fact<StringPair>>> {
  static const char* GLEAN_name() {
    return "glean.test.StringPairBox";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct StringPairBox

struct StringPair : Predicate<std::tuple<std::string, std::string>> {
  static const char* GLEAN_name() {
    return "glean.test.StringPair";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct StringPair

struct StoredRevStringPairWithRev : Predicate<std::tuple<std::string, std::string>> {
  static const char* GLEAN_name() {
    return "glean.test.StoredRevStringPairWithRev";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct StoredRevStringPairWithRev

struct StoredRevStringPairWithA : Predicate<std::tuple<std::string, std::string>> {
  static const char* GLEAN_name() {
    return "glean.test.StoredRevStringPairWithA";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct StoredRevStringPairWithA

struct StoredRevStringPairSum : Predicate<std::tuple<std::string, std::string>> {
  static const char* GLEAN_name() {
    return "glean.test.StoredRevStringPairSum";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct StoredRevStringPairSum

struct StoredRevStringPair : Predicate<std::tuple<std::string, std::string>> {
  static const char* GLEAN_name() {
    return "glean.test.StoredRevStringPair";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct StoredRevStringPair

struct StoredDualStringPair : Predicate<std::tuple<Fact<StringPair>, Fact<StringPair>>> {
  static const char* GLEAN_name() {
    return "glean.test.StoredDualStringPair";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct StoredDualStringPair

struct SkipRevEdge : Predicate<std::tuple<Fact<Node>, Fact<Node>>> {
  static const char* GLEAN_name() {
    return "glean.test.SkipRevEdge";
  }

  static constexpr size_t GLEAN_version() {
     return 5;
  }
}; // struct SkipRevEdge

struct SameString : Predicate<std::tuple<std::string, std::string>> {
  static const char* GLEAN_name() {
    return "glean.test.SameString";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct SameString

struct RevStringPairs : Predicate<std::tuple<std::string, Fact<RevStringPair>>> {
  static const char* GLEAN_name() {
    return "glean.test.RevStringPairs";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct RevStringPairs

struct RevStringPairRec : Predicate<std::tuple<std::string, std::string>> {
  static const char* GLEAN_name() {
    return "glean.test.RevStringPairRec";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct RevStringPairRec

struct RevStringPair : Predicate<std::tuple<std::string, std::string>> {
  static const char* GLEAN_name() {
    return "glean.test.RevStringPair";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct RevStringPair

struct RevRevStringPair : Predicate<std::tuple<std::string, std::string>> {
  static const char* GLEAN_name() {
    return "glean.test.RevRevStringPair";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct RevRevStringPair

struct RevEdge : Predicate<std::tuple<Fact<Node>, Fact<Node>>> {
  static const char* GLEAN_name() {
    return "glean.test.RevEdge";
  }

  static constexpr size_t GLEAN_version() {
     return 5;
  }
}; // struct RevEdge

struct ReflStringPair : Predicate<std::string> {
  static const char* GLEAN_name() {
    return "glean.test.ReflStringPair";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct ReflStringPair

struct RefRef : Predicate<Fact<Ref>> {
  static const char* GLEAN_name() {
    return "glean.test.RefRef";
  }

  static constexpr size_t GLEAN_version() {
     return 5;
  }
}; // struct RefRef

struct Ref : Predicate<Fact<Predicate_>> {
  static const char* GLEAN_name() {
    return "glean.test.Ref";
  }

  static constexpr size_t GLEAN_version() {
     return 5;
  }
}; // struct Ref

struct Qux : Predicate<std::string> {
  static const char* GLEAN_name() {
    return "glean.test.Qux";
  }

  static constexpr size_t GLEAN_version() {
     return 5;
  }
}; // struct Qux

struct NodePair : Predicate<std::tuple<Fact<Node>, Fact<Node>>> {
  static const char* GLEAN_name() {
    return "glean.test.NodePair";
  }

  static constexpr size_t GLEAN_version() {
     return 5;
  }
}; // struct NodePair

struct Node : Predicate<std::tuple<std::string>> {
  static const char* GLEAN_name() {
    return "glean.test.Node";
  }

  static constexpr size_t GLEAN_version() {
     return 5;
  }
}; // struct Node

struct Name : Predicate<std::string> {
  static const char* GLEAN_name() {
    return "glean.test.Name";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct Name

struct MatchOneAlt : Predicate<std::tuple<Sum_, uint64_t>> {
  static const char* GLEAN_name() {
    return "glean.test.MatchOneAlt";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct MatchOneAlt

struct LeftOr2 : Predicate<std::tuple<std::string, uint64_t>> {
  static const char* GLEAN_name() {
    return "glean.test.LeftOr2";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct LeftOr2

struct LeftOr : Predicate<std::tuple<std::string, uint64_t>> {
  static const char* GLEAN_name() {
    return "glean.test.LeftOr";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct LeftOr

struct KeyValue : Predicate<std::tuple<std::string, uint64_t>, std::tuple<uint64_t, std::string>> {
  static const char* GLEAN_name() {
    return "glean.test.KeyValue";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct KeyValue

struct IsThree : Predicate<uint64_t> {
  static const char* GLEAN_name() {
    return "glean.test.IsThree";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct IsThree

struct IsParent : Predicate<Fact<Node>> {
  static const char* GLEAN_name() {
    return "glean.test.IsParent";
  }

  static constexpr size_t GLEAN_version() {
     return 5;
  }
}; // struct IsParent

struct IsGlean : Predicate<std::string> {
  static const char* GLEAN_name() {
    return "glean.test.IsGlean";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct IsGlean

struct FooToFoo : Predicate<Fact<Foo>, Fact<Foo>> {
  static const char* GLEAN_name() {
    return "glean.test.FooToFoo";
  }

  static constexpr size_t GLEAN_version() {
     return 5;
  }
}; // struct FooToFoo

struct Foo : Predicate<std::string, Fact<Bar>> {
  static const char* GLEAN_name() {
    return "glean.test.Foo";
  }

  static constexpr size_t GLEAN_version() {
     return 5;
  }
}; // struct Foo

struct Expr : Predicate<boost::variant<Alt<0, Fact<Name>>, Alt<1, uint64_t>, Alt<2, Fact<Name>>, Alt<3, std::tuple<Fact<Expr>, Fact<Expr>>>, Alt<4, std::tuple<Fact<Name>, Fact<Expr>>>>> {
  static const char* GLEAN_name() {
    return "glean.test.Expr";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct Expr

} // namespace Test

} // namespace Glean

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Glean::Test::Enum_> {
  using Type = Enum<3>;
};


namespace schema {

namespace Glean {

namespace Test {

enum class Enum_ { red, green, blue };

} // namespace Test

} // namespace Glean

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Glean::Test::Rec> {
  using Type = Tuple<Repr<facebook::glean::cpp::schema::Glean::Test::Enum_>, Repr<facebook::glean::cpp::schema::Glean::Test::Sum_>>;
};


namespace schema {

namespace Glean {

namespace Test {

struct Rec {
  Enum_ alpha;
  Sum_ beta;

  bool operator==(const Rec& other) const {
    return std::tie(alpha,beta)
             == std::tie(other.alpha,other.beta);
  }
  bool operator!=(const Rec& other) const {
    return std::tie(alpha,beta)
             != std::tie(other.alpha,other.beta);
  }
  bool operator<(const Rec& other) const {
    return std::tie(alpha,beta)
             < std::tie(other.alpha,other.beta);
  }
  bool operator<=(const Rec& other) const {
    return std::tie(alpha,beta)
             <= std::tie(other.alpha,other.beta);
  }
  bool operator>(const Rec& other) const {
    return std::tie(alpha,beta)
             > std::tie(other.alpha,other.beta);
  }
  bool operator>=(const Rec& other) const {
    return std::tie(alpha,beta)
             >= std::tie(other.alpha,other.beta);
  }
  void outputRepr(Output<Repr<Rec>> out) const {
    outputValue(out, std::make_tuple(alpha, beta));
  }
}; // struct Rec

} // namespace Test

} // namespace Glean

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Glean::Test::KitchenSink_1> {
  using Type = Tuple<Byte, Nat, Array<Byte>, Array<Nat>, Tuple<Byte, Nat>, Sum<Byte, Nat>, Repr<facebook::glean::cpp::schema::Glean::Test::Rec>, Repr<facebook::glean::cpp::schema::Glean::Test::Sum_>, Repr<facebook::glean::cpp::schema::Glean::Test::Enum_>, facebook::glean::cpp::schema::Sys::Blob, Maybe<Tuple<>>, Bool, String>;
};


namespace schema {

namespace Glean {

namespace Test {

struct KitchenSink_1 {
  uint8_t byt;
  uint64_t nat;
  std::vector<uint8_t> array_of_byte;
  std::vector<uint64_t> array_of_nat;
  std::tuple<uint8_t, uint64_t> record_;
  boost::variant<Alt<0, uint8_t>, Alt<1, uint64_t>> sum_;
  Rec named_record_;
  Sum_ named_sum_;
  Enum_ named_enum_;
  Fact<facebook::glean::cpp::schema::Sys::Blob> pred;
  boost::variant<Alt<0, std::tuple<>>, Alt<1, std::tuple<>>> maybe_;
  bool bool_;
  std::string string_;

  bool operator==(const KitchenSink_1& other) const {
    return std::tie(byt,nat,array_of_byte,array_of_nat,record_,sum_,named_record_,named_sum_,named_enum_,pred,maybe_,bool_,string_)
             == std::tie(other.byt,other.nat,other.array_of_byte,other.array_of_nat,other.record_,other.sum_,other.named_record_,other.named_sum_,other.named_enum_,other.pred,other.maybe_,other.bool_,other.string_);
  }
  bool operator!=(const KitchenSink_1& other) const {
    return std::tie(byt,nat,array_of_byte,array_of_nat,record_,sum_,named_record_,named_sum_,named_enum_,pred,maybe_,bool_,string_)
             != std::tie(other.byt,other.nat,other.array_of_byte,other.array_of_nat,other.record_,other.sum_,other.named_record_,other.named_sum_,other.named_enum_,other.pred,other.maybe_,other.bool_,other.string_);
  }
  bool operator<(const KitchenSink_1& other) const {
    return std::tie(byt,nat,array_of_byte,array_of_nat,record_,sum_,named_record_,named_sum_,named_enum_,pred,maybe_,bool_,string_)
             < std::tie(other.byt,other.nat,other.array_of_byte,other.array_of_nat,other.record_,other.sum_,other.named_record_,other.named_sum_,other.named_enum_,other.pred,other.maybe_,other.bool_,other.string_);
  }
  bool operator<=(const KitchenSink_1& other) const {
    return std::tie(byt,nat,array_of_byte,array_of_nat,record_,sum_,named_record_,named_sum_,named_enum_,pred,maybe_,bool_,string_)
             <= std::tie(other.byt,other.nat,other.array_of_byte,other.array_of_nat,other.record_,other.sum_,other.named_record_,other.named_sum_,other.named_enum_,other.pred,other.maybe_,other.bool_,other.string_);
  }
  bool operator>(const KitchenSink_1& other) const {
    return std::tie(byt,nat,array_of_byte,array_of_nat,record_,sum_,named_record_,named_sum_,named_enum_,pred,maybe_,bool_,string_)
             > std::tie(other.byt,other.nat,other.array_of_byte,other.array_of_nat,other.record_,other.sum_,other.named_record_,other.named_sum_,other.named_enum_,other.pred,other.maybe_,other.bool_,other.string_);
  }
  bool operator>=(const KitchenSink_1& other) const {
    return std::tie(byt,nat,array_of_byte,array_of_nat,record_,sum_,named_record_,named_sum_,named_enum_,pred,maybe_,bool_,string_)
             >= std::tie(other.byt,other.nat,other.array_of_byte,other.array_of_nat,other.record_,other.sum_,other.named_record_,other.named_sum_,other.named_enum_,other.pred,other.maybe_,other.bool_,other.string_);
  }
  void outputRepr(Output<Repr<KitchenSink_1>> out) const {
    outputValue(out, std::make_tuple(byt, nat, array_of_byte, array_of_nat, record_, sum_, named_record_, named_sum_, named_enum_, pred, maybe_, bool_, string_));
  }
}; // struct KitchenSink_1

struct Predicate_1 : Predicate<KitchenSink_1> {
  static const char* GLEAN_name() {
    return "glean.test.Predicate";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct Predicate_1

struct EmptyStoredStringPair : Predicate<std::tuple<std::string, std::string>> {
  static const char* GLEAN_name() {
    return "glean.test.EmptyStoredStringPair";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct EmptyStoredStringPair

struct EdgeWrapper : Predicate<std::tuple<Fact<Edge>>> {
  static const char* GLEAN_name() {
    return "glean.test.EdgeWrapper";
  }

  static constexpr size_t GLEAN_version() {
     return 5;
  }
}; // struct EdgeWrapper

} // namespace Test

} // namespace Glean

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Glean::Test::EdgeSum> {
  using Type = Sum<facebook::glean::cpp::schema::Glean::Test::EdgeWrapper, facebook::glean::cpp::schema::Glean::Test::EdgeWrapper>;
};


namespace schema {

namespace Glean {

namespace Test {

struct EdgeSum {
  boost::variant<Alt<0, Fact<EdgeWrapper>>, Alt<1, Fact<EdgeWrapper>>> GLEAN_value;

  static EdgeSum fst(const Fact<EdgeWrapper>& a) {
    return EdgeSum{Alt<0, Fact<EdgeWrapper>>(a)};
  }
  static EdgeSum snd(const Fact<EdgeWrapper>& a) {
    return EdgeSum{Alt<1, Fact<EdgeWrapper>>(a)};
  }

  bool operator==(const EdgeSum& other) const {
    return std::tie(GLEAN_value)
             == std::tie(other.GLEAN_value);
  }
  bool operator!=(const EdgeSum& other) const {
    return std::tie(GLEAN_value)
             != std::tie(other.GLEAN_value);
  }
  bool operator<(const EdgeSum& other) const {
    return std::tie(GLEAN_value)
             < std::tie(other.GLEAN_value);
  }
  bool operator<=(const EdgeSum& other) const {
    return std::tie(GLEAN_value)
             <= std::tie(other.GLEAN_value);
  }
  bool operator>(const EdgeSum& other) const {
    return std::tie(GLEAN_value)
             > std::tie(other.GLEAN_value);
  }
  bool operator>=(const EdgeSum& other) const {
    return std::tie(GLEAN_value)
             >= std::tie(other.GLEAN_value);
  }

  void outputRepr(Output<Repr<EdgeSum>> out) const {
    outputValue(out, GLEAN_value);
  }
}; // struct EdgeSum

struct Edge : Predicate<std::tuple<Fact<Node>, Fact<Node>>> {
  static const char* GLEAN_name() {
    return "glean.test.Edge";
  }

  static constexpr size_t GLEAN_version() {
     return 5;
  }
}; // struct Edge

struct DualStringPair : Predicate<std::tuple<Fact<StringPair>, Fact<StringPair>>> {
  static const char* GLEAN_name() {
    return "glean.test.DualStringPair";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct DualStringPair

struct DerivedKeyValue2 : Predicate<std::tuple<std::string, uint64_t>, std::tuple<uint64_t, std::string>> {
  static const char* GLEAN_name() {
    return "glean.test.DerivedKeyValue2";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct DerivedKeyValue2

struct DerivedKeyValue : Predicate<std::tuple<std::string, uint64_t, uint64_t, std::string>> {
  static const char* GLEAN_name() {
    return "glean.test.DerivedKeyValue";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct DerivedKeyValue

struct Bar : Predicate<std::string, Fact<Qux>> {
  static const char* GLEAN_name() {
    return "glean.test.Bar";
  }

  static constexpr size_t GLEAN_version() {
     return 5;
  }
}; // struct Bar

using ArrayString = std::vector<std::string>;

using ArrayNat = std::vector<uint64_t>;

using ArrayByte = std::vector<uint8_t>;

using ArrayBool = std::vector<bool>;

enum class KitchenSink_enum_ { e, f, g };

} // namespace Test

} // namespace Glean

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Glean::Test::KitchenSink_enum_> {
  using Type = Enum<3>;
};


template<> struct Repr_<facebook::glean::cpp::schema::Glean::Test::KitchenSink> {
  using Type = Tuple<Byte, Nat, Bool, String, facebook::glean::cpp::schema::Sys::Blob, Maybe<Tuple<>>, Tuple<Byte, Nat>, Sum<facebook::glean::cpp::schema::Glean::Test::Predicate_, facebook::glean::cpp::schema::Sys::Blob>, Enum<3>, Repr<facebook::glean::cpp::schema::Glean::Test::Rec>, Repr<facebook::glean::cpp::schema::Glean::Test::Sum_>, Repr<facebook::glean::cpp::schema::Glean::Test::Enum_>, Array<Byte>, Array<Nat>, Array<Bool>, Array<String>, Array<facebook::glean::cpp::schema::Glean::Test::Predicate_>, Array<Repr<facebook::glean::cpp::schema::Glean::Test::Rec>>, Array<Repr<facebook::glean::cpp::schema::Glean::Test::Sum_>>, Array<Repr<facebook::glean::cpp::schema::Glean::Test::Enum_>>, Array<Repr<facebook::glean::cpp::schema::Glean::Test::ArrayByte>>, Array<Repr<facebook::glean::cpp::schema::Glean::Test::ArrayNat>>, Array<Repr<facebook::glean::cpp::schema::Glean::Test::ArrayBool>>, Array<Repr<facebook::glean::cpp::schema::Glean::Test::ArrayString>>>;
};


namespace schema {

namespace Glean {

namespace Test {

struct KitchenSink {
  uint8_t byt;
  uint64_t nat;
  bool bool_;
  std::string string_;
  Fact<facebook::glean::cpp::schema::Sys::Blob> pred;
  boost::variant<Alt<0, std::tuple<>>, Alt<1, std::tuple<>>> maybe_;
  std::tuple<uint8_t, uint64_t> record_;
  boost::variant<Alt<0, Fact<Predicate_>>, Alt<1, Fact<facebook::glean::cpp::schema::Sys::Blob>>> sum_;
  KitchenSink_enum_ enum_;
  Rec named_record_;
  Sum_ named_sum_;
  Enum_ named_enum_;
  std::vector<uint8_t> array_of_byte;
  std::vector<uint64_t> array_of_nat;
  std::vector<bool> array_of_bool;
  std::vector<std::string> array_of_string;
  std::vector<Fact<Predicate_>> array_of_pred;
  std::vector<Rec> array_of_named_record;
  std::vector<Sum_> array_of_named_sum;
  std::vector<Enum_> array_of_named_enum;
  std::vector<ArrayByte> array2_of_byte;
  std::vector<ArrayNat> array2_of_nat;
  std::vector<ArrayBool> array2_of_bool;
  std::vector<ArrayString> array2_of_string;

  bool operator==(const KitchenSink& other) const {
    return std::tie(byt,nat,bool_,string_,pred,maybe_,record_,sum_,enum_,named_record_,named_sum_,named_enum_,array_of_byte,array_of_nat,array_of_bool,array_of_string,array_of_pred,array_of_named_record,array_of_named_sum,array_of_named_enum,array2_of_byte,array2_of_nat,array2_of_bool,array2_of_string)
             == std::tie(other.byt,other.nat,other.bool_,other.string_,other.pred,other.maybe_,other.record_,other.sum_,other.enum_,other.named_record_,other.named_sum_,other.named_enum_,other.array_of_byte,other.array_of_nat,other.array_of_bool,other.array_of_string,other.array_of_pred,other.array_of_named_record,other.array_of_named_sum,other.array_of_named_enum,other.array2_of_byte,other.array2_of_nat,other.array2_of_bool,other.array2_of_string);
  }
  bool operator!=(const KitchenSink& other) const {
    return std::tie(byt,nat,bool_,string_,pred,maybe_,record_,sum_,enum_,named_record_,named_sum_,named_enum_,array_of_byte,array_of_nat,array_of_bool,array_of_string,array_of_pred,array_of_named_record,array_of_named_sum,array_of_named_enum,array2_of_byte,array2_of_nat,array2_of_bool,array2_of_string)
             != std::tie(other.byt,other.nat,other.bool_,other.string_,other.pred,other.maybe_,other.record_,other.sum_,other.enum_,other.named_record_,other.named_sum_,other.named_enum_,other.array_of_byte,other.array_of_nat,other.array_of_bool,other.array_of_string,other.array_of_pred,other.array_of_named_record,other.array_of_named_sum,other.array_of_named_enum,other.array2_of_byte,other.array2_of_nat,other.array2_of_bool,other.array2_of_string);
  }
  bool operator<(const KitchenSink& other) const {
    return std::tie(byt,nat,bool_,string_,pred,maybe_,record_,sum_,enum_,named_record_,named_sum_,named_enum_,array_of_byte,array_of_nat,array_of_bool,array_of_string,array_of_pred,array_of_named_record,array_of_named_sum,array_of_named_enum,array2_of_byte,array2_of_nat,array2_of_bool,array2_of_string)
             < std::tie(other.byt,other.nat,other.bool_,other.string_,other.pred,other.maybe_,other.record_,other.sum_,other.enum_,other.named_record_,other.named_sum_,other.named_enum_,other.array_of_byte,other.array_of_nat,other.array_of_bool,other.array_of_string,other.array_of_pred,other.array_of_named_record,other.array_of_named_sum,other.array_of_named_enum,other.array2_of_byte,other.array2_of_nat,other.array2_of_bool,other.array2_of_string);
  }
  bool operator<=(const KitchenSink& other) const {
    return std::tie(byt,nat,bool_,string_,pred,maybe_,record_,sum_,enum_,named_record_,named_sum_,named_enum_,array_of_byte,array_of_nat,array_of_bool,array_of_string,array_of_pred,array_of_named_record,array_of_named_sum,array_of_named_enum,array2_of_byte,array2_of_nat,array2_of_bool,array2_of_string)
             <= std::tie(other.byt,other.nat,other.bool_,other.string_,other.pred,other.maybe_,other.record_,other.sum_,other.enum_,other.named_record_,other.named_sum_,other.named_enum_,other.array_of_byte,other.array_of_nat,other.array_of_bool,other.array_of_string,other.array_of_pred,other.array_of_named_record,other.array_of_named_sum,other.array_of_named_enum,other.array2_of_byte,other.array2_of_nat,other.array2_of_bool,other.array2_of_string);
  }
  bool operator>(const KitchenSink& other) const {
    return std::tie(byt,nat,bool_,string_,pred,maybe_,record_,sum_,enum_,named_record_,named_sum_,named_enum_,array_of_byte,array_of_nat,array_of_bool,array_of_string,array_of_pred,array_of_named_record,array_of_named_sum,array_of_named_enum,array2_of_byte,array2_of_nat,array2_of_bool,array2_of_string)
             > std::tie(other.byt,other.nat,other.bool_,other.string_,other.pred,other.maybe_,other.record_,other.sum_,other.enum_,other.named_record_,other.named_sum_,other.named_enum_,other.array_of_byte,other.array_of_nat,other.array_of_bool,other.array_of_string,other.array_of_pred,other.array_of_named_record,other.array_of_named_sum,other.array_of_named_enum,other.array2_of_byte,other.array2_of_nat,other.array2_of_bool,other.array2_of_string);
  }
  bool operator>=(const KitchenSink& other) const {
    return std::tie(byt,nat,bool_,string_,pred,maybe_,record_,sum_,enum_,named_record_,named_sum_,named_enum_,array_of_byte,array_of_nat,array_of_bool,array_of_string,array_of_pred,array_of_named_record,array_of_named_sum,array_of_named_enum,array2_of_byte,array2_of_nat,array2_of_bool,array2_of_string)
             >= std::tie(other.byt,other.nat,other.bool_,other.string_,other.pred,other.maybe_,other.record_,other.sum_,other.enum_,other.named_record_,other.named_sum_,other.named_enum_,other.array_of_byte,other.array_of_nat,other.array_of_bool,other.array_of_string,other.array_of_pred,other.array_of_named_record,other.array_of_named_sum,other.array_of_named_enum,other.array2_of_byte,other.array2_of_nat,other.array2_of_bool,other.array2_of_string);
  }
  void outputRepr(Output<Repr<KitchenSink>> out) const {
    outputValue(out, std::make_tuple(byt, nat, bool_, string_, pred, maybe_, record_, sum_, enum_, named_record_, named_sum_, named_enum_, array_of_byte, array_of_nat, array_of_bool, array_of_string, array_of_pred, array_of_named_record, array_of_named_sum, array_of_named_enum, array2_of_byte, array2_of_nat, array2_of_bool, array2_of_string));
  }
}; // struct KitchenSink

struct Predicate_ : Predicate<KitchenSink> {
  static const char* GLEAN_name() {
    return "glean.test.Predicate";
  }

  static constexpr size_t GLEAN_version() {
     return 5;
  }
}; // struct Predicate_

} // namespace Test

} // namespace Glean

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Gencode::GenCodeVariant> {
  using Type = Enum<2>;
};


namespace schema {

namespace Gencode {

enum class GenCodeVariant { Full, Partial };

struct GenCodeSignature : Predicate<std::string> {
  static const char* GLEAN_name() {
    return "gencode.GenCodeSignature";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct GenCodeSignature

struct GenCodeCommand : Predicate<std::string> {
  static const char* GLEAN_name() {
    return "gencode.GenCodeCommand";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct GenCodeCommand

struct GenCodeClass : Predicate<std::string> {
  static const char* GLEAN_name() {
    return "gencode.GenCodeClass";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct GenCodeClass

struct GenCodeBySource : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Src::File>, Fact<facebook::glean::cpp::schema::Src::File>>> {
  static const char* GLEAN_name() {
    return "gencode.GenCodeBySource";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct GenCodeBySource

struct GenCode : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Src::File>, GenCodeVariant, boost::variant<Alt<0, std::tuple<>>, Alt<1, Fact<facebook::glean::cpp::schema::Src::File>>>, boost::variant<Alt<0, std::tuple<>>, Alt<1, Fact<GenCodeCommand>>>, boost::variant<Alt<0, std::tuple<>>, Alt<1, Fact<GenCodeClass>>>, boost::variant<Alt<0, std::tuple<>>, Alt<1, Fact<GenCodeSignature>>>>> {
  static const char* GLEAN_name() {
    return "gencode.GenCode";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct GenCode

} // namespace Gencode

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Flow::XRef> {
  using Type = Sum<facebook::glean::cpp::schema::Flow::LocalDeclarationReference, facebook::glean::cpp::schema::Flow::MemberDeclarationReference, facebook::glean::cpp::schema::Flow::TypeDeclarationReference>;
};


namespace schema {

namespace Flow {

struct XRef {
  boost::variant<Alt<0, Fact<LocalDeclarationReference>>, Alt<1, Fact<MemberDeclarationReference>>, Alt<2, Fact<TypeDeclarationReference>>> GLEAN_value;

  static XRef localRef(const Fact<LocalDeclarationReference>& a) {
    return XRef{Alt<0, Fact<LocalDeclarationReference>>(a)};
  }
  static XRef memberRef(const Fact<MemberDeclarationReference>& a) {
    return XRef{Alt<1, Fact<MemberDeclarationReference>>(a)};
  }
  static XRef typeRef(const Fact<TypeDeclarationReference>& a) {
    return XRef{Alt<2, Fact<TypeDeclarationReference>>(a)};
  }

  bool operator==(const XRef& other) const {
    return std::tie(GLEAN_value)
             == std::tie(other.GLEAN_value);
  }
  bool operator!=(const XRef& other) const {
    return std::tie(GLEAN_value)
             != std::tie(other.GLEAN_value);
  }
  bool operator<(const XRef& other) const {
    return std::tie(GLEAN_value)
             < std::tie(other.GLEAN_value);
  }
  bool operator<=(const XRef& other) const {
    return std::tie(GLEAN_value)
             <= std::tie(other.GLEAN_value);
  }
  bool operator>(const XRef& other) const {
    return std::tie(GLEAN_value)
             > std::tie(other.GLEAN_value);
  }
  bool operator>=(const XRef& other) const {
    return std::tie(GLEAN_value)
             >= std::tie(other.GLEAN_value);
  }

  void outputRepr(Output<Repr<XRef>> out) const {
    outputValue(out, GLEAN_value);
  }
}; // struct XRef

struct TypeImportDeclaration : Predicate<std::tuple<Fact<TypeDeclaration>, boost::variant<Alt<0, Fact<ModuleTypeExport>>, Alt<1, Fact<ModuleExport>>, Alt<2, Fact<Module>>>>> {
  static const char* GLEAN_name() {
    return "flow.TypeImportDeclaration";
  }

  static constexpr size_t GLEAN_version() {
     return 3;
  }
}; // struct TypeImportDeclaration

struct TypeExport : Predicate<boost::variant<Alt<0, Fact<Name>>, Alt<1, Fact<Module>>>> {
  static const char* GLEAN_name() {
    return "flow.TypeExport";
  }

  static constexpr size_t GLEAN_version() {
     return 3;
  }
}; // struct TypeExport

struct TypeDeclarationReference : Predicate<std::tuple<Fact<TypeDeclaration>, Fact<Range>>> {
  static const char* GLEAN_name() {
    return "flow.TypeDeclarationReference";
  }

  static constexpr size_t GLEAN_version() {
     return 3;
  }
}; // struct TypeDeclarationReference

struct TypeDeclarationInfo : Predicate<std::tuple<Fact<TypeDeclaration>, Fact<Type>, boost::variant<Alt<0, std::tuple<>>, Alt<1, Fact<Documentation>>>, boost::variant<Alt<0, std::tuple<>>, Alt<1, Fact<Range>>>>> {
  static const char* GLEAN_name() {
    return "flow.TypeDeclarationInfo";
  }

  static constexpr size_t GLEAN_version() {
     return 3;
  }
}; // struct TypeDeclarationInfo

struct TypeDeclaration : Predicate<std::tuple<Fact<Name>, Fact<Range>>> {
  static const char* GLEAN_name() {
    return "flow.TypeDeclaration";
  }

  static constexpr size_t GLEAN_version() {
     return 3;
  }
}; // struct TypeDeclaration

struct Type : Predicate<std::string> {
  static const char* GLEAN_name() {
    return "flow.Type";
  }

  static constexpr size_t GLEAN_version() {
     return 3;
  }
}; // struct Type

struct StringToFileModule : Predicate<std::tuple<std::string, Fact<facebook::glean::cpp::schema::Src::File>>> {
  static const char* GLEAN_name() {
    return "flow.StringToFileModule";
  }

  static constexpr size_t GLEAN_version() {
     return 3;
  }
}; // struct StringToFileModule

struct SourceOfTypeExport : Predicate<std::tuple<Fact<ModuleTypeExport>, boost::variant<Alt<0, Fact<TypeDeclaration>>, Alt<1, Fact<ModuleTypeExport>>, Alt<2, Fact<Module>>>>> {
  static const char* GLEAN_name() {
    return "flow.SourceOfTypeExport";
  }

  static constexpr size_t GLEAN_version() {
     return 3;
  }
}; // struct SourceOfTypeExport

struct SourceOfExport : Predicate<std::tuple<Fact<ModuleExport>, boost::variant<Alt<0, Fact<Declaration>>, Alt<1, Fact<MemberDeclaration>>, Alt<2, Fact<ModuleExport>>, Alt<3, Fact<Module>>>>> {
  static const char* GLEAN_name() {
    return "flow.SourceOfExport";
  }

  static constexpr size_t GLEAN_version() {
     return 3;
  }
}; // struct SourceOfExport

} // namespace Flow

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Flow::SomeDeclaration> {
  using Type = Sum<facebook::glean::cpp::schema::Flow::Declaration, facebook::glean::cpp::schema::Flow::MemberDeclaration, facebook::glean::cpp::schema::Flow::TypeDeclaration>;
};


namespace schema {

namespace Flow {

struct SomeDeclaration {
  boost::variant<Alt<0, Fact<Declaration>>, Alt<1, Fact<MemberDeclaration>>, Alt<2, Fact<TypeDeclaration>>> GLEAN_value;

  static SomeDeclaration localDecl(const Fact<Declaration>& a) {
    return SomeDeclaration{Alt<0, Fact<Declaration>>(a)};
  }
  static SomeDeclaration memberDecl(const Fact<MemberDeclaration>& a) {
    return SomeDeclaration{Alt<1, Fact<MemberDeclaration>>(a)};
  }
  static SomeDeclaration typeDecl(const Fact<TypeDeclaration>& a) {
    return SomeDeclaration{Alt<2, Fact<TypeDeclaration>>(a)};
  }

  bool operator==(const SomeDeclaration& other) const {
    return std::tie(GLEAN_value)
             == std::tie(other.GLEAN_value);
  }
  bool operator!=(const SomeDeclaration& other) const {
    return std::tie(GLEAN_value)
             != std::tie(other.GLEAN_value);
  }
  bool operator<(const SomeDeclaration& other) const {
    return std::tie(GLEAN_value)
             < std::tie(other.GLEAN_value);
  }
  bool operator<=(const SomeDeclaration& other) const {
    return std::tie(GLEAN_value)
             <= std::tie(other.GLEAN_value);
  }
  bool operator>(const SomeDeclaration& other) const {
    return std::tie(GLEAN_value)
             > std::tie(other.GLEAN_value);
  }
  bool operator>=(const SomeDeclaration& other) const {
    return std::tie(GLEAN_value)
             >= std::tie(other.GLEAN_value);
  }

  void outputRepr(Output<Repr<SomeDeclaration>> out) const {
    outputValue(out, GLEAN_value);
  }
}; // struct SomeDeclaration

} // namespace Flow

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Flow::SomeEntity> {
  using Type = Sum<Repr<facebook::glean::cpp::schema::Flow::SomeDeclaration>, facebook::glean::cpp::schema::Flow::Module>;
};


namespace schema {

namespace Flow {

struct SomeEntity {
  boost::variant<Alt<0, SomeDeclaration>, Alt<1, Fact<Module>>> GLEAN_value;

  static SomeEntity decl(const SomeDeclaration& a) {
    return SomeEntity{Alt<0, SomeDeclaration>(a)};
  }
  static SomeEntity module_(const Fact<Module>& a) {
    return SomeEntity{Alt<1, Fact<Module>>(a)};
  }

  bool operator==(const SomeEntity& other) const {
    return std::tie(GLEAN_value)
             == std::tie(other.GLEAN_value);
  }
  bool operator!=(const SomeEntity& other) const {
    return std::tie(GLEAN_value)
             != std::tie(other.GLEAN_value);
  }
  bool operator<(const SomeEntity& other) const {
    return std::tie(GLEAN_value)
             < std::tie(other.GLEAN_value);
  }
  bool operator<=(const SomeEntity& other) const {
    return std::tie(GLEAN_value)
             <= std::tie(other.GLEAN_value);
  }
  bool operator>(const SomeEntity& other) const {
    return std::tie(GLEAN_value)
             > std::tie(other.GLEAN_value);
  }
  bool operator>=(const SomeEntity& other) const {
    return std::tie(GLEAN_value)
             >= std::tie(other.GLEAN_value);
  }

  void outputRepr(Output<Repr<SomeEntity>> out) const {
    outputValue(out, GLEAN_value);
  }
}; // struct SomeEntity

} // namespace Flow

namespace Search {

namespace Flow {

struct FlowSearchByNameNonImport : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Flow::Name>, facebook::glean::cpp::schema::Flow::SomeDeclaration>> {
  static const char* GLEAN_name() {
    return "search.flow.FlowSearchByNameNonImport";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct FlowSearchByNameNonImport

} // namespace Flow

} // namespace Search

namespace Flow {

struct SearchTypeByModuleExport : Predicate<std::tuple<std::string, Fact<Name>, SomeDeclaration>> {
  static const char* GLEAN_name() {
    return "flow.SearchTypeByModuleExport";
  }

  static constexpr size_t GLEAN_version() {
     return 3;
  }
}; // struct SearchTypeByModuleExport

struct SearchByNameModule : Predicate<std::tuple<std::string, Fact<Module>>> {
  static const char* GLEAN_name() {
    return "flow.SearchByNameModule";
  }

  static constexpr size_t GLEAN_version() {
     return 3;
  }
}; // struct SearchByNameModule

struct SearchByName : Predicate<std::tuple<Fact<Name>, SomeDeclaration>> {
  static const char* GLEAN_name() {
    return "flow.SearchByName";
  }

  static constexpr size_t GLEAN_version() {
     return 3;
  }
}; // struct SearchByName

struct SearchByModule : Predicate<std::tuple<std::string, Fact<Name>, SomeDeclaration>> {
  static const char* GLEAN_name() {
    return "flow.SearchByModule";
  }

  static constexpr size_t GLEAN_version() {
     return 3;
  }
}; // struct SearchByModule

struct SearchByFileModule : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Src::File>, Fact<Name>, SomeDeclaration>> {
  static const char* GLEAN_name() {
    return "flow.SearchByFileModule";
  }

  static constexpr size_t GLEAN_version() {
     return 3;
  }
}; // struct SearchByFileModule

struct Range : Predicate<std::tuple<Fact<Module>, facebook::glean::cpp::schema::Src::ByteSpan>> {
  static const char* GLEAN_name() {
    return "flow.Range";
  }

  static constexpr size_t GLEAN_version() {
     return 3;
  }
}; // struct Range

struct NameLowerCase : Predicate<std::tuple<std::string, Fact<Name>>> {
  static const char* GLEAN_name() {
    return "flow.NameLowerCase";
  }

  static constexpr size_t GLEAN_version() {
     return 3;
  }
}; // struct NameLowerCase

struct Name : Predicate<std::string> {
  static const char* GLEAN_name() {
    return "flow.Name";
  }

  static constexpr size_t GLEAN_version() {
     return 3;
  }
}; // struct Name

struct ModuleTypeExport : Predicate<std::tuple<Fact<Module>, Fact<TypeExport>>> {
  static const char* GLEAN_name() {
    return "flow.ModuleTypeExport";
  }

  static constexpr size_t GLEAN_version() {
     return 3;
  }
}; // struct ModuleTypeExport

struct ModuleNameLowerCase : Predicate<std::tuple<std::string, Fact<Module>>> {
  static const char* GLEAN_name() {
    return "flow.ModuleNameLowerCase";
  }

  static constexpr size_t GLEAN_version() {
     return 3;
  }
}; // struct ModuleNameLowerCase

struct ModuleLocationByFile : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Src::File>, Fact<Module>, facebook::glean::cpp::schema::Src::ByteSpan, std::string>> {
  static const char* GLEAN_name() {
    return "flow.ModuleLocationByFile";
  }

  static constexpr size_t GLEAN_version() {
     return 3;
  }
}; // struct ModuleLocationByFile

struct ModuleLocation : Predicate<std::tuple<Fact<Module>, Fact<facebook::glean::cpp::schema::Src::File>, facebook::glean::cpp::schema::Src::ByteSpan, std::string>> {
  static const char* GLEAN_name() {
    return "flow.ModuleLocation";
  }

  static constexpr size_t GLEAN_version() {
     return 3;
  }
}; // struct ModuleLocation

struct ModuleExport : Predicate<std::tuple<Fact<Module>, Fact<Export>>> {
  static const char* GLEAN_name() {
    return "flow.ModuleExport";
  }

  static constexpr size_t GLEAN_version() {
     return 3;
  }
}; // struct ModuleExport

struct ModuleDoc : Predicate<std::tuple<Fact<Documentation>, Fact<facebook::glean::cpp::schema::Src::File>>> {
  static const char* GLEAN_name() {
    return "flow.ModuleDoc";
  }

  static constexpr size_t GLEAN_version() {
     return 3;
  }
}; // struct ModuleDoc

struct ModuleContains : Predicate<std::tuple<Fact<Module>, SomeDeclaration>> {
  static const char* GLEAN_name() {
    return "flow.ModuleContains";
  }

  static constexpr size_t GLEAN_version() {
     return 3;
  }
}; // struct ModuleContains

struct ModuleComments : Predicate<std::tuple<Fact<Module>, Fact<facebook::glean::cpp::schema::Src::File>, facebook::glean::cpp::schema::Src::ByteSpan>> {
  static const char* GLEAN_name() {
    return "flow.ModuleComments";
  }

  static constexpr size_t GLEAN_version() {
     return 3;
  }
}; // struct ModuleComments

struct Module : Predicate<boost::variant<Alt<0, Fact<facebook::glean::cpp::schema::Src::File>>, Alt<1, std::tuple<>>, Alt<2, std::string>, Alt<3, std::tuple<>>, Alt<4, std::string>>> {
  static const char* GLEAN_name() {
    return "flow.Module";
  }

  static constexpr size_t GLEAN_version() {
     return 3;
  }
}; // struct Module

struct MemberDeclarationReference : Predicate<std::tuple<Fact<MemberDeclaration>, Fact<Range>>> {
  static const char* GLEAN_name() {
    return "flow.MemberDeclarationReference";
  }

  static constexpr size_t GLEAN_version() {
     return 3;
  }
}; // struct MemberDeclarationReference

struct MemberDeclarationInfo : Predicate<std::tuple<Fact<MemberDeclaration>, Fact<Type>, boost::variant<Alt<0, std::tuple<>>, Alt<1, Fact<Documentation>>>, boost::variant<Alt<0, std::tuple<>>, Alt<1, Fact<Range>>>>> {
  static const char* GLEAN_name() {
    return "flow.MemberDeclarationInfo";
  }

  static constexpr size_t GLEAN_version() {
     return 3;
  }
}; // struct MemberDeclarationInfo

struct MemberDeclaration : Predicate<std::tuple<Fact<Name>, Fact<Range>>> {
  static const char* GLEAN_name() {
    return "flow.MemberDeclaration";
  }

  static constexpr size_t GLEAN_version() {
     return 3;
  }
}; // struct MemberDeclaration

struct LocalDeclarationReference : Predicate<std::tuple<Fact<Declaration>, Fact<Range>>> {
  static const char* GLEAN_name() {
    return "flow.LocalDeclarationReference";
  }

  static constexpr size_t GLEAN_version() {
     return 3;
  }
}; // struct LocalDeclarationReference

struct ImportDeclaration : Predicate<std::tuple<Fact<Declaration>, boost::variant<Alt<0, Fact<ModuleExport>>, Alt<1, Fact<Module>>>>> {
  static const char* GLEAN_name() {
    return "flow.ImportDeclaration";
  }

  static constexpr size_t GLEAN_version() {
     return 3;
  }
}; // struct ImportDeclaration

struct FlowXRefDeclInfo : Predicate<std::tuple<XRef, Fact<Range>, Fact<Name>, Fact<Range>, SomeDeclaration>> {
  static const char* GLEAN_name() {
    return "flow.FlowXRefDeclInfo";
  }

  static constexpr size_t GLEAN_version() {
     return 3;
  }
}; // struct FlowXRefDeclInfo

struct FlowTypeImportXRef : Predicate<std::tuple<Fact<TypeDeclaration>, SomeEntity, Fact<facebook::glean::cpp::schema::Src::File>, facebook::glean::cpp::schema::Src::ByteSpan>> {
  static const char* GLEAN_name() {
    return "flow.FlowTypeImportXRef";
  }

  static constexpr size_t GLEAN_version() {
     return 3;
  }
}; // struct FlowTypeImportXRef

struct FlowTypeExportLocation : Predicate<std::tuple<Fact<ModuleTypeExport>, SomeEntity, Fact<facebook::glean::cpp::schema::Src::File>, facebook::glean::cpp::schema::Src::ByteSpan>> {
  static const char* GLEAN_name() {
    return "flow.FlowTypeExportLocation";
  }

  static constexpr size_t GLEAN_version() {
     return 3;
  }
}; // struct FlowTypeExportLocation

struct FlowTypeEntityImportUses : Predicate<std::tuple<SomeEntity, Fact<TypeDeclaration>>> {
  static const char* GLEAN_name() {
    return "flow.FlowTypeEntityImportUses";
  }

  static constexpr size_t GLEAN_version() {
     return 3;
  }
}; // struct FlowTypeEntityImportUses

struct FlowSameModule : Predicate<std::tuple<Fact<Module>, Fact<Module>>> {
  static const char* GLEAN_name() {
    return "flow.FlowSameModule";
  }

  static constexpr size_t GLEAN_version() {
     return 3;
  }
}; // struct FlowSameModule

struct FlowModuleNamespaceXRef : Predicate<std::tuple<Fact<Declaration>, SomeEntity, Fact<facebook::glean::cpp::schema::Src::File>>> {
  static const char* GLEAN_name() {
    return "flow.FlowModuleNamespaceXRef";
  }

  static constexpr size_t GLEAN_version() {
     return 3;
  }
}; // struct FlowModuleNamespaceXRef

struct FlowImportXRef : Predicate<std::tuple<Fact<Declaration>, SomeEntity, Fact<facebook::glean::cpp::schema::Src::File>, facebook::glean::cpp::schema::Src::ByteSpan>> {
  static const char* GLEAN_name() {
    return "flow.FlowImportXRef";
  }

  static constexpr size_t GLEAN_version() {
     return 3;
  }
}; // struct FlowImportXRef

struct FlowExportLocation : Predicate<std::tuple<Fact<Module>, Fact<Export>, SomeEntity, Fact<facebook::glean::cpp::schema::Src::File>, facebook::glean::cpp::schema::Src::ByteSpan>> {
  static const char* GLEAN_name() {
    return "flow.FlowExportLocation";
  }

  static constexpr size_t GLEAN_version() {
     return 3;
  }
}; // struct FlowExportLocation

struct FlowEntityUsesAll : Predicate<std::tuple<SomeEntity, Fact<facebook::glean::cpp::schema::Src::File>, facebook::glean::cpp::schema::Src::ByteSpan>> {
  static const char* GLEAN_name() {
    return "flow.FlowEntityUsesAll";
  }

  static constexpr size_t GLEAN_version() {
     return 3;
  }
}; // struct FlowEntityUsesAll

struct FlowEntityImportUses : Predicate<std::tuple<SomeEntity, Fact<Declaration>>> {
  static const char* GLEAN_name() {
    return "flow.FlowEntityImportUses";
  }

  static constexpr size_t GLEAN_version() {
     return 3;
  }
}; // struct FlowEntityImportUses

struct FlowCompatibleExport : Predicate<std::tuple<Fact<Export>, Fact<Export>>> {
  static const char* GLEAN_name() {
    return "flow.FlowCompatibleExport";
  }

  static constexpr size_t GLEAN_version() {
     return 3;
  }
}; // struct FlowCompatibleExport

struct FileXRef : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Src::File>, XRef>> {
  static const char* GLEAN_name() {
    return "flow.FileXRef";
  }

  static constexpr size_t GLEAN_version() {
     return 3;
  }
}; // struct FileXRef

struct FileOfStringModule : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Src::File>, std::string>> {
  static const char* GLEAN_name() {
    return "flow.FileOfStringModule";
  }

  static constexpr size_t GLEAN_version() {
     return 3;
  }
}; // struct FileOfStringModule

struct FileDeclaration : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Src::File>, SomeDeclaration>> {
  static const char* GLEAN_name() {
    return "flow.FileDeclaration";
  }

  static constexpr size_t GLEAN_version() {
     return 3;
  }
}; // struct FileDeclaration

struct Export : Predicate<boost::variant<Alt<0, std::tuple<>>, Alt<1, Fact<Name>>, Alt<2, Fact<Name>>, Alt<3, std::tuple<>>, Alt<4, Fact<Module>>>> {
  static const char* GLEAN_name() {
    return "flow.Export";
  }

  static constexpr size_t GLEAN_version() {
     return 3;
  }
}; // struct Export

struct Documentation : Predicate<Fact<Range>> {
  static const char* GLEAN_name() {
    return "flow.Documentation";
  }

  static constexpr size_t GLEAN_version() {
     return 3;
  }
}; // struct Documentation

struct DeclarationUses : Predicate<std::tuple<SomeDeclaration, Fact<facebook::glean::cpp::schema::Src::File>, facebook::glean::cpp::schema::Src::ByteSpan>> {
  static const char* GLEAN_name() {
    return "flow.DeclarationUses";
  }

  static constexpr size_t GLEAN_version() {
     return 3;
  }
}; // struct DeclarationUses

struct DeclarationSignature : Predicate<std::tuple<SomeDeclaration, std::string>> {
  static const char* GLEAN_name() {
    return "flow.DeclarationSignature";
  }

  static constexpr size_t GLEAN_version() {
     return 3;
  }
}; // struct DeclarationSignature

struct DeclarationNameSpan : Predicate<std::tuple<SomeDeclaration, Fact<Name>, facebook::glean::cpp::schema::Src::ByteSpan>> {
  static const char* GLEAN_name() {
    return "flow.DeclarationNameSpan";
  }

  static constexpr size_t GLEAN_version() {
     return 3;
  }
}; // struct DeclarationNameSpan

struct DeclarationLocation : Predicate<std::tuple<SomeDeclaration, Fact<facebook::glean::cpp::schema::Src::File>, facebook::glean::cpp::schema::Src::ByteSpan>> {
  static const char* GLEAN_name() {
    return "flow.DeclarationLocation";
  }

  static constexpr size_t GLEAN_version() {
     return 3;
  }
}; // struct DeclarationLocation

struct DeclarationInfo : Predicate<std::tuple<Fact<Declaration>, Fact<Type>, boost::variant<Alt<0, std::tuple<>>, Alt<1, Fact<Documentation>>>, boost::variant<Alt<0, std::tuple<>>, Alt<1, Fact<Range>>>>> {
  static const char* GLEAN_name() {
    return "flow.DeclarationInfo";
  }

  static constexpr size_t GLEAN_version() {
     return 3;
  }
}; // struct DeclarationInfo

struct Declaration : Predicate<std::tuple<Fact<Name>, Fact<Range>>> {
  static const char* GLEAN_name() {
    return "flow.Declaration";
  }

  static constexpr size_t GLEAN_version() {
     return 3;
  }
}; // struct Declaration

} // namespace Flow

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Fbthrift::XRefTarget> {
  using Type = Sum<facebook::glean::cpp::schema::Fbthrift::File, facebook::glean::cpp::schema::Fbthrift::NamedDecl, facebook::glean::cpp::schema::Fbthrift::ExceptionName, facebook::glean::cpp::schema::Fbthrift::ServiceName, facebook::glean::cpp::schema::Fbthrift::Constant, facebook::glean::cpp::schema::Fbthrift::EnumValue, facebook::glean::cpp::schema::Fbthrift::FunctionName>;
};


namespace schema {

namespace Fbthrift {

struct XRefTarget {
  boost::variant<Alt<0, Fact<File>>, Alt<1, Fact<NamedDecl>>, Alt<2, Fact<ExceptionName>>, Alt<3, Fact<ServiceName>>, Alt<4, Fact<Constant>>, Alt<5, Fact<EnumValue>>, Alt<6, Fact<FunctionName>>> GLEAN_value;

  static XRefTarget include_(const Fact<File>& a) {
    return XRefTarget{Alt<0, Fact<File>>(a)};
  }
  static XRefTarget named(const Fact<NamedDecl>& a) {
    return XRefTarget{Alt<1, Fact<NamedDecl>>(a)};
  }
  static XRefTarget exception_(const Fact<ExceptionName>& a) {
    return XRefTarget{Alt<2, Fact<ExceptionName>>(a)};
  }
  static XRefTarget service_(const Fact<ServiceName>& a) {
    return XRefTarget{Alt<3, Fact<ServiceName>>(a)};
  }
  static XRefTarget constant(const Fact<Constant>& a) {
    return XRefTarget{Alt<4, Fact<Constant>>(a)};
  }
  static XRefTarget enumValue(const Fact<EnumValue>& a) {
    return XRefTarget{Alt<5, Fact<EnumValue>>(a)};
  }
  static XRefTarget function_(const Fact<FunctionName>& a) {
    return XRefTarget{Alt<6, Fact<FunctionName>>(a)};
  }

  bool operator==(const XRefTarget& other) const {
    return std::tie(GLEAN_value)
             == std::tie(other.GLEAN_value);
  }
  bool operator!=(const XRefTarget& other) const {
    return std::tie(GLEAN_value)
             != std::tie(other.GLEAN_value);
  }
  bool operator<(const XRefTarget& other) const {
    return std::tie(GLEAN_value)
             < std::tie(other.GLEAN_value);
  }
  bool operator<=(const XRefTarget& other) const {
    return std::tie(GLEAN_value)
             <= std::tie(other.GLEAN_value);
  }
  bool operator>(const XRefTarget& other) const {
    return std::tie(GLEAN_value)
             > std::tie(other.GLEAN_value);
  }
  bool operator>=(const XRefTarget& other) const {
    return std::tie(GLEAN_value)
             >= std::tie(other.GLEAN_value);
  }

  void outputRepr(Output<Repr<XRefTarget>> out) const {
    outputValue(out, GLEAN_value);
  }
}; // struct XRefTarget

} // namespace Fbthrift

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Fbthrift::TypedConst> {
  using Type = Sum<facebook::glean::cpp::schema::Fbthrift::Literal, facebook::glean::cpp::schema::Fbthrift::Constant>;
};


namespace schema {

namespace Fbthrift {

struct TypedConst {
  boost::variant<Alt<0, Fact<Literal>>, Alt<1, Fact<Constant>>> GLEAN_value;

  static TypedConst literal(const Fact<Literal>& a) {
    return TypedConst{Alt<0, Fact<Literal>>(a)};
  }
  static TypedConst identifier(const Fact<Constant>& a) {
    return TypedConst{Alt<1, Fact<Constant>>(a)};
  }

  bool operator==(const TypedConst& other) const {
    return std::tie(GLEAN_value)
             == std::tie(other.GLEAN_value);
  }
  bool operator!=(const TypedConst& other) const {
    return std::tie(GLEAN_value)
             != std::tie(other.GLEAN_value);
  }
  bool operator<(const TypedConst& other) const {
    return std::tie(GLEAN_value)
             < std::tie(other.GLEAN_value);
  }
  bool operator<=(const TypedConst& other) const {
    return std::tie(GLEAN_value)
             <= std::tie(other.GLEAN_value);
  }
  bool operator>(const TypedConst& other) const {
    return std::tie(GLEAN_value)
             > std::tie(other.GLEAN_value);
  }
  bool operator>=(const TypedConst& other) const {
    return std::tie(GLEAN_value)
             >= std::tie(other.GLEAN_value);
  }

  void outputRepr(Output<Repr<TypedConst>> out) const {
    outputValue(out, GLEAN_value);
  }
}; // struct TypedConst

} // namespace Fbthrift

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Fbthrift::TypedConstT> {
  using Type = Tuple<Repr<facebook::glean::cpp::schema::Fbthrift::TypedConst>, facebook::glean::cpp::schema::Fbthrift::TypeSpecification>;
};


namespace schema {

namespace Fbthrift {

struct TypedConstT {
  TypedConst const_;
  Fact<TypeSpecification> type_;

  bool operator==(const TypedConstT& other) const {
    return std::tie(const_,type_)
             == std::tie(other.const_,other.type_);
  }
  bool operator!=(const TypedConstT& other) const {
    return std::tie(const_,type_)
             != std::tie(other.const_,other.type_);
  }
  bool operator<(const TypedConstT& other) const {
    return std::tie(const_,type_)
             < std::tie(other.const_,other.type_);
  }
  bool operator<=(const TypedConstT& other) const {
    return std::tie(const_,type_)
             <= std::tie(other.const_,other.type_);
  }
  bool operator>(const TypedConstT& other) const {
    return std::tie(const_,type_)
             > std::tie(other.const_,other.type_);
  }
  bool operator>=(const TypedConstT& other) const {
    return std::tie(const_,type_)
             >= std::tie(other.const_,other.type_);
  }
  void outputRepr(Output<Repr<TypedConstT>> out) const {
    outputValue(out, std::make_tuple(const_, type_));
  }
}; // struct TypedConstT

} // namespace Fbthrift

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Fbthrift::UnionFieldVal> {
  using Type = Tuple<facebook::glean::cpp::schema::Fbthrift::Identifier, Repr<facebook::glean::cpp::schema::Fbthrift::TypedConstT>>;
};


namespace schema {

namespace Fbthrift {

struct UnionFieldVal {
  Fact<Identifier> name;
  TypedConstT value;

  bool operator==(const UnionFieldVal& other) const {
    return std::tie(name,value)
             == std::tie(other.name,other.value);
  }
  bool operator!=(const UnionFieldVal& other) const {
    return std::tie(name,value)
             != std::tie(other.name,other.value);
  }
  bool operator<(const UnionFieldVal& other) const {
    return std::tie(name,value)
             < std::tie(other.name,other.value);
  }
  bool operator<=(const UnionFieldVal& other) const {
    return std::tie(name,value)
             <= std::tie(other.name,other.value);
  }
  bool operator>(const UnionFieldVal& other) const {
    return std::tie(name,value)
             > std::tie(other.name,other.value);
  }
  bool operator>=(const UnionFieldVal& other) const {
    return std::tie(name,value)
             >= std::tie(other.name,other.value);
  }
  void outputRepr(Output<Repr<UnionFieldVal>> out) const {
    outputValue(out, std::make_tuple(name, value));
  }
}; // struct UnionFieldVal

struct UnionVal : Predicate<std::tuple<UnionFieldVal>> {
  static const char* GLEAN_name() {
    return "fbthrift.UnionVal";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct UnionVal

} // namespace Fbthrift

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Fbthrift::Target> {
  using Type = Tuple<Repr<facebook::glean::cpp::schema::Fbthrift::XRefTarget>>;
};


namespace schema {

namespace Fbthrift {

struct Target {
  XRefTarget target;

  bool operator==(const Target& other) const {
    return std::tie(target)
             == std::tie(other.target);
  }
  bool operator!=(const Target& other) const {
    return std::tie(target)
             != std::tie(other.target);
  }
  bool operator<(const Target& other) const {
    return std::tie(target)
             < std::tie(other.target);
  }
  bool operator<=(const Target& other) const {
    return std::tie(target)
             <= std::tie(other.target);
  }
  bool operator>(const Target& other) const {
    return std::tie(target)
             > std::tie(other.target);
  }
  bool operator>=(const Target& other) const {
    return std::tie(target)
             >= std::tie(other.target);
  }
  void outputRepr(Output<Repr<Target>> out) const {
    outputValue(out, std::make_tuple(target));
  }
}; // struct Target

struct StructuredAnnotation : Predicate<std::tuple<Fact<TypeSpecification>, Fact<StructVal>>> {
  static const char* GLEAN_name() {
    return "fbthrift.StructuredAnnotation";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct StructuredAnnotation

} // namespace Fbthrift

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Fbthrift::StructFieldValValue> {
  using Type = Sum<Repr<facebook::glean::cpp::schema::Fbthrift::TypedConstT>, facebook::glean::cpp::schema::Fbthrift::TypeSpecification, Repr<facebook::glean::cpp::schema::Fbthrift::TypedConstT>, Tuple<>>;
};


namespace schema {

namespace Fbthrift {

struct StructFieldValValue {
  boost::variant<Alt<0, TypedConstT>, Alt<1, Fact<TypeSpecification>>, Alt<2, TypedConstT>, Alt<3, std::tuple<>>> GLEAN_value;

  static StructFieldValValue val(const TypedConstT& a) {
    return StructFieldValValue{Alt<0, TypedConstT>(a)};
  }
  static StructFieldValValue default_(const Fact<TypeSpecification>& a) {
    return StructFieldValValue{Alt<1, Fact<TypeSpecification>>(a)};
  }
  static StructFieldValValue just(const TypedConstT& a) {
    return StructFieldValValue{Alt<2, TypedConstT>(a)};
  }
  static StructFieldValValue nothing() {
    return StructFieldValValue{Alt<3, std::tuple<>>(std::make_tuple())};
  }

  bool operator==(const StructFieldValValue& other) const {
    return std::tie(GLEAN_value)
             == std::tie(other.GLEAN_value);
  }
  bool operator!=(const StructFieldValValue& other) const {
    return std::tie(GLEAN_value)
             != std::tie(other.GLEAN_value);
  }
  bool operator<(const StructFieldValValue& other) const {
    return std::tie(GLEAN_value)
             < std::tie(other.GLEAN_value);
  }
  bool operator<=(const StructFieldValValue& other) const {
    return std::tie(GLEAN_value)
             <= std::tie(other.GLEAN_value);
  }
  bool operator>(const StructFieldValValue& other) const {
    return std::tie(GLEAN_value)
             > std::tie(other.GLEAN_value);
  }
  bool operator>=(const StructFieldValValue& other) const {
    return std::tie(GLEAN_value)
             >= std::tie(other.GLEAN_value);
  }

  void outputRepr(Output<Repr<StructFieldValValue>> out) const {
    outputValue(out, GLEAN_value);
  }
}; // struct StructFieldValValue

} // namespace Fbthrift

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Fbthrift::StructFieldVal> {
  using Type = Tuple<facebook::glean::cpp::schema::Fbthrift::Identifier, Repr<facebook::glean::cpp::schema::Fbthrift::StructFieldValValue>>;
};


namespace schema {

namespace Fbthrift {

struct StructFieldVal {
  Fact<Identifier> name;
  StructFieldValValue value;

  bool operator==(const StructFieldVal& other) const {
    return std::tie(name,value)
             == std::tie(other.name,other.value);
  }
  bool operator!=(const StructFieldVal& other) const {
    return std::tie(name,value)
             != std::tie(other.name,other.value);
  }
  bool operator<(const StructFieldVal& other) const {
    return std::tie(name,value)
             < std::tie(other.name,other.value);
  }
  bool operator<=(const StructFieldVal& other) const {
    return std::tie(name,value)
             <= std::tie(other.name,other.value);
  }
  bool operator>(const StructFieldVal& other) const {
    return std::tie(name,value)
             > std::tie(other.name,other.value);
  }
  bool operator>=(const StructFieldVal& other) const {
    return std::tie(name,value)
             >= std::tie(other.name,other.value);
  }
  void outputRepr(Output<Repr<StructFieldVal>> out) const {
    outputValue(out, std::make_tuple(name, value));
  }
}; // struct StructFieldVal

struct StructVal : Predicate<std::tuple<std::vector<StructFieldVal>>> {
  static const char* GLEAN_name() {
    return "fbthrift.StructVal";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct StructVal

struct ServiceParent : Predicate<std::tuple<Fact<ServiceName>, Fact<ServiceName>>> {
  static const char* GLEAN_name() {
    return "fbthrift.ServiceParent";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct ServiceParent

struct ServiceName : Predicate<std::tuple<Fact<QualName>>> {
  static const char* GLEAN_name() {
    return "fbthrift.ServiceName";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct ServiceName

struct ServiceInteractionFunctions : Predicate<std::tuple<Fact<ServiceName>, Fact<FunctionSpecification>>> {
  static const char* GLEAN_name() {
    return "fbthrift.ServiceInteractionFunctions";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct ServiceInteractionFunctions

struct ServiceDefinition : Predicate<std::tuple<Fact<ServiceName>, std::vector<Fact<FunctionSpecification>>, std::vector<Fact<StructuredAnnotation>>, std::vector<Fact<InteractionName>>>> {
  static const char* GLEAN_name() {
    return "fbthrift.ServiceDefinition";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct ServiceDefinition

struct ServiceChild : Predicate<std::tuple<Fact<ServiceName>, Fact<ServiceName>>> {
  static const char* GLEAN_name() {
    return "fbthrift.ServiceChild";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct ServiceChild

struct SearchByName : Predicate<std::tuple<Fact<Identifier>, Fact<QualName>>> {
  static const char* GLEAN_name() {
    return "fbthrift.SearchByName";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct SearchByName

} // namespace Fbthrift

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Fbthrift::ResultSink> {
  using Type = Tuple<facebook::glean::cpp::schema::Fbthrift::TypeSpecification, Maybe<facebook::glean::cpp::schema::Fbthrift::TypeSpecification>, Maybe<facebook::glean::cpp::schema::Fbthrift::TypeSpecification>>;
};


namespace schema {

namespace Fbthrift {

struct ResultSink {
  Fact<TypeSpecification> type_;
  boost::variant<Alt<0, std::tuple<>>, Alt<1, Fact<TypeSpecification>>> firstResponse;
  boost::variant<Alt<0, std::tuple<>>, Alt<1, Fact<TypeSpecification>>> finalResponse;

  bool operator==(const ResultSink& other) const {
    return std::tie(type_,firstResponse,finalResponse)
             == std::tie(other.type_,other.firstResponse,other.finalResponse);
  }
  bool operator!=(const ResultSink& other) const {
    return std::tie(type_,firstResponse,finalResponse)
             != std::tie(other.type_,other.firstResponse,other.finalResponse);
  }
  bool operator<(const ResultSink& other) const {
    return std::tie(type_,firstResponse,finalResponse)
             < std::tie(other.type_,other.firstResponse,other.finalResponse);
  }
  bool operator<=(const ResultSink& other) const {
    return std::tie(type_,firstResponse,finalResponse)
             <= std::tie(other.type_,other.firstResponse,other.finalResponse);
  }
  bool operator>(const ResultSink& other) const {
    return std::tie(type_,firstResponse,finalResponse)
             > std::tie(other.type_,other.firstResponse,other.finalResponse);
  }
  bool operator>=(const ResultSink& other) const {
    return std::tie(type_,firstResponse,finalResponse)
             >= std::tie(other.type_,other.firstResponse,other.finalResponse);
  }
  void outputRepr(Output<Repr<ResultSink>> out) const {
    outputValue(out, std::make_tuple(type_, firstResponse, finalResponse));
  }
}; // struct ResultSink

} // namespace Fbthrift

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Fbthrift::Qualifier> {
  using Type = Enum<3>;
};


namespace schema {

namespace Fbthrift {

enum class Qualifier { default_, optional_, required_ };

struct QualName : Predicate<std::tuple<Fact<File>, Fact<Identifier>>> {
  static const char* GLEAN_name() {
    return "fbthrift.QualName";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct QualName

} // namespace Fbthrift

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Fbthrift::PrimitiveType> {
  using Type = Enum<9>;
};


namespace schema {

namespace Fbthrift {

enum class PrimitiveType { bool_, byte_, i16_, i32_, i64_, float_, double_, binary_, string_ };

struct PackageName : Predicate<std::string> {
  static const char* GLEAN_name() {
    return "fbthrift.PackageName";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct PackageName

struct Package : Predicate<std::tuple<Fact<File>, Fact<PackageName>>> {
  static const char* GLEAN_name() {
    return "fbthrift.Package";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct Package

struct NamespaceValue : Predicate<std::string> {
  static const char* GLEAN_name() {
    return "fbthrift.NamespaceValue";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct NamespaceValue

struct NamespaceName : Predicate<std::string> {
  static const char* GLEAN_name() {
    return "fbthrift.NamespaceName";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct NamespaceName

struct Namespace : Predicate<std::tuple<Fact<File>, Fact<NamespaceName>, Fact<NamespaceValue>, bool>> {
  static const char* GLEAN_name() {
    return "fbthrift.Namespace";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct Namespace

} // namespace Fbthrift

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Fbthrift::NamedKind> {
  using Type = Enum<4>;
};


namespace schema {

namespace Fbthrift {

enum class NamedKind { typedef_, enum_, struct_, union_ };

} // namespace Fbthrift

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Fbthrift::NamedType> {
  using Type = Tuple<facebook::glean::cpp::schema::Fbthrift::QualName, Repr<facebook::glean::cpp::schema::Fbthrift::NamedKind>>;
};


namespace schema {

namespace Fbthrift {

struct NamedType {
  Fact<QualName> name;
  NamedKind kind;

  bool operator==(const NamedType& other) const {
    return std::tie(name,kind)
             == std::tie(other.name,other.kind);
  }
  bool operator!=(const NamedType& other) const {
    return std::tie(name,kind)
             != std::tie(other.name,other.kind);
  }
  bool operator<(const NamedType& other) const {
    return std::tie(name,kind)
             < std::tie(other.name,other.kind);
  }
  bool operator<=(const NamedType& other) const {
    return std::tie(name,kind)
             <= std::tie(other.name,other.kind);
  }
  bool operator>(const NamedType& other) const {
    return std::tie(name,kind)
             > std::tie(other.name,other.kind);
  }
  bool operator>=(const NamedType& other) const {
    return std::tie(name,kind)
             >= std::tie(other.name,other.kind);
  }
  void outputRepr(Output<Repr<NamedType>> out) const {
    outputValue(out, std::make_tuple(name, kind));
  }
}; // struct NamedType

struct NamedDecl : Predicate<std::tuple<NamedType>> {
  static const char* GLEAN_name() {
    return "fbthrift.NamedDecl";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct NamedDecl

struct NameLowerCase : Predicate<std::tuple<std::string, Fact<Identifier>>> {
  static const char* GLEAN_name() {
    return "fbthrift.NameLowerCase";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct NameLowerCase

} // namespace Fbthrift

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Fbthrift::MapType> {
  using Type = Tuple<facebook::glean::cpp::schema::Fbthrift::TypeSpecification, facebook::glean::cpp::schema::Fbthrift::TypeSpecification>;
};


namespace schema {

namespace Fbthrift {

struct MapType {
  Fact<TypeSpecification> key_;
  Fact<TypeSpecification> value;

  bool operator==(const MapType& other) const {
    return std::tie(key_,value)
             == std::tie(other.key_,other.value);
  }
  bool operator!=(const MapType& other) const {
    return std::tie(key_,value)
             != std::tie(other.key_,other.value);
  }
  bool operator<(const MapType& other) const {
    return std::tie(key_,value)
             < std::tie(other.key_,other.value);
  }
  bool operator<=(const MapType& other) const {
    return std::tie(key_,value)
             <= std::tie(other.key_,other.value);
  }
  bool operator>(const MapType& other) const {
    return std::tie(key_,value)
             > std::tie(other.key_,other.value);
  }
  bool operator>=(const MapType& other) const {
    return std::tie(key_,value)
             >= std::tie(other.key_,other.value);
  }
  void outputRepr(Output<Repr<MapType>> out) const {
    outputValue(out, std::make_tuple(key_, value));
  }
}; // struct MapType

} // namespace Fbthrift

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Fbthrift::Loc> {
  using Type = Tuple<Nat, Nat, Nat, Nat>;
};


namespace schema {

namespace Fbthrift {

struct Loc {
  uint64_t startLine;
  uint64_t startCol;
  uint64_t endLine;
  uint64_t endCol;

  bool operator==(const Loc& other) const {
    return std::tie(startLine,startCol,endLine,endCol)
             == std::tie(other.startLine,other.startCol,other.endLine,other.endCol);
  }
  bool operator!=(const Loc& other) const {
    return std::tie(startLine,startCol,endLine,endCol)
             != std::tie(other.startLine,other.startCol,other.endLine,other.endCol);
  }
  bool operator<(const Loc& other) const {
    return std::tie(startLine,startCol,endLine,endCol)
             < std::tie(other.startLine,other.startCol,other.endLine,other.endCol);
  }
  bool operator<=(const Loc& other) const {
    return std::tie(startLine,startCol,endLine,endCol)
             <= std::tie(other.startLine,other.startCol,other.endLine,other.endCol);
  }
  bool operator>(const Loc& other) const {
    return std::tie(startLine,startCol,endLine,endCol)
             > std::tie(other.startLine,other.startCol,other.endLine,other.endCol);
  }
  bool operator>=(const Loc& other) const {
    return std::tie(startLine,startCol,endLine,endCol)
             >= std::tie(other.startLine,other.startCol,other.endLine,other.endCol);
  }
  void outputRepr(Output<Repr<Loc>> out) const {
    outputValue(out, std::make_tuple(startLine, startCol, endLine, endCol));
  }
}; // struct Loc

} // namespace Fbthrift

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Fbthrift::XRef> {
  using Type = Tuple<Repr<facebook::glean::cpp::schema::Fbthrift::Loc>, Repr<facebook::glean::cpp::schema::Fbthrift::XRefTarget>>;
};


namespace schema {

namespace Fbthrift {

struct XRef {
  Loc locRef;
  XRefTarget target;

  bool operator==(const XRef& other) const {
    return std::tie(locRef,target)
             == std::tie(other.locRef,other.target);
  }
  bool operator!=(const XRef& other) const {
    return std::tie(locRef,target)
             != std::tie(other.locRef,other.target);
  }
  bool operator<(const XRef& other) const {
    return std::tie(locRef,target)
             < std::tie(other.locRef,other.target);
  }
  bool operator<=(const XRef& other) const {
    return std::tie(locRef,target)
             <= std::tie(other.locRef,other.target);
  }
  bool operator>(const XRef& other) const {
    return std::tie(locRef,target)
             > std::tie(other.locRef,other.target);
  }
  bool operator>=(const XRef& other) const {
    return std::tie(locRef,target)
             >= std::tie(other.locRef,other.target);
  }
  void outputRepr(Output<Repr<XRef>> out) const {
    outputValue(out, std::make_tuple(locRef, target));
  }
}; // struct XRef

} // namespace Fbthrift

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Fbthrift::KeyValue> {
  using Type = Tuple<Repr<facebook::glean::cpp::schema::Fbthrift::TypedConst>, Repr<facebook::glean::cpp::schema::Fbthrift::TypedConst>>;
};


namespace schema {

namespace Fbthrift {

struct KeyValue {
  TypedConst key;
  TypedConst value;

  bool operator==(const KeyValue& other) const {
    return std::tie(key,value)
             == std::tie(other.key,other.value);
  }
  bool operator!=(const KeyValue& other) const {
    return std::tie(key,value)
             != std::tie(other.key,other.value);
  }
  bool operator<(const KeyValue& other) const {
    return std::tie(key,value)
             < std::tie(other.key,other.value);
  }
  bool operator<=(const KeyValue& other) const {
    return std::tie(key,value)
             <= std::tie(other.key,other.value);
  }
  bool operator>(const KeyValue& other) const {
    return std::tie(key,value)
             > std::tie(other.key,other.value);
  }
  bool operator>=(const KeyValue& other) const {
    return std::tie(key,value)
             >= std::tie(other.key,other.value);
  }
  void outputRepr(Output<Repr<KeyValue>> out) const {
    outputValue(out, std::make_tuple(key, value));
  }
}; // struct KeyValue

struct InteractionName : Predicate<std::tuple<Fact<QualName>>> {
  static const char* GLEAN_name() {
    return "fbthrift.InteractionName";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct InteractionName

struct InteractionDefinition : Predicate<std::tuple<Fact<InteractionName>, std::vector<Fact<FunctionSpecification>>, std::vector<Fact<StructuredAnnotation>>>> {
  static const char* GLEAN_name() {
    return "fbthrift.InteractionDefinition";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct InteractionDefinition

} // namespace Fbthrift

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Fbthrift::IntegerLiteral> {
  using Type = Tuple<Bool, Nat>;
};


namespace schema {

namespace Fbthrift {

struct IntegerLiteral {
  bool isNonNegative;
  uint64_t absValue;

  bool operator==(const IntegerLiteral& other) const {
    return std::tie(isNonNegative,absValue)
             == std::tie(other.isNonNegative,other.absValue);
  }
  bool operator!=(const IntegerLiteral& other) const {
    return std::tie(isNonNegative,absValue)
             != std::tie(other.isNonNegative,other.absValue);
  }
  bool operator<(const IntegerLiteral& other) const {
    return std::tie(isNonNegative,absValue)
             < std::tie(other.isNonNegative,other.absValue);
  }
  bool operator<=(const IntegerLiteral& other) const {
    return std::tie(isNonNegative,absValue)
             <= std::tie(other.isNonNegative,other.absValue);
  }
  bool operator>(const IntegerLiteral& other) const {
    return std::tie(isNonNegative,absValue)
             > std::tie(other.isNonNegative,other.absValue);
  }
  bool operator>=(const IntegerLiteral& other) const {
    return std::tie(isNonNegative,absValue)
             >= std::tie(other.isNonNegative,other.absValue);
  }
  void outputRepr(Output<Repr<IntegerLiteral>> out) const {
    outputValue(out, std::make_tuple(isNonNegative, absValue));
  }
}; // struct IntegerLiteral

struct Identifier : Predicate<std::string> {
  static const char* GLEAN_name() {
    return "fbthrift.Identifier";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct Identifier

struct FunctionName : Predicate<std::tuple<Fact<ServiceName>, Fact<Identifier>>> {
  static const char* GLEAN_name() {
    return "fbthrift.FunctionName";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct FunctionName

} // namespace Fbthrift

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Fbthrift::FloatLiteral> {
  using Type = Tuple<Bool, Bool, Nat, Nat>;
};


namespace schema {

namespace Fbthrift {

struct FloatLiteral {
  bool isNaN;
  bool isPositive;
  uint64_t exponent;
  uint64_t significand;

  bool operator==(const FloatLiteral& other) const {
    return std::tie(isNaN,isPositive,exponent,significand)
             == std::tie(other.isNaN,other.isPositive,other.exponent,other.significand);
  }
  bool operator!=(const FloatLiteral& other) const {
    return std::tie(isNaN,isPositive,exponent,significand)
             != std::tie(other.isNaN,other.isPositive,other.exponent,other.significand);
  }
  bool operator<(const FloatLiteral& other) const {
    return std::tie(isNaN,isPositive,exponent,significand)
             < std::tie(other.isNaN,other.isPositive,other.exponent,other.significand);
  }
  bool operator<=(const FloatLiteral& other) const {
    return std::tie(isNaN,isPositive,exponent,significand)
             <= std::tie(other.isNaN,other.isPositive,other.exponent,other.significand);
  }
  bool operator>(const FloatLiteral& other) const {
    return std::tie(isNaN,isPositive,exponent,significand)
             > std::tie(other.isNaN,other.isPositive,other.exponent,other.significand);
  }
  bool operator>=(const FloatLiteral& other) const {
    return std::tie(isNaN,isPositive,exponent,significand)
             >= std::tie(other.isNaN,other.isPositive,other.exponent,other.significand);
  }
  void outputRepr(Output<Repr<FloatLiteral>> out) const {
    outputValue(out, std::make_tuple(isNaN, isPositive, exponent, significand));
  }
}; // struct FloatLiteral

struct Literal : Predicate<boost::variant<Alt<0, IntegerLiteral>, Alt<1, IntegerLiteral>, Alt<2, IntegerLiteral>, Alt<3, IntegerLiteral>, Alt<4, FloatLiteral>, Alt<5, FloatLiteral>, Alt<6, bool>, Alt<7, std::string>, Alt<8, std::vector<uint8_t>>, Alt<9, std::vector<TypedConst>>, Alt<10, std::vector<TypedConst>>, Alt<11, std::vector<KeyValue>>, Alt<12, Fact<Literal>>, Alt<13, Fact<StructVal>>, Alt<14, Fact<ExceptionVal>>, Alt<15, Fact<UnionVal>>, Alt<16, Fact<EnumVal>>>> {
  static const char* GLEAN_name() {
    return "fbthrift.Literal";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct Literal

struct FileXRefs : Predicate<std::tuple<Fact<File>, std::vector<XRef>>> {
  static const char* GLEAN_name() {
    return "fbthrift.FileXRefs";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct FileXRefs

struct File : Predicate<Fact<facebook::glean::cpp::schema::Src::File>> {
  static const char* GLEAN_name() {
    return "fbthrift.File";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct File

using FieldId = IntegerLiteral;

} // namespace Fbthrift

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Fbthrift::FieldSpecification> {
  using Type = Tuple<Repr<facebook::glean::cpp::schema::Fbthrift::FieldId>, Repr<facebook::glean::cpp::schema::Fbthrift::Qualifier>, facebook::glean::cpp::schema::Fbthrift::TypeSpecification, facebook::glean::cpp::schema::Fbthrift::Identifier, Maybe<Repr<facebook::glean::cpp::schema::Fbthrift::TypedConst>>, Array<facebook::glean::cpp::schema::Fbthrift::StructuredAnnotation>>;
};


namespace schema {

namespace Fbthrift {

struct FieldSpecification {
  FieldId id;
  Qualifier qualifier;
  Fact<TypeSpecification> type_;
  Fact<Identifier> name;
  boost::variant<Alt<0, std::tuple<>>, Alt<1, TypedConst>> value;
  std::vector<Fact<StructuredAnnotation>> structuredAnnotations;

  bool operator==(const FieldSpecification& other) const {
    return std::tie(id,qualifier,type_,name,value,structuredAnnotations)
             == std::tie(other.id,other.qualifier,other.type_,other.name,other.value,other.structuredAnnotations);
  }
  bool operator!=(const FieldSpecification& other) const {
    return std::tie(id,qualifier,type_,name,value,structuredAnnotations)
             != std::tie(other.id,other.qualifier,other.type_,other.name,other.value,other.structuredAnnotations);
  }
  bool operator<(const FieldSpecification& other) const {
    return std::tie(id,qualifier,type_,name,value,structuredAnnotations)
             < std::tie(other.id,other.qualifier,other.type_,other.name,other.value,other.structuredAnnotations);
  }
  bool operator<=(const FieldSpecification& other) const {
    return std::tie(id,qualifier,type_,name,value,structuredAnnotations)
             <= std::tie(other.id,other.qualifier,other.type_,other.name,other.value,other.structuredAnnotations);
  }
  bool operator>(const FieldSpecification& other) const {
    return std::tie(id,qualifier,type_,name,value,structuredAnnotations)
             > std::tie(other.id,other.qualifier,other.type_,other.name,other.value,other.structuredAnnotations);
  }
  bool operator>=(const FieldSpecification& other) const {
    return std::tie(id,qualifier,type_,name,value,structuredAnnotations)
             >= std::tie(other.id,other.qualifier,other.type_,other.name,other.value,other.structuredAnnotations);
  }
  void outputRepr(Output<Repr<FieldSpecification>> out) const {
    outputValue(out, std::make_tuple(id, qualifier, type_, name, value, structuredAnnotations));
  }
}; // struct FieldSpecification

struct StructType : Predicate<std::tuple<Fact<QualName>, std::vector<FieldSpecification>, std::vector<Fact<StructuredAnnotation>>>> {
  static const char* GLEAN_name() {
    return "fbthrift.StructType";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct StructType

} // namespace Fbthrift

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Fbthrift::UnqualField> {
  using Type = Tuple<Repr<facebook::glean::cpp::schema::Fbthrift::FieldId>, facebook::glean::cpp::schema::Fbthrift::TypeSpecification, facebook::glean::cpp::schema::Fbthrift::Identifier, Array<facebook::glean::cpp::schema::Fbthrift::StructuredAnnotation>>;
};


namespace schema {

namespace Fbthrift {

struct UnqualField {
  FieldId id;
  Fact<TypeSpecification> type_;
  Fact<Identifier> name;
  std::vector<Fact<StructuredAnnotation>> structuredAnnotations;

  bool operator==(const UnqualField& other) const {
    return std::tie(id,type_,name,structuredAnnotations)
             == std::tie(other.id,other.type_,other.name,other.structuredAnnotations);
  }
  bool operator!=(const UnqualField& other) const {
    return std::tie(id,type_,name,structuredAnnotations)
             != std::tie(other.id,other.type_,other.name,other.structuredAnnotations);
  }
  bool operator<(const UnqualField& other) const {
    return std::tie(id,type_,name,structuredAnnotations)
             < std::tie(other.id,other.type_,other.name,other.structuredAnnotations);
  }
  bool operator<=(const UnqualField& other) const {
    return std::tie(id,type_,name,structuredAnnotations)
             <= std::tie(other.id,other.type_,other.name,other.structuredAnnotations);
  }
  bool operator>(const UnqualField& other) const {
    return std::tie(id,type_,name,structuredAnnotations)
             > std::tie(other.id,other.type_,other.name,other.structuredAnnotations);
  }
  bool operator>=(const UnqualField& other) const {
    return std::tie(id,type_,name,structuredAnnotations)
             >= std::tie(other.id,other.type_,other.name,other.structuredAnnotations);
  }
  void outputRepr(Output<Repr<UnqualField>> out) const {
    outputValue(out, std::make_tuple(id, type_, name, structuredAnnotations));
  }
}; // struct UnqualField

struct UnionType : Predicate<std::tuple<Fact<QualName>, std::vector<UnqualField>, std::vector<Fact<StructuredAnnotation>>>> {
  static const char* GLEAN_name() {
    return "fbthrift.UnionType";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct UnionType

struct ExceptionVal : Predicate<Fact<StructVal>> {
  static const char* GLEAN_name() {
    return "fbthrift.ExceptionVal";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct ExceptionVal

struct ExceptionType : Predicate<std::tuple<Fact<QualName>, std::vector<FieldSpecification>, std::vector<Fact<StructuredAnnotation>>>> {
  static const char* GLEAN_name() {
    return "fbthrift.ExceptionType";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct ExceptionType

} // namespace Fbthrift

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Fbthrift::ExceptionSpecName> {
  using Type = Sum<facebook::glean::cpp::schema::Fbthrift::ExceptionName, facebook::glean::cpp::schema::Fbthrift::TypeDefException>;
};


namespace schema {

namespace Fbthrift {

struct ExceptionSpecName {
  boost::variant<Alt<0, Fact<ExceptionName>>, Alt<1, Fact<TypeDefException>>> GLEAN_value;

  static ExceptionSpecName simple(const Fact<ExceptionName>& a) {
    return ExceptionSpecName{Alt<0, Fact<ExceptionName>>(a)};
  }
  static ExceptionSpecName typedef_(const Fact<TypeDefException>& a) {
    return ExceptionSpecName{Alt<1, Fact<TypeDefException>>(a)};
  }

  bool operator==(const ExceptionSpecName& other) const {
    return std::tie(GLEAN_value)
             == std::tie(other.GLEAN_value);
  }
  bool operator!=(const ExceptionSpecName& other) const {
    return std::tie(GLEAN_value)
             != std::tie(other.GLEAN_value);
  }
  bool operator<(const ExceptionSpecName& other) const {
    return std::tie(GLEAN_value)
             < std::tie(other.GLEAN_value);
  }
  bool operator<=(const ExceptionSpecName& other) const {
    return std::tie(GLEAN_value)
             <= std::tie(other.GLEAN_value);
  }
  bool operator>(const ExceptionSpecName& other) const {
    return std::tie(GLEAN_value)
             > std::tie(other.GLEAN_value);
  }
  bool operator>=(const ExceptionSpecName& other) const {
    return std::tie(GLEAN_value)
             >= std::tie(other.GLEAN_value);
  }

  void outputRepr(Output<Repr<ExceptionSpecName>> out) const {
    outputValue(out, GLEAN_value);
  }
}; // struct ExceptionSpecName

} // namespace Fbthrift

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Fbthrift::ExceptionSpecification> {
  using Type = Tuple<Repr<facebook::glean::cpp::schema::Fbthrift::FieldId>, Repr<facebook::glean::cpp::schema::Fbthrift::ExceptionSpecName>, facebook::glean::cpp::schema::Fbthrift::Identifier, Array<facebook::glean::cpp::schema::Fbthrift::StructuredAnnotation>>;
};


namespace schema {

namespace Fbthrift {

struct ExceptionSpecification {
  FieldId id;
  ExceptionSpecName type_;
  Fact<Identifier> name;
  std::vector<Fact<StructuredAnnotation>> structuredAnnotations;

  bool operator==(const ExceptionSpecification& other) const {
    return std::tie(id,type_,name,structuredAnnotations)
             == std::tie(other.id,other.type_,other.name,other.structuredAnnotations);
  }
  bool operator!=(const ExceptionSpecification& other) const {
    return std::tie(id,type_,name,structuredAnnotations)
             != std::tie(other.id,other.type_,other.name,other.structuredAnnotations);
  }
  bool operator<(const ExceptionSpecification& other) const {
    return std::tie(id,type_,name,structuredAnnotations)
             < std::tie(other.id,other.type_,other.name,other.structuredAnnotations);
  }
  bool operator<=(const ExceptionSpecification& other) const {
    return std::tie(id,type_,name,structuredAnnotations)
             <= std::tie(other.id,other.type_,other.name,other.structuredAnnotations);
  }
  bool operator>(const ExceptionSpecification& other) const {
    return std::tie(id,type_,name,structuredAnnotations)
             > std::tie(other.id,other.type_,other.name,other.structuredAnnotations);
  }
  bool operator>=(const ExceptionSpecification& other) const {
    return std::tie(id,type_,name,structuredAnnotations)
             >= std::tie(other.id,other.type_,other.name,other.structuredAnnotations);
  }
  void outputRepr(Output<Repr<ExceptionSpecification>> out) const {
    outputValue(out, std::make_tuple(id, type_, name, structuredAnnotations));
  }
}; // struct ExceptionSpecification

} // namespace Fbthrift

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Fbthrift::ResultStream> {
  using Type = Tuple<Maybe<facebook::glean::cpp::schema::Fbthrift::TypeSpecification>, facebook::glean::cpp::schema::Fbthrift::TypeSpecification, Array<Repr<facebook::glean::cpp::schema::Fbthrift::ExceptionSpecification>>>;
};


namespace schema {

namespace Fbthrift {

struct ResultStream {
  boost::variant<Alt<0, std::tuple<>>, Alt<1, Fact<TypeSpecification>>> response;
  Fact<TypeSpecification> stream_;
  std::vector<ExceptionSpecification> throws_;

  bool operator==(const ResultStream& other) const {
    return std::tie(response,stream_,throws_)
             == std::tie(other.response,other.stream_,other.throws_);
  }
  bool operator!=(const ResultStream& other) const {
    return std::tie(response,stream_,throws_)
             != std::tie(other.response,other.stream_,other.throws_);
  }
  bool operator<(const ResultStream& other) const {
    return std::tie(response,stream_,throws_)
             < std::tie(other.response,other.stream_,other.throws_);
  }
  bool operator<=(const ResultStream& other) const {
    return std::tie(response,stream_,throws_)
             <= std::tie(other.response,other.stream_,other.throws_);
  }
  bool operator>(const ResultStream& other) const {
    return std::tie(response,stream_,throws_)
             > std::tie(other.response,other.stream_,other.throws_);
  }
  bool operator>=(const ResultStream& other) const {
    return std::tie(response,stream_,throws_)
             >= std::tie(other.response,other.stream_,other.throws_);
  }
  void outputRepr(Output<Repr<ResultStream>> out) const {
    outputValue(out, std::make_tuple(response, stream_, throws_));
  }
}; // struct ResultStream

struct TypeDefException : Predicate<std::tuple<Fact<NamedDecl>, ExceptionSpecName>> {
  static const char* GLEAN_name() {
    return "fbthrift.TypeDefException";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct TypeDefException

struct ExceptionName : Predicate<std::tuple<Fact<QualName>>> {
  static const char* GLEAN_name() {
    return "fbthrift.ExceptionName";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct ExceptionName

struct EnumerationType : Predicate<std::tuple<Fact<QualName>, std::vector<Fact<EnumValueDef>>, std::vector<Fact<StructuredAnnotation>>>> {
  static const char* GLEAN_name() {
    return "fbthrift.EnumerationType";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct EnumerationType

struct EnumValueDef : Predicate<std::tuple<Fact<EnumValue>, IntegerLiteral, std::vector<Fact<StructuredAnnotation>>>> {
  static const char* GLEAN_name() {
    return "fbthrift.EnumValueDef";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct EnumValueDef

struct EnumValue : Predicate<std::tuple<NamedType, Fact<Identifier>>> {
  static const char* GLEAN_name() {
    return "fbthrift.EnumValue";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct EnumValue

struct EnumVal : Predicate<std::tuple<Fact<QualName>>> {
  static const char* GLEAN_name() {
    return "fbthrift.EnumVal";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct EnumVal

using Declaration = XRefTarget;

struct DeclarationComment : Predicate<std::tuple<Declaration, Fact<facebook::glean::cpp::schema::Src::File>, facebook::glean::cpp::schema::Src::ByteSpan>> {
  static const char* GLEAN_name() {
    return "fbthrift.DeclarationComment";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct DeclarationComment

struct DeclarationFile : Predicate<std::tuple<Declaration, Fact<File>>> {
  static const char* GLEAN_name() {
    return "fbthrift.DeclarationFile";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct DeclarationFile

struct DeclarationName : Predicate<std::tuple<Fact<QualName>, Declaration>> {
  static const char* GLEAN_name() {
    return "fbthrift.DeclarationName";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct DeclarationName

struct DeclarationNameSpan : Predicate<std::tuple<Declaration, Fact<Identifier>, Fact<File>, Loc>> {
  static const char* GLEAN_name() {
    return "fbthrift.DeclarationNameSpan";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct DeclarationNameSpan

struct DeclarationUses : Predicate<std::tuple<Declaration, Fact<facebook::glean::cpp::schema::Src::File>, Loc>> {
  static const char* GLEAN_name() {
    return "fbthrift.DeclarationUses";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct DeclarationUses

struct FileDeclaration : Predicate<std::tuple<Fact<File>, Declaration>> {
  static const char* GLEAN_name() {
    return "fbthrift.FileDeclaration";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct FileDeclaration

struct FunctionDeclarationName : Predicate<std::tuple<Fact<QualName>, Fact<Identifier>, Declaration>> {
  static const char* GLEAN_name() {
    return "fbthrift.FunctionDeclarationName";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct FunctionDeclarationName

} // namespace Fbthrift

namespace Hack {

struct HackToThrift : Predicate<std::tuple<Declaration, facebook::glean::cpp::schema::Fbthrift::Declaration>> {
  static const char* GLEAN_name() {
    return "hack.HackToThrift";
  }

  static constexpr size_t GLEAN_version() {
     return 6;
  }
}; // struct HackToThrift

struct ThriftToHack : Predicate<std::tuple<facebook::glean::cpp::schema::Fbthrift::Declaration, Declaration>> {
  static const char* GLEAN_name() {
    return "hack.ThriftToHack";
  }

  static constexpr size_t GLEAN_version() {
     return 6;
  }
}; // struct ThriftToHack

} // namespace Hack

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Fbthrift::ContainerType> {
  using Type = Sum<facebook::glean::cpp::schema::Fbthrift::TypeSpecification, facebook::glean::cpp::schema::Fbthrift::TypeSpecification, Repr<facebook::glean::cpp::schema::Fbthrift::MapType>>;
};


namespace schema {

namespace Fbthrift {

struct ContainerType {
  boost::variant<Alt<0, Fact<TypeSpecification>>, Alt<1, Fact<TypeSpecification>>, Alt<2, MapType>> GLEAN_value;

  static ContainerType list_(const Fact<TypeSpecification>& a) {
    return ContainerType{Alt<0, Fact<TypeSpecification>>(a)};
  }
  static ContainerType set_(const Fact<TypeSpecification>& a) {
    return ContainerType{Alt<1, Fact<TypeSpecification>>(a)};
  }
  static ContainerType map_(const MapType& a) {
    return ContainerType{Alt<2, MapType>(a)};
  }

  bool operator==(const ContainerType& other) const {
    return std::tie(GLEAN_value)
             == std::tie(other.GLEAN_value);
  }
  bool operator!=(const ContainerType& other) const {
    return std::tie(GLEAN_value)
             != std::tie(other.GLEAN_value);
  }
  bool operator<(const ContainerType& other) const {
    return std::tie(GLEAN_value)
             < std::tie(other.GLEAN_value);
  }
  bool operator<=(const ContainerType& other) const {
    return std::tie(GLEAN_value)
             <= std::tie(other.GLEAN_value);
  }
  bool operator>(const ContainerType& other) const {
    return std::tie(GLEAN_value)
             > std::tie(other.GLEAN_value);
  }
  bool operator>=(const ContainerType& other) const {
    return std::tie(GLEAN_value)
             >= std::tie(other.GLEAN_value);
  }

  void outputRepr(Output<Repr<ContainerType>> out) const {
    outputValue(out, GLEAN_value);
  }
}; // struct ContainerType

struct TypeSpecification : Predicate<boost::variant<Alt<0, PrimitiveType>, Alt<1, ContainerType>, Alt<2, NamedType>>> {
  static const char* GLEAN_name() {
    return "fbthrift.TypeSpecification";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct TypeSpecification

struct Constant : Predicate<std::tuple<Fact<QualName>>> {
  static const char* GLEAN_name() {
    return "fbthrift.Constant";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct Constant

} // namespace Fbthrift

namespace Erlang {

struct NameLowerCase : Predicate<std::tuple<std::string, std::string>> {
  static const char* GLEAN_name() {
    return "erlang.NameLowerCase";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct NameLowerCase

} // namespace Erlang

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Erlang::Fqn> {
  using Type = Tuple<String, String, Nat>;
};


namespace schema {

namespace Erlang {

struct Fqn {
  std::string module;
  std::string name;
  uint64_t arity;

  bool operator==(const Fqn& other) const {
    return std::tie(module,name,arity)
             == std::tie(other.module,other.name,other.arity);
  }
  bool operator!=(const Fqn& other) const {
    return std::tie(module,name,arity)
             != std::tie(other.module,other.name,other.arity);
  }
  bool operator<(const Fqn& other) const {
    return std::tie(module,name,arity)
             < std::tie(other.module,other.name,other.arity);
  }
  bool operator<=(const Fqn& other) const {
    return std::tie(module,name,arity)
             <= std::tie(other.module,other.name,other.arity);
  }
  bool operator>(const Fqn& other) const {
    return std::tie(module,name,arity)
             > std::tie(other.module,other.name,other.arity);
  }
  bool operator>=(const Fqn& other) const {
    return std::tie(module,name,arity)
             >= std::tie(other.module,other.name,other.arity);
  }
  void outputRepr(Output<Repr<Fqn>> out) const {
    outputValue(out, std::make_tuple(module, name, arity));
  }
}; // struct Fqn

struct FunctionDeclaration : Predicate<std::tuple<Fqn, Fact<facebook::glean::cpp::schema::Src::File>, facebook::glean::cpp::schema::Src::ByteSpan>> {
  static const char* GLEAN_name() {
    return "erlang.FunctionDeclaration";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct FunctionDeclaration

} // namespace Erlang

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Erlang::XRefViaFqn> {
  using Type = Tuple<Repr<facebook::glean::cpp::schema::Erlang::Fqn>, Repr<facebook::glean::cpp::schema::Src::ByteSpan>>;
};


namespace schema {

namespace Erlang {

struct XRefViaFqn {
  Fqn target;
  facebook::glean::cpp::schema::Src::ByteSpan source;

  bool operator==(const XRefViaFqn& other) const {
    return std::tie(target,source)
             == std::tie(other.target,other.source);
  }
  bool operator!=(const XRefViaFqn& other) const {
    return std::tie(target,source)
             != std::tie(other.target,other.source);
  }
  bool operator<(const XRefViaFqn& other) const {
    return std::tie(target,source)
             < std::tie(other.target,other.source);
  }
  bool operator<=(const XRefViaFqn& other) const {
    return std::tie(target,source)
             <= std::tie(other.target,other.source);
  }
  bool operator>(const XRefViaFqn& other) const {
    return std::tie(target,source)
             > std::tie(other.target,other.source);
  }
  bool operator>=(const XRefViaFqn& other) const {
    return std::tie(target,source)
             >= std::tie(other.target,other.source);
  }
  void outputRepr(Output<Repr<XRefViaFqn>> out) const {
    outputValue(out, std::make_tuple(target, source));
  }
}; // struct XRefViaFqn

struct XRefsViaFqnByFile : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Src::File>, std::vector<XRefViaFqn>>> {
  static const char* GLEAN_name() {
    return "erlang.XRefsViaFqnByFile";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct XRefsViaFqnByFile

struct DeclarationComment : Predicate<std::tuple<Fact<FunctionDeclaration>, Fact<facebook::glean::cpp::schema::Src::File>, facebook::glean::cpp::schema::Src::ByteSpan, boost::variant<Alt<0, std::tuple<>>, Alt<1, std::string>>>> {
  static const char* GLEAN_name() {
    return "erlang.DeclarationComment";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct DeclarationComment

} // namespace Erlang

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Erlang::Declaration> {
  using Type = Sum<facebook::glean::cpp::schema::Erlang::FunctionDeclaration>;
};


namespace schema {

namespace Erlang {

struct Declaration {
  boost::variant<Alt<0, Fact<FunctionDeclaration>>> GLEAN_value;

  static Declaration func(const Fact<FunctionDeclaration>& a) {
    return Declaration{Alt<0, Fact<FunctionDeclaration>>(a)};
  }

  bool operator==(const Declaration& other) const {
    return std::tie(GLEAN_value)
             == std::tie(other.GLEAN_value);
  }
  bool operator!=(const Declaration& other) const {
    return std::tie(GLEAN_value)
             != std::tie(other.GLEAN_value);
  }
  bool operator<(const Declaration& other) const {
    return std::tie(GLEAN_value)
             < std::tie(other.GLEAN_value);
  }
  bool operator<=(const Declaration& other) const {
    return std::tie(GLEAN_value)
             <= std::tie(other.GLEAN_value);
  }
  bool operator>(const Declaration& other) const {
    return std::tie(GLEAN_value)
             > std::tie(other.GLEAN_value);
  }
  bool operator>=(const Declaration& other) const {
    return std::tie(GLEAN_value)
             >= std::tie(other.GLEAN_value);
  }

  void outputRepr(Output<Repr<Declaration>> out) const {
    outputValue(out, GLEAN_value);
  }
}; // struct Declaration

struct DeclarationLocation : Predicate<std::tuple<Declaration, Fact<facebook::glean::cpp::schema::Src::File>, facebook::glean::cpp::schema::Src::ByteSpan>> {
  static const char* GLEAN_name() {
    return "erlang.DeclarationLocation";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct DeclarationLocation

struct DeclarationReference : Predicate<std::tuple<Declaration, Declaration>> {
  static const char* GLEAN_name() {
    return "erlang.DeclarationReference";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct DeclarationReference

struct DeclarationToFqn : Predicate<Declaration, Fqn> {
  static const char* GLEAN_name() {
    return "erlang.DeclarationToFqn";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct DeclarationToFqn

struct DeclarationUses : Predicate<std::tuple<Declaration, Fact<facebook::glean::cpp::schema::Src::File>, facebook::glean::cpp::schema::Src::ByteSpan>> {
  static const char* GLEAN_name() {
    return "erlang.DeclarationUses";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct DeclarationUses

struct DeclarationWithFqn : Predicate<std::tuple<Fqn, Declaration>> {
  static const char* GLEAN_name() {
    return "erlang.DeclarationWithFqn";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct DeclarationWithFqn

struct DeclarationsByFile : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Src::File>, facebook::glean::cpp::schema::Src::ByteSpan, Declaration>> {
  static const char* GLEAN_name() {
    return "erlang.DeclarationsByFile";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct DeclarationsByFile

struct SearchByName : Predicate<std::tuple<std::string, Declaration>> {
  static const char* GLEAN_name() {
    return "erlang.SearchByName";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct SearchByName

} // namespace Erlang

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Dyn::Usage> {
  using Type = Enum<3>;
};


namespace schema {

namespace Dyn {

enum class Usage { Unused, Enumerated, Used };

struct ObserverIdentifier : Predicate<std::string> {
  static const char* GLEAN_name() {
    return "dyn.ObserverIdentifier";
  }

  static constexpr size_t GLEAN_version() {
     return 6;
  }
}; // struct ObserverIdentifier

} // namespace Dyn

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Dyn::Observer> {
  using Type = Sum<facebook::glean::cpp::schema::Dyn::ObserverIdentifier, facebook::glean::cpp::schema::Dyn::ObserverIdentifier>;
};


namespace schema {

namespace Dyn {

struct Observer {
  boost::variant<Alt<0, Fact<ObserverIdentifier>>, Alt<1, Fact<ObserverIdentifier>>> GLEAN_value;

  static Observer symbol(const Fact<ObserverIdentifier>& a) {
    return Observer{Alt<0, Fact<ObserverIdentifier>>(a)};
  }
  static Observer other(const Fact<ObserverIdentifier>& a) {
    return Observer{Alt<1, Fact<ObserverIdentifier>>(a)};
  }

  bool operator==(const Observer& other) const {
    return std::tie(GLEAN_value)
             == std::tie(other.GLEAN_value);
  }
  bool operator!=(const Observer& other) const {
    return std::tie(GLEAN_value)
             != std::tie(other.GLEAN_value);
  }
  bool operator<(const Observer& other) const {
    return std::tie(GLEAN_value)
             < std::tie(other.GLEAN_value);
  }
  bool operator<=(const Observer& other) const {
    return std::tie(GLEAN_value)
             <= std::tie(other.GLEAN_value);
  }
  bool operator>(const Observer& other) const {
    return std::tie(GLEAN_value)
             > std::tie(other.GLEAN_value);
  }
  bool operator>=(const Observer& other) const {
    return std::tie(GLEAN_value)
             >= std::tie(other.GLEAN_value);
  }

  void outputRepr(Output<Repr<Observer>> out) const {
    outputValue(out, GLEAN_value);
  }
}; // struct Observer

struct Environment : Predicate<std::string> {
  static const char* GLEAN_name() {
    return "dyn.Environment";
  }

  static constexpr size_t GLEAN_version() {
     return 6;
  }
}; // struct Environment

struct EntityDynamicReference : Predicate<std::tuple<Fact<EntityUsage>, Fact<facebook::glean::cpp::schema::Src::File>, facebook::glean::cpp::schema::Src::ByteSpan>> {
  static const char* GLEAN_name() {
    return "dyn.EntityDynamicReference";
  }

  static constexpr size_t GLEAN_version() {
     return 6;
  }
}; // struct EntityDynamicReference

} // namespace Dyn

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Digest::Digest> {
  using Type = Tuple<String, Nat>;
};


namespace schema {

namespace Digest {

struct Digest {
  std::string hash;
  uint64_t size;

  bool operator==(const Digest& other) const {
    return std::tie(hash,size)
             == std::tie(other.hash,other.size);
  }
  bool operator!=(const Digest& other) const {
    return std::tie(hash,size)
             != std::tie(other.hash,other.size);
  }
  bool operator<(const Digest& other) const {
    return std::tie(hash,size)
             < std::tie(other.hash,other.size);
  }
  bool operator<=(const Digest& other) const {
    return std::tie(hash,size)
             <= std::tie(other.hash,other.size);
  }
  bool operator>(const Digest& other) const {
    return std::tie(hash,size)
             > std::tie(other.hash,other.size);
  }
  bool operator>=(const Digest& other) const {
    return std::tie(hash,size)
             >= std::tie(other.hash,other.size);
  }
  void outputRepr(Output<Repr<Digest>> out) const {
    outputValue(out, std::make_tuple(hash, size));
  }
}; // struct Digest

struct FileDigest : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Src::File>, Digest>> {
  static const char* GLEAN_name() {
    return "digest.FileDigest";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct FileDigest

} // namespace Digest

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Glass::FileMetadata> {
  using Type = Tuple<Bool, Maybe<facebook::glean::cpp::schema::Src::FileLines>, Maybe<Repr<facebook::glean::cpp::schema::Digest::Digest>>, Maybe<facebook::glean::cpp::schema::Src::IndexFailure>>;
};


namespace schema {

namespace Glass {

struct FileMetadata {
  bool indexed;
  boost::variant<Alt<0, std::tuple<>>, Alt<1, Fact<facebook::glean::cpp::schema::Src::FileLines>>> offsets;
  boost::variant<Alt<0, std::tuple<>>, Alt<1, facebook::glean::cpp::schema::Digest::Digest>> digest;
  boost::variant<Alt<0, std::tuple<>>, Alt<1, Fact<facebook::glean::cpp::schema::Src::IndexFailure>>> indexFailure;

  bool operator==(const FileMetadata& other) const {
    return std::tie(indexed,offsets,digest,indexFailure)
             == std::tie(other.indexed,other.offsets,other.digest,other.indexFailure);
  }
  bool operator!=(const FileMetadata& other) const {
    return std::tie(indexed,offsets,digest,indexFailure)
             != std::tie(other.indexed,other.offsets,other.digest,other.indexFailure);
  }
  bool operator<(const FileMetadata& other) const {
    return std::tie(indexed,offsets,digest,indexFailure)
             < std::tie(other.indexed,other.offsets,other.digest,other.indexFailure);
  }
  bool operator<=(const FileMetadata& other) const {
    return std::tie(indexed,offsets,digest,indexFailure)
             <= std::tie(other.indexed,other.offsets,other.digest,other.indexFailure);
  }
  bool operator>(const FileMetadata& other) const {
    return std::tie(indexed,offsets,digest,indexFailure)
             > std::tie(other.indexed,other.offsets,other.digest,other.indexFailure);
  }
  bool operator>=(const FileMetadata& other) const {
    return std::tie(indexed,offsets,digest,indexFailure)
             >= std::tie(other.indexed,other.offsets,other.digest,other.indexFailure);
  }
  void outputRepr(Output<Repr<FileMetadata>> out) const {
    outputValue(out, std::make_tuple(indexed, offsets, digest, indexFailure));
  }
}; // struct FileMetadata

struct FileInfo : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Src::File>, FileMetadata>> {
  static const char* GLEAN_name() {
    return "glass.FileInfo";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct FileInfo

} // namespace Glass

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Deadcode::GraphType> {
  using Type = Enum<2>;
};


namespace schema {

namespace Deadcode {

enum class GraphType { Raw, Condensed };

struct GraphNodeByEntity : Predicate<std::tuple<Fact<GraphEntity>, Fact<GraphNode>>> {
  static const char* GLEAN_name() {
    return "deadcode.GraphNodeByEntity";
  }

  static constexpr size_t GLEAN_version() {
     return 7;
  }
}; // struct GraphNodeByEntity

struct GraphNode : Predicate<std::tuple<GraphType, std::vector<Fact<GraphEntity>>, uint64_t, uint64_t>> {
  static const char* GLEAN_name() {
    return "deadcode.GraphNode";
  }

  static constexpr size_t GLEAN_version() {
     return 7;
  }
}; // struct GraphNode

struct GraphInverseEdge : Predicate<std::tuple<Fact<GraphNode>, Fact<GraphNode>>> {
  static const char* GLEAN_name() {
    return "deadcode.GraphInverseEdge";
  }

  static constexpr size_t GLEAN_version() {
     return 7;
  }
}; // struct GraphInverseEdge

struct GraphEntityByFile : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Src::File>, Fact<GraphEntity>>> {
  static const char* GLEAN_name() {
    return "deadcode.GraphEntityByFile";
  }

  static constexpr size_t GLEAN_version() {
     return 7;
  }
}; // struct GraphEntityByFile

struct GraphEdge : Predicate<std::tuple<Fact<GraphNode>, Fact<GraphNode>>> {
  static const char* GLEAN_name() {
    return "deadcode.GraphEdge";
  }

  static constexpr size_t GLEAN_version() {
     return 7;
  }
}; // struct GraphEdge

} // namespace Deadcode

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Cxx1::XRefVia> {
  using Type = Sum<facebook::glean::cpp::schema::Cxx1::UsingDeclaration, facebook::glean::cpp::schema::Cxx1::UsingDirective, facebook::glean::cpp::schema::Pp1::Use>;
};


namespace schema {

namespace Cxx1 {

struct XRefVia {
  boost::variant<Alt<0, Fact<UsingDeclaration>>, Alt<1, Fact<UsingDirective>>, Alt<2, Fact<facebook::glean::cpp::schema::Pp1::Use>>> GLEAN_value;

  static XRefVia usingDeclaration(const Fact<UsingDeclaration>& a) {
    return XRefVia{Alt<0, Fact<UsingDeclaration>>(a)};
  }
  static XRefVia usingDirective(const Fact<UsingDirective>& a) {
    return XRefVia{Alt<1, Fact<UsingDirective>>(a)};
  }
  static XRefVia macro(const Fact<facebook::glean::cpp::schema::Pp1::Use>& a) {
    return XRefVia{Alt<2, Fact<facebook::glean::cpp::schema::Pp1::Use>>(a)};
  }

  bool operator==(const XRefVia& other) const {
    return std::tie(GLEAN_value)
             == std::tie(other.GLEAN_value);
  }
  bool operator!=(const XRefVia& other) const {
    return std::tie(GLEAN_value)
             != std::tie(other.GLEAN_value);
  }
  bool operator<(const XRefVia& other) const {
    return std::tie(GLEAN_value)
             < std::tie(other.GLEAN_value);
  }
  bool operator<=(const XRefVia& other) const {
    return std::tie(GLEAN_value)
             <= std::tie(other.GLEAN_value);
  }
  bool operator>(const XRefVia& other) const {
    return std::tie(GLEAN_value)
             > std::tie(other.GLEAN_value);
  }
  bool operator>=(const XRefVia& other) const {
    return std::tie(GLEAN_value)
             >= std::tie(other.GLEAN_value);
  }

  void outputRepr(Output<Repr<XRefVia>> out) const {
    outputValue(out, GLEAN_value);
  }
}; // struct XRefVia

struct UsingDirective : Predicate<std::tuple<Fact<QName>, facebook::glean::cpp::schema::Src::Range>> {
  static const char* GLEAN_name() {
    return "cxx1.UsingDirective";
  }

  static constexpr size_t GLEAN_version() {
     return 5;
  }
}; // struct UsingDirective

struct UsingDeclaration : Predicate<std::tuple<Fact<FunctionQName>, facebook::glean::cpp::schema::Src::Range>> {
  static const char* GLEAN_name() {
    return "cxx1.UsingDeclaration";
  }

  static constexpr size_t GLEAN_version() {
     return 5;
  }
}; // struct UsingDeclaration

using USR = std::string;

} // namespace Cxx1

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Cxx1::TypeAliasKind> {
  using Type = Enum<2>;
};


namespace schema {

namespace Cxx1 {

enum class TypeAliasKind { Typedef, Using };

struct TypeAliasDeclaration : Predicate<std::tuple<Fact<QName>, Fact<Type>, TypeAliasKind, facebook::glean::cpp::schema::Src::Range>> {
  static const char* GLEAN_name() {
    return "cxx1.TypeAliasDeclaration";
  }

  static constexpr size_t GLEAN_version() {
     return 5;
  }
}; // struct TypeAliasDeclaration

struct Type : Predicate<std::string> {
  static const char* GLEAN_name() {
    return "cxx1.Type";
  }

  static constexpr size_t GLEAN_version() {
     return 5;
  }
}; // struct Type

struct TranslationUnitXRefs : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Buck::TranslationUnit>, std::vector<Fact<FileXRefs>>>> {
  static const char* GLEAN_name() {
    return "cxx1.TranslationUnitXRefs";
  }

  static constexpr size_t GLEAN_version() {
     return 5;
  }
}; // struct TranslationUnitXRefs

struct TranslationUnitTrace : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Buck::TranslationUnit>, Fact<Trace>>> {
  static const char* GLEAN_name() {
    return "cxx1.TranslationUnitTrace";
  }

  static constexpr size_t GLEAN_version() {
     return 5;
  }
}; // struct TranslationUnitTrace

struct TranslationUnitIncludeTree : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Buck::TranslationUnit>, Fact<IncludeTree>>> {
  static const char* GLEAN_name() {
    return "cxx1.TranslationUnitIncludeTree";
  }

  static constexpr size_t GLEAN_version() {
     return 5;
  }
}; // struct TranslationUnitIncludeTree

struct Trace : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Src::File>, Fact<Declarations>, Fact<PPTrace>>> {
  static const char* GLEAN_name() {
    return "cxx1.Trace";
  }

  static constexpr size_t GLEAN_version() {
     return 5;
  }
}; // struct Trace

} // namespace Cxx1

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Cxx1::RefQualifier> {
  using Type = Enum<3>;
};


namespace schema {

namespace Cxx1 {

enum class RefQualifier { None_, LValue, RValue };

struct RecordDerived : Predicate<std::tuple<Fact<RecordDeclaration>, Fact<RecordDeclaration>>> {
  static const char* GLEAN_name() {
    return "cxx1.RecordDerived";
  }

  static constexpr size_t GLEAN_version() {
     return 5;
  }
}; // struct RecordDerived

} // namespace Cxx1

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Cxx1::PpEntity> {
  using Type = Sum<facebook::glean::cpp::schema::Pp1::Define, facebook::glean::cpp::schema::Pp1::Undef, facebook::glean::cpp::schema::Src::File>;
};


namespace schema {

namespace Cxx1 {

struct PpEntity {
  boost::variant<Alt<0, Fact<facebook::glean::cpp::schema::Pp1::Define>>, Alt<1, Fact<facebook::glean::cpp::schema::Pp1::Undef>>, Alt<2, Fact<facebook::glean::cpp::schema::Src::File>>> GLEAN_value;

  static PpEntity define(const Fact<facebook::glean::cpp::schema::Pp1::Define>& a) {
    return PpEntity{Alt<0, Fact<facebook::glean::cpp::schema::Pp1::Define>>(a)};
  }
  static PpEntity undef(const Fact<facebook::glean::cpp::schema::Pp1::Undef>& a) {
    return PpEntity{Alt<1, Fact<facebook::glean::cpp::schema::Pp1::Undef>>(a)};
  }
  static PpEntity include_(const Fact<facebook::glean::cpp::schema::Src::File>& a) {
    return PpEntity{Alt<2, Fact<facebook::glean::cpp::schema::Src::File>>(a)};
  }

  bool operator==(const PpEntity& other) const {
    return std::tie(GLEAN_value)
             == std::tie(other.GLEAN_value);
  }
  bool operator!=(const PpEntity& other) const {
    return std::tie(GLEAN_value)
             != std::tie(other.GLEAN_value);
  }
  bool operator<(const PpEntity& other) const {
    return std::tie(GLEAN_value)
             < std::tie(other.GLEAN_value);
  }
  bool operator<=(const PpEntity& other) const {
    return std::tie(GLEAN_value)
             <= std::tie(other.GLEAN_value);
  }
  bool operator>(const PpEntity& other) const {
    return std::tie(GLEAN_value)
             > std::tie(other.GLEAN_value);
  }
  bool operator>=(const PpEntity& other) const {
    return std::tie(GLEAN_value)
             >= std::tie(other.GLEAN_value);
  }

  void outputRepr(Output<Repr<PpEntity>> out) const {
    outputValue(out, GLEAN_value);
  }
}; // struct PpEntity

} // namespace Cxx1

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Cxx1::Parameter> {
  using Type = Tuple<facebook::glean::cpp::schema::Cxx1::Name, facebook::glean::cpp::schema::Cxx1::Type>;
};


namespace schema {

namespace Cxx1 {

struct Parameter {
  Fact<Name> name;
  Fact<Type> type;

  bool operator==(const Parameter& other) const {
    return std::tie(name,type)
             == std::tie(other.name,other.type);
  }
  bool operator!=(const Parameter& other) const {
    return std::tie(name,type)
             != std::tie(other.name,other.type);
  }
  bool operator<(const Parameter& other) const {
    return std::tie(name,type)
             < std::tie(other.name,other.type);
  }
  bool operator<=(const Parameter& other) const {
    return std::tie(name,type)
             <= std::tie(other.name,other.type);
  }
  bool operator>(const Parameter& other) const {
    return std::tie(name,type)
             > std::tie(other.name,other.type);
  }
  bool operator>=(const Parameter& other) const {
    return std::tie(name,type)
             >= std::tie(other.name,other.type);
  }
  void outputRepr(Output<Repr<Parameter>> out) const {
    outputValue(out, std::make_tuple(name, type));
  }
}; // struct Parameter

struct Signature : Predicate<std::tuple<Fact<Type>, std::vector<Parameter>>> {
  static const char* GLEAN_name() {
    return "cxx1.Signature";
  }

  static constexpr size_t GLEAN_version() {
     return 5;
  }
}; // struct Signature

struct PPDefineLocation : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Pp1::Define>, std::string, Fact<facebook::glean::cpp::schema::Src::File>, facebook::glean::cpp::schema::Src::Range>> {
  static const char* GLEAN_name() {
    return "cxx1.PPDefineLocation";
  }

  static constexpr size_t GLEAN_version() {
     return 5;
  }
}; // struct PPDefineLocation

using Operator = std::string;

} // namespace Cxx1

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Cxx1::ObjcSelectorSlot> {
  using Type = Tuple<facebook::glean::cpp::schema::Cxx1::ObjcMethodDeclaration, Nat>;
};


namespace schema {

namespace Cxx1 {

struct ObjcSelectorSlot {
  Fact<ObjcMethodDeclaration> objcMethod;
  uint64_t index;

  bool operator==(const ObjcSelectorSlot& other) const {
    return std::tie(objcMethod,index)
             == std::tie(other.objcMethod,other.index);
  }
  bool operator!=(const ObjcSelectorSlot& other) const {
    return std::tie(objcMethod,index)
             != std::tie(other.objcMethod,other.index);
  }
  bool operator<(const ObjcSelectorSlot& other) const {
    return std::tie(objcMethod,index)
             < std::tie(other.objcMethod,other.index);
  }
  bool operator<=(const ObjcSelectorSlot& other) const {
    return std::tie(objcMethod,index)
             <= std::tie(other.objcMethod,other.index);
  }
  bool operator>(const ObjcSelectorSlot& other) const {
    return std::tie(objcMethod,index)
             > std::tie(other.objcMethod,other.index);
  }
  bool operator>=(const ObjcSelectorSlot& other) const {
    return std::tie(objcMethod,index)
             >= std::tie(other.objcMethod,other.index);
  }
  void outputRepr(Output<Repr<ObjcSelectorSlot>> out) const {
    outputValue(out, std::make_tuple(objcMethod, index));
  }
}; // struct ObjcSelectorSlot

struct ObjcSelector : Predicate<std::vector<std::string>> {
  static const char* GLEAN_name() {
    return "cxx1.ObjcSelector";
  }

  static constexpr size_t GLEAN_version() {
     return 5;
  }
}; // struct ObjcSelector

} // namespace Cxx1

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Cxx1::ObjcPropertyKind> {
  using Type = Enum<2>;
};


namespace schema {

namespace Cxx1 {

enum class ObjcPropertyKind { Synthesize, Dynamic };

struct ObjcPropertyImplementation : Predicate<std::tuple<Fact<ObjcPropertyDeclaration>, ObjcPropertyKind, boost::variant<Alt<0, std::tuple<>>, Alt<1, Fact<Name>>>, facebook::glean::cpp::schema::Src::Range>> {
  static const char* GLEAN_name() {
    return "cxx1.ObjcPropertyImplementation";
  }

  static constexpr size_t GLEAN_version() {
     return 5;
  }
}; // struct ObjcPropertyImplementation

struct ObjcPropertyIVar : Predicate<std::tuple<Fact<ObjcPropertyDeclaration>, Fact<VariableDeclaration>>> {
  static const char* GLEAN_name() {
    return "cxx1.ObjcPropertyIVar";
  }

  static constexpr size_t GLEAN_version() {
     return 5;
  }
}; // struct ObjcPropertyIVar

struct ObjcMethodDefinition : Predicate<Fact<ObjcMethodDeclaration>> {
  static const char* GLEAN_name() {
    return "cxx1.ObjcMethodDefinition";
  }

  static constexpr size_t GLEAN_version() {
     return 5;
  }
}; // struct ObjcMethodDefinition

struct ObjcMethodDeclarationName : Predicate<std::tuple<Fact<ObjcMethodDeclaration>, Fact<Name>>> {
  static const char* GLEAN_name() {
    return "cxx1.ObjcMethodDeclarationName";
  }

  static constexpr size_t GLEAN_version() {
     return 5;
  }
}; // struct ObjcMethodDeclarationName

struct ObjcInterfaceToImplementation : Predicate<std::tuple<Fact<ObjcContainerDeclaration>, Fact<ObjcContainerDeclaration>>> {
  static const char* GLEAN_name() {
    return "cxx1.ObjcInterfaceToImplementation";
  }

  static constexpr size_t GLEAN_version() {
     return 5;
  }
}; // struct ObjcInterfaceToImplementation

struct ObjcImplements : Predicate<std::tuple<Fact<ObjcContainerDeclaration>, Fact<ObjcContainerDeclaration>>> {
  static const char* GLEAN_name() {
    return "cxx1.ObjcImplements";
  }

  static constexpr size_t GLEAN_version() {
     return 5;
  }
}; // struct ObjcImplements

} // namespace Cxx1

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Cxx1::ObjcIVar> {
  using Type = Tuple<Bool, Maybe<Nat>>;
};


namespace schema {

namespace Cxx1 {

struct ObjcIVar {
  bool synthesize;
  boost::variant<Alt<0, std::tuple<>>, Alt<1, uint64_t>> bitsize;

  bool operator==(const ObjcIVar& other) const {
    return std::tie(synthesize,bitsize)
             == std::tie(other.synthesize,other.bitsize);
  }
  bool operator!=(const ObjcIVar& other) const {
    return std::tie(synthesize,bitsize)
             != std::tie(other.synthesize,other.bitsize);
  }
  bool operator<(const ObjcIVar& other) const {
    return std::tie(synthesize,bitsize)
             < std::tie(other.synthesize,other.bitsize);
  }
  bool operator<=(const ObjcIVar& other) const {
    return std::tie(synthesize,bitsize)
             <= std::tie(other.synthesize,other.bitsize);
  }
  bool operator>(const ObjcIVar& other) const {
    return std::tie(synthesize,bitsize)
             > std::tie(other.synthesize,other.bitsize);
  }
  bool operator>=(const ObjcIVar& other) const {
    return std::tie(synthesize,bitsize)
             >= std::tie(other.synthesize,other.bitsize);
  }
  void outputRepr(Output<Repr<ObjcIVar>> out) const {
    outputValue(out, std::make_tuple(synthesize, bitsize));
  }
}; // struct ObjcIVar

struct ObjcContainerInheritance : Predicate<std::tuple<Fact<ObjcContainerDeclaration>, Fact<ObjcContainerDeclaration>>> {
  static const char* GLEAN_name() {
    return "cxx1.ObjcContainerInheritance";
  }

  static constexpr size_t GLEAN_version() {
     return 5;
  }
}; // struct ObjcContainerInheritance

struct ObjcContainerDefinition : Predicate<std::tuple<Fact<ObjcContainerDeclaration>, std::vector<Fact<ObjcContainerDeclaration>>, Fact<Declarations>>> {
  static const char* GLEAN_name() {
    return "cxx1.ObjcContainerDefinition";
  }

  static constexpr size_t GLEAN_version() {
     return 5;
  }
}; // struct ObjcContainerDefinition

struct ObjcContainerBase : Predicate<std::tuple<Fact<ObjcContainerDeclaration>, Fact<ObjcContainerDeclaration>>> {
  static const char* GLEAN_name() {
    return "cxx1.ObjcContainerBase";
  }

  static constexpr size_t GLEAN_version() {
     return 5;
  }
}; // struct ObjcContainerBase

} // namespace Cxx1

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Cxx1::ObjcCategoryId> {
  using Type = Tuple<facebook::glean::cpp::schema::Cxx1::Name, facebook::glean::cpp::schema::Cxx1::Name>;
};


namespace schema {

namespace Cxx1 {

struct ObjcCategoryId {
  Fact<Name> className;
  Fact<Name> categoryName;

  bool operator==(const ObjcCategoryId& other) const {
    return std::tie(className,categoryName)
             == std::tie(other.className,other.categoryName);
  }
  bool operator!=(const ObjcCategoryId& other) const {
    return std::tie(className,categoryName)
             != std::tie(other.className,other.categoryName);
  }
  bool operator<(const ObjcCategoryId& other) const {
    return std::tie(className,categoryName)
             < std::tie(other.className,other.categoryName);
  }
  bool operator<=(const ObjcCategoryId& other) const {
    return std::tie(className,categoryName)
             <= std::tie(other.className,other.categoryName);
  }
  bool operator>(const ObjcCategoryId& other) const {
    return std::tie(className,categoryName)
             > std::tie(other.className,other.categoryName);
  }
  bool operator>=(const ObjcCategoryId& other) const {
    return std::tie(className,categoryName)
             >= std::tie(other.className,other.categoryName);
  }
  void outputRepr(Output<Repr<ObjcCategoryId>> out) const {
    outputValue(out, std::make_tuple(className, categoryName));
  }
}; // struct ObjcCategoryId

} // namespace Cxx1

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Cxx1::ObjcContainerId> {
  using Type = Sum<facebook::glean::cpp::schema::Cxx1::Name, facebook::glean::cpp::schema::Cxx1::Name, Repr<facebook::glean::cpp::schema::Cxx1::ObjcCategoryId>, facebook::glean::cpp::schema::Cxx1::Name, facebook::glean::cpp::schema::Cxx1::Name, Repr<facebook::glean::cpp::schema::Cxx1::ObjcCategoryId>>;
};


namespace schema {

namespace Cxx1 {

struct ObjcContainerId {
  boost::variant<Alt<0, Fact<Name>>, Alt<1, Fact<Name>>, Alt<2, ObjcCategoryId>, Alt<3, Fact<Name>>, Alt<4, Fact<Name>>, Alt<5, ObjcCategoryId>> GLEAN_value;

  static ObjcContainerId protocol(const Fact<Name>& a) {
    return ObjcContainerId{Alt<0, Fact<Name>>(a)};
  }
  static ObjcContainerId interface_(const Fact<Name>& a) {
    return ObjcContainerId{Alt<1, Fact<Name>>(a)};
  }
  static ObjcContainerId categoryInterface(const ObjcCategoryId& a) {
    return ObjcContainerId{Alt<2, ObjcCategoryId>(a)};
  }
  static ObjcContainerId extensionInterface(const Fact<Name>& a) {
    return ObjcContainerId{Alt<3, Fact<Name>>(a)};
  }
  static ObjcContainerId implementation(const Fact<Name>& a) {
    return ObjcContainerId{Alt<4, Fact<Name>>(a)};
  }
  static ObjcContainerId categoryImplementation(const ObjcCategoryId& a) {
    return ObjcContainerId{Alt<5, ObjcCategoryId>(a)};
  }

  bool operator==(const ObjcContainerId& other) const {
    return std::tie(GLEAN_value)
             == std::tie(other.GLEAN_value);
  }
  bool operator!=(const ObjcContainerId& other) const {
    return std::tie(GLEAN_value)
             != std::tie(other.GLEAN_value);
  }
  bool operator<(const ObjcContainerId& other) const {
    return std::tie(GLEAN_value)
             < std::tie(other.GLEAN_value);
  }
  bool operator<=(const ObjcContainerId& other) const {
    return std::tie(GLEAN_value)
             <= std::tie(other.GLEAN_value);
  }
  bool operator>(const ObjcContainerId& other) const {
    return std::tie(GLEAN_value)
             > std::tie(other.GLEAN_value);
  }
  bool operator>=(const ObjcContainerId& other) const {
    return std::tie(GLEAN_value)
             >= std::tie(other.GLEAN_value);
  }

  void outputRepr(Output<Repr<ObjcContainerId>> out) const {
    outputValue(out, GLEAN_value);
  }
}; // struct ObjcContainerId

struct ObjcContainerDeclaration : Predicate<std::tuple<ObjcContainerId, facebook::glean::cpp::schema::Src::Range>> {
  static const char* GLEAN_name() {
    return "cxx1.ObjcContainerDeclaration";
  }

  static constexpr size_t GLEAN_version() {
     return 5;
  }
}; // struct ObjcContainerDeclaration

struct ObjcMethodDeclaration : Predicate<std::tuple<Fact<ObjcSelector>, std::vector<facebook::glean::cpp::schema::Src::FileLocation>, ObjcContainerId, Fact<Signature>, bool, bool, bool, facebook::glean::cpp::schema::Src::Range>> {
  static const char* GLEAN_name() {
    return "cxx1.ObjcMethodDeclaration";
  }

  static constexpr size_t GLEAN_version() {
     return 5;
  }
}; // struct ObjcMethodDeclaration

struct ObjcPropertyDeclaration : Predicate<std::tuple<Fact<Name>, ObjcContainerId, Fact<Type>, bool, bool, bool, bool, facebook::glean::cpp::schema::Src::Range>> {
  static const char* GLEAN_name() {
    return "cxx1.ObjcPropertyDeclaration";
  }

  static constexpr size_t GLEAN_version() {
     return 5;
  }
}; // struct ObjcPropertyDeclaration

struct ObjContainerIdName : Predicate<std::tuple<ObjcContainerId, Fact<Name>>> {
  static const char* GLEAN_name() {
    return "cxx1.ObjContainerIdName";
  }

  static constexpr size_t GLEAN_version() {
     return 5;
  }
}; // struct ObjContainerIdName

} // namespace Cxx1

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Cxx1::NamespaceTarget> {
  using Type = Sum<facebook::glean::cpp::schema::Cxx1::NamespaceDeclaration, facebook::glean::cpp::schema::Cxx1::NamespaceAliasDeclaration>;
};


namespace schema {

namespace Cxx1 {

struct NamespaceTarget {
  boost::variant<Alt<0, Fact<NamespaceDeclaration>>, Alt<1, Fact<NamespaceAliasDeclaration>>> GLEAN_value;

  static NamespaceTarget namespace_(const Fact<NamespaceDeclaration>& a) {
    return NamespaceTarget{Alt<0, Fact<NamespaceDeclaration>>(a)};
  }
  static NamespaceTarget namespaceAlias(const Fact<NamespaceAliasDeclaration>& a) {
    return NamespaceTarget{Alt<1, Fact<NamespaceAliasDeclaration>>(a)};
  }

  bool operator==(const NamespaceTarget& other) const {
    return std::tie(GLEAN_value)
             == std::tie(other.GLEAN_value);
  }
  bool operator!=(const NamespaceTarget& other) const {
    return std::tie(GLEAN_value)
             != std::tie(other.GLEAN_value);
  }
  bool operator<(const NamespaceTarget& other) const {
    return std::tie(GLEAN_value)
             < std::tie(other.GLEAN_value);
  }
  bool operator<=(const NamespaceTarget& other) const {
    return std::tie(GLEAN_value)
             <= std::tie(other.GLEAN_value);
  }
  bool operator>(const NamespaceTarget& other) const {
    return std::tie(GLEAN_value)
             > std::tie(other.GLEAN_value);
  }
  bool operator>=(const NamespaceTarget& other) const {
    return std::tie(GLEAN_value)
             >= std::tie(other.GLEAN_value);
  }

  void outputRepr(Output<Repr<NamespaceTarget>> out) const {
    outputValue(out, GLEAN_value);
  }
}; // struct NamespaceTarget

struct NamespaceQName : Predicate<std::tuple<boost::variant<Alt<0, std::tuple<>>, Alt<1, Fact<Name>>>, boost::variant<Alt<0, std::tuple<>>, Alt<1, Fact<NamespaceQName>>>>> {
  static const char* GLEAN_name() {
    return "cxx1.NamespaceQName";
  }

  static constexpr size_t GLEAN_version() {
     return 5;
  }
}; // struct NamespaceQName

struct NamespaceDefinition : Predicate<std::tuple<Fact<NamespaceDeclaration>, Fact<Declarations>>> {
  static const char* GLEAN_name() {
    return "cxx1.NamespaceDefinition";
  }

  static constexpr size_t GLEAN_version() {
     return 5;
  }
}; // struct NamespaceDefinition

struct NamespaceDeclarationName : Predicate<std::tuple<Fact<NamespaceQName>, Fact<Name>>> {
  static const char* GLEAN_name() {
    return "cxx1.NamespaceDeclarationName";
  }

  static constexpr size_t GLEAN_version() {
     return 5;
  }
}; // struct NamespaceDeclarationName

struct NamespaceDeclaration : Predicate<std::tuple<Fact<NamespaceQName>, facebook::glean::cpp::schema::Src::Range>> {
  static const char* GLEAN_name() {
    return "cxx1.NamespaceDeclaration";
  }

  static constexpr size_t GLEAN_version() {
     return 5;
  }
}; // struct NamespaceDeclaration

struct NamespaceAliasDeclaration : Predicate<std::tuple<Fact<NamespaceQName>, NamespaceTarget, facebook::glean::cpp::schema::Src::Range>> {
  static const char* GLEAN_name() {
    return "cxx1.NamespaceAliasDeclaration";
  }

  static constexpr size_t GLEAN_version() {
     return 5;
  }
}; // struct NamespaceAliasDeclaration

struct Name : Predicate<std::string> {
  static const char* GLEAN_name() {
    return "cxx1.Name";
  }

  static constexpr size_t GLEAN_version() {
     return 5;
  }
}; // struct Name

} // namespace Cxx1

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Cxx1::MethodSignature> {
  using Type = Tuple<Bool, Bool, Bool, Repr<facebook::glean::cpp::schema::Cxx1::RefQualifier>>;
};


namespace schema {

namespace Cxx1 {

struct MethodSignature {
  bool isVirtual;
  bool isConst;
  bool isVolatile;
  RefQualifier refQualifier;

  bool operator==(const MethodSignature& other) const {
    return std::tie(isVirtual,isConst,isVolatile,refQualifier)
             == std::tie(other.isVirtual,other.isConst,other.isVolatile,other.refQualifier);
  }
  bool operator!=(const MethodSignature& other) const {
    return std::tie(isVirtual,isConst,isVolatile,refQualifier)
             != std::tie(other.isVirtual,other.isConst,other.isVolatile,other.refQualifier);
  }
  bool operator<(const MethodSignature& other) const {
    return std::tie(isVirtual,isConst,isVolatile,refQualifier)
             < std::tie(other.isVirtual,other.isConst,other.isVolatile,other.refQualifier);
  }
  bool operator<=(const MethodSignature& other) const {
    return std::tie(isVirtual,isConst,isVolatile,refQualifier)
             <= std::tie(other.isVirtual,other.isConst,other.isVolatile,other.refQualifier);
  }
  bool operator>(const MethodSignature& other) const {
    return std::tie(isVirtual,isConst,isVolatile,refQualifier)
             > std::tie(other.isVirtual,other.isConst,other.isVolatile,other.refQualifier);
  }
  bool operator>=(const MethodSignature& other) const {
    return std::tie(isVirtual,isConst,isVolatile,refQualifier)
             >= std::tie(other.isVirtual,other.isConst,other.isVolatile,other.refQualifier);
  }
  void outputRepr(Output<Repr<MethodSignature>> out) const {
    outputValue(out, std::make_tuple(isVirtual, isConst, isVolatile, refQualifier));
  }
}; // struct MethodSignature

struct MethodOverrides : Predicate<std::tuple<Fact<FunctionDeclaration>, Fact<FunctionDeclaration>>> {
  static const char* GLEAN_name() {
    return "cxx1.MethodOverrides";
  }

  static constexpr size_t GLEAN_version() {
     return 5;
  }
}; // struct MethodOverrides

struct MethodOverridden : Predicate<std::tuple<Fact<FunctionDeclaration>, Fact<FunctionDeclaration>>> {
  static const char* GLEAN_name() {
    return "cxx1.MethodOverridden";
  }

  static constexpr size_t GLEAN_version() {
     return 5;
  }
}; // struct MethodOverridden

} // namespace Cxx1

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Cxx1::MaybeIncludeTree> {
  using Type = Tuple<Maybe<facebook::glean::cpp::schema::Cxx1::IncludeTree>>;
};


namespace schema {

namespace Cxx1 {

struct MaybeIncludeTree {
  boost::variant<Alt<0, std::tuple<>>, Alt<1, Fact<IncludeTree>>> tree;

  bool operator==(const MaybeIncludeTree& other) const {
    return std::tie(tree)
             == std::tie(other.tree);
  }
  bool operator!=(const MaybeIncludeTree& other) const {
    return std::tie(tree)
             != std::tie(other.tree);
  }
  bool operator<(const MaybeIncludeTree& other) const {
    return std::tie(tree)
             < std::tie(other.tree);
  }
  bool operator<=(const MaybeIncludeTree& other) const {
    return std::tie(tree)
             <= std::tie(other.tree);
  }
  bool operator>(const MaybeIncludeTree& other) const {
    return std::tie(tree)
             > std::tie(other.tree);
  }
  bool operator>=(const MaybeIncludeTree& other) const {
    return std::tie(tree)
             >= std::tie(other.tree);
  }
  void outputRepr(Output<Repr<MaybeIncludeTree>> out) const {
    outputValue(out, std::make_tuple(tree));
  }
}; // struct MaybeIncludeTree

} // namespace Cxx1

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Cxx1::LocalVariableKind> {
  using Type = Enum<3>;
};


namespace schema {

namespace Cxx1 {

enum class LocalVariableKind { SimpleVariable, StaticVariable, Parameter };

} // namespace Cxx1

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Cxx1::LocalVariableAttribute> {
  using Type = Enum<2>;
};


namespace schema {

namespace Cxx1 {

enum class LocalVariableAttribute { Plain, Constexpr };

} // namespace Cxx1

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Cxx1::LocalVariable> {
  using Type = Tuple<Repr<facebook::glean::cpp::schema::Cxx1::LocalVariableKind>, Repr<facebook::glean::cpp::schema::Cxx1::LocalVariableAttribute>>;
};


namespace schema {

namespace Cxx1 {

struct LocalVariable {
  LocalVariableKind kind;
  LocalVariableAttribute attribute;

  bool operator==(const LocalVariable& other) const {
    return std::tie(kind,attribute)
             == std::tie(other.kind,other.attribute);
  }
  bool operator!=(const LocalVariable& other) const {
    return std::tie(kind,attribute)
             != std::tie(other.kind,other.attribute);
  }
  bool operator<(const LocalVariable& other) const {
    return std::tie(kind,attribute)
             < std::tie(other.kind,other.attribute);
  }
  bool operator<=(const LocalVariable& other) const {
    return std::tie(kind,attribute)
             <= std::tie(other.kind,other.attribute);
  }
  bool operator>(const LocalVariable& other) const {
    return std::tie(kind,attribute)
             > std::tie(other.kind,other.attribute);
  }
  bool operator>=(const LocalVariable& other) const {
    return std::tie(kind,attribute)
             >= std::tie(other.kind,other.attribute);
  }
  void outputRepr(Output<Repr<LocalVariable>> out) const {
    outputValue(out, std::make_tuple(kind, attribute));
  }
}; // struct LocalVariable

using LiteralOperator = std::string;

struct IncludeTree : Predicate<std::tuple<Fact<Trace>, std::vector<MaybeIncludeTree>>> {
  static const char* GLEAN_name() {
    return "cxx1.IncludeTree";
  }

  static constexpr size_t GLEAN_version() {
     return 5;
  }
}; // struct IncludeTree

} // namespace Cxx1

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Cxx1::IncludeTrace> {
  using Type = Tuple<facebook::glean::cpp::schema::Pp1::Include, Maybe<facebook::glean::cpp::schema::Cxx1::Trace>>;
};


namespace schema {

namespace Cxx1 {

struct IncludeTrace {
  Fact<facebook::glean::cpp::schema::Pp1::Include> include_;
  boost::variant<Alt<0, std::tuple<>>, Alt<1, Fact<Trace>>> trace;

  bool operator==(const IncludeTrace& other) const {
    return std::tie(include_,trace)
             == std::tie(other.include_,other.trace);
  }
  bool operator!=(const IncludeTrace& other) const {
    return std::tie(include_,trace)
             != std::tie(other.include_,other.trace);
  }
  bool operator<(const IncludeTrace& other) const {
    return std::tie(include_,trace)
             < std::tie(other.include_,other.trace);
  }
  bool operator<=(const IncludeTrace& other) const {
    return std::tie(include_,trace)
             <= std::tie(other.include_,other.trace);
  }
  bool operator>(const IncludeTrace& other) const {
    return std::tie(include_,trace)
             > std::tie(other.include_,other.trace);
  }
  bool operator>=(const IncludeTrace& other) const {
    return std::tie(include_,trace)
             >= std::tie(other.include_,other.trace);
  }
  void outputRepr(Output<Repr<IncludeTrace>> out) const {
    outputValue(out, std::make_tuple(include_, trace));
  }
}; // struct IncludeTrace

} // namespace Cxx1

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Cxx1::PPEvent> {
  using Type = Sum<Repr<facebook::glean::cpp::schema::Cxx1::IncludeTrace>, facebook::glean::cpp::schema::Pp1::Define, facebook::glean::cpp::schema::Pp1::Undef, facebook::glean::cpp::schema::Pp1::Use>;
};


namespace schema {

namespace Cxx1 {

struct PPEvent {
  boost::variant<Alt<0, IncludeTrace>, Alt<1, Fact<facebook::glean::cpp::schema::Pp1::Define>>, Alt<2, Fact<facebook::glean::cpp::schema::Pp1::Undef>>, Alt<3, Fact<facebook::glean::cpp::schema::Pp1::Use>>> GLEAN_value;

  static PPEvent include_(const IncludeTrace& a) {
    return PPEvent{Alt<0, IncludeTrace>(a)};
  }
  static PPEvent define(const Fact<facebook::glean::cpp::schema::Pp1::Define>& a) {
    return PPEvent{Alt<1, Fact<facebook::glean::cpp::schema::Pp1::Define>>(a)};
  }
  static PPEvent undef(const Fact<facebook::glean::cpp::schema::Pp1::Undef>& a) {
    return PPEvent{Alt<2, Fact<facebook::glean::cpp::schema::Pp1::Undef>>(a)};
  }
  static PPEvent use(const Fact<facebook::glean::cpp::schema::Pp1::Use>& a) {
    return PPEvent{Alt<3, Fact<facebook::glean::cpp::schema::Pp1::Use>>(a)};
  }

  bool operator==(const PPEvent& other) const {
    return std::tie(GLEAN_value)
             == std::tie(other.GLEAN_value);
  }
  bool operator!=(const PPEvent& other) const {
    return std::tie(GLEAN_value)
             != std::tie(other.GLEAN_value);
  }
  bool operator<(const PPEvent& other) const {
    return std::tie(GLEAN_value)
             < std::tie(other.GLEAN_value);
  }
  bool operator<=(const PPEvent& other) const {
    return std::tie(GLEAN_value)
             <= std::tie(other.GLEAN_value);
  }
  bool operator>(const PPEvent& other) const {
    return std::tie(GLEAN_value)
             > std::tie(other.GLEAN_value);
  }
  bool operator>=(const PPEvent& other) const {
    return std::tie(GLEAN_value)
             >= std::tie(other.GLEAN_value);
  }

  void outputRepr(Output<Repr<PPEvent>> out) const {
    outputValue(out, GLEAN_value);
  }
}; // struct PPEvent

struct PPTrace : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Src::File>, std::vector<PPEvent>>> {
  static const char* GLEAN_name() {
    return "cxx1.PPTrace";
  }

  static constexpr size_t GLEAN_version() {
     return 5;
  }
}; // struct PPTrace

} // namespace Cxx1

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Cxx1::GlobalVariableKind> {
  using Type = Enum<3>;
};


namespace schema {

namespace Cxx1 {

enum class GlobalVariableKind { SimpleVariable, StaticVariable, StaticMember };

} // namespace Cxx1

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Cxx1::GlobalVariableAttribute> {
  using Type = Enum<3>;
};


namespace schema {

namespace Cxx1 {

enum class GlobalVariableAttribute { Plain, Inline, Constexpr };

} // namespace Cxx1

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Cxx1::GlobalVariable> {
  using Type = Tuple<Repr<facebook::glean::cpp::schema::Cxx1::GlobalVariableKind>, Repr<facebook::glean::cpp::schema::Cxx1::GlobalVariableAttribute>, Bool>;
};


namespace schema {

namespace Cxx1 {

struct GlobalVariable {
  GlobalVariableKind kind;
  GlobalVariableAttribute attribute;
  bool definition;

  bool operator==(const GlobalVariable& other) const {
    return std::tie(kind,attribute,definition)
             == std::tie(other.kind,other.attribute,other.definition);
  }
  bool operator!=(const GlobalVariable& other) const {
    return std::tie(kind,attribute,definition)
             != std::tie(other.kind,other.attribute,other.definition);
  }
  bool operator<(const GlobalVariable& other) const {
    return std::tie(kind,attribute,definition)
             < std::tie(other.kind,other.attribute,other.definition);
  }
  bool operator<=(const GlobalVariable& other) const {
    return std::tie(kind,attribute,definition)
             <= std::tie(other.kind,other.attribute,other.definition);
  }
  bool operator>(const GlobalVariable& other) const {
    return std::tie(kind,attribute,definition)
             > std::tie(other.kind,other.attribute,other.definition);
  }
  bool operator>=(const GlobalVariable& other) const {
    return std::tie(kind,attribute,definition)
             >= std::tie(other.kind,other.attribute,other.definition);
  }
  void outputRepr(Output<Repr<GlobalVariable>> out) const {
    outputValue(out, std::make_tuple(kind, attribute, definition));
  }
}; // struct GlobalVariable

struct FunctionDefinition : Predicate<std::tuple<Fact<FunctionDeclaration>, bool>> {
  static const char* GLEAN_name() {
    return "cxx1.FunctionDefinition";
  }

  static constexpr size_t GLEAN_version() {
     return 5;
  }
}; // struct FunctionDefinition

struct FunctionDeclarationNameString : Predicate<std::tuple<Fact<FunctionName>, std::string>> {
  static const char* GLEAN_name() {
    return "cxx1.FunctionDeclarationNameString";
  }

  static constexpr size_t GLEAN_version() {
     return 5;
  }
}; // struct FunctionDeclarationNameString

struct FunctionDeclarationName : Predicate<std::tuple<Fact<FunctionName>, Fact<Name>>> {
  static const char* GLEAN_name() {
    return "cxx1.FunctionDeclarationName";
  }

  static constexpr size_t GLEAN_version() {
     return 5;
  }
}; // struct FunctionDeclarationName

struct FunctionDeclaration : Predicate<std::tuple<Fact<FunctionQName>, Fact<Signature>, boost::variant<Alt<0, std::tuple<>>, Alt<1, MethodSignature>>, facebook::glean::cpp::schema::Src::Range>> {
  static const char* GLEAN_name() {
    return "cxx1.FunctionDeclaration";
  }

  static constexpr size_t GLEAN_version() {
     return 5;
  }
}; // struct FunctionDeclaration

struct FunctionDeclAttribute : Predicate<std::tuple<Fact<FunctionDeclaration>, Fact<Attribute>>> {
  static const char* GLEAN_name() {
    return "cxx1.FunctionDeclAttribute";
  }

  static constexpr size_t GLEAN_version() {
     return 5;
  }
}; // struct FunctionDeclAttribute

struct FunctionAttribute : Predicate<std::tuple<Fact<Attribute>, Fact<FunctionDeclaration>>> {
  static const char* GLEAN_name() {
    return "cxx1.FunctionAttribute";
  }

  static constexpr size_t GLEAN_version() {
     return 5;
  }
}; // struct FunctionAttribute

} // namespace Cxx1

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Cxx1::From> {
  using Type = Tuple<Repr<facebook::glean::cpp::schema::Src::PackedByteSpans>, Repr<facebook::glean::cpp::schema::Src::PackedByteSpans>, Repr<facebook::glean::cpp::schema::Src::PackedByteSpans>>;
};


namespace schema {

namespace Cxx1 {

struct From {
  facebook::glean::cpp::schema::Src::PackedByteSpans spans;
  facebook::glean::cpp::schema::Src::PackedByteSpans expansions;
  facebook::glean::cpp::schema::Src::PackedByteSpans spellings;

  bool operator==(const From& other) const {
    return std::tie(spans,expansions,spellings)
             == std::tie(other.spans,other.expansions,other.spellings);
  }
  bool operator!=(const From& other) const {
    return std::tie(spans,expansions,spellings)
             != std::tie(other.spans,other.expansions,other.spellings);
  }
  bool operator<(const From& other) const {
    return std::tie(spans,expansions,spellings)
             < std::tie(other.spans,other.expansions,other.spellings);
  }
  bool operator<=(const From& other) const {
    return std::tie(spans,expansions,spellings)
             <= std::tie(other.spans,other.expansions,other.spellings);
  }
  bool operator>(const From& other) const {
    return std::tie(spans,expansions,spellings)
             > std::tie(other.spans,other.expansions,other.spellings);
  }
  bool operator>=(const From& other) const {
    return std::tie(spans,expansions,spellings)
             >= std::tie(other.spans,other.expansions,other.spellings);
  }
  void outputRepr(Output<Repr<From>> out) const {
    outputValue(out, std::make_tuple(spans, expansions, spellings));
  }
}; // struct From

struct FileXRefs : Predicate<std::tuple<Fact<FileXRefMap>, std::vector<Fact<XRefTargets>>>> {
  static const char* GLEAN_name() {
    return "cxx1.FileXRefs";
  }

  static constexpr size_t GLEAN_version() {
     return 5;
  }
}; // struct FileXRefs

struct FilePPUseXRefs : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Src::File>, facebook::glean::cpp::schema::Src::Range, Fact<facebook::glean::cpp::schema::Pp1::Define>>> {
  static const char* GLEAN_name() {
    return "cxx1.FilePPUseXRefs";
  }

  static constexpr size_t GLEAN_version() {
     return 5;
  }
}; // struct FilePPUseXRefs

struct FilePPUseTraceXRefs : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Src::File>, Fact<Trace>, facebook::glean::cpp::schema::Src::Range, Fact<facebook::glean::cpp::schema::Pp1::Define>>> {
  static const char* GLEAN_name() {
    return "cxx1.FilePPUseTraceXRefs";
  }

  static constexpr size_t GLEAN_version() {
     return 5;
  }
}; // struct FilePPUseTraceXRefs

struct FilePPTraceXRefs : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Src::File>, Fact<Trace>, facebook::glean::cpp::schema::Src::Range, PpEntity, facebook::glean::cpp::schema::Src::ByteSpan>> {
  static const char* GLEAN_name() {
    return "cxx1.FilePPTraceXRefs";
  }

  static constexpr size_t GLEAN_version() {
     return 5;
  }
}; // struct FilePPTraceXRefs

} // namespace Cxx1

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Cxx1::Field> {
  using Type = Tuple<Bool, Maybe<Nat>>;
};


namespace schema {

namespace Cxx1 {

struct Field {
  bool mutable_;
  boost::variant<Alt<0, std::tuple<>>, Alt<1, uint64_t>> bitsize;

  bool operator==(const Field& other) const {
    return std::tie(mutable_,bitsize)
             == std::tie(other.mutable_,other.bitsize);
  }
  bool operator!=(const Field& other) const {
    return std::tie(mutable_,bitsize)
             != std::tie(other.mutable_,other.bitsize);
  }
  bool operator<(const Field& other) const {
    return std::tie(mutable_,bitsize)
             < std::tie(other.mutable_,other.bitsize);
  }
  bool operator<=(const Field& other) const {
    return std::tie(mutable_,bitsize)
             <= std::tie(other.mutable_,other.bitsize);
  }
  bool operator>(const Field& other) const {
    return std::tie(mutable_,bitsize)
             > std::tie(other.mutable_,other.bitsize);
  }
  bool operator>=(const Field& other) const {
    return std::tie(mutable_,bitsize)
             >= std::tie(other.mutable_,other.bitsize);
  }
  void outputRepr(Output<Repr<Field>> out) const {
    outputValue(out, std::make_tuple(mutable_, bitsize));
  }
}; // struct Field

} // namespace Cxx1

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Cxx1::VariableKind> {
  using Type = Sum<Repr<facebook::glean::cpp::schema::Cxx1::GlobalVariable>, Repr<facebook::glean::cpp::schema::Cxx1::LocalVariable>, Repr<facebook::glean::cpp::schema::Cxx1::Field>, Repr<facebook::glean::cpp::schema::Cxx1::ObjcIVar>>;
};


namespace schema {

namespace Cxx1 {

struct VariableKind {
  boost::variant<Alt<0, GlobalVariable>, Alt<1, LocalVariable>, Alt<2, Field>, Alt<3, ObjcIVar>> GLEAN_value;

  static VariableKind global_(const GlobalVariable& a) {
    return VariableKind{Alt<0, GlobalVariable>(a)};
  }
  static VariableKind local(const LocalVariable& a) {
    return VariableKind{Alt<1, LocalVariable>(a)};
  }
  static VariableKind field(const Field& a) {
    return VariableKind{Alt<2, Field>(a)};
  }
  static VariableKind ivar(const ObjcIVar& a) {
    return VariableKind{Alt<3, ObjcIVar>(a)};
  }

  bool operator==(const VariableKind& other) const {
    return std::tie(GLEAN_value)
             == std::tie(other.GLEAN_value);
  }
  bool operator!=(const VariableKind& other) const {
    return std::tie(GLEAN_value)
             != std::tie(other.GLEAN_value);
  }
  bool operator<(const VariableKind& other) const {
    return std::tie(GLEAN_value)
             < std::tie(other.GLEAN_value);
  }
  bool operator<=(const VariableKind& other) const {
    return std::tie(GLEAN_value)
             <= std::tie(other.GLEAN_value);
  }
  bool operator>(const VariableKind& other) const {
    return std::tie(GLEAN_value)
             > std::tie(other.GLEAN_value);
  }
  bool operator>=(const VariableKind& other) const {
    return std::tie(GLEAN_value)
             >= std::tie(other.GLEAN_value);
  }

  void outputRepr(Output<Repr<VariableKind>> out) const {
    outputValue(out, GLEAN_value);
  }
}; // struct VariableKind

struct VariableDeclaration : Predicate<std::tuple<Fact<QName>, Fact<Type>, VariableKind, facebook::glean::cpp::schema::Src::Range>> {
  static const char* GLEAN_name() {
    return "cxx1.VariableDeclaration";
  }

  static constexpr size_t GLEAN_version() {
     return 5;
  }
}; // struct VariableDeclaration

struct EnumeratorInEnum : Predicate<std::tuple<Fact<Enumerator>, Fact<EnumDefinition>>> {
  static const char* GLEAN_name() {
    return "cxx1.EnumeratorInEnum";
  }

  static constexpr size_t GLEAN_version() {
     return 5;
  }
}; // struct EnumeratorInEnum

struct Enumerator : Predicate<std::tuple<Fact<Name>, Fact<EnumDeclaration>, facebook::glean::cpp::schema::Src::Range>> {
  static const char* GLEAN_name() {
    return "cxx1.Enumerator";
  }

  static constexpr size_t GLEAN_version() {
     return 5;
  }
}; // struct Enumerator

struct EnumDefinition : Predicate<std::tuple<Fact<EnumDeclaration>, std::vector<Fact<Enumerator>>>> {
  static const char* GLEAN_name() {
    return "cxx1.EnumDefinition";
  }

  static constexpr size_t GLEAN_version() {
     return 5;
  }
}; // struct EnumDefinition

struct EnumDeclaration : Predicate<std::tuple<Fact<QName>, bool, boost::variant<Alt<0, std::tuple<>>, Alt<1, Fact<Type>>>, facebook::glean::cpp::schema::Src::Range>> {
  static const char* GLEAN_name() {
    return "cxx1.EnumDeclaration";
  }

  static constexpr size_t GLEAN_version() {
     return 5;
  }
}; // struct EnumDeclaration

} // namespace Cxx1

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Cxx1::DefinitionEntity> {
  using Type = Sum<facebook::glean::cpp::schema::Cxx1::RecordDefinition, facebook::glean::cpp::schema::Cxx1::FunctionDefinition, facebook::glean::cpp::schema::Cxx1::EnumDefinition, facebook::glean::cpp::schema::Cxx1::ObjcMethodDefinition, facebook::glean::cpp::schema::Cxx1::ObjcContainerDefinition, facebook::glean::cpp::schema::Cxx1::VariableDeclaration, facebook::glean::cpp::schema::Cxx1::NamespaceDefinition>;
};


namespace schema {

namespace Cxx1 {

struct DefinitionEntity {
  boost::variant<Alt<0, Fact<RecordDefinition>>, Alt<1, Fact<FunctionDefinition>>, Alt<2, Fact<EnumDefinition>>, Alt<3, Fact<ObjcMethodDefinition>>, Alt<4, Fact<ObjcContainerDefinition>>, Alt<5, Fact<VariableDeclaration>>, Alt<6, Fact<NamespaceDefinition>>> GLEAN_value;

  static DefinitionEntity record_(const Fact<RecordDefinition>& a) {
    return DefinitionEntity{Alt<0, Fact<RecordDefinition>>(a)};
  }
  static DefinitionEntity function_(const Fact<FunctionDefinition>& a) {
    return DefinitionEntity{Alt<1, Fact<FunctionDefinition>>(a)};
  }
  static DefinitionEntity enum_(const Fact<EnumDefinition>& a) {
    return DefinitionEntity{Alt<2, Fact<EnumDefinition>>(a)};
  }
  static DefinitionEntity objcMethod(const Fact<ObjcMethodDefinition>& a) {
    return DefinitionEntity{Alt<3, Fact<ObjcMethodDefinition>>(a)};
  }
  static DefinitionEntity objcContainer(const Fact<ObjcContainerDefinition>& a) {
    return DefinitionEntity{Alt<4, Fact<ObjcContainerDefinition>>(a)};
  }
  static DefinitionEntity variable(const Fact<VariableDeclaration>& a) {
    return DefinitionEntity{Alt<5, Fact<VariableDeclaration>>(a)};
  }
  static DefinitionEntity namespace_(const Fact<NamespaceDefinition>& a) {
    return DefinitionEntity{Alt<6, Fact<NamespaceDefinition>>(a)};
  }

  bool operator==(const DefinitionEntity& other) const {
    return std::tie(GLEAN_value)
             == std::tie(other.GLEAN_value);
  }
  bool operator!=(const DefinitionEntity& other) const {
    return std::tie(GLEAN_value)
             != std::tie(other.GLEAN_value);
  }
  bool operator<(const DefinitionEntity& other) const {
    return std::tie(GLEAN_value)
             < std::tie(other.GLEAN_value);
  }
  bool operator<=(const DefinitionEntity& other) const {
    return std::tie(GLEAN_value)
             <= std::tie(other.GLEAN_value);
  }
  bool operator>(const DefinitionEntity& other) const {
    return std::tie(GLEAN_value)
             > std::tie(other.GLEAN_value);
  }
  bool operator>=(const DefinitionEntity& other) const {
    return std::tie(GLEAN_value)
             >= std::tie(other.GLEAN_value);
  }

  void outputRepr(Output<Repr<DefinitionEntity>> out) const {
    outputValue(out, GLEAN_value);
  }
}; // struct DefinitionEntity

struct DefnInRecord : Predicate<std::tuple<DefinitionEntity, Fact<RecordDefinition>>> {
  static const char* GLEAN_name() {
    return "cxx1.DefnInRecord";
  }

  static constexpr size_t GLEAN_version() {
     return 5;
  }
}; // struct DefnInRecord

} // namespace Cxx1

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Cxx1::Declaration> {
  using Type = Sum<facebook::glean::cpp::schema::Cxx1::NamespaceDeclaration, facebook::glean::cpp::schema::Cxx1::UsingDeclaration, facebook::glean::cpp::schema::Cxx1::UsingDirective, facebook::glean::cpp::schema::Cxx1::RecordDeclaration, facebook::glean::cpp::schema::Cxx1::EnumDeclaration, facebook::glean::cpp::schema::Cxx1::FunctionDeclaration, facebook::glean::cpp::schema::Cxx1::VariableDeclaration, facebook::glean::cpp::schema::Cxx1::ObjcContainerDeclaration, facebook::glean::cpp::schema::Cxx1::ObjcMethodDeclaration, facebook::glean::cpp::schema::Cxx1::ObjcPropertyDeclaration, facebook::glean::cpp::schema::Cxx1::TypeAliasDeclaration, facebook::glean::cpp::schema::Cxx1::NamespaceAliasDeclaration>;
};


namespace schema {

namespace Cxx1 {

struct Declaration {
  boost::variant<Alt<0, Fact<NamespaceDeclaration>>, Alt<1, Fact<UsingDeclaration>>, Alt<2, Fact<UsingDirective>>, Alt<3, Fact<RecordDeclaration>>, Alt<4, Fact<EnumDeclaration>>, Alt<5, Fact<FunctionDeclaration>>, Alt<6, Fact<VariableDeclaration>>, Alt<7, Fact<ObjcContainerDeclaration>>, Alt<8, Fact<ObjcMethodDeclaration>>, Alt<9, Fact<ObjcPropertyDeclaration>>, Alt<10, Fact<TypeAliasDeclaration>>, Alt<11, Fact<NamespaceAliasDeclaration>>> GLEAN_value;

  static Declaration namespace_(const Fact<NamespaceDeclaration>& a) {
    return Declaration{Alt<0, Fact<NamespaceDeclaration>>(a)};
  }
  static Declaration usingDeclaration(const Fact<UsingDeclaration>& a) {
    return Declaration{Alt<1, Fact<UsingDeclaration>>(a)};
  }
  static Declaration usingDirective(const Fact<UsingDirective>& a) {
    return Declaration{Alt<2, Fact<UsingDirective>>(a)};
  }
  static Declaration record_(const Fact<RecordDeclaration>& a) {
    return Declaration{Alt<3, Fact<RecordDeclaration>>(a)};
  }
  static Declaration enum_(const Fact<EnumDeclaration>& a) {
    return Declaration{Alt<4, Fact<EnumDeclaration>>(a)};
  }
  static Declaration function_(const Fact<FunctionDeclaration>& a) {
    return Declaration{Alt<5, Fact<FunctionDeclaration>>(a)};
  }
  static Declaration variable(const Fact<VariableDeclaration>& a) {
    return Declaration{Alt<6, Fact<VariableDeclaration>>(a)};
  }
  static Declaration objcContainer(const Fact<ObjcContainerDeclaration>& a) {
    return Declaration{Alt<7, Fact<ObjcContainerDeclaration>>(a)};
  }
  static Declaration objcMethod(const Fact<ObjcMethodDeclaration>& a) {
    return Declaration{Alt<8, Fact<ObjcMethodDeclaration>>(a)};
  }
  static Declaration objcProperty(const Fact<ObjcPropertyDeclaration>& a) {
    return Declaration{Alt<9, Fact<ObjcPropertyDeclaration>>(a)};
  }
  static Declaration typeAlias(const Fact<TypeAliasDeclaration>& a) {
    return Declaration{Alt<10, Fact<TypeAliasDeclaration>>(a)};
  }
  static Declaration namespaceAlias(const Fact<NamespaceAliasDeclaration>& a) {
    return Declaration{Alt<11, Fact<NamespaceAliasDeclaration>>(a)};
  }

  bool operator==(const Declaration& other) const {
    return std::tie(GLEAN_value)
             == std::tie(other.GLEAN_value);
  }
  bool operator!=(const Declaration& other) const {
    return std::tie(GLEAN_value)
             != std::tie(other.GLEAN_value);
  }
  bool operator<(const Declaration& other) const {
    return std::tie(GLEAN_value)
             < std::tie(other.GLEAN_value);
  }
  bool operator<=(const Declaration& other) const {
    return std::tie(GLEAN_value)
             <= std::tie(other.GLEAN_value);
  }
  bool operator>(const Declaration& other) const {
    return std::tie(GLEAN_value)
             > std::tie(other.GLEAN_value);
  }
  bool operator>=(const Declaration& other) const {
    return std::tie(GLEAN_value)
             >= std::tie(other.GLEAN_value);
  }

  void outputRepr(Output<Repr<Declaration>> out) const {
    outputValue(out, GLEAN_value);
  }
}; // struct Declaration

struct DeclarationComment : Predicate<std::tuple<Declaration, Fact<facebook::glean::cpp::schema::Src::File>, facebook::glean::cpp::schema::Src::ByteSpan>> {
  static const char* GLEAN_name() {
    return "cxx1.DeclarationComment";
  }

  static constexpr size_t GLEAN_version() {
     return 5;
  }
}; // struct DeclarationComment

struct DeclarationInTrace : Predicate<std::tuple<Declaration, Fact<Trace>>> {
  static const char* GLEAN_name() {
    return "cxx1.DeclarationInTrace";
  }

  static constexpr size_t GLEAN_version() {
     return 5;
  }
}; // struct DeclarationInTrace

struct DeclarationLocationName : Predicate<std::tuple<Declaration, facebook::glean::cpp::schema::Src::Range, std::string>> {
  static const char* GLEAN_name() {
    return "cxx1.DeclarationLocationName";
  }

  static constexpr size_t GLEAN_version() {
     return 5;
  }
}; // struct DeclarationLocationName

struct DeclarationLocationNameSpan : Predicate<std::tuple<Declaration, facebook::glean::cpp::schema::Src::Range, std::string, Fact<facebook::glean::cpp::schema::Src::File>, facebook::glean::cpp::schema::Src::ByteSpan>> {
  static const char* GLEAN_name() {
    return "cxx1.DeclarationLocationNameSpan";
  }

  static constexpr size_t GLEAN_version() {
     return 5;
  }
}; // struct DeclarationLocationNameSpan

struct DeclarationNameSpan : Predicate<std::tuple<Declaration, Fact<facebook::glean::cpp::schema::Src::File>, facebook::glean::cpp::schema::Src::ByteSpan>> {
  static const char* GLEAN_name() {
    return "cxx1.DeclarationNameSpan";
  }

  static constexpr size_t GLEAN_version() {
     return 5;
  }
}; // struct DeclarationNameSpan

struct DeclarationSources : Predicate<std::tuple<Declaration, std::vector<Declaration>>> {
  static const char* GLEAN_name() {
    return "cxx1.DeclarationSources";
  }

  static constexpr size_t GLEAN_version() {
     return 5;
  }
}; // struct DeclarationSources

struct DeclarationSrcRange : Predicate<std::tuple<Declaration, facebook::glean::cpp::schema::Src::Range>> {
  static const char* GLEAN_name() {
    return "cxx1.DeclarationSrcRange";
  }

  static constexpr size_t GLEAN_version() {
     return 5;
  }
}; // struct DeclarationSrcRange

struct DeclarationTargets : Predicate<std::tuple<Declaration, std::vector<Declaration>>> {
  static const char* GLEAN_name() {
    return "cxx1.DeclarationTargets";
  }

  static constexpr size_t GLEAN_version() {
     return 5;
  }
}; // struct DeclarationTargets

struct DeclarationToUSR : Predicate<std::tuple<Declaration, USR>> {
  static const char* GLEAN_name() {
    return "cxx1.DeclarationToUSR";
  }

  static constexpr size_t GLEAN_version() {
     return 5;
  }
}; // struct DeclarationToUSR

struct Declarations : Predicate<std::vector<Declaration>> {
  static const char* GLEAN_name() {
    return "cxx1.Declarations";
  }

  static constexpr size_t GLEAN_version() {
     return 5;
  }
}; // struct Declarations

struct DefToBaseDecl : Predicate<std::tuple<DefinitionEntity, Declaration>> {
  static const char* GLEAN_name() {
    return "cxx1.DefToBaseDecl";
  }

  static constexpr size_t GLEAN_version() {
     return 5;
  }
}; // struct DefToBaseDecl

struct Same : Predicate<std::tuple<Declaration, Declaration>> {
  static const char* GLEAN_name() {
    return "cxx1.Same";
  }

  static constexpr size_t GLEAN_version() {
     return 5;
  }
}; // struct Same

struct USRToDeclaration : Predicate<std::tuple<USR, Declaration>> {
  static const char* GLEAN_name() {
    return "cxx1.USRToDeclaration";
  }

  static constexpr size_t GLEAN_version() {
     return 5;
  }
}; // struct USRToDeclaration

} // namespace Cxx1

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Cxx1::XRefTarget> {
  using Type = Sum<Repr<facebook::glean::cpp::schema::Cxx1::Declaration>, facebook::glean::cpp::schema::Cxx1::Enumerator, facebook::glean::cpp::schema::Cxx1::ObjcSelector, Repr<facebook::glean::cpp::schema::Cxx1::ObjcSelectorSlot>, Repr<facebook::glean::cpp::schema::Src::Loc>, facebook::glean::cpp::schema::Cxx1::XRefIndirectTarget>;
};


namespace schema {

namespace Cxx1 {

struct XRefTarget {
  boost::variant<Alt<0, Declaration>, Alt<1, Fact<Enumerator>>, Alt<2, Fact<ObjcSelector>>, Alt<3, ObjcSelectorSlot>, Alt<4, facebook::glean::cpp::schema::Src::Loc>, Alt<5, Fact<XRefIndirectTarget>>> GLEAN_value;

  static XRefTarget declaration(const Declaration& a) {
    return XRefTarget{Alt<0, Declaration>(a)};
  }
  static XRefTarget enumerator(const Fact<Enumerator>& a) {
    return XRefTarget{Alt<1, Fact<Enumerator>>(a)};
  }
  static XRefTarget objcSelector(const Fact<ObjcSelector>& a) {
    return XRefTarget{Alt<2, Fact<ObjcSelector>>(a)};
  }
  static XRefTarget objcSelectorSlot(const ObjcSelectorSlot& a) {
    return XRefTarget{Alt<3, ObjcSelectorSlot>(a)};
  }
  static XRefTarget unknown(const facebook::glean::cpp::schema::Src::Loc& a) {
    return XRefTarget{Alt<4, facebook::glean::cpp::schema::Src::Loc>(a)};
  }
  static XRefTarget indirect(const Fact<XRefIndirectTarget>& a) {
    return XRefTarget{Alt<5, Fact<XRefIndirectTarget>>(a)};
  }

  bool operator==(const XRefTarget& other) const {
    return std::tie(GLEAN_value)
             == std::tie(other.GLEAN_value);
  }
  bool operator!=(const XRefTarget& other) const {
    return std::tie(GLEAN_value)
             != std::tie(other.GLEAN_value);
  }
  bool operator<(const XRefTarget& other) const {
    return std::tie(GLEAN_value)
             < std::tie(other.GLEAN_value);
  }
  bool operator<=(const XRefTarget& other) const {
    return std::tie(GLEAN_value)
             <= std::tie(other.GLEAN_value);
  }
  bool operator>(const XRefTarget& other) const {
    return std::tie(GLEAN_value)
             > std::tie(other.GLEAN_value);
  }
  bool operator>=(const XRefTarget& other) const {
    return std::tie(GLEAN_value)
             >= std::tie(other.GLEAN_value);
  }

  void outputRepr(Output<Repr<XRefTarget>> out) const {
    outputValue(out, GLEAN_value);
  }
}; // struct XRefTarget

} // namespace Cxx1

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Cxx1::FixedXRef> {
  using Type = Tuple<Repr<facebook::glean::cpp::schema::Cxx1::XRefTarget>, Repr<facebook::glean::cpp::schema::Cxx1::From>>;
};


namespace schema {

namespace Cxx1 {

struct FixedXRef {
  XRefTarget target;
  From from;

  bool operator==(const FixedXRef& other) const {
    return std::tie(target,from)
             == std::tie(other.target,other.from);
  }
  bool operator!=(const FixedXRef& other) const {
    return std::tie(target,from)
             != std::tie(other.target,other.from);
  }
  bool operator<(const FixedXRef& other) const {
    return std::tie(target,from)
             < std::tie(other.target,other.from);
  }
  bool operator<=(const FixedXRef& other) const {
    return std::tie(target,from)
             <= std::tie(other.target,other.from);
  }
  bool operator>(const FixedXRef& other) const {
    return std::tie(target,from)
             > std::tie(other.target,other.from);
  }
  bool operator>=(const FixedXRef& other) const {
    return std::tie(target,from)
             >= std::tie(other.target,other.from);
  }
  void outputRepr(Output<Repr<FixedXRef>> out) const {
    outputValue(out, std::make_tuple(target, from));
  }
}; // struct FixedXRef

struct FileXRefMap : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Src::File>, std::vector<FixedXRef>, std::vector<From>>> {
  static const char* GLEAN_name() {
    return "cxx1.FileXRefMap";
  }

  static constexpr size_t GLEAN_version() {
     return 5;
  }
}; // struct FileXRefMap

struct SpellingXRef : Predicate<std::tuple<facebook::glean::cpp::schema::Src::FileLocation, XRefTarget>> {
  static const char* GLEAN_name() {
    return "cxx1.SpellingXRef";
  }

  static constexpr size_t GLEAN_version() {
     return 5;
  }
}; // struct SpellingXRef

struct TargetUses : Predicate<std::tuple<XRefTarget, Fact<facebook::glean::cpp::schema::Src::File>, From>> {
  static const char* GLEAN_name() {
    return "cxx1.TargetUses";
  }

  static constexpr size_t GLEAN_version() {
     return 5;
  }
}; // struct TargetUses

struct XRefIndirectTarget : Predicate<std::tuple<XRefVia, XRefTarget>> {
  static const char* GLEAN_name() {
    return "cxx1.XRefIndirectTarget";
  }

  static constexpr size_t GLEAN_version() {
     return 5;
  }
}; // struct XRefIndirectTarget

struct XRefTargets : Predicate<std::vector<XRefTarget>> {
  static const char* GLEAN_name() {
    return "cxx1.XRefTargets";
  }

  static constexpr size_t GLEAN_version() {
     return 5;
  }
}; // struct XRefTargets

} // namespace Cxx1

namespace Search {

namespace Cxx {

struct GlobalDeclarationWithName : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Cxx1::Name>, facebook::glean::cpp::schema::Cxx1::Declaration>> {
  static const char* GLEAN_name() {
    return "search.cxx.GlobalDeclarationWithName";
  }

  static constexpr size_t GLEAN_version() {
     return 5;
  }
}; // struct GlobalDeclarationWithName

} // namespace Cxx

} // namespace Search

namespace Symbolid {

namespace Cxx {

struct LookupNamespaceDeclaration : Predicate<std::tuple<boost::variant<Alt<0, std::tuple<>>, Alt<1, Fact<facebook::glean::cpp::schema::Cxx1::Name>>>, boost::variant<Alt<0, std::tuple<>>, Alt<1, Fact<facebook::glean::cpp::schema::Cxx1::NamespaceQName>>>, facebook::glean::cpp::schema::Cxx1::Declaration>> {
  static const char* GLEAN_name() {
    return "symbolid.cxx.LookupNamespaceDeclaration";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct LookupNamespaceDeclaration

} // namespace Cxx

} // namespace Symbolid

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Thrift::Cpp2Item> {
  using Type = Sum<facebook::glean::cpp::schema::Src::File, Repr<facebook::glean::cpp::schema::Cxx1::Declaration>, Repr<facebook::glean::cpp::schema::Thrift::Cpp2ItemNamed>>;
};


namespace schema {

namespace Thrift {

struct Cpp2Item {
  boost::variant<Alt<0, Fact<facebook::glean::cpp::schema::Src::File>>, Alt<1, facebook::glean::cpp::schema::Cxx1::Declaration>, Alt<2, Cpp2ItemNamed>> GLEAN_value;

  static Cpp2Item file(const Fact<facebook::glean::cpp::schema::Src::File>& a) {
    return Cpp2Item{Alt<0, Fact<facebook::glean::cpp::schema::Src::File>>(a)};
  }
  static Cpp2Item decl(const facebook::glean::cpp::schema::Cxx1::Declaration& a) {
    return Cpp2Item{Alt<1, facebook::glean::cpp::schema::Cxx1::Declaration>(a)};
  }
  static Cpp2Item named(const Cpp2ItemNamed& a) {
    return Cpp2Item{Alt<2, Cpp2ItemNamed>(a)};
  }

  bool operator==(const Cpp2Item& other) const {
    return std::tie(GLEAN_value)
             == std::tie(other.GLEAN_value);
  }
  bool operator!=(const Cpp2Item& other) const {
    return std::tie(GLEAN_value)
             != std::tie(other.GLEAN_value);
  }
  bool operator<(const Cpp2Item& other) const {
    return std::tie(GLEAN_value)
             < std::tie(other.GLEAN_value);
  }
  bool operator<=(const Cpp2Item& other) const {
    return std::tie(GLEAN_value)
             <= std::tie(other.GLEAN_value);
  }
  bool operator>(const Cpp2Item& other) const {
    return std::tie(GLEAN_value)
             > std::tie(other.GLEAN_value);
  }
  bool operator>=(const Cpp2Item& other) const {
    return std::tie(GLEAN_value)
             >= std::tie(other.GLEAN_value);
  }

  void outputRepr(Output<Repr<Cpp2Item>> out) const {
    outputValue(out, GLEAN_value);
  }
}; // struct Cpp2Item

struct FromCpp2 : Predicate<std::tuple<Cpp2Item, Item, GenRole>> {
  static const char* GLEAN_name() {
    return "thrift.FromCpp2";
  }

  static constexpr size_t GLEAN_version() {
     return 7;
  }
}; // struct FromCpp2

} // namespace Thrift

namespace Cxx1 {

struct DeclToFamily : Predicate<std::tuple<Declaration, Fact<DeclFamily>>> {
  static const char* GLEAN_name() {
    return "cxx1.DeclToFamily";
  }

  static constexpr size_t GLEAN_version() {
     return 5;
  }
}; // struct DeclToFamily

} // namespace Cxx1

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Cxx1::DeclKind> {
  using Type = Enum<14>;
};


namespace schema {

namespace Cxx1 {

enum class DeclKind { namespace_, usingDeclaration, usingDirective, record_, enum_, enumerator, function_, variable, objcContainer, objcMethod, objcProperty, typeAlias, namespaceAlias, macro };

struct DeclInRecord : Predicate<std::tuple<Declaration, Fact<RecordDefinition>>> {
  static const char* GLEAN_name() {
    return "cxx1.DeclInRecord";
  }

  static constexpr size_t GLEAN_version() {
     return 5;
  }
}; // struct DeclInRecord

struct DeclInObjcContainer : Predicate<std::tuple<Declaration, Fact<ObjcContainerDefinition>>> {
  static const char* GLEAN_name() {
    return "cxx1.DeclInObjcContainer";
  }

  static constexpr size_t GLEAN_version() {
     return 5;
  }
}; // struct DeclInObjcContainer

} // namespace Cxx1

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Cxx1::DeclIdent> {
  using Type = Sum<facebook::glean::cpp::schema::Cxx1::Name, facebook::glean::cpp::schema::Pp1::Macro, facebook::glean::cpp::schema::Cxx1::ObjcSelector>;
};


namespace schema {

namespace Cxx1 {

struct DeclIdent {
  boost::variant<Alt<0, Fact<Name>>, Alt<1, Fact<facebook::glean::cpp::schema::Pp1::Macro>>, Alt<2, Fact<ObjcSelector>>> GLEAN_value;

  static DeclIdent name(const Fact<Name>& a) {
    return DeclIdent{Alt<0, Fact<Name>>(a)};
  }
  static DeclIdent macro(const Fact<facebook::glean::cpp::schema::Pp1::Macro>& a) {
    return DeclIdent{Alt<1, Fact<facebook::glean::cpp::schema::Pp1::Macro>>(a)};
  }
  static DeclIdent selector(const Fact<ObjcSelector>& a) {
    return DeclIdent{Alt<2, Fact<ObjcSelector>>(a)};
  }

  bool operator==(const DeclIdent& other) const {
    return std::tie(GLEAN_value)
             == std::tie(other.GLEAN_value);
  }
  bool operator!=(const DeclIdent& other) const {
    return std::tie(GLEAN_value)
             != std::tie(other.GLEAN_value);
  }
  bool operator<(const DeclIdent& other) const {
    return std::tie(GLEAN_value)
             < std::tie(other.GLEAN_value);
  }
  bool operator<=(const DeclIdent& other) const {
    return std::tie(GLEAN_value)
             <= std::tie(other.GLEAN_value);
  }
  bool operator>(const DeclIdent& other) const {
    return std::tie(GLEAN_value)
             > std::tie(other.GLEAN_value);
  }
  bool operator>=(const DeclIdent& other) const {
    return std::tie(GLEAN_value)
             >= std::tie(other.GLEAN_value);
  }

  void outputRepr(Output<Repr<DeclIdent>> out) const {
    outputValue(out, GLEAN_value);
  }
}; // struct DeclIdent

struct DeclFamilyOf : Predicate<std::tuple<Declaration, Declaration>> {
  static const char* GLEAN_name() {
    return "cxx1.DeclFamilyOf";
  }

  static constexpr size_t GLEAN_version() {
     return 5;
  }
}; // struct DeclFamilyOf

struct DeclFamily : Predicate<std::vector<Declaration>> {
  static const char* GLEAN_name() {
    return "cxx1.DeclFamily";
  }

  static constexpr size_t GLEAN_version() {
     return 5;
  }
}; // struct DeclFamily

struct DeclByName : Predicate<std::tuple<std::string, DeclKind, DeclIdent>> {
  static const char* GLEAN_name() {
    return "cxx1.DeclByName";
  }

  static constexpr size_t GLEAN_version() {
     return 5;
  }
}; // struct DeclByName

struct CxxToThrift : Predicate<std::tuple<XRefTarget, facebook::glean::cpp::schema::Fbthrift::Declaration>> {
  static const char* GLEAN_name() {
    return "cxx1.CxxToThrift";
  }

  static constexpr size_t GLEAN_version() {
     return 5;
  }
}; // struct CxxToThrift

struct Attribute : Predicate<std::string> {
  static const char* GLEAN_name() {
    return "cxx1.Attribute";
  }

  static constexpr size_t GLEAN_version() {
     return 5;
  }
}; // struct Attribute

} // namespace Cxx1

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Cxx1::Access> {
  using Type = Enum<3>;
};


namespace schema {

namespace Cxx1 {

enum class Access { Public, Protected, Private };

} // namespace Cxx1

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Cxx1::RecordBase> {
  using Type = Tuple<facebook::glean::cpp::schema::Cxx1::RecordDeclaration, Repr<facebook::glean::cpp::schema::Cxx1::Access>, Bool>;
};


namespace schema {

namespace Cxx1 {

struct RecordBase {
  Fact<RecordDeclaration> base;
  Access access;
  bool isVirtual;

  bool operator==(const RecordBase& other) const {
    return std::tie(base,access,isVirtual)
             == std::tie(other.base,other.access,other.isVirtual);
  }
  bool operator!=(const RecordBase& other) const {
    return std::tie(base,access,isVirtual)
             != std::tie(other.base,other.access,other.isVirtual);
  }
  bool operator<(const RecordBase& other) const {
    return std::tie(base,access,isVirtual)
             < std::tie(other.base,other.access,other.isVirtual);
  }
  bool operator<=(const RecordBase& other) const {
    return std::tie(base,access,isVirtual)
             <= std::tie(other.base,other.access,other.isVirtual);
  }
  bool operator>(const RecordBase& other) const {
    return std::tie(base,access,isVirtual)
             > std::tie(other.base,other.access,other.isVirtual);
  }
  bool operator>=(const RecordBase& other) const {
    return std::tie(base,access,isVirtual)
             >= std::tie(other.base,other.access,other.isVirtual);
  }
  void outputRepr(Output<Repr<RecordBase>> out) const {
    outputValue(out, std::make_tuple(base, access, isVirtual));
  }
}; // struct RecordBase

struct RecordDefinition : Predicate<std::tuple<Fact<RecordDeclaration>, std::vector<RecordBase>, Fact<Declarations>>> {
  static const char* GLEAN_name() {
    return "cxx1.RecordDefinition";
  }

  static constexpr size_t GLEAN_version() {
     return 5;
  }
}; // struct RecordDefinition

} // namespace Cxx1

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Csharp::Variance> {
  using Type = Enum<3>;
};


namespace schema {

namespace Csharp {

enum class Variance { In, None_, Out };

} // namespace Csharp

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Csharp::UnityPackageType> {
  using Type = Enum<9>;
};


namespace schema {

namespace Csharp {

enum class UnityPackageType { Undefined, ThirdParty, Core, Runtime, Modules, Worlds, Apps, Clones, TestPackages };

struct UnityPackageToProject : Predicate<std::tuple<Fact<UnityPackage>, Fact<Project>>> {
  static const char* GLEAN_name() {
    return "csharp.UnityPackageToProject";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct UnityPackageToProject

struct UnityPackage : Predicate<std::tuple<UnityPackageType, std::string>> {
  static const char* GLEAN_name() {
    return "csharp.UnityPackage";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct UnityPackage

} // namespace Csharp

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Csharp::UnityAssemblyType> {
  using Type = Enum<7>;
};


namespace schema {

namespace Csharp {

enum class UnityAssemblyType { Package, Editor, Tests, TestsEditor, UnitTests, Internal, AllApis };

struct UnityProjectSource : Predicate<std::tuple<std::string, Fact<UnityPackage>, UnityAssemblyType, Fact<facebook::glean::cpp::schema::Src::File>>> {
  static const char* GLEAN_name() {
    return "csharp.UnityProjectSource";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct UnityProjectSource

struct TypeParameter : Predicate<std::tuple<Fact<Name>, boost::variant<Alt<0, std::tuple<>>, Alt<1, Variance>>, bool, bool, bool>> {
  static const char* GLEAN_name() {
    return "csharp.TypeParameter";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct TypeParameter

struct SourceFileToProject : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Src::File>, Fact<Project>>> {
  static const char* GLEAN_name() {
    return "csharp.SourceFileToProject";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct SourceFileToProject

struct SolutionToProject : Predicate<std::tuple<Fact<Solution>, Fact<Project>>> {
  static const char* GLEAN_name() {
    return "csharp.SolutionToProject";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct SolutionToProject

struct Solution : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Src::File>>> {
  static const char* GLEAN_name() {
    return "csharp.Solution";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct Solution

} // namespace Csharp

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Csharp::RefKind> {
  using Type = Enum<5>;
};


namespace schema {

namespace Csharp {

enum class RefKind { In, None_, Out, Ref, RefReadOnly };

struct ProjectToSourceFile : Predicate<std::tuple<Fact<Project>, Fact<facebook::glean::cpp::schema::Src::File>>> {
  static const char* GLEAN_name() {
    return "csharp.ProjectToSourceFile";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct ProjectToSourceFile

struct ProjectToSolution : Predicate<std::tuple<Fact<Project>, Fact<Solution>>> {
  static const char* GLEAN_name() {
    return "csharp.ProjectToSolution";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct ProjectToSolution

} // namespace Csharp

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Csharp::ProjectSource> {
  using Type = Sum<facebook::glean::cpp::schema::Csharp::UnityProjectSource, facebook::glean::cpp::schema::Csharp::MSBuildProjectSource>;
};


namespace schema {

namespace Csharp {

struct ProjectSource {
  boost::variant<Alt<0, Fact<UnityProjectSource>>, Alt<1, Fact<MSBuildProjectSource>>> GLEAN_value;

  static ProjectSource unityProjectSource(const Fact<UnityProjectSource>& a) {
    return ProjectSource{Alt<0, Fact<UnityProjectSource>>(a)};
  }
  static ProjectSource msbuildProjectSource(const Fact<MSBuildProjectSource>& a) {
    return ProjectSource{Alt<1, Fact<MSBuildProjectSource>>(a)};
  }

  bool operator==(const ProjectSource& other) const {
    return std::tie(GLEAN_value)
             == std::tie(other.GLEAN_value);
  }
  bool operator!=(const ProjectSource& other) const {
    return std::tie(GLEAN_value)
             != std::tie(other.GLEAN_value);
  }
  bool operator<(const ProjectSource& other) const {
    return std::tie(GLEAN_value)
             < std::tie(other.GLEAN_value);
  }
  bool operator<=(const ProjectSource& other) const {
    return std::tie(GLEAN_value)
             <= std::tie(other.GLEAN_value);
  }
  bool operator>(const ProjectSource& other) const {
    return std::tie(GLEAN_value)
             > std::tie(other.GLEAN_value);
  }
  bool operator>=(const ProjectSource& other) const {
    return std::tie(GLEAN_value)
             >= std::tie(other.GLEAN_value);
  }

  void outputRepr(Output<Repr<ProjectSource>> out) const {
    outputValue(out, GLEAN_value);
  }
}; // struct ProjectSource

struct Project : Predicate<std::tuple<ProjectSource, boost::variant<Alt<0, std::tuple<>>, Alt<1, std::string>>, boost::variant<Alt<0, std::tuple<>>, Alt<1, std::string>>, boost::variant<Alt<0, std::tuple<>>, Alt<1, std::string>>, boost::variant<Alt<0, std::tuple<>>, Alt<1, std::string>>, boost::variant<Alt<0, std::tuple<>>, Alt<1, std::string>>, boost::variant<Alt<0, std::tuple<>>, Alt<1, std::string>>>> {
  static const char* GLEAN_name() {
    return "csharp.Project";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct Project

struct Namespace : Predicate<std::tuple<Fact<Name>, boost::variant<Alt<0, std::tuple<>>, Alt<1, Fact<Namespace>>>>> {
  static const char* GLEAN_name() {
    return "csharp.Namespace";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct Namespace

} // namespace Csharp

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Csharp::NamedType> {
  using Type = Sum<facebook::glean::cpp::schema::Csharp::Class, facebook::glean::cpp::schema::Csharp::Interface, facebook::glean::cpp::schema::Csharp::Record, facebook::glean::cpp::schema::Csharp::Struct>;
};


namespace schema {

namespace Csharp {

struct NamedType {
  boost::variant<Alt<0, Fact<Class>>, Alt<1, Fact<Interface>>, Alt<2, Fact<Record>>, Alt<3, Fact<Struct>>> GLEAN_value;

  static NamedType class_(const Fact<Class>& a) {
    return NamedType{Alt<0, Fact<Class>>(a)};
  }
  static NamedType interface_(const Fact<Interface>& a) {
    return NamedType{Alt<1, Fact<Interface>>(a)};
  }
  static NamedType record_(const Fact<Record>& a) {
    return NamedType{Alt<2, Fact<Record>>(a)};
  }
  static NamedType struct_(const Fact<Struct>& a) {
    return NamedType{Alt<3, Fact<Struct>>(a)};
  }

  bool operator==(const NamedType& other) const {
    return std::tie(GLEAN_value)
             == std::tie(other.GLEAN_value);
  }
  bool operator!=(const NamedType& other) const {
    return std::tie(GLEAN_value)
             != std::tie(other.GLEAN_value);
  }
  bool operator<(const NamedType& other) const {
    return std::tie(GLEAN_value)
             < std::tie(other.GLEAN_value);
  }
  bool operator<=(const NamedType& other) const {
    return std::tie(GLEAN_value)
             <= std::tie(other.GLEAN_value);
  }
  bool operator>(const NamedType& other) const {
    return std::tie(GLEAN_value)
             > std::tie(other.GLEAN_value);
  }
  bool operator>=(const NamedType& other) const {
    return std::tie(GLEAN_value)
             >= std::tie(other.GLEAN_value);
  }

  void outputRepr(Output<Repr<NamedType>> out) const {
    outputValue(out, GLEAN_value);
  }
}; // struct NamedType

struct NameLowerCase : Predicate<std::tuple<std::string, Fact<Name>>> {
  static const char* GLEAN_name() {
    return "csharp.NameLowerCase";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct NameLowerCase

struct Name : Predicate<std::string> {
  static const char* GLEAN_name() {
    return "csharp.Name";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct Name

} // namespace Csharp

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Csharp::MethodKind> {
  using Type = Enum<21>;
};


namespace schema {

namespace Csharp {

enum class MethodKind { AnonymousFunction, BuiltinOperator, Constructor, Conversion, DeclareMethod, DelegateInvoke, Destructor, EventAdd, EventRaise, EventRemove, ExplicitInterfaceImplementation, FunctionPointerSignature, LambdaMethod, LocalFunction, Ordinary, PropertyGet, PropertySet, ReducedExtension, SharedConstructor, StaticConstructor, UserDefinedOperator };

} // namespace Csharp

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Csharp::MethodInvocationExpression> {
  using Type = Tuple<facebook::glean::cpp::schema::Csharp::MemberAccessLocation>;
};


namespace schema {

namespace Csharp {

struct MethodInvocationExpression {
  Fact<MemberAccessLocation> memberAccess;

  bool operator==(const MethodInvocationExpression& other) const {
    return std::tie(memberAccess)
             == std::tie(other.memberAccess);
  }
  bool operator!=(const MethodInvocationExpression& other) const {
    return std::tie(memberAccess)
             != std::tie(other.memberAccess);
  }
  bool operator<(const MethodInvocationExpression& other) const {
    return std::tie(memberAccess)
             < std::tie(other.memberAccess);
  }
  bool operator<=(const MethodInvocationExpression& other) const {
    return std::tie(memberAccess)
             <= std::tie(other.memberAccess);
  }
  bool operator>(const MethodInvocationExpression& other) const {
    return std::tie(memberAccess)
             > std::tie(other.memberAccess);
  }
  bool operator>=(const MethodInvocationExpression& other) const {
    return std::tie(memberAccess)
             >= std::tie(other.memberAccess);
  }
  void outputRepr(Output<Repr<MethodInvocationExpression>> out) const {
    outputValue(out, std::make_tuple(memberAccess));
  }
}; // struct MethodInvocationExpression

} // namespace Csharp

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Csharp::MemberAccessExpression> {
  using Type = Sum<facebook::glean::cpp::schema::Csharp::Local, facebook::glean::cpp::schema::Csharp::Parameter, facebook::glean::cpp::schema::Csharp::Field, facebook::glean::cpp::schema::Csharp::Property, facebook::glean::cpp::schema::Csharp::Method>;
};


namespace schema {

namespace Csharp {

struct MemberAccessExpression {
  boost::variant<Alt<0, Fact<Local>>, Alt<1, Fact<Parameter>>, Alt<2, Fact<Field>>, Alt<3, Fact<Property>>, Alt<4, Fact<Method>>> GLEAN_value;

  static MemberAccessExpression local(const Fact<Local>& a) {
    return MemberAccessExpression{Alt<0, Fact<Local>>(a)};
  }
  static MemberAccessExpression parameter(const Fact<Parameter>& a) {
    return MemberAccessExpression{Alt<1, Fact<Parameter>>(a)};
  }
  static MemberAccessExpression field(const Fact<Field>& a) {
    return MemberAccessExpression{Alt<2, Fact<Field>>(a)};
  }
  static MemberAccessExpression property(const Fact<Property>& a) {
    return MemberAccessExpression{Alt<3, Fact<Property>>(a)};
  }
  static MemberAccessExpression method(const Fact<Method>& a) {
    return MemberAccessExpression{Alt<4, Fact<Method>>(a)};
  }

  bool operator==(const MemberAccessExpression& other) const {
    return std::tie(GLEAN_value)
             == std::tie(other.GLEAN_value);
  }
  bool operator!=(const MemberAccessExpression& other) const {
    return std::tie(GLEAN_value)
             != std::tie(other.GLEAN_value);
  }
  bool operator<(const MemberAccessExpression& other) const {
    return std::tie(GLEAN_value)
             < std::tie(other.GLEAN_value);
  }
  bool operator<=(const MemberAccessExpression& other) const {
    return std::tie(GLEAN_value)
             <= std::tie(other.GLEAN_value);
  }
  bool operator>(const MemberAccessExpression& other) const {
    return std::tie(GLEAN_value)
             > std::tie(other.GLEAN_value);
  }
  bool operator>=(const MemberAccessExpression& other) const {
    return std::tie(GLEAN_value)
             >= std::tie(other.GLEAN_value);
  }

  void outputRepr(Output<Repr<MemberAccessExpression>> out) const {
    outputValue(out, GLEAN_value);
  }
}; // struct MemberAccessExpression

struct MSBuildProjectSource : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Src::File>>> {
  static const char* GLEAN_name() {
    return "csharp.MSBuildProjectSource";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct MSBuildProjectSource

} // namespace Csharp

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Csharp::Location> {
  using Type = Tuple<Repr<facebook::glean::cpp::schema::Src::FileLocation>, facebook::glean::cpp::schema::Src::FileLines>;
};


namespace schema {

namespace Csharp {

struct Location {
  facebook::glean::cpp::schema::Src::FileLocation fileLocation;
  Fact<facebook::glean::cpp::schema::Src::FileLines> fileLines;

  bool operator==(const Location& other) const {
    return std::tie(fileLocation,fileLines)
             == std::tie(other.fileLocation,other.fileLines);
  }
  bool operator!=(const Location& other) const {
    return std::tie(fileLocation,fileLines)
             != std::tie(other.fileLocation,other.fileLines);
  }
  bool operator<(const Location& other) const {
    return std::tie(fileLocation,fileLines)
             < std::tie(other.fileLocation,other.fileLines);
  }
  bool operator<=(const Location& other) const {
    return std::tie(fileLocation,fileLines)
             <= std::tie(other.fileLocation,other.fileLines);
  }
  bool operator>(const Location& other) const {
    return std::tie(fileLocation,fileLines)
             > std::tie(other.fileLocation,other.fileLines);
  }
  bool operator>=(const Location& other) const {
    return std::tie(fileLocation,fileLines)
             >= std::tie(other.fileLocation,other.fileLines);
  }
  void outputRepr(Output<Repr<Location>> out) const {
    outputValue(out, std::make_tuple(fileLocation, fileLines));
  }
}; // struct Location

struct MemberAccessLocation : Predicate<std::tuple<MemberAccessExpression, Location>> {
  static const char* GLEAN_name() {
    return "csharp.MemberAccessLocation";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct MemberAccessLocation

struct MethodInvocationLocation : Predicate<std::tuple<Fact<Method>, Location, boost::variant<Alt<0, std::tuple<>>, Alt<1, MethodInvocationExpression>>>> {
  static const char* GLEAN_name() {
    return "csharp.MethodInvocationLocation";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct MethodInvocationLocation

struct Implements : Predicate<std::tuple<NamedType, Fact<Interface>>> {
  static const char* GLEAN_name() {
    return "csharp.Implements";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct Implements

struct FunctionPointerType : Predicate<std::tuple<Fact<FullName>, Fact<Method>>> {
  static const char* GLEAN_name() {
    return "csharp.FunctionPointerType";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct FunctionPointerType

struct FullName : Predicate<std::tuple<Fact<Name>, Fact<Namespace>>> {
  static const char* GLEAN_name() {
    return "csharp.FullName";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct FullName

} // namespace Csharp

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Csharp::Accessibility> {
  using Type = Enum<10>;
};


namespace schema {

namespace Csharp {

enum class Accessibility { Friend, Internal, NotApplicable, Private, Protected, ProtectedAndFriend, ProtectedAndInternal, ProtectedOrFriend, ProtectedOrInternal, Public };

struct Class : Predicate<std::tuple<Fact<FullName>, boost::variant<Alt<0, std::tuple<>>, Alt<1, Fact<Class>>>, std::vector<Fact<TypeParameter>>, boost::variant<Alt<0, std::tuple<>>, Alt<1, NamedType>>, Accessibility, bool, bool, bool>> {
  static const char* GLEAN_name() {
    return "csharp.Class";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct Class

struct Interface : Predicate<std::tuple<Fact<FullName>, std::vector<Fact<TypeParameter>>, boost::variant<Alt<0, std::tuple<>>, Alt<1, NamedType>>, Accessibility, bool>> {
  static const char* GLEAN_name() {
    return "csharp.Interface";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct Interface

struct Record : Predicate<std::tuple<Fact<FullName>, boost::variant<Alt<0, std::tuple<>>, Alt<1, Fact<Record>>>, std::vector<Fact<TypeParameter>>, boost::variant<Alt<0, std::tuple<>>, Alt<1, NamedType>>, Accessibility, bool, bool>> {
  static const char* GLEAN_name() {
    return "csharp.Record";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct Record

struct Struct : Predicate<std::tuple<Fact<FullName>, std::vector<Fact<TypeParameter>>, boost::variant<Alt<0, std::tuple<>>, Alt<1, NamedType>>, Accessibility>> {
  static const char* GLEAN_name() {
    return "csharp.Struct";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct Struct

} // namespace Csharp

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Csharp::AType> {
  using Type = Sum<facebook::glean::cpp::schema::Csharp::ArrayType, Repr<facebook::glean::cpp::schema::Csharp::NamedType>, facebook::glean::cpp::schema::Csharp::FunctionPointerType, facebook::glean::cpp::schema::Csharp::PointerType, facebook::glean::cpp::schema::Csharp::TypeParameter>;
};


namespace schema {

namespace Csharp {

struct AType {
  boost::variant<Alt<0, Fact<ArrayType>>, Alt<1, NamedType>, Alt<2, Fact<FunctionPointerType>>, Alt<3, Fact<PointerType>>, Alt<4, Fact<TypeParameter>>> GLEAN_value;

  static AType arrayType(const Fact<ArrayType>& a) {
    return AType{Alt<0, Fact<ArrayType>>(a)};
  }
  static AType namedType(const NamedType& a) {
    return AType{Alt<1, NamedType>(a)};
  }
  static AType functionPointerType(const Fact<FunctionPointerType>& a) {
    return AType{Alt<2, Fact<FunctionPointerType>>(a)};
  }
  static AType pointerType(const Fact<PointerType>& a) {
    return AType{Alt<3, Fact<PointerType>>(a)};
  }
  static AType typeParameter(const Fact<TypeParameter>& a) {
    return AType{Alt<4, Fact<TypeParameter>>(a)};
  }

  bool operator==(const AType& other) const {
    return std::tie(GLEAN_value)
             == std::tie(other.GLEAN_value);
  }
  bool operator!=(const AType& other) const {
    return std::tie(GLEAN_value)
             != std::tie(other.GLEAN_value);
  }
  bool operator<(const AType& other) const {
    return std::tie(GLEAN_value)
             < std::tie(other.GLEAN_value);
  }
  bool operator<=(const AType& other) const {
    return std::tie(GLEAN_value)
             <= std::tie(other.GLEAN_value);
  }
  bool operator>(const AType& other) const {
    return std::tie(GLEAN_value)
             > std::tie(other.GLEAN_value);
  }
  bool operator>=(const AType& other) const {
    return std::tie(GLEAN_value)
             >= std::tie(other.GLEAN_value);
  }

  void outputRepr(Output<Repr<AType>> out) const {
    outputValue(out, GLEAN_value);
  }
}; // struct AType

struct ArrayType : Predicate<std::tuple<AType, uint8_t>> {
  static const char* GLEAN_name() {
    return "csharp.ArrayType";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct ArrayType

} // namespace Csharp

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Csharp::Definition> {
  using Type = Sum<Repr<facebook::glean::cpp::schema::Csharp::AType>, facebook::glean::cpp::schema::Csharp::Method, facebook::glean::cpp::schema::Csharp::Field, facebook::glean::cpp::schema::Csharp::Parameter, facebook::glean::cpp::schema::Csharp::TypeParameter, facebook::glean::cpp::schema::Csharp::Local, facebook::glean::cpp::schema::Csharp::Property>;
};


namespace schema {

namespace Csharp {

struct Definition {
  boost::variant<Alt<0, AType>, Alt<1, Fact<Method>>, Alt<2, Fact<Field>>, Alt<3, Fact<Parameter>>, Alt<4, Fact<TypeParameter>>, Alt<5, Fact<Local>>, Alt<6, Fact<Property>>> GLEAN_value;

  static Definition type(const AType& a) {
    return Definition{Alt<0, AType>(a)};
  }
  static Definition method(const Fact<Method>& a) {
    return Definition{Alt<1, Fact<Method>>(a)};
  }
  static Definition field(const Fact<Field>& a) {
    return Definition{Alt<2, Fact<Field>>(a)};
  }
  static Definition parameter(const Fact<Parameter>& a) {
    return Definition{Alt<3, Fact<Parameter>>(a)};
  }
  static Definition typeParameter(const Fact<TypeParameter>& a) {
    return Definition{Alt<4, Fact<TypeParameter>>(a)};
  }
  static Definition local(const Fact<Local>& a) {
    return Definition{Alt<5, Fact<Local>>(a)};
  }
  static Definition property(const Fact<Property>& a) {
    return Definition{Alt<6, Fact<Property>>(a)};
  }

  bool operator==(const Definition& other) const {
    return std::tie(GLEAN_value)
             == std::tie(other.GLEAN_value);
  }
  bool operator!=(const Definition& other) const {
    return std::tie(GLEAN_value)
             != std::tie(other.GLEAN_value);
  }
  bool operator<(const Definition& other) const {
    return std::tie(GLEAN_value)
             < std::tie(other.GLEAN_value);
  }
  bool operator<=(const Definition& other) const {
    return std::tie(GLEAN_value)
             <= std::tie(other.GLEAN_value);
  }
  bool operator>(const Definition& other) const {
    return std::tie(GLEAN_value)
             > std::tie(other.GLEAN_value);
  }
  bool operator>=(const Definition& other) const {
    return std::tie(GLEAN_value)
             >= std::tie(other.GLEAN_value);
  }

  void outputRepr(Output<Repr<Definition>> out) const {
    outputValue(out, GLEAN_value);
  }
}; // struct Definition

struct DefinitionLocation : Predicate<std::tuple<Definition, Location>> {
  static const char* GLEAN_name() {
    return "csharp.DefinitionLocation";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct DefinitionLocation

struct DefinitionLocationName : Predicate<std::tuple<Definition, Fact<facebook::glean::cpp::schema::Src::File>, facebook::glean::cpp::schema::Src::ByteSpan, std::string>> {
  static const char* GLEAN_name() {
    return "csharp.DefinitionLocationName";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct DefinitionLocationName

struct FileDefinitions : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Src::File>, Definition>> {
  static const char* GLEAN_name() {
    return "csharp.FileDefinitions";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct FileDefinitions

struct FileEntityXRefs : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Src::File>, facebook::glean::cpp::schema::Src::ByteSpan, Definition>> {
  static const char* GLEAN_name() {
    return "csharp.FileEntityXRefs";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct FileEntityXRefs

struct SearchByName : Predicate<std::tuple<Fact<Name>, Definition>> {
  static const char* GLEAN_name() {
    return "csharp.SearchByName";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct SearchByName

struct Field : Predicate<std::tuple<Fact<Name>, AType, NamedType, Accessibility, bool, bool, bool>> {
  static const char* GLEAN_name() {
    return "csharp.Field";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct Field

struct Local : Predicate<std::tuple<Fact<Name>, AType, Fact<Method>, RefKind, bool>> {
  static const char* GLEAN_name() {
    return "csharp.Local";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct Local

struct Method : Predicate<std::tuple<Fact<Name>, NamedType, std::vector<Fact<TypeParameter>>, std::vector<Fact<Parameter>>, bool, AType, Accessibility>> {
  static const char* GLEAN_name() {
    return "csharp.Method";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct Method

struct ObjectCreationLocation : Predicate<std::tuple<AType, Fact<Method>, Location>> {
  static const char* GLEAN_name() {
    return "csharp.ObjectCreationLocation";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct ObjectCreationLocation

struct Parameter : Predicate<std::tuple<Fact<Name>, AType, RefKind, bool, bool, bool>> {
  static const char* GLEAN_name() {
    return "csharp.Parameter";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct Parameter

struct PointerType : Predicate<std::tuple<AType>> {
  static const char* GLEAN_name() {
    return "csharp.PointerType";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct PointerType

struct Property : Predicate<std::tuple<Fact<Name>, NamedType, AType, std::vector<Fact<Parameter>>, boost::variant<Alt<0, std::tuple<>>, Alt<1, Fact<Method>>>, boost::variant<Alt<0, std::tuple<>>, Alt<1, Fact<Method>>>, bool, bool>> {
  static const char* GLEAN_name() {
    return "csharp.Property";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct Property

struct TypeLocation : Predicate<std::tuple<AType, Location>> {
  static const char* GLEAN_name() {
    return "csharp.TypeLocation";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct TypeLocation

} // namespace Csharp

namespace Contbuild {

struct Owner : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Src::File>, Fact<ContbuildLocator>>> {
  static const char* GLEAN_name() {
    return "contbuild.Owner";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct Owner

struct IndexerName : Predicate<std::string> {
  static const char* GLEAN_name() {
    return "contbuild.IndexerName";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct IndexerName

struct FileToContbuild : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Src::File>, Fact<ContbuildName>>> {
  static const char* GLEAN_name() {
    return "contbuild.FileToContbuild";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct FileToContbuild

} // namespace Contbuild

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Contbuild::FailureReason> {
  using Type = Enum<3>;
};


namespace schema {

namespace Contbuild {

enum class FailureReason { ParseError, Skipped, Blocked };

struct IndexFailure : Predicate<std::tuple<Fact<ContbuildName>, Fact<IndexerName>, FailureReason, std::string>> {
  static const char* GLEAN_name() {
    return "contbuild.IndexFailure";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct IndexFailure

struct ContbuildName : Predicate<std::string> {
  static const char* GLEAN_name() {
    return "contbuild.ContbuildName";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct ContbuildName

struct ContbuildLocator : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Buck::Locator>, Fact<ContbuildName>>> {
  static const char* GLEAN_name() {
    return "contbuild.ContbuildLocator";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct ContbuildLocator

struct ContbuildFbpkg : Predicate<std::tuple<std::string, Fact<ContbuildName>>> {
  static const char* GLEAN_name() {
    return "contbuild.ContbuildFbpkg";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct ContbuildFbpkg

} // namespace Contbuild

namespace Configerator {

struct ImportFilesStatement : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Python::ImportStatement>, bool>> {
  static const char* GLEAN_name() {
    return "configerator.ImportFilesStatement";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct ImportFilesStatement

} // namespace Configerator

namespace Codexref {

struct SymbolName : Predicate<std::string> {
  static const char* GLEAN_name() {
    return "codexref.SymbolName";
  }

  static constexpr size_t GLEAN_version() {
     return 6;
  }
}; // struct SymbolName

using Shard = uint64_t;

} // namespace Codexref

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Codexref::Location> {
  using Type = Sum<Nat, Nat>;
};


namespace schema {

namespace Codexref {

struct Location {
  boost::variant<Alt<0, uint64_t>, Alt<1, uint64_t>> GLEAN_value;

  static Location start(const uint64_t& a) {
    return Location{Alt<0, uint64_t>(a)};
  }
  static Location line(const uint64_t& a) {
    return Location{Alt<1, uint64_t>(a)};
  }

  bool operator==(const Location& other) const {
    return std::tie(GLEAN_value)
             == std::tie(other.GLEAN_value);
  }
  bool operator!=(const Location& other) const {
    return std::tie(GLEAN_value)
             != std::tie(other.GLEAN_value);
  }
  bool operator<(const Location& other) const {
    return std::tie(GLEAN_value)
             < std::tie(other.GLEAN_value);
  }
  bool operator<=(const Location& other) const {
    return std::tie(GLEAN_value)
             <= std::tie(other.GLEAN_value);
  }
  bool operator>(const Location& other) const {
    return std::tie(GLEAN_value)
             > std::tie(other.GLEAN_value);
  }
  bool operator>=(const Location& other) const {
    return std::tie(GLEAN_value)
             >= std::tie(other.GLEAN_value);
  }

  void outputRepr(Output<Repr<Location>> out) const {
    outputValue(out, GLEAN_value);
  }
}; // struct Location

} // namespace Codexref

namespace Codemetrics {

struct CxxRecordReferenceTo : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Cxx1::RecordDefinition>, facebook::glean::cpp::schema::Cxx1::Declaration>> {
  static const char* GLEAN_name() {
    return "codemetrics.CxxRecordReferenceTo";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct CxxRecordReferenceTo

struct CxxRecordReference : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Cxx1::RecordDefinition>, facebook::glean::cpp::schema::Cxx1::Declaration>> {
  static const char* GLEAN_name() {
    return "codemetrics.CxxRecordReference";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct CxxRecordReference

} // namespace Codemetrics

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Codemarkup::Types::Visibility> {
  using Type = Enum<4>;
};


namespace schema {

namespace Codemarkup {

namespace Types {

enum class Visibility { Public, Protected, Private, Internal };

} // namespace Types

} // namespace Codemarkup

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Codemarkup::Types::SymbolKind> {
  using Type = Enum<34>;
};


namespace schema {

namespace Codemarkup {

namespace Types {

enum class SymbolKind { Package, Type, Value, File, Module, Namespace, Class_, Method, Property, Field, Constructor, Enum_, Interface, Function, Variable, Constant, String, Number, Boolean, Array_, Object_, Key, Null, Enumerator, Struct, Event, Operator, TypeParameter, Union, Macro, Trait, Fragment, Operation, Directive };

} // namespace Types

} // namespace Codemarkup

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Codexref::XRefDatum> {
  using Type = Tuple<facebook::glean::cpp::schema::Src::File, Repr<facebook::glean::cpp::schema::Codemarkup::Types::SymbolKind>, facebook::glean::cpp::schema::Codexref::SymbolName, Repr<facebook::glean::cpp::schema::Codexref::Location>, Repr<facebook::glean::cpp::schema::Codexref::Location>>;
};


namespace schema {

namespace Codexref {

struct XRefDatum {
  Fact<facebook::glean::cpp::schema::Src::File> file;
  facebook::glean::cpp::schema::Codemarkup::Types::SymbolKind symbol_kind;
  Fact<SymbolName> symbol_name;
  Location src_location;
  Location dst_location;

  bool operator==(const XRefDatum& other) const {
    return std::tie(file,symbol_kind,symbol_name,src_location,dst_location)
             == std::tie(other.file,other.symbol_kind,other.symbol_name,other.src_location,other.dst_location);
  }
  bool operator!=(const XRefDatum& other) const {
    return std::tie(file,symbol_kind,symbol_name,src_location,dst_location)
             != std::tie(other.file,other.symbol_kind,other.symbol_name,other.src_location,other.dst_location);
  }
  bool operator<(const XRefDatum& other) const {
    return std::tie(file,symbol_kind,symbol_name,src_location,dst_location)
             < std::tie(other.file,other.symbol_kind,other.symbol_name,other.src_location,other.dst_location);
  }
  bool operator<=(const XRefDatum& other) const {
    return std::tie(file,symbol_kind,symbol_name,src_location,dst_location)
             <= std::tie(other.file,other.symbol_kind,other.symbol_name,other.src_location,other.dst_location);
  }
  bool operator>(const XRefDatum& other) const {
    return std::tie(file,symbol_kind,symbol_name,src_location,dst_location)
             > std::tie(other.file,other.symbol_kind,other.symbol_name,other.src_location,other.dst_location);
  }
  bool operator>=(const XRefDatum& other) const {
    return std::tie(file,symbol_kind,symbol_name,src_location,dst_location)
             >= std::tie(other.file,other.symbol_kind,other.symbol_name,other.src_location,other.dst_location);
  }
  void outputRepr(Output<Repr<XRefDatum>> out) const {
    outputValue(out, std::make_tuple(file, symbol_kind, symbol_name, src_location, dst_location));
  }
}; // struct XRefDatum

struct IncomingXRefs : Predicate<std::tuple<std::string, Shard>, std::tuple<std::vector<XRefDatum>>> {
  static const char* GLEAN_name() {
    return "codexref.IncomingXRefs";
  }

  static constexpr size_t GLEAN_version() {
     return 6;
  }
}; // struct IncomingXRefs

struct OutgoingXRefs : Predicate<std::tuple<std::string, Shard>, std::tuple<std::vector<XRefDatum>>> {
  static const char* GLEAN_name() {
    return "codexref.OutgoingXRefs";
  }

  static constexpr size_t GLEAN_version() {
     return 6;
  }
}; // struct OutgoingXRefs

} // namespace Codexref

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Codemarkup::Types::SymbolInfo> {
  using Type = Tuple<Repr<facebook::glean::cpp::schema::Codemarkup::Types::SymbolKind>, Bool>;
};


namespace schema {

namespace Codemarkup {

namespace Types {

struct SymbolInfo {
  SymbolKind kind;
  bool isAbstract;

  bool operator==(const SymbolInfo& other) const {
    return std::tie(kind,isAbstract)
             == std::tie(other.kind,other.isAbstract);
  }
  bool operator!=(const SymbolInfo& other) const {
    return std::tie(kind,isAbstract)
             != std::tie(other.kind,other.isAbstract);
  }
  bool operator<(const SymbolInfo& other) const {
    return std::tie(kind,isAbstract)
             < std::tie(other.kind,other.isAbstract);
  }
  bool operator<=(const SymbolInfo& other) const {
    return std::tie(kind,isAbstract)
             <= std::tie(other.kind,other.isAbstract);
  }
  bool operator>(const SymbolInfo& other) const {
    return std::tie(kind,isAbstract)
             > std::tie(other.kind,other.isAbstract);
  }
  bool operator>=(const SymbolInfo& other) const {
    return std::tie(kind,isAbstract)
             >= std::tie(other.kind,other.isAbstract);
  }
  void outputRepr(Output<Repr<SymbolInfo>> out) const {
    outputValue(out, std::make_tuple(kind, isAbstract));
  }
}; // struct SymbolInfo

} // namespace Types

} // namespace Codemarkup

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Codemarkup::Types::RangeSpan> {
  using Type = Sum<Repr<facebook::glean::cpp::schema::Src::ByteSpan>, Repr<facebook::glean::cpp::schema::Src::Range>>;
};


namespace schema {

namespace Codemarkup {

namespace Types {

struct RangeSpan {
  boost::variant<Alt<0, facebook::glean::cpp::schema::Src::ByteSpan>, Alt<1, facebook::glean::cpp::schema::Src::Range>> GLEAN_value;

  static RangeSpan span(const facebook::glean::cpp::schema::Src::ByteSpan& a) {
    return RangeSpan{Alt<0, facebook::glean::cpp::schema::Src::ByteSpan>(a)};
  }
  static RangeSpan range(const facebook::glean::cpp::schema::Src::Range& a) {
    return RangeSpan{Alt<1, facebook::glean::cpp::schema::Src::Range>(a)};
  }

  bool operator==(const RangeSpan& other) const {
    return std::tie(GLEAN_value)
             == std::tie(other.GLEAN_value);
  }
  bool operator!=(const RangeSpan& other) const {
    return std::tie(GLEAN_value)
             != std::tie(other.GLEAN_value);
  }
  bool operator<(const RangeSpan& other) const {
    return std::tie(GLEAN_value)
             < std::tie(other.GLEAN_value);
  }
  bool operator<=(const RangeSpan& other) const {
    return std::tie(GLEAN_value)
             <= std::tie(other.GLEAN_value);
  }
  bool operator>(const RangeSpan& other) const {
    return std::tie(GLEAN_value)
             > std::tie(other.GLEAN_value);
  }
  bool operator>=(const RangeSpan& other) const {
    return std::tie(GLEAN_value)
             >= std::tie(other.GLEAN_value);
  }

  void outputRepr(Output<Repr<RangeSpan>> out) const {
    outputValue(out, GLEAN_value);
  }
}; // struct RangeSpan

struct RangeSpanContains : Predicate<std::tuple<RangeSpan, RangeSpan>> {
  static const char* GLEAN_name() {
    return "codemarkup.types.RangeSpanContains";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct RangeSpanContains

} // namespace Types

} // namespace Codemarkup

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Codemarkup::Types::Modifiers> {
  using Type = Tuple<Bool, Bool, Bool, Bool, Bool, Bool, Bool, Bool, Bool, Bool>;
};


namespace schema {

namespace Codemarkup {

namespace Types {

struct Modifiers {
  bool isAbstract;
  bool isFinal;
  bool isAsync;
  bool isStatic;
  bool isReadonly;
  bool isConst;
  bool isMutable;
  bool isVolatile;
  bool isVirtual;
  bool isInline;

  bool operator==(const Modifiers& other) const {
    return std::tie(isAbstract,isFinal,isAsync,isStatic,isReadonly,isConst,isMutable,isVolatile,isVirtual,isInline)
             == std::tie(other.isAbstract,other.isFinal,other.isAsync,other.isStatic,other.isReadonly,other.isConst,other.isMutable,other.isVolatile,other.isVirtual,other.isInline);
  }
  bool operator!=(const Modifiers& other) const {
    return std::tie(isAbstract,isFinal,isAsync,isStatic,isReadonly,isConst,isMutable,isVolatile,isVirtual,isInline)
             != std::tie(other.isAbstract,other.isFinal,other.isAsync,other.isStatic,other.isReadonly,other.isConst,other.isMutable,other.isVolatile,other.isVirtual,other.isInline);
  }
  bool operator<(const Modifiers& other) const {
    return std::tie(isAbstract,isFinal,isAsync,isStatic,isReadonly,isConst,isMutable,isVolatile,isVirtual,isInline)
             < std::tie(other.isAbstract,other.isFinal,other.isAsync,other.isStatic,other.isReadonly,other.isConst,other.isMutable,other.isVolatile,other.isVirtual,other.isInline);
  }
  bool operator<=(const Modifiers& other) const {
    return std::tie(isAbstract,isFinal,isAsync,isStatic,isReadonly,isConst,isMutable,isVolatile,isVirtual,isInline)
             <= std::tie(other.isAbstract,other.isFinal,other.isAsync,other.isStatic,other.isReadonly,other.isConst,other.isMutable,other.isVolatile,other.isVirtual,other.isInline);
  }
  bool operator>(const Modifiers& other) const {
    return std::tie(isAbstract,isFinal,isAsync,isStatic,isReadonly,isConst,isMutable,isVolatile,isVirtual,isInline)
             > std::tie(other.isAbstract,other.isFinal,other.isAsync,other.isStatic,other.isReadonly,other.isConst,other.isMutable,other.isVolatile,other.isVirtual,other.isInline);
  }
  bool operator>=(const Modifiers& other) const {
    return std::tie(isAbstract,isFinal,isAsync,isStatic,isReadonly,isConst,isMutable,isVolatile,isVirtual,isInline)
             >= std::tie(other.isAbstract,other.isFinal,other.isAsync,other.isStatic,other.isReadonly,other.isConst,other.isMutable,other.isVolatile,other.isVirtual,other.isInline);
  }
  void outputRepr(Output<Repr<Modifiers>> out) const {
    outputValue(out, std::make_tuple(isAbstract, isFinal, isAsync, isStatic, isReadonly, isConst, isMutable, isVolatile, isVirtual, isInline));
  }
}; // struct Modifiers

} // namespace Types

} // namespace Codemarkup

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Codemarkup::Types::Modifier> {
  using Type = Enum<10>;
};


namespace schema {

namespace Codemarkup {

namespace Types {

enum class Modifier { Abstract, Final, Async, Static, Readonly, Const, Mutable, Volatile, Virtual, Inline };

} // namespace Types

} // namespace Codemarkup

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Codemarkup::Types::Location> {
  using Type = Tuple<String, facebook::glean::cpp::schema::Src::File, Repr<facebook::glean::cpp::schema::Codemarkup::Types::RangeSpan>, Maybe<Repr<facebook::glean::cpp::schema::Src::FileLocation>>>;
};


namespace schema {

namespace Codemarkup {

namespace Types {

struct Location {
  std::string name;
  Fact<facebook::glean::cpp::schema::Src::File> file;
  RangeSpan location;
  boost::variant<Alt<0, std::tuple<>>, Alt<1, facebook::glean::cpp::schema::Src::FileLocation>> destination;

  bool operator==(const Location& other) const {
    return std::tie(name,file,location,destination)
             == std::tie(other.name,other.file,other.location,other.destination);
  }
  bool operator!=(const Location& other) const {
    return std::tie(name,file,location,destination)
             != std::tie(other.name,other.file,other.location,other.destination);
  }
  bool operator<(const Location& other) const {
    return std::tie(name,file,location,destination)
             < std::tie(other.name,other.file,other.location,other.destination);
  }
  bool operator<=(const Location& other) const {
    return std::tie(name,file,location,destination)
             <= std::tie(other.name,other.file,other.location,other.destination);
  }
  bool operator>(const Location& other) const {
    return std::tie(name,file,location,destination)
             > std::tie(other.name,other.file,other.location,other.destination);
  }
  bool operator>=(const Location& other) const {
    return std::tie(name,file,location,destination)
             >= std::tie(other.name,other.file,other.location,other.destination);
  }
  void outputRepr(Output<Repr<Location>> out) const {
    outputValue(out, std::make_tuple(name, file, location, destination));
  }
}; // struct Location

} // namespace Types

} // namespace Codemarkup

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Codemarkup::Types::XRefLocation> {
  using Type = Tuple<Repr<facebook::glean::cpp::schema::Codemarkup::Types::Location>, Repr<facebook::glean::cpp::schema::Codemarkup::Types::RangeSpan>>;
};


namespace schema {

namespace Codemarkup {

namespace Types {

struct XRefLocation {
  Location target;
  RangeSpan source;

  bool operator==(const XRefLocation& other) const {
    return std::tie(target,source)
             == std::tie(other.target,other.source);
  }
  bool operator!=(const XRefLocation& other) const {
    return std::tie(target,source)
             != std::tie(other.target,other.source);
  }
  bool operator<(const XRefLocation& other) const {
    return std::tie(target,source)
             < std::tie(other.target,other.source);
  }
  bool operator<=(const XRefLocation& other) const {
    return std::tie(target,source)
             <= std::tie(other.target,other.source);
  }
  bool operator>(const XRefLocation& other) const {
    return std::tie(target,source)
             > std::tie(other.target,other.source);
  }
  bool operator>=(const XRefLocation& other) const {
    return std::tie(target,source)
             >= std::tie(other.target,other.source);
  }
  void outputRepr(Output<Repr<XRefLocation>> out) const {
    outputValue(out, std::make_tuple(target, source));
  }
}; // struct XRefLocation

} // namespace Types

} // namespace Codemarkup

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Codemarkup::Search::SearchCase> {
  using Type = Enum<2>;
};


namespace schema {

namespace Codemarkup {

namespace Search {

enum class SearchCase { Sensitive, Insensitive };

} // namespace Search

namespace Scip {

struct LsifKindToKind : Predicate<std::tuple<facebook::glean::cpp::schema::Lsif::Types::SymbolKind, facebook::glean::cpp::schema::Codemarkup::Types::SymbolKind>> {
  static const char* GLEAN_name() {
    return "codemarkup.scip.LsifKindToKind";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct LsifKindToKind

} // namespace Scip

namespace Python {

struct NonImportPythonDeclarationKind : Predicate<std::tuple<facebook::glean::cpp::schema::Python::Declaration, facebook::glean::cpp::schema::Codemarkup::Types::SymbolKind>> {
  static const char* GLEAN_name() {
    return "codemarkup.python.NonImportPythonDeclarationKind";
  }

  static constexpr size_t GLEAN_version() {
     return 2;
  }
}; // struct NonImportPythonDeclarationKind

struct NonImportPythonDeclarationInfo : Predicate<std::tuple<facebook::glean::cpp::schema::Python::Declaration, facebook::glean::cpp::schema::Codemarkup::Types::SymbolInfo>> {
  static const char* GLEAN_name() {
    return "codemarkup.python.NonImportPythonDeclarationInfo";
  }

  static constexpr size_t GLEAN_version() {
     return 2;
  }
}; // struct NonImportPythonDeclarationInfo

struct ConvertLabel : Predicate<std::tuple<boost::variant<Alt<0, std::tuple<>>, Alt<1, Fact<facebook::glean::cpp::schema::Python::Name>>>, boost::variant<Alt<0, std::tuple<>>, Alt<1, std::string>>>> {
  static const char* GLEAN_name() {
    return "codemarkup.python.ConvertLabel";
  }

  static constexpr size_t GLEAN_version() {
     return 2;
  }
}; // struct ConvertLabel

} // namespace Python

namespace Pp {

struct PpIncludeXRefLocations : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Cxx1::PPTrace>, facebook::glean::cpp::schema::Src::Range, Fact<facebook::glean::cpp::schema::Src::File>>> {
  static const char* GLEAN_name() {
    return "codemarkup.pp.PpIncludeXRefLocations";
  }

  static constexpr size_t GLEAN_version() {
     return 3;
  }
}; // struct PpIncludeXRefLocations

} // namespace Pp

namespace Lsif {

struct LsifKindToKind : Predicate<std::tuple<facebook::glean::cpp::schema::Lsif::Types::SymbolKind, facebook::glean::cpp::schema::Codemarkup::Types::SymbolKind>> {
  static const char* GLEAN_name() {
    return "codemarkup.lsif.LsifKindToKind";
  }

  static constexpr size_t GLEAN_version() {
     return 3;
  }
}; // struct LsifKindToKind

} // namespace Lsif

} // namespace Codemarkup

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Codemarkup::Hack::RequiredRelation> {
  using Type = Enum<3>;
};


namespace schema {

namespace Codemarkup {

namespace Hack {

enum class RequiredRelation { implements_, extends_, class_ };

struct HackEnumInheritedMembers : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Hack::MethodDeclaration>>> {
  static const char* GLEAN_name() {
    return "codemarkup.hack.HackEnumInheritedMembers";
  }

  static constexpr size_t GLEAN_version() {
     return 2;
  }
}; // struct HackEnumInheritedMembers

struct FromHackVisibility : Predicate<std::tuple<facebook::glean::cpp::schema::Hack::Visibility, facebook::glean::cpp::schema::Codemarkup::Types::Visibility>> {
  static const char* GLEAN_name() {
    return "codemarkup.hack.FromHackVisibility";
  }

  static constexpr size_t GLEAN_version() {
     return 2;
  }
}; // struct FromHackVisibility

} // namespace Hack

namespace Flow {

struct FlowDocumentationSpan : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Flow::Documentation>, Fact<facebook::glean::cpp::schema::Src::File>, facebook::glean::cpp::schema::Src::ByteSpan>> {
  static const char* GLEAN_name() {
    return "codemarkup.flow.FlowDocumentationSpan";
  }

  static constexpr size_t GLEAN_version() {
     return 2;
  }
}; // struct FlowDocumentationSpan

struct FlowDeclarationDocumentation : Predicate<std::tuple<facebook::glean::cpp::schema::Flow::SomeDeclaration, Fact<facebook::glean::cpp::schema::Src::File>, facebook::glean::cpp::schema::Src::ByteSpan>> {
  static const char* GLEAN_name() {
    return "codemarkup.flow.FlowDeclarationDocumentation";
  }

  static constexpr size_t GLEAN_version() {
     return 2;
  }
}; // struct FlowDeclarationDocumentation

} // namespace Flow

namespace Cxx {

struct FromCxxVisibility : Predicate<std::tuple<facebook::glean::cpp::schema::Cxx1::Access, facebook::glean::cpp::schema::Codemarkup::Types::Visibility>> {
  static const char* GLEAN_name() {
    return "codemarkup.cxx.FromCxxVisibility";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct FromCxxVisibility

struct CxxFileEntityXMapVariableXRefDeclLocations : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Cxx1::FileXRefs>, facebook::glean::cpp::schema::Cxx1::Declaration, facebook::glean::cpp::schema::Codemarkup::Types::Location>> {
  static const char* GLEAN_name() {
    return "codemarkup.cxx.CxxFileEntityXMapVariableXRefDeclLocations";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct CxxFileEntityXMapVariableXRefDeclLocations

struct CxxDeclarationModifiers : Predicate<std::tuple<facebook::glean::cpp::schema::Cxx1::Declaration, facebook::glean::cpp::schema::Codemarkup::Types::Modifiers>> {
  static const char* GLEAN_name() {
    return "codemarkup.cxx.CxxDeclarationModifiers";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct CxxDeclarationModifiers

struct CxxDeclVisibility : Predicate<std::tuple<facebook::glean::cpp::schema::Cxx1::Declaration, facebook::glean::cpp::schema::Codemarkup::Types::Visibility>> {
  static const char* GLEAN_name() {
    return "codemarkup.cxx.CxxDeclVisibility";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct CxxDeclVisibility

struct CxxDeclKind : Predicate<std::tuple<facebook::glean::cpp::schema::Cxx1::Declaration, facebook::glean::cpp::schema::Codemarkup::Types::SymbolKind>> {
  static const char* GLEAN_name() {
    return "codemarkup.cxx.CxxDeclKind";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct CxxDeclKind

struct CxxDeclInfo : Predicate<std::tuple<facebook::glean::cpp::schema::Cxx1::Declaration, facebook::glean::cpp::schema::Codemarkup::Types::SymbolInfo>> {
  static const char* GLEAN_name() {
    return "codemarkup.cxx.CxxDeclInfo";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct CxxDeclInfo

struct CxxDataAvailable : Predicate<Fact<facebook::glean::cpp::schema::Src::File>> {
  static const char* GLEAN_name() {
    return "codemarkup.cxx.CxxDataAvailable";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct CxxDataAvailable

} // namespace Cxx

} // namespace Codemarkup

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Codemarkup::SearchStyle> {
  using Type = Enum<2>;
};


namespace schema {

namespace Codemarkup {

enum class SearchStyle { ShowAll, HideUninteresting };

} // namespace Codemarkup

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Codemarkup::RelationType> {
  using Type = Enum<7>;
};


namespace schema {

namespace Codemarkup {

enum class RelationType { ExtendsParentOfChild, ExtendsChildOfParent, ContainsChildOfParent, ContainsParentOfChild, RequireExtendsParentOfChild, RequireImplementsParentOfChild, RequireClassParentOfChild };

struct IndexedFile : Predicate<Fact<facebook::glean::cpp::schema::Src::File>> {
  static const char* GLEAN_name() {
    return "codemarkup.IndexedFile";
  }

  static constexpr size_t GLEAN_version() {
     return 30;
  }
}; // struct IndexedFile

struct EntityDataAvailable : Predicate<Fact<facebook::glean::cpp::schema::Src::File>> {
  static const char* GLEAN_name() {
    return "codemarkup.EntityDataAvailable";
  }

  static constexpr size_t GLEAN_version() {
     return 30;
  }
}; // struct EntityDataAvailable

} // namespace Codemarkup

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Code::Scip::Entity> {
  using Type = Sum<Repr<facebook::glean::cpp::schema::Scip::SomeEntity>, Repr<facebook::glean::cpp::schema::Scip::SomeEntity>, Repr<facebook::glean::cpp::schema::Scip::SomeEntity>>;
};


namespace schema {

namespace Code {

namespace Scip {

struct Entity {
  boost::variant<Alt<0, facebook::glean::cpp::schema::Scip::SomeEntity>, Alt<1, facebook::glean::cpp::schema::Scip::SomeEntity>, Alt<2, facebook::glean::cpp::schema::Scip::SomeEntity>> GLEAN_value;

  static Entity rust(const facebook::glean::cpp::schema::Scip::SomeEntity& a) {
    return Entity{Alt<0, facebook::glean::cpp::schema::Scip::SomeEntity>(a)};
  }
  static Entity go(const facebook::glean::cpp::schema::Scip::SomeEntity& a) {
    return Entity{Alt<1, facebook::glean::cpp::schema::Scip::SomeEntity>(a)};
  }
  static Entity typescript(const facebook::glean::cpp::schema::Scip::SomeEntity& a) {
    return Entity{Alt<2, facebook::glean::cpp::schema::Scip::SomeEntity>(a)};
  }

  bool operator==(const Entity& other) const {
    return std::tie(GLEAN_value)
             == std::tie(other.GLEAN_value);
  }
  bool operator!=(const Entity& other) const {
    return std::tie(GLEAN_value)
             != std::tie(other.GLEAN_value);
  }
  bool operator<(const Entity& other) const {
    return std::tie(GLEAN_value)
             < std::tie(other.GLEAN_value);
  }
  bool operator<=(const Entity& other) const {
    return std::tie(GLEAN_value)
             <= std::tie(other.GLEAN_value);
  }
  bool operator>(const Entity& other) const {
    return std::tie(GLEAN_value)
             > std::tie(other.GLEAN_value);
  }
  bool operator>=(const Entity& other) const {
    return std::tie(GLEAN_value)
             >= std::tie(other.GLEAN_value);
  }

  void outputRepr(Output<Repr<Entity>> out) const {
    outputValue(out, GLEAN_value);
  }
}; // struct Entity

} // namespace Scip

} // namespace Code

namespace Codemarkup {

namespace Scip {

struct EntityInfo : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Scip::Entity, facebook::glean::cpp::schema::Codemarkup::Types::SymbolInfo>> {
  static const char* GLEAN_name() {
    return "codemarkup.scip.EntityInfo";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct EntityInfo

struct ScipEntityLocation : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Scip::Entity, facebook::glean::cpp::schema::Codemarkup::Types::Location>> {
  static const char* GLEAN_name() {
    return "codemarkup.scip.ScipEntityLocation";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct ScipEntityLocation

struct ScipEntityUses : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Scip::Entity, Fact<facebook::glean::cpp::schema::Src::File>, facebook::glean::cpp::schema::Src::Range>> {
  static const char* GLEAN_name() {
    return "codemarkup.scip.ScipEntityUses";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct ScipEntityUses

struct ScipFileEntityXRefLocations : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Src::File>, facebook::glean::cpp::schema::Codemarkup::Types::XRefLocation, facebook::glean::cpp::schema::Code::Scip::Entity>> {
  static const char* GLEAN_name() {
    return "codemarkup.scip.ScipFileEntityXRefLocations";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct ScipFileEntityXRefLocations

struct ScipResolveLocation : Predicate<std::tuple<facebook::glean::cpp::schema::Codemarkup::Types::Location, facebook::glean::cpp::schema::Code::Scip::Entity>> {
  static const char* GLEAN_name() {
    return "codemarkup.scip.ScipResolveLocation";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct ScipResolveLocation

} // namespace Scip

} // namespace Codemarkup

namespace Code {

namespace Quality {

struct Repository : Predicate<std::string> {
  static const char* GLEAN_name() {
    return "code.quality.Repository";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct Repository

} // namespace Quality

} // namespace Code

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Code::Quality::Range> {
  using Type = Tuple<Nat, Nat, Nat, Nat>;
};


namespace schema {

namespace Code {

namespace Quality {

struct Range {
  uint64_t lineBegin;
  uint64_t lineEnd;
  uint64_t columnBegin;
  uint64_t columnEnd;

  bool operator==(const Range& other) const {
    return std::tie(lineBegin,lineEnd,columnBegin,columnEnd)
             == std::tie(other.lineBegin,other.lineEnd,other.columnBegin,other.columnEnd);
  }
  bool operator!=(const Range& other) const {
    return std::tie(lineBegin,lineEnd,columnBegin,columnEnd)
             != std::tie(other.lineBegin,other.lineEnd,other.columnBegin,other.columnEnd);
  }
  bool operator<(const Range& other) const {
    return std::tie(lineBegin,lineEnd,columnBegin,columnEnd)
             < std::tie(other.lineBegin,other.lineEnd,other.columnBegin,other.columnEnd);
  }
  bool operator<=(const Range& other) const {
    return std::tie(lineBegin,lineEnd,columnBegin,columnEnd)
             <= std::tie(other.lineBegin,other.lineEnd,other.columnBegin,other.columnEnd);
  }
  bool operator>(const Range& other) const {
    return std::tie(lineBegin,lineEnd,columnBegin,columnEnd)
             > std::tie(other.lineBegin,other.lineEnd,other.columnBegin,other.columnEnd);
  }
  bool operator>=(const Range& other) const {
    return std::tie(lineBegin,lineEnd,columnBegin,columnEnd)
             >= std::tie(other.lineBegin,other.lineEnd,other.columnBegin,other.columnEnd);
  }
  void outputRepr(Output<Repr<Range>> out) const {
    outputValue(out, std::make_tuple(lineBegin, lineEnd, columnBegin, columnEnd));
  }
}; // struct Range

struct Producer : Predicate<std::string> {
  static const char* GLEAN_name() {
    return "code.quality.Producer";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct Producer

} // namespace Quality

} // namespace Code

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Code::Quality::Point> {
  using Type = Tuple<Nat, Nat>;
};


namespace schema {

namespace Code {

namespace Quality {

struct Point {
  uint64_t line;
  uint64_t column;

  bool operator==(const Point& other) const {
    return std::tie(line,column)
             == std::tie(other.line,other.column);
  }
  bool operator!=(const Point& other) const {
    return std::tie(line,column)
             != std::tie(other.line,other.column);
  }
  bool operator<(const Point& other) const {
    return std::tie(line,column)
             < std::tie(other.line,other.column);
  }
  bool operator<=(const Point& other) const {
    return std::tie(line,column)
             <= std::tie(other.line,other.column);
  }
  bool operator>(const Point& other) const {
    return std::tie(line,column)
             > std::tie(other.line,other.column);
  }
  bool operator>=(const Point& other) const {
    return std::tie(line,column)
             >= std::tie(other.line,other.column);
  }
  void outputRepr(Output<Repr<Point>> out) const {
    outputValue(out, std::make_tuple(line, column));
  }
}; // struct Point

struct Integration : Predicate<std::string> {
  static const char* GLEAN_name() {
    return "code.quality.Integration";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct Integration

struct FlagType : Predicate<uint64_t> {
  static const char* GLEAN_name() {
    return "code.quality.FlagType";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct FlagType

struct FlagName : Predicate<std::string> {
  static const char* GLEAN_name() {
    return "code.quality.FlagName";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct FlagName

struct FlagInfo : Predicate<std::tuple<Fact<FlagName>, Fact<FlagType>, Fact<Producer>, boost::variant<Alt<0, std::tuple<>>, Alt<1, Fact<Category>>>>> {
  static const char* GLEAN_name() {
    return "code.quality.FlagInfo";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct FlagInfo

struct Detail : Predicate<std::string> {
  static const char* GLEAN_name() {
    return "code.quality.Detail";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct Detail

using CommitId = Fact<facebook::glean::cpp::schema::Scm::Rev>;

struct Category : Predicate<std::string> {
  static const char* GLEAN_name() {
    return "code.quality.Category";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct Category

} // namespace Quality

} // namespace Code

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Code::Python::Entity> {
  using Type = Sum<Repr<facebook::glean::cpp::schema::Python::Declaration>>;
};


namespace schema {

namespace Code {

namespace Python {

struct Entity {
  boost::variant<Alt<0, facebook::glean::cpp::schema::Python::Declaration>> GLEAN_value;

  static Entity decl(const facebook::glean::cpp::schema::Python::Declaration& a) {
    return Entity{Alt<0, facebook::glean::cpp::schema::Python::Declaration>(a)};
  }

  bool operator==(const Entity& other) const {
    return std::tie(GLEAN_value)
             == std::tie(other.GLEAN_value);
  }
  bool operator!=(const Entity& other) const {
    return std::tie(GLEAN_value)
             != std::tie(other.GLEAN_value);
  }
  bool operator<(const Entity& other) const {
    return std::tie(GLEAN_value)
             < std::tie(other.GLEAN_value);
  }
  bool operator<=(const Entity& other) const {
    return std::tie(GLEAN_value)
             <= std::tie(other.GLEAN_value);
  }
  bool operator>(const Entity& other) const {
    return std::tie(GLEAN_value)
             > std::tie(other.GLEAN_value);
  }
  bool operator>=(const Entity& other) const {
    return std::tie(GLEAN_value)
             >= std::tie(other.GLEAN_value);
  }

  void outputRepr(Output<Repr<Entity>> out) const {
    outputValue(out, GLEAN_value);
  }
}; // struct Entity

} // namespace Python

} // namespace Code

namespace Codemarkup {

namespace Python {

struct PythonContainsChildEntity : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Python::Entity, facebook::glean::cpp::schema::Code::Python::Entity>> {
  static const char* GLEAN_name() {
    return "codemarkup.python.PythonContainsChildEntity";
  }

  static constexpr size_t GLEAN_version() {
     return 2;
  }
}; // struct PythonContainsChildEntity

struct PythonContainsParentEntity : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Python::Entity, facebook::glean::cpp::schema::Code::Python::Entity>> {
  static const char* GLEAN_name() {
    return "codemarkup.python.PythonContainsParentEntity";
  }

  static constexpr size_t GLEAN_version() {
     return 2;
  }
}; // struct PythonContainsParentEntity

struct PythonEntityComments : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Python::Entity, Fact<facebook::glean::cpp::schema::Src::File>, facebook::glean::cpp::schema::Src::ByteSpan, boost::variant<Alt<0, std::tuple<>>, Alt<1, std::string>>>> {
  static const char* GLEAN_name() {
    return "codemarkup.python.PythonEntityComments";
  }

  static constexpr size_t GLEAN_version() {
     return 2;
  }
}; // struct PythonEntityComments

struct PythonEntityInfo : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Python::Entity, facebook::glean::cpp::schema::Codemarkup::Types::SymbolInfo>> {
  static const char* GLEAN_name() {
    return "codemarkup.python.PythonEntityInfo";
  }

  static constexpr size_t GLEAN_version() {
     return 2;
  }
}; // struct PythonEntityInfo

struct PythonEntityKind : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Python::Entity, facebook::glean::cpp::schema::Codemarkup::Types::SymbolKind>> {
  static const char* GLEAN_name() {
    return "codemarkup.python.PythonEntityKind";
  }

  static constexpr size_t GLEAN_version() {
     return 2;
  }
}; // struct PythonEntityKind

struct PythonEntityLocation : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Python::Entity, facebook::glean::cpp::schema::Codemarkup::Types::Location>> {
  static const char* GLEAN_name() {
    return "codemarkup.python.PythonEntityLocation";
  }

  static constexpr size_t GLEAN_version() {
     return 2;
  }
}; // struct PythonEntityLocation

struct PythonEntityModuleName : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Python::Entity, std::string>> {
  static const char* GLEAN_name() {
    return "codemarkup.python.PythonEntityModuleName";
  }

  static constexpr size_t GLEAN_version() {
     return 2;
  }
}; // struct PythonEntityModuleName

struct PythonEntityUses : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Python::Entity, Fact<facebook::glean::cpp::schema::Src::File>, facebook::glean::cpp::schema::Src::ByteSpan>> {
  static const char* GLEAN_name() {
    return "codemarkup.python.PythonEntityUses";
  }

  static constexpr size_t GLEAN_version() {
     return 2;
  }
}; // struct PythonEntityUses

struct PythonExtendsChildEntity : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Python::Entity, facebook::glean::cpp::schema::Code::Python::Entity>> {
  static const char* GLEAN_name() {
    return "codemarkup.python.PythonExtendsChildEntity";
  }

  static constexpr size_t GLEAN_version() {
     return 2;
  }
}; // struct PythonExtendsChildEntity

struct PythonExtendsParentEntity : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Python::Entity, facebook::glean::cpp::schema::Code::Python::Entity>> {
  static const char* GLEAN_name() {
    return "codemarkup.python.PythonExtendsParentEntity";
  }

  static constexpr size_t GLEAN_version() {
     return 2;
  }
}; // struct PythonExtendsParentEntity

struct PythonFileEntityXRefLocations : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Src::File>, facebook::glean::cpp::schema::Codemarkup::Types::XRefLocation, facebook::glean::cpp::schema::Code::Python::Entity>> {
  static const char* GLEAN_name() {
    return "codemarkup.python.PythonFileEntityXRefLocations";
  }

  static constexpr size_t GLEAN_version() {
     return 2;
  }
}; // struct PythonFileEntityXRefLocations

struct PythonModifiers : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Python::Entity, facebook::glean::cpp::schema::Codemarkup::Types::Modifiers>> {
  static const char* GLEAN_name() {
    return "codemarkup.python.PythonModifiers";
  }

  static constexpr size_t GLEAN_version() {
     return 2;
  }
}; // struct PythonModifiers

struct PythonResolveLocation : Predicate<std::tuple<facebook::glean::cpp::schema::Codemarkup::Types::Location, facebook::glean::cpp::schema::Code::Python::Entity>> {
  static const char* GLEAN_name() {
    return "codemarkup.python.PythonResolveLocation";
  }

  static constexpr size_t GLEAN_version() {
     return 2;
  }
}; // struct PythonResolveLocation

struct PythonVisibility : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Python::Entity, facebook::glean::cpp::schema::Codemarkup::Types::Visibility>> {
  static const char* GLEAN_name() {
    return "codemarkup.python.PythonVisibility";
  }

  static constexpr size_t GLEAN_version() {
     return 2;
  }
}; // struct PythonVisibility

} // namespace Python

} // namespace Codemarkup

namespace Code {

namespace Python {

using CallArgument = facebook::glean::cpp::schema::Python::CallArgument;

} // namespace Python

} // namespace Code

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Code::Python::Annotations> {
  using Type = Sum<Array<Repr<facebook::glean::cpp::schema::Python::Decorator>>>;
};


namespace schema {

namespace Code {

namespace Python {

struct Annotations {
  boost::variant<Alt<0, std::vector<facebook::glean::cpp::schema::Python::Decorator>>> GLEAN_value;

  static Annotations decorators(const std::vector<facebook::glean::cpp::schema::Python::Decorator>& a) {
    return Annotations{Alt<0, std::vector<facebook::glean::cpp::schema::Python::Decorator>>(a)};
  }

  bool operator==(const Annotations& other) const {
    return std::tie(GLEAN_value)
             == std::tie(other.GLEAN_value);
  }
  bool operator!=(const Annotations& other) const {
    return std::tie(GLEAN_value)
             != std::tie(other.GLEAN_value);
  }
  bool operator<(const Annotations& other) const {
    return std::tie(GLEAN_value)
             < std::tie(other.GLEAN_value);
  }
  bool operator<=(const Annotations& other) const {
    return std::tie(GLEAN_value)
             <= std::tie(other.GLEAN_value);
  }
  bool operator>(const Annotations& other) const {
    return std::tie(GLEAN_value)
             > std::tie(other.GLEAN_value);
  }
  bool operator>=(const Annotations& other) const {
    return std::tie(GLEAN_value)
             >= std::tie(other.GLEAN_value);
  }

  void outputRepr(Output<Repr<Annotations>> out) const {
    outputValue(out, GLEAN_value);
  }
}; // struct Annotations

} // namespace Python

} // namespace Code

namespace Codemarkup {

namespace Python {

struct PythonAnnotation : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Python::Entity, facebook::glean::cpp::schema::Code::Python::Annotations>> {
  static const char* GLEAN_name() {
    return "codemarkup.python.PythonAnnotation";
  }

  static constexpr size_t GLEAN_version() {
     return 2;
  }
}; // struct PythonAnnotation

} // namespace Python

} // namespace Codemarkup

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Code::Pp::Entity> {
  using Type = Sum<facebook::glean::cpp::schema::Pp1::Define, facebook::glean::cpp::schema::Pp1::Undef, facebook::glean::cpp::schema::Src::File>;
};


namespace schema {

namespace Code {

namespace Pp {

struct Entity {
  boost::variant<Alt<0, Fact<facebook::glean::cpp::schema::Pp1::Define>>, Alt<1, Fact<facebook::glean::cpp::schema::Pp1::Undef>>, Alt<2, Fact<facebook::glean::cpp::schema::Src::File>>> GLEAN_value;

  static Entity define(const Fact<facebook::glean::cpp::schema::Pp1::Define>& a) {
    return Entity{Alt<0, Fact<facebook::glean::cpp::schema::Pp1::Define>>(a)};
  }
  static Entity undef(const Fact<facebook::glean::cpp::schema::Pp1::Undef>& a) {
    return Entity{Alt<1, Fact<facebook::glean::cpp::schema::Pp1::Undef>>(a)};
  }
  static Entity include_(const Fact<facebook::glean::cpp::schema::Src::File>& a) {
    return Entity{Alt<2, Fact<facebook::glean::cpp::schema::Src::File>>(a)};
  }

  bool operator==(const Entity& other) const {
    return std::tie(GLEAN_value)
             == std::tie(other.GLEAN_value);
  }
  bool operator!=(const Entity& other) const {
    return std::tie(GLEAN_value)
             != std::tie(other.GLEAN_value);
  }
  bool operator<(const Entity& other) const {
    return std::tie(GLEAN_value)
             < std::tie(other.GLEAN_value);
  }
  bool operator<=(const Entity& other) const {
    return std::tie(GLEAN_value)
             <= std::tie(other.GLEAN_value);
  }
  bool operator>(const Entity& other) const {
    return std::tie(GLEAN_value)
             > std::tie(other.GLEAN_value);
  }
  bool operator>=(const Entity& other) const {
    return std::tie(GLEAN_value)
             >= std::tie(other.GLEAN_value);
  }

  void outputRepr(Output<Repr<Entity>> out) const {
    outputValue(out, GLEAN_value);
  }
}; // struct Entity

} // namespace Pp

} // namespace Code

namespace Codemarkup {

namespace Pp {

struct PPEntityLocation : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Pp::Entity, facebook::glean::cpp::schema::Codemarkup::Types::Location>> {
  static const char* GLEAN_name() {
    return "codemarkup.pp.PPEntityLocation";
  }

  static constexpr size_t GLEAN_version() {
     return 3;
  }
}; // struct PPEntityLocation

struct PpEntityInfo : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Pp::Entity, facebook::glean::cpp::schema::Codemarkup::Types::SymbolInfo>> {
  static const char* GLEAN_name() {
    return "codemarkup.pp.PpEntityInfo";
  }

  static constexpr size_t GLEAN_version() {
     return 3;
  }
}; // struct PpEntityInfo

struct PpEntityKind : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Pp::Entity, facebook::glean::cpp::schema::Codemarkup::Types::SymbolKind>> {
  static const char* GLEAN_name() {
    return "codemarkup.pp.PpEntityKind";
  }

  static constexpr size_t GLEAN_version() {
     return 3;
  }
}; // struct PpEntityKind

struct PpEntityTraceXRefLocations : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Cxx1::Trace>, facebook::glean::cpp::schema::Codemarkup::Types::XRefLocation, facebook::glean::cpp::schema::Code::Pp::Entity>> {
  static const char* GLEAN_name() {
    return "codemarkup.pp.PpEntityTraceXRefLocations";
  }

  static constexpr size_t GLEAN_version() {
     return 3;
  }
}; // struct PpEntityTraceXRefLocations

struct PpEntityUses : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Pp::Entity, Fact<facebook::glean::cpp::schema::Src::File>, facebook::glean::cpp::schema::Src::ByteSpan>> {
  static const char* GLEAN_name() {
    return "codemarkup.pp.PpEntityUses";
  }

  static constexpr size_t GLEAN_version() {
     return 3;
  }
}; // struct PpEntityUses

struct PpFileEntityXRefLocations : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Src::File>, facebook::glean::cpp::schema::Codemarkup::Types::XRefLocation, facebook::glean::cpp::schema::Code::Pp::Entity>> {
  static const char* GLEAN_name() {
    return "codemarkup.pp.PpFileEntityXRefLocations";
  }

  static constexpr size_t GLEAN_version() {
     return 3;
  }
}; // struct PpFileEntityXRefLocations

struct PpResolveLocation : Predicate<std::tuple<facebook::glean::cpp::schema::Codemarkup::Types::Location, facebook::glean::cpp::schema::Code::Pp::Entity>> {
  static const char* GLEAN_name() {
    return "codemarkup.pp.PpResolveLocation";
  }

  static constexpr size_t GLEAN_version() {
     return 3;
  }
}; // struct PpResolveLocation

struct PpResolveTraceLocation : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Cxx1::Trace>, facebook::glean::cpp::schema::Codemarkup::Types::Location, facebook::glean::cpp::schema::Code::Pp::Entity>> {
  static const char* GLEAN_name() {
    return "codemarkup.pp.PpResolveTraceLocation";
  }

  static constexpr size_t GLEAN_version() {
     return 3;
  }
}; // struct PpResolveTraceLocation

} // namespace Pp

} // namespace Codemarkup

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Code::Lsif::Entity> {
  using Type = Sum<Repr<facebook::glean::cpp::schema::Lsif::SomeEntity>, Repr<facebook::glean::cpp::schema::Lsif::SomeEntity>, Repr<facebook::glean::cpp::schema::Lsif::SomeEntity>, Repr<facebook::glean::cpp::schema::Lsif::SomeEntity>, Repr<facebook::glean::cpp::schema::Lsif::SomeEntity>, Repr<facebook::glean::cpp::schema::Lsif::SomeEntity>, Repr<facebook::glean::cpp::schema::Lsif::SomeEntity>, Repr<facebook::glean::cpp::schema::Lsif::SomeEntity>, Repr<facebook::glean::cpp::schema::Lsif::SomeEntity>, Repr<facebook::glean::cpp::schema::Lsif::SomeEntity>, Repr<facebook::glean::cpp::schema::Lsif::SomeEntity>, Repr<facebook::glean::cpp::schema::Lsif::SomeEntity>>;
};


namespace schema {

namespace Code {

namespace Lsif {

struct Entity {
  boost::variant<Alt<0, facebook::glean::cpp::schema::Lsif::SomeEntity>, Alt<1, facebook::glean::cpp::schema::Lsif::SomeEntity>, Alt<2, facebook::glean::cpp::schema::Lsif::SomeEntity>, Alt<3, facebook::glean::cpp::schema::Lsif::SomeEntity>, Alt<4, facebook::glean::cpp::schema::Lsif::SomeEntity>, Alt<5, facebook::glean::cpp::schema::Lsif::SomeEntity>, Alt<6, facebook::glean::cpp::schema::Lsif::SomeEntity>, Alt<7, facebook::glean::cpp::schema::Lsif::SomeEntity>, Alt<8, facebook::glean::cpp::schema::Lsif::SomeEntity>, Alt<9, facebook::glean::cpp::schema::Lsif::SomeEntity>, Alt<10, facebook::glean::cpp::schema::Lsif::SomeEntity>, Alt<11, facebook::glean::cpp::schema::Lsif::SomeEntity>> GLEAN_value;

  static Entity erlang(const facebook::glean::cpp::schema::Lsif::SomeEntity& a) {
    return Entity{Alt<0, facebook::glean::cpp::schema::Lsif::SomeEntity>(a)};
  }
  static Entity fsharp(const facebook::glean::cpp::schema::Lsif::SomeEntity& a) {
    return Entity{Alt<1, facebook::glean::cpp::schema::Lsif::SomeEntity>(a)};
  }
  static Entity go(const facebook::glean::cpp::schema::Lsif::SomeEntity& a) {
    return Entity{Alt<2, facebook::glean::cpp::schema::Lsif::SomeEntity>(a)};
  }
  static Entity haskell(const facebook::glean::cpp::schema::Lsif::SomeEntity& a) {
    return Entity{Alt<3, facebook::glean::cpp::schema::Lsif::SomeEntity>(a)};
  }
  static Entity java(const facebook::glean::cpp::schema::Lsif::SomeEntity& a) {
    return Entity{Alt<4, facebook::glean::cpp::schema::Lsif::SomeEntity>(a)};
  }
  static Entity kotlin(const facebook::glean::cpp::schema::Lsif::SomeEntity& a) {
    return Entity{Alt<5, facebook::glean::cpp::schema::Lsif::SomeEntity>(a)};
  }
  static Entity ocaml(const facebook::glean::cpp::schema::Lsif::SomeEntity& a) {
    return Entity{Alt<6, facebook::glean::cpp::schema::Lsif::SomeEntity>(a)};
  }
  static Entity python(const facebook::glean::cpp::schema::Lsif::SomeEntity& a) {
    return Entity{Alt<7, facebook::glean::cpp::schema::Lsif::SomeEntity>(a)};
  }
  static Entity rust(const facebook::glean::cpp::schema::Lsif::SomeEntity& a) {
    return Entity{Alt<8, facebook::glean::cpp::schema::Lsif::SomeEntity>(a)};
  }
  static Entity scala(const facebook::glean::cpp::schema::Lsif::SomeEntity& a) {
    return Entity{Alt<9, facebook::glean::cpp::schema::Lsif::SomeEntity>(a)};
  }
  static Entity swift(const facebook::glean::cpp::schema::Lsif::SomeEntity& a) {
    return Entity{Alt<10, facebook::glean::cpp::schema::Lsif::SomeEntity>(a)};
  }
  static Entity typescript(const facebook::glean::cpp::schema::Lsif::SomeEntity& a) {
    return Entity{Alt<11, facebook::glean::cpp::schema::Lsif::SomeEntity>(a)};
  }

  bool operator==(const Entity& other) const {
    return std::tie(GLEAN_value)
             == std::tie(other.GLEAN_value);
  }
  bool operator!=(const Entity& other) const {
    return std::tie(GLEAN_value)
             != std::tie(other.GLEAN_value);
  }
  bool operator<(const Entity& other) const {
    return std::tie(GLEAN_value)
             < std::tie(other.GLEAN_value);
  }
  bool operator<=(const Entity& other) const {
    return std::tie(GLEAN_value)
             <= std::tie(other.GLEAN_value);
  }
  bool operator>(const Entity& other) const {
    return std::tie(GLEAN_value)
             > std::tie(other.GLEAN_value);
  }
  bool operator>=(const Entity& other) const {
    return std::tie(GLEAN_value)
             >= std::tie(other.GLEAN_value);
  }

  void outputRepr(Output<Repr<Entity>> out) const {
    outputValue(out, GLEAN_value);
  }
}; // struct Entity

} // namespace Lsif

} // namespace Code

namespace Codemarkup {

namespace Lsif {

struct EntityInfo : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Lsif::Entity, facebook::glean::cpp::schema::Codemarkup::Types::SymbolInfo>> {
  static const char* GLEAN_name() {
    return "codemarkup.lsif.EntityInfo";
  }

  static constexpr size_t GLEAN_version() {
     return 3;
  }
}; // struct EntityInfo

struct LsifEntityLocation : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Lsif::Entity, facebook::glean::cpp::schema::Codemarkup::Types::Location>> {
  static const char* GLEAN_name() {
    return "codemarkup.lsif.LsifEntityLocation";
  }

  static constexpr size_t GLEAN_version() {
     return 3;
  }
}; // struct LsifEntityLocation

struct LsifEntityModuleName : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Lsif::Entity, std::string>> {
  static const char* GLEAN_name() {
    return "codemarkup.lsif.LsifEntityModuleName";
  }

  static constexpr size_t GLEAN_version() {
     return 3;
  }
}; // struct LsifEntityModuleName

struct LsifEntityUses : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Lsif::Entity, Fact<facebook::glean::cpp::schema::Src::File>, facebook::glean::cpp::schema::Src::Range>> {
  static const char* GLEAN_name() {
    return "codemarkup.lsif.LsifEntityUses";
  }

  static constexpr size_t GLEAN_version() {
     return 3;
  }
}; // struct LsifEntityUses

struct LsifFileEntityXRefLocations : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Src::File>, facebook::glean::cpp::schema::Codemarkup::Types::XRefLocation, facebook::glean::cpp::schema::Code::Lsif::Entity>> {
  static const char* GLEAN_name() {
    return "codemarkup.lsif.LsifFileEntityXRefLocations";
  }

  static constexpr size_t GLEAN_version() {
     return 3;
  }
}; // struct LsifFileEntityXRefLocations

struct LsifResolveLocation : Predicate<std::tuple<facebook::glean::cpp::schema::Codemarkup::Types::Location, facebook::glean::cpp::schema::Code::Lsif::Entity>> {
  static const char* GLEAN_name() {
    return "codemarkup.lsif.LsifResolveLocation";
  }

  static constexpr size_t GLEAN_version() {
     return 3;
  }
}; // struct LsifResolveLocation

} // namespace Lsif

} // namespace Codemarkup

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Code::Kotlin::Entity> {
  using Type = Sum<Repr<facebook::glean::cpp::schema::Kotlin::Alpha::Declaration>>;
};


namespace schema {

namespace Code {

namespace Kotlin {

struct Entity {
  boost::variant<Alt<0, facebook::glean::cpp::schema::Kotlin::Alpha::Declaration>> GLEAN_value;

  static Entity decl(const facebook::glean::cpp::schema::Kotlin::Alpha::Declaration& a) {
    return Entity{Alt<0, facebook::glean::cpp::schema::Kotlin::Alpha::Declaration>(a)};
  }

  bool operator==(const Entity& other) const {
    return std::tie(GLEAN_value)
             == std::tie(other.GLEAN_value);
  }
  bool operator!=(const Entity& other) const {
    return std::tie(GLEAN_value)
             != std::tie(other.GLEAN_value);
  }
  bool operator<(const Entity& other) const {
    return std::tie(GLEAN_value)
             < std::tie(other.GLEAN_value);
  }
  bool operator<=(const Entity& other) const {
    return std::tie(GLEAN_value)
             <= std::tie(other.GLEAN_value);
  }
  bool operator>(const Entity& other) const {
    return std::tie(GLEAN_value)
             > std::tie(other.GLEAN_value);
  }
  bool operator>=(const Entity& other) const {
    return std::tie(GLEAN_value)
             >= std::tie(other.GLEAN_value);
  }

  void outputRepr(Output<Repr<Entity>> out) const {
    outputValue(out, GLEAN_value);
  }
}; // struct Entity

} // namespace Kotlin

} // namespace Code

namespace Codemarkup {

namespace Kotlin {

struct KotlinContainsChildEntity : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Kotlin::Entity, facebook::glean::cpp::schema::Code::Kotlin::Entity>> {
  static const char* GLEAN_name() {
    return "codemarkup.kotlin.KotlinContainsChildEntity";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct KotlinContainsChildEntity

struct KotlinContainsParentEntity : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Kotlin::Entity, facebook::glean::cpp::schema::Code::Kotlin::Entity>> {
  static const char* GLEAN_name() {
    return "codemarkup.kotlin.KotlinContainsParentEntity";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct KotlinContainsParentEntity

struct KotlinEntityKind : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Kotlin::Entity, facebook::glean::cpp::schema::Codemarkup::Types::SymbolKind>> {
  static const char* GLEAN_name() {
    return "codemarkup.kotlin.KotlinEntityKind";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct KotlinEntityKind

struct KotlinEntityLocation : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Kotlin::Entity, facebook::glean::cpp::schema::Codemarkup::Types::Location>> {
  static const char* GLEAN_name() {
    return "codemarkup.kotlin.KotlinEntityLocation";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct KotlinEntityLocation

struct KotlinEntityUses : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Kotlin::Entity, Fact<facebook::glean::cpp::schema::Src::File>, facebook::glean::cpp::schema::Src::ByteSpan>> {
  static const char* GLEAN_name() {
    return "codemarkup.kotlin.KotlinEntityUses";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct KotlinEntityUses

struct KotlinExtendsParentEntity : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Kotlin::Entity, facebook::glean::cpp::schema::Code::Kotlin::Entity>> {
  static const char* GLEAN_name() {
    return "codemarkup.kotlin.KotlinExtendsParentEntity";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct KotlinExtendsParentEntity

struct KotlinFileEntityXRefLocations : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Src::File>, facebook::glean::cpp::schema::Codemarkup::Types::XRefLocation, facebook::glean::cpp::schema::Code::Kotlin::Entity>> {
  static const char* GLEAN_name() {
    return "codemarkup.kotlin.KotlinFileEntityXRefLocations";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct KotlinFileEntityXRefLocations

struct KotlinResolveLocation : Predicate<std::tuple<facebook::glean::cpp::schema::Codemarkup::Types::Location, facebook::glean::cpp::schema::Code::Kotlin::Entity>> {
  static const char* GLEAN_name() {
    return "codemarkup.kotlin.KotlinResolveLocation";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct KotlinResolveLocation

} // namespace Kotlin

} // namespace Codemarkup

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Code::Java::Entity> {
  using Type = Sum<Repr<facebook::glean::cpp::schema::Java::Alpha::Declaration>>;
};


namespace schema {

namespace Code {

namespace Java {

struct Entity {
  boost::variant<Alt<0, facebook::glean::cpp::schema::Java::Alpha::Declaration>> GLEAN_value;

  static Entity decl(const facebook::glean::cpp::schema::Java::Alpha::Declaration& a) {
    return Entity{Alt<0, facebook::glean::cpp::schema::Java::Alpha::Declaration>(a)};
  }

  bool operator==(const Entity& other) const {
    return std::tie(GLEAN_value)
             == std::tie(other.GLEAN_value);
  }
  bool operator!=(const Entity& other) const {
    return std::tie(GLEAN_value)
             != std::tie(other.GLEAN_value);
  }
  bool operator<(const Entity& other) const {
    return std::tie(GLEAN_value)
             < std::tie(other.GLEAN_value);
  }
  bool operator<=(const Entity& other) const {
    return std::tie(GLEAN_value)
             <= std::tie(other.GLEAN_value);
  }
  bool operator>(const Entity& other) const {
    return std::tie(GLEAN_value)
             > std::tie(other.GLEAN_value);
  }
  bool operator>=(const Entity& other) const {
    return std::tie(GLEAN_value)
             >= std::tie(other.GLEAN_value);
  }

  void outputRepr(Output<Repr<Entity>> out) const {
    outputValue(out, GLEAN_value);
  }
}; // struct Entity

} // namespace Java

} // namespace Code

namespace Codemarkup {

namespace Java {

struct JavaContainsChildEntity : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Java::Entity, facebook::glean::cpp::schema::Code::Java::Entity>> {
  static const char* GLEAN_name() {
    return "codemarkup.java.JavaContainsChildEntity";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct JavaContainsChildEntity

struct JavaContainsParentEntity : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Java::Entity, facebook::glean::cpp::schema::Code::Java::Entity>> {
  static const char* GLEAN_name() {
    return "codemarkup.java.JavaContainsParentEntity";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct JavaContainsParentEntity

struct JavaEntityDocumentation : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Java::Entity, Fact<facebook::glean::cpp::schema::Src::File>, facebook::glean::cpp::schema::Src::ByteSpan>> {
  static const char* GLEAN_name() {
    return "codemarkup.java.JavaEntityDocumentation";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct JavaEntityDocumentation

struct JavaEntityKind : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Java::Entity, facebook::glean::cpp::schema::Codemarkup::Types::SymbolKind>> {
  static const char* GLEAN_name() {
    return "codemarkup.java.JavaEntityKind";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct JavaEntityKind

struct JavaEntityLocation : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Java::Entity, facebook::glean::cpp::schema::Codemarkup::Types::Location>> {
  static const char* GLEAN_name() {
    return "codemarkup.java.JavaEntityLocation";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct JavaEntityLocation

struct JavaEntityUses : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Java::Entity, Fact<facebook::glean::cpp::schema::Src::File>, facebook::glean::cpp::schema::Src::ByteSpan>> {
  static const char* GLEAN_name() {
    return "codemarkup.java.JavaEntityUses";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct JavaEntityUses

struct JavaExtendsChildEntity : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Java::Entity, facebook::glean::cpp::schema::Code::Java::Entity>> {
  static const char* GLEAN_name() {
    return "codemarkup.java.JavaExtendsChildEntity";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct JavaExtendsChildEntity

struct JavaExtendsParentEntity : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Java::Entity, facebook::glean::cpp::schema::Code::Java::Entity>> {
  static const char* GLEAN_name() {
    return "codemarkup.java.JavaExtendsParentEntity";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct JavaExtendsParentEntity

struct JavaModifiers : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Java::Entity, facebook::glean::cpp::schema::Codemarkup::Types::Modifiers>> {
  static const char* GLEAN_name() {
    return "codemarkup.java.JavaModifiers";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct JavaModifiers

struct JavaResolveLocation : Predicate<std::tuple<facebook::glean::cpp::schema::Codemarkup::Types::Location, facebook::glean::cpp::schema::Code::Java::Entity>> {
  static const char* GLEAN_name() {
    return "codemarkup.java.JavaResolveLocation";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct JavaResolveLocation

struct JavaVisibility : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Java::Entity, facebook::glean::cpp::schema::Codemarkup::Types::Visibility>> {
  static const char* GLEAN_name() {
    return "codemarkup.java.JavaVisibility";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct JavaVisibility

struct JavalFileEntityXRefLocations : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Src::File>, facebook::glean::cpp::schema::Codemarkup::Types::XRefLocation, facebook::glean::cpp::schema::Code::Java::Entity>> {
  static const char* GLEAN_name() {
    return "codemarkup.java.JavalFileEntityXRefLocations";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct JavalFileEntityXRefLocations

} // namespace Java

} // namespace Codemarkup

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Code::Java::Annotations> {
  using Type = Sum<Array<facebook::glean::cpp::schema::Java::Alpha::Annotation>>;
};


namespace schema {

namespace Code {

namespace Java {

struct Annotations {
  boost::variant<Alt<0, std::vector<Fact<facebook::glean::cpp::schema::Java::Alpha::Annotation>>>> GLEAN_value;

  static Annotations annotations(const std::vector<Fact<facebook::glean::cpp::schema::Java::Alpha::Annotation>>& a) {
    return Annotations{Alt<0, std::vector<Fact<facebook::glean::cpp::schema::Java::Alpha::Annotation>>>(a)};
  }

  bool operator==(const Annotations& other) const {
    return std::tie(GLEAN_value)
             == std::tie(other.GLEAN_value);
  }
  bool operator!=(const Annotations& other) const {
    return std::tie(GLEAN_value)
             != std::tie(other.GLEAN_value);
  }
  bool operator<(const Annotations& other) const {
    return std::tie(GLEAN_value)
             < std::tie(other.GLEAN_value);
  }
  bool operator<=(const Annotations& other) const {
    return std::tie(GLEAN_value)
             <= std::tie(other.GLEAN_value);
  }
  bool operator>(const Annotations& other) const {
    return std::tie(GLEAN_value)
             > std::tie(other.GLEAN_value);
  }
  bool operator>=(const Annotations& other) const {
    return std::tie(GLEAN_value)
             >= std::tie(other.GLEAN_value);
  }

  void outputRepr(Output<Repr<Annotations>> out) const {
    outputValue(out, GLEAN_value);
  }
}; // struct Annotations

} // namespace Java

} // namespace Code

namespace Codemarkup {

namespace Java {

struct JavaAnnotation : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Java::Entity, facebook::glean::cpp::schema::Code::Java::Annotations>> {
  static const char* GLEAN_name() {
    return "codemarkup.java.JavaAnnotation";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct JavaAnnotation

} // namespace Java

} // namespace Codemarkup

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Code::Hs::Entity> {
  using Type = Sum<facebook::glean::cpp::schema::Hs::Definition, facebook::glean::cpp::schema::Hs::FunctionDefinition, facebook::glean::cpp::schema::Hs::Class>;
};


namespace schema {

namespace Code {

namespace Hs {

struct Entity {
  boost::variant<Alt<0, Fact<facebook::glean::cpp::schema::Hs::Definition>>, Alt<1, Fact<facebook::glean::cpp::schema::Hs::FunctionDefinition>>, Alt<2, Fact<facebook::glean::cpp::schema::Hs::Class>>> GLEAN_value;

  static Entity definition(const Fact<facebook::glean::cpp::schema::Hs::Definition>& a) {
    return Entity{Alt<0, Fact<facebook::glean::cpp::schema::Hs::Definition>>(a)};
  }
  static Entity function_(const Fact<facebook::glean::cpp::schema::Hs::FunctionDefinition>& a) {
    return Entity{Alt<1, Fact<facebook::glean::cpp::schema::Hs::FunctionDefinition>>(a)};
  }
  static Entity class_(const Fact<facebook::glean::cpp::schema::Hs::Class>& a) {
    return Entity{Alt<2, Fact<facebook::glean::cpp::schema::Hs::Class>>(a)};
  }

  bool operator==(const Entity& other) const {
    return std::tie(GLEAN_value)
             == std::tie(other.GLEAN_value);
  }
  bool operator!=(const Entity& other) const {
    return std::tie(GLEAN_value)
             != std::tie(other.GLEAN_value);
  }
  bool operator<(const Entity& other) const {
    return std::tie(GLEAN_value)
             < std::tie(other.GLEAN_value);
  }
  bool operator<=(const Entity& other) const {
    return std::tie(GLEAN_value)
             <= std::tie(other.GLEAN_value);
  }
  bool operator>(const Entity& other) const {
    return std::tie(GLEAN_value)
             > std::tie(other.GLEAN_value);
  }
  bool operator>=(const Entity& other) const {
    return std::tie(GLEAN_value)
             >= std::tie(other.GLEAN_value);
  }

  void outputRepr(Output<Repr<Entity>> out) const {
    outputValue(out, GLEAN_value);
  }
}; // struct Entity

} // namespace Hs

} // namespace Code

namespace Codemarkup {

namespace Haskell {

struct HaskellEntityLocation : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Hs::Entity, facebook::glean::cpp::schema::Codemarkup::Types::Location>> {
  static const char* GLEAN_name() {
    return "codemarkup.haskell.HaskellEntityLocation";
  }

  static constexpr size_t GLEAN_version() {
     return 2;
  }
}; // struct HaskellEntityLocation

struct HaskellEntityUses : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Hs::Entity, Fact<facebook::glean::cpp::schema::Src::File>, facebook::glean::cpp::schema::Src::ByteSpan>> {
  static const char* GLEAN_name() {
    return "codemarkup.haskell.HaskellEntityUses";
  }

  static constexpr size_t GLEAN_version() {
     return 2;
  }
}; // struct HaskellEntityUses

struct HaskellFileEntityXRefLocations : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Src::File>, facebook::glean::cpp::schema::Codemarkup::Types::XRefLocation, facebook::glean::cpp::schema::Code::Hs::Entity>> {
  static const char* GLEAN_name() {
    return "codemarkup.haskell.HaskellFileEntityXRefLocations";
  }

  static constexpr size_t GLEAN_version() {
     return 2;
  }
}; // struct HaskellFileEntityXRefLocations

struct HaskellResolveLocation : Predicate<std::tuple<facebook::glean::cpp::schema::Codemarkup::Types::Location, facebook::glean::cpp::schema::Code::Hs::Entity>> {
  static const char* GLEAN_name() {
    return "codemarkup.haskell.HaskellResolveLocation";
  }

  static constexpr size_t GLEAN_version() {
     return 2;
  }
}; // struct HaskellResolveLocation

} // namespace Haskell

} // namespace Codemarkup

namespace Search {

namespace Hs {

struct SearchByName : Predicate<std::tuple<std::string, facebook::glean::cpp::schema::Code::Hs::Entity>> {
  static const char* GLEAN_name() {
    return "search.hs.SearchByName";
  }

  static constexpr size_t GLEAN_version() {
     return 9;
  }
}; // struct SearchByName

} // namespace Hs

} // namespace Search

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Code::Hack::Entity> {
  using Type = Sum<Repr<facebook::glean::cpp::schema::Hack::Declaration>>;
};


namespace schema {

namespace Code {

namespace Hack {

struct Entity {
  boost::variant<Alt<0, facebook::glean::cpp::schema::Hack::Declaration>> GLEAN_value;

  static Entity decl(const facebook::glean::cpp::schema::Hack::Declaration& a) {
    return Entity{Alt<0, facebook::glean::cpp::schema::Hack::Declaration>(a)};
  }

  bool operator==(const Entity& other) const {
    return std::tie(GLEAN_value)
             == std::tie(other.GLEAN_value);
  }
  bool operator!=(const Entity& other) const {
    return std::tie(GLEAN_value)
             != std::tie(other.GLEAN_value);
  }
  bool operator<(const Entity& other) const {
    return std::tie(GLEAN_value)
             < std::tie(other.GLEAN_value);
  }
  bool operator<=(const Entity& other) const {
    return std::tie(GLEAN_value)
             <= std::tie(other.GLEAN_value);
  }
  bool operator>(const Entity& other) const {
    return std::tie(GLEAN_value)
             > std::tie(other.GLEAN_value);
  }
  bool operator>=(const Entity& other) const {
    return std::tie(GLEAN_value)
             >= std::tie(other.GLEAN_value);
  }

  void outputRepr(Output<Repr<Entity>> out) const {
    outputValue(out, GLEAN_value);
  }
}; // struct Entity

} // namespace Hack

} // namespace Code

namespace Codemarkup {

namespace Hack {

struct EntityHasHideFromDocsAttr : Predicate<facebook::glean::cpp::schema::Code::Hack::Entity> {
  static const char* GLEAN_name() {
    return "codemarkup.hack.EntityHasHideFromDocsAttr";
  }

  static constexpr size_t GLEAN_version() {
     return 2;
  }
}; // struct EntityHasHideFromDocsAttr

struct HackContainsChildEntity : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Hack::Entity, facebook::glean::cpp::schema::Code::Hack::Entity>> {
  static const char* GLEAN_name() {
    return "codemarkup.hack.HackContainsChildEntity";
  }

  static constexpr size_t GLEAN_version() {
     return 2;
  }
}; // struct HackContainsChildEntity

struct HackContainsParentEntity : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Hack::Entity, facebook::glean::cpp::schema::Code::Hack::Entity>> {
  static const char* GLEAN_name() {
    return "codemarkup.hack.HackContainsParentEntity";
  }

  static constexpr size_t GLEAN_version() {
     return 2;
  }
}; // struct HackContainsParentEntity

struct HackEntityDocumentation : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Hack::Entity, Fact<facebook::glean::cpp::schema::Src::File>, facebook::glean::cpp::schema::Src::ByteSpan>> {
  static const char* GLEAN_name() {
    return "codemarkup.hack.HackEntityDocumentation";
  }

  static constexpr size_t GLEAN_version() {
     return 2;
  }
}; // struct HackEntityDocumentation

struct HackEntityInfo : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Hack::Entity, facebook::glean::cpp::schema::Codemarkup::Types::SymbolInfo>> {
  static const char* GLEAN_name() {
    return "codemarkup.hack.HackEntityInfo";
  }

  static constexpr size_t GLEAN_version() {
     return 2;
  }
}; // struct HackEntityInfo

struct HackEntityKind : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Hack::Entity, facebook::glean::cpp::schema::Codemarkup::Types::SymbolKind>> {
  static const char* GLEAN_name() {
    return "codemarkup.hack.HackEntityKind";
  }

  static constexpr size_t GLEAN_version() {
     return 2;
  }
}; // struct HackEntityKind

struct HackEntityLocation : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Hack::Entity, facebook::glean::cpp::schema::Codemarkup::Types::Location>> {
  static const char* GLEAN_name() {
    return "codemarkup.hack.HackEntityLocation";
  }

  static constexpr size_t GLEAN_version() {
     return 2;
  }
}; // struct HackEntityLocation

struct HackEntityModuleName : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Hack::Entity, std::string>> {
  static const char* GLEAN_name() {
    return "codemarkup.hack.HackEntityModuleName";
  }

  static constexpr size_t GLEAN_version() {
     return 2;
  }
}; // struct HackEntityModuleName

struct HackEntitySource : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Hack::Entity, facebook::glean::cpp::schema::Code::Hack::Entity>> {
  static const char* GLEAN_name() {
    return "codemarkup.hack.HackEntitySource";
  }

  static constexpr size_t GLEAN_version() {
     return 2;
  }
}; // struct HackEntitySource

struct HackEntityUses : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Hack::Entity, Fact<facebook::glean::cpp::schema::Src::File>, facebook::glean::cpp::schema::Src::ByteSpan>> {
  static const char* GLEAN_name() {
    return "codemarkup.hack.HackEntityUses";
  }

  static constexpr size_t GLEAN_version() {
     return 2;
  }
}; // struct HackEntityUses

struct HackExtendsChildEntity : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Hack::Entity, facebook::glean::cpp::schema::Code::Hack::Entity>> {
  static const char* GLEAN_name() {
    return "codemarkup.hack.HackExtendsChildEntity";
  }

  static constexpr size_t GLEAN_version() {
     return 2;
  }
}; // struct HackExtendsChildEntity

struct HackExtendsParentEntity : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Hack::Entity, facebook::glean::cpp::schema::Code::Hack::Entity>> {
  static const char* GLEAN_name() {
    return "codemarkup.hack.HackExtendsParentEntity";
  }

  static constexpr size_t GLEAN_version() {
     return 2;
  }
}; // struct HackExtendsParentEntity

struct HackExtendsParentEntityConcise : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Hack::Entity, facebook::glean::cpp::schema::Code::Hack::Entity>> {
  static const char* GLEAN_name() {
    return "codemarkup.hack.HackExtendsParentEntityConcise";
  }

  static constexpr size_t GLEAN_version() {
     return 2;
  }
}; // struct HackExtendsParentEntityConcise

struct HackFileEntityXRefLocations : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Src::File>, facebook::glean::cpp::schema::Codemarkup::Types::XRefLocation, facebook::glean::cpp::schema::Code::Hack::Entity>> {
  static const char* GLEAN_name() {
    return "codemarkup.hack.HackFileEntityXRefLocations";
  }

  static constexpr size_t GLEAN_version() {
     return 2;
  }
}; // struct HackFileEntityXRefLocations

struct HackFileEntityXRefSpans : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Src::File>, facebook::glean::cpp::schema::Src::ByteSpan, facebook::glean::cpp::schema::Code::Hack::Entity>> {
  static const char* GLEAN_name() {
    return "codemarkup.hack.HackFileEntityXRefSpans";
  }

  static constexpr size_t GLEAN_version() {
     return 2;
  }
}; // struct HackFileEntityXRefSpans

struct HackModifiers : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Hack::Entity, facebook::glean::cpp::schema::Codemarkup::Types::Modifiers>> {
  static const char* GLEAN_name() {
    return "codemarkup.hack.HackModifiers";
  }

  static constexpr size_t GLEAN_version() {
     return 2;
  }
}; // struct HackModifiers

struct HackRequiredConstraint : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Hack::Entity, RequiredRelation, facebook::glean::cpp::schema::Code::Hack::Entity>> {
  static const char* GLEAN_name() {
    return "codemarkup.hack.HackRequiredConstraint";
  }

  static constexpr size_t GLEAN_version() {
     return 2;
  }
}; // struct HackRequiredConstraint

struct HackResolveLocation : Predicate<std::tuple<facebook::glean::cpp::schema::Codemarkup::Types::Location, facebook::glean::cpp::schema::Code::Hack::Entity>> {
  static const char* GLEAN_name() {
    return "codemarkup.hack.HackResolveLocation";
  }

  static constexpr size_t GLEAN_version() {
     return 2;
  }
}; // struct HackResolveLocation

struct HackVisibility : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Hack::Entity, facebook::glean::cpp::schema::Codemarkup::Types::Visibility>> {
  static const char* GLEAN_name() {
    return "codemarkup.hack.HackVisibility";
  }

  static constexpr size_t GLEAN_version() {
     return 2;
  }
}; // struct HackVisibility

} // namespace Hack

} // namespace Codemarkup

namespace Codemetrics {

struct HackReferencesFrom : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Hack::Entity, facebook::glean::cpp::schema::Code::Hack::Entity>> {
  static const char* GLEAN_name() {
    return "codemetrics.HackReferencesFrom";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct HackReferencesFrom

struct HackReferencesTo : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Hack::Entity, facebook::glean::cpp::schema::Code::Hack::Entity>> {
  static const char* GLEAN_name() {
    return "codemetrics.HackReferencesTo";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct HackReferencesTo

} // namespace Codemetrics

namespace Code {

namespace Hack {

using CallArgument = facebook::glean::cpp::schema::Hack::CallArgument;

} // namespace Hack

} // namespace Code

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Code::Hack::Annotations> {
  using Type = Sum<Array<facebook::glean::cpp::schema::Hack::UserAttribute>>;
};


namespace schema {

namespace Code {

namespace Hack {

struct Annotations {
  boost::variant<Alt<0, std::vector<Fact<facebook::glean::cpp::schema::Hack::UserAttribute>>>> GLEAN_value;

  static Annotations attributes(const std::vector<Fact<facebook::glean::cpp::schema::Hack::UserAttribute>>& a) {
    return Annotations{Alt<0, std::vector<Fact<facebook::glean::cpp::schema::Hack::UserAttribute>>>(a)};
  }

  bool operator==(const Annotations& other) const {
    return std::tie(GLEAN_value)
             == std::tie(other.GLEAN_value);
  }
  bool operator!=(const Annotations& other) const {
    return std::tie(GLEAN_value)
             != std::tie(other.GLEAN_value);
  }
  bool operator<(const Annotations& other) const {
    return std::tie(GLEAN_value)
             < std::tie(other.GLEAN_value);
  }
  bool operator<=(const Annotations& other) const {
    return std::tie(GLEAN_value)
             <= std::tie(other.GLEAN_value);
  }
  bool operator>(const Annotations& other) const {
    return std::tie(GLEAN_value)
             > std::tie(other.GLEAN_value);
  }
  bool operator>=(const Annotations& other) const {
    return std::tie(GLEAN_value)
             >= std::tie(other.GLEAN_value);
  }

  void outputRepr(Output<Repr<Annotations>> out) const {
    outputValue(out, GLEAN_value);
  }
}; // struct Annotations

} // namespace Hack

} // namespace Code

namespace Codemarkup {

namespace Hack {

struct HackAnnotation : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Hack::Entity, facebook::glean::cpp::schema::Code::Hack::Annotations>> {
  static const char* GLEAN_name() {
    return "codemarkup.hack.HackAnnotation";
  }

  static constexpr size_t GLEAN_version() {
     return 2;
  }
}; // struct HackAnnotation

} // namespace Hack

} // namespace Codemarkup

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Code::Graphql::Entity> {
  using Type = Sum<Repr<facebook::glean::cpp::schema::Graphql::Declaration>>;
};


namespace schema {

namespace Code {

namespace Graphql {

struct Entity {
  boost::variant<Alt<0, facebook::glean::cpp::schema::Graphql::Declaration>> GLEAN_value;

  static Entity decl(const facebook::glean::cpp::schema::Graphql::Declaration& a) {
    return Entity{Alt<0, facebook::glean::cpp::schema::Graphql::Declaration>(a)};
  }

  bool operator==(const Entity& other) const {
    return std::tie(GLEAN_value)
             == std::tie(other.GLEAN_value);
  }
  bool operator!=(const Entity& other) const {
    return std::tie(GLEAN_value)
             != std::tie(other.GLEAN_value);
  }
  bool operator<(const Entity& other) const {
    return std::tie(GLEAN_value)
             < std::tie(other.GLEAN_value);
  }
  bool operator<=(const Entity& other) const {
    return std::tie(GLEAN_value)
             <= std::tie(other.GLEAN_value);
  }
  bool operator>(const Entity& other) const {
    return std::tie(GLEAN_value)
             > std::tie(other.GLEAN_value);
  }
  bool operator>=(const Entity& other) const {
    return std::tie(GLEAN_value)
             >= std::tie(other.GLEAN_value);
  }

  void outputRepr(Output<Repr<Entity>> out) const {
    outputValue(out, GLEAN_value);
  }
}; // struct Entity

} // namespace Graphql

} // namespace Code

namespace Codemarkup {

namespace Graphql {

struct GraphQLEntityKind : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Graphql::Entity, facebook::glean::cpp::schema::Codemarkup::Types::SymbolKind>> {
  static const char* GLEAN_name() {
    return "codemarkup.graphql.GraphQLEntityKind";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct GraphQLEntityKind

struct GraphQLEntityLocation : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Graphql::Entity, facebook::glean::cpp::schema::Codemarkup::Types::Location>> {
  static const char* GLEAN_name() {
    return "codemarkup.graphql.GraphQLEntityLocation";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct GraphQLEntityLocation

struct GraphQLEntityUses : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Graphql::Entity, Fact<facebook::glean::cpp::schema::Src::File>, facebook::glean::cpp::schema::Src::ByteSpan>> {
  static const char* GLEAN_name() {
    return "codemarkup.graphql.GraphQLEntityUses";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct GraphQLEntityUses

struct GraphQLFileEntityXRefLocations : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Src::File>, facebook::glean::cpp::schema::Codemarkup::Types::XRefLocation, facebook::glean::cpp::schema::Code::Graphql::Entity>> {
  static const char* GLEAN_name() {
    return "codemarkup.graphql.GraphQLFileEntityXRefLocations";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct GraphQLFileEntityXRefLocations

struct GraphQLResolveLocation : Predicate<std::tuple<facebook::glean::cpp::schema::Codemarkup::Types::Location, facebook::glean::cpp::schema::Code::Graphql::Entity>> {
  static const char* GLEAN_name() {
    return "codemarkup.graphql.GraphQLResolveLocation";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct GraphQLResolveLocation

} // namespace Graphql

} // namespace Codemarkup

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Code::Flow::Entity> {
  using Type = Sum<Repr<facebook::glean::cpp::schema::Flow::SomeDeclaration>, facebook::glean::cpp::schema::Flow::Module>;
};


namespace schema {

namespace Code {

namespace Flow {

struct Entity {
  boost::variant<Alt<0, facebook::glean::cpp::schema::Flow::SomeDeclaration>, Alt<1, Fact<facebook::glean::cpp::schema::Flow::Module>>> GLEAN_value;

  static Entity decl(const facebook::glean::cpp::schema::Flow::SomeDeclaration& a) {
    return Entity{Alt<0, facebook::glean::cpp::schema::Flow::SomeDeclaration>(a)};
  }
  static Entity module_(const Fact<facebook::glean::cpp::schema::Flow::Module>& a) {
    return Entity{Alt<1, Fact<facebook::glean::cpp::schema::Flow::Module>>(a)};
  }

  bool operator==(const Entity& other) const {
    return std::tie(GLEAN_value)
             == std::tie(other.GLEAN_value);
  }
  bool operator!=(const Entity& other) const {
    return std::tie(GLEAN_value)
             != std::tie(other.GLEAN_value);
  }
  bool operator<(const Entity& other) const {
    return std::tie(GLEAN_value)
             < std::tie(other.GLEAN_value);
  }
  bool operator<=(const Entity& other) const {
    return std::tie(GLEAN_value)
             <= std::tie(other.GLEAN_value);
  }
  bool operator>(const Entity& other) const {
    return std::tie(GLEAN_value)
             > std::tie(other.GLEAN_value);
  }
  bool operator>=(const Entity& other) const {
    return std::tie(GLEAN_value)
             >= std::tie(other.GLEAN_value);
  }

  void outputRepr(Output<Repr<Entity>> out) const {
    outputValue(out, GLEAN_value);
  }
}; // struct Entity

} // namespace Flow

} // namespace Code

namespace Codemarkup {

namespace Flow {

struct FlowContainsChildEntity : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Flow::Entity, facebook::glean::cpp::schema::Code::Flow::Entity>> {
  static const char* GLEAN_name() {
    return "codemarkup.flow.FlowContainsChildEntity";
  }

  static constexpr size_t GLEAN_version() {
     return 2;
  }
}; // struct FlowContainsChildEntity

struct FlowContainsParentEntity : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Flow::Entity, facebook::glean::cpp::schema::Code::Flow::Entity>> {
  static const char* GLEAN_name() {
    return "codemarkup.flow.FlowContainsParentEntity";
  }

  static constexpr size_t GLEAN_version() {
     return 2;
  }
}; // struct FlowContainsParentEntity

struct FlowEntityDocumentation : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Flow::Entity, Fact<facebook::glean::cpp::schema::Src::File>, facebook::glean::cpp::schema::Src::ByteSpan>> {
  static const char* GLEAN_name() {
    return "codemarkup.flow.FlowEntityDocumentation";
  }

  static constexpr size_t GLEAN_version() {
     return 2;
  }
}; // struct FlowEntityDocumentation

struct FlowEntityKind : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Flow::Entity, facebook::glean::cpp::schema::Codemarkup::Types::SymbolKind>> {
  static const char* GLEAN_name() {
    return "codemarkup.flow.FlowEntityKind";
  }

  static constexpr size_t GLEAN_version() {
     return 2;
  }
}; // struct FlowEntityKind

struct FlowEntityLocation : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Flow::Entity, facebook::glean::cpp::schema::Codemarkup::Types::Location>> {
  static const char* GLEAN_name() {
    return "codemarkup.flow.FlowEntityLocation";
  }

  static constexpr size_t GLEAN_version() {
     return 2;
  }
}; // struct FlowEntityLocation

struct FlowEntityModuleName : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Flow::Entity, std::string>> {
  static const char* GLEAN_name() {
    return "codemarkup.flow.FlowEntityModuleName";
  }

  static constexpr size_t GLEAN_version() {
     return 2;
  }
}; // struct FlowEntityModuleName

struct FlowEntityUses : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Flow::Entity, Fact<facebook::glean::cpp::schema::Src::File>, facebook::glean::cpp::schema::Src::ByteSpan>> {
  static const char* GLEAN_name() {
    return "codemarkup.flow.FlowEntityUses";
  }

  static constexpr size_t GLEAN_version() {
     return 2;
  }
}; // struct FlowEntityUses

struct FlowFileEntityXRefLocations : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Src::File>, facebook::glean::cpp::schema::Codemarkup::Types::XRefLocation, facebook::glean::cpp::schema::Code::Flow::Entity>> {
  static const char* GLEAN_name() {
    return "codemarkup.flow.FlowFileEntityXRefLocations";
  }

  static constexpr size_t GLEAN_version() {
     return 2;
  }
}; // struct FlowFileEntityXRefLocations

struct FlowFileImportDeclEntityXRefLocations : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Src::File>, facebook::glean::cpp::schema::Codemarkup::Types::XRefLocation, facebook::glean::cpp::schema::Code::Flow::Entity>> {
  static const char* GLEAN_name() {
    return "codemarkup.flow.FlowFileImportDeclEntityXRefLocations";
  }

  static constexpr size_t GLEAN_version() {
     return 2;
  }
}; // struct FlowFileImportDeclEntityXRefLocations

struct FlowFileReferenceEntityXRefLocations : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Src::File>, facebook::glean::cpp::schema::Codemarkup::Types::XRefLocation, facebook::glean::cpp::schema::Code::Flow::Entity>> {
  static const char* GLEAN_name() {
    return "codemarkup.flow.FlowFileReferenceEntityXRefLocations";
  }

  static constexpr size_t GLEAN_version() {
     return 2;
  }
}; // struct FlowFileReferenceEntityXRefLocations

struct FlowResolveLocation : Predicate<std::tuple<facebook::glean::cpp::schema::Codemarkup::Types::Location, facebook::glean::cpp::schema::Code::Flow::Entity>> {
  static const char* GLEAN_name() {
    return "codemarkup.flow.FlowResolveLocation";
  }

  static constexpr size_t GLEAN_version() {
     return 2;
  }
}; // struct FlowResolveLocation

} // namespace Flow

} // namespace Codemarkup

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Code::Fbthrift::Entity> {
  using Type = Sum<Repr<facebook::glean::cpp::schema::Fbthrift::Declaration>>;
};


namespace schema {

namespace Code {

namespace Fbthrift {

struct Entity {
  boost::variant<Alt<0, facebook::glean::cpp::schema::Fbthrift::Declaration>> GLEAN_value;

  static Entity decl(const facebook::glean::cpp::schema::Fbthrift::Declaration& a) {
    return Entity{Alt<0, facebook::glean::cpp::schema::Fbthrift::Declaration>(a)};
  }

  bool operator==(const Entity& other) const {
    return std::tie(GLEAN_value)
             == std::tie(other.GLEAN_value);
  }
  bool operator!=(const Entity& other) const {
    return std::tie(GLEAN_value)
             != std::tie(other.GLEAN_value);
  }
  bool operator<(const Entity& other) const {
    return std::tie(GLEAN_value)
             < std::tie(other.GLEAN_value);
  }
  bool operator<=(const Entity& other) const {
    return std::tie(GLEAN_value)
             <= std::tie(other.GLEAN_value);
  }
  bool operator>(const Entity& other) const {
    return std::tie(GLEAN_value)
             > std::tie(other.GLEAN_value);
  }
  bool operator>=(const Entity& other) const {
    return std::tie(GLEAN_value)
             >= std::tie(other.GLEAN_value);
  }

  void outputRepr(Output<Repr<Entity>> out) const {
    outputValue(out, GLEAN_value);
  }
}; // struct Entity

} // namespace Fbthrift

} // namespace Code

namespace Codemarkup {

namespace Fbthrift {

struct FbthriftEntityDocumentation : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Fbthrift::Entity, Fact<facebook::glean::cpp::schema::Src::File>, facebook::glean::cpp::schema::Src::ByteSpan>> {
  static const char* GLEAN_name() {
    return "codemarkup.fbthrift.FbthriftEntityDocumentation";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct FbthriftEntityDocumentation

struct ThriftContainsChildEntity : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Fbthrift::Entity, facebook::glean::cpp::schema::Code::Fbthrift::Entity>> {
  static const char* GLEAN_name() {
    return "codemarkup.fbthrift.ThriftContainsChildEntity";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct ThriftContainsChildEntity

struct ThriftContainsParentEntity : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Fbthrift::Entity, facebook::glean::cpp::schema::Code::Fbthrift::Entity>> {
  static const char* GLEAN_name() {
    return "codemarkup.fbthrift.ThriftContainsParentEntity";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct ThriftContainsParentEntity

struct ThriftEntityKind : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Fbthrift::Entity, facebook::glean::cpp::schema::Codemarkup::Types::SymbolKind>> {
  static const char* GLEAN_name() {
    return "codemarkup.fbthrift.ThriftEntityKind";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct ThriftEntityKind

struct ThriftEntityLocation : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Fbthrift::Entity, facebook::glean::cpp::schema::Codemarkup::Types::Location>> {
  static const char* GLEAN_name() {
    return "codemarkup.fbthrift.ThriftEntityLocation";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct ThriftEntityLocation

struct ThriftExtendsChildEntity : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Fbthrift::Entity, facebook::glean::cpp::schema::Code::Fbthrift::Entity>> {
  static const char* GLEAN_name() {
    return "codemarkup.fbthrift.ThriftExtendsChildEntity";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct ThriftExtendsChildEntity

struct ThriftExtendsParentEntity : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Fbthrift::Entity, facebook::glean::cpp::schema::Code::Fbthrift::Entity>> {
  static const char* GLEAN_name() {
    return "codemarkup.fbthrift.ThriftExtendsParentEntity";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct ThriftExtendsParentEntity

struct ThriftFileEntityXRefLocations : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Src::File>, facebook::glean::cpp::schema::Codemarkup::Types::XRefLocation, facebook::glean::cpp::schema::Code::Fbthrift::Entity>> {
  static const char* GLEAN_name() {
    return "codemarkup.fbthrift.ThriftFileEntityXRefLocations";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct ThriftFileEntityXRefLocations

struct ThriftResolveLocation : Predicate<std::tuple<facebook::glean::cpp::schema::Codemarkup::Types::Location, facebook::glean::cpp::schema::Code::Fbthrift::Entity>> {
  static const char* GLEAN_name() {
    return "codemarkup.fbthrift.ThriftResolveLocation";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct ThriftResolveLocation

} // namespace Fbthrift

} // namespace Codemarkup

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Code::Fbthrift::Annotations> {
  using Type = Sum<Array<facebook::glean::cpp::schema::Fbthrift::StructuredAnnotation>>;
};


namespace schema {

namespace Code {

namespace Fbthrift {

struct Annotations {
  boost::variant<Alt<0, std::vector<Fact<facebook::glean::cpp::schema::Fbthrift::StructuredAnnotation>>>> GLEAN_value;

  static Annotations annotations(const std::vector<Fact<facebook::glean::cpp::schema::Fbthrift::StructuredAnnotation>>& a) {
    return Annotations{Alt<0, std::vector<Fact<facebook::glean::cpp::schema::Fbthrift::StructuredAnnotation>>>(a)};
  }

  bool operator==(const Annotations& other) const {
    return std::tie(GLEAN_value)
             == std::tie(other.GLEAN_value);
  }
  bool operator!=(const Annotations& other) const {
    return std::tie(GLEAN_value)
             != std::tie(other.GLEAN_value);
  }
  bool operator<(const Annotations& other) const {
    return std::tie(GLEAN_value)
             < std::tie(other.GLEAN_value);
  }
  bool operator<=(const Annotations& other) const {
    return std::tie(GLEAN_value)
             <= std::tie(other.GLEAN_value);
  }
  bool operator>(const Annotations& other) const {
    return std::tie(GLEAN_value)
             > std::tie(other.GLEAN_value);
  }
  bool operator>=(const Annotations& other) const {
    return std::tie(GLEAN_value)
             >= std::tie(other.GLEAN_value);
  }

  void outputRepr(Output<Repr<Annotations>> out) const {
    outputValue(out, GLEAN_value);
  }
}; // struct Annotations

} // namespace Fbthrift

} // namespace Code

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Code::Erlang::Entity> {
  using Type = Sum<Repr<facebook::glean::cpp::schema::Erlang::Declaration>>;
};


namespace schema {

namespace Code {

namespace Erlang {

struct Entity {
  boost::variant<Alt<0, facebook::glean::cpp::schema::Erlang::Declaration>> GLEAN_value;

  static Entity decl(const facebook::glean::cpp::schema::Erlang::Declaration& a) {
    return Entity{Alt<0, facebook::glean::cpp::schema::Erlang::Declaration>(a)};
  }

  bool operator==(const Entity& other) const {
    return std::tie(GLEAN_value)
             == std::tie(other.GLEAN_value);
  }
  bool operator!=(const Entity& other) const {
    return std::tie(GLEAN_value)
             != std::tie(other.GLEAN_value);
  }
  bool operator<(const Entity& other) const {
    return std::tie(GLEAN_value)
             < std::tie(other.GLEAN_value);
  }
  bool operator<=(const Entity& other) const {
    return std::tie(GLEAN_value)
             <= std::tie(other.GLEAN_value);
  }
  bool operator>(const Entity& other) const {
    return std::tie(GLEAN_value)
             > std::tie(other.GLEAN_value);
  }
  bool operator>=(const Entity& other) const {
    return std::tie(GLEAN_value)
             >= std::tie(other.GLEAN_value);
  }

  void outputRepr(Output<Repr<Entity>> out) const {
    outputValue(out, GLEAN_value);
  }
}; // struct Entity

} // namespace Erlang

} // namespace Code

namespace Codemarkup {

namespace Erlang {

struct ErlangEntityDocumentation : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Erlang::Entity, Fact<facebook::glean::cpp::schema::Src::File>, facebook::glean::cpp::schema::Src::ByteSpan, boost::variant<Alt<0, std::tuple<>>, Alt<1, std::string>>>> {
  static const char* GLEAN_name() {
    return "codemarkup.erlang.ErlangEntityDocumentation";
  }

  static constexpr size_t GLEAN_version() {
     return 2;
  }
}; // struct ErlangEntityDocumentation

struct ErlangEntityInfo : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Erlang::Entity, facebook::glean::cpp::schema::Codemarkup::Types::SymbolInfo>> {
  static const char* GLEAN_name() {
    return "codemarkup.erlang.ErlangEntityInfo";
  }

  static constexpr size_t GLEAN_version() {
     return 2;
  }
}; // struct ErlangEntityInfo

struct ErlangEntityKind : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Erlang::Entity, facebook::glean::cpp::schema::Codemarkup::Types::SymbolKind>> {
  static const char* GLEAN_name() {
    return "codemarkup.erlang.ErlangEntityKind";
  }

  static constexpr size_t GLEAN_version() {
     return 2;
  }
}; // struct ErlangEntityKind

struct ErlangEntityLocation : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Erlang::Entity, facebook::glean::cpp::schema::Codemarkup::Types::Location>> {
  static const char* GLEAN_name() {
    return "codemarkup.erlang.ErlangEntityLocation";
  }

  static constexpr size_t GLEAN_version() {
     return 2;
  }
}; // struct ErlangEntityLocation

struct ErlangEntityUses : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Erlang::Entity, Fact<facebook::glean::cpp::schema::Src::File>, facebook::glean::cpp::schema::Src::ByteSpan>> {
  static const char* GLEAN_name() {
    return "codemarkup.erlang.ErlangEntityUses";
  }

  static constexpr size_t GLEAN_version() {
     return 2;
  }
}; // struct ErlangEntityUses

struct ErlangFileEntityXRefLocations : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Src::File>, facebook::glean::cpp::schema::Codemarkup::Types::XRefLocation, facebook::glean::cpp::schema::Code::Erlang::Entity>> {
  static const char* GLEAN_name() {
    return "codemarkup.erlang.ErlangFileEntityXRefLocations";
  }

  static constexpr size_t GLEAN_version() {
     return 2;
  }
}; // struct ErlangFileEntityXRefLocations

struct ErlangResolveLocation : Predicate<std::tuple<facebook::glean::cpp::schema::Codemarkup::Types::Location, facebook::glean::cpp::schema::Code::Erlang::Entity>> {
  static const char* GLEAN_name() {
    return "codemarkup.erlang.ErlangResolveLocation";
  }

  static constexpr size_t GLEAN_version() {
     return 2;
  }
}; // struct ErlangResolveLocation

} // namespace Erlang

} // namespace Codemarkup

namespace Search {

namespace Erlang {

struct SearchByFQN : Predicate<std::tuple<std::string, std::string, uint64_t, facebook::glean::cpp::schema::Code::Erlang::Entity>> {
  static const char* GLEAN_name() {
    return "search.erlang.SearchByFQN";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct SearchByFQN

struct SearchByName : Predicate<std::tuple<std::string, facebook::glean::cpp::schema::Code::Erlang::Entity>> {
  static const char* GLEAN_name() {
    return "search.erlang.SearchByName";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct SearchByName

} // namespace Erlang

} // namespace Search

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Code::Cxx::ObjcMethodEntity> {
  using Type = Sum<facebook::glean::cpp::schema::Cxx1::ObjcMethodDeclaration, facebook::glean::cpp::schema::Cxx1::ObjcMethodDefinition>;
};


namespace schema {

namespace Code {

namespace Cxx {

struct ObjcMethodEntity {
  boost::variant<Alt<0, Fact<facebook::glean::cpp::schema::Cxx1::ObjcMethodDeclaration>>, Alt<1, Fact<facebook::glean::cpp::schema::Cxx1::ObjcMethodDefinition>>> GLEAN_value;

  static ObjcMethodEntity decl(const Fact<facebook::glean::cpp::schema::Cxx1::ObjcMethodDeclaration>& a) {
    return ObjcMethodEntity{Alt<0, Fact<facebook::glean::cpp::schema::Cxx1::ObjcMethodDeclaration>>(a)};
  }
  static ObjcMethodEntity defn(const Fact<facebook::glean::cpp::schema::Cxx1::ObjcMethodDefinition>& a) {
    return ObjcMethodEntity{Alt<1, Fact<facebook::glean::cpp::schema::Cxx1::ObjcMethodDefinition>>(a)};
  }

  bool operator==(const ObjcMethodEntity& other) const {
    return std::tie(GLEAN_value)
             == std::tie(other.GLEAN_value);
  }
  bool operator!=(const ObjcMethodEntity& other) const {
    return std::tie(GLEAN_value)
             != std::tie(other.GLEAN_value);
  }
  bool operator<(const ObjcMethodEntity& other) const {
    return std::tie(GLEAN_value)
             < std::tie(other.GLEAN_value);
  }
  bool operator<=(const ObjcMethodEntity& other) const {
    return std::tie(GLEAN_value)
             <= std::tie(other.GLEAN_value);
  }
  bool operator>(const ObjcMethodEntity& other) const {
    return std::tie(GLEAN_value)
             > std::tie(other.GLEAN_value);
  }
  bool operator>=(const ObjcMethodEntity& other) const {
    return std::tie(GLEAN_value)
             >= std::tie(other.GLEAN_value);
  }

  void outputRepr(Output<Repr<ObjcMethodEntity>> out) const {
    outputValue(out, GLEAN_value);
  }
}; // struct ObjcMethodEntity

} // namespace Cxx

} // namespace Code

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Code::Cxx::ObjcSelectorSlotEntity> {
  using Type = Tuple<Repr<facebook::glean::cpp::schema::Code::Cxx::ObjcMethodEntity>, Nat>;
};


namespace schema {

namespace Code {

namespace Cxx {

struct ObjcSelectorSlotEntity {
  ObjcMethodEntity objcMethod;
  uint64_t index;

  bool operator==(const ObjcSelectorSlotEntity& other) const {
    return std::tie(objcMethod,index)
             == std::tie(other.objcMethod,other.index);
  }
  bool operator!=(const ObjcSelectorSlotEntity& other) const {
    return std::tie(objcMethod,index)
             != std::tie(other.objcMethod,other.index);
  }
  bool operator<(const ObjcSelectorSlotEntity& other) const {
    return std::tie(objcMethod,index)
             < std::tie(other.objcMethod,other.index);
  }
  bool operator<=(const ObjcSelectorSlotEntity& other) const {
    return std::tie(objcMethod,index)
             <= std::tie(other.objcMethod,other.index);
  }
  bool operator>(const ObjcSelectorSlotEntity& other) const {
    return std::tie(objcMethod,index)
             > std::tie(other.objcMethod,other.index);
  }
  bool operator>=(const ObjcSelectorSlotEntity& other) const {
    return std::tie(objcMethod,index)
             >= std::tie(other.objcMethod,other.index);
  }
  void outputRepr(Output<Repr<ObjcSelectorSlotEntity>> out) const {
    outputValue(out, std::make_tuple(objcMethod, index));
  }
}; // struct ObjcSelectorSlotEntity

} // namespace Cxx

} // namespace Code

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Code::Cxx::Definition> {
  using Type = Sum<facebook::glean::cpp::schema::Cxx1::RecordDefinition, facebook::glean::cpp::schema::Cxx1::FunctionDefinition, facebook::glean::cpp::schema::Cxx1::EnumDefinition, facebook::glean::cpp::schema::Cxx1::ObjcMethodDefinition, facebook::glean::cpp::schema::Cxx1::ObjcContainerDefinition, facebook::glean::cpp::schema::Cxx1::VariableDeclaration, facebook::glean::cpp::schema::Cxx1::NamespaceDefinition>;
};


namespace schema {

namespace Code {

namespace Cxx {

struct Definition {
  boost::variant<Alt<0, Fact<facebook::glean::cpp::schema::Cxx1::RecordDefinition>>, Alt<1, Fact<facebook::glean::cpp::schema::Cxx1::FunctionDefinition>>, Alt<2, Fact<facebook::glean::cpp::schema::Cxx1::EnumDefinition>>, Alt<3, Fact<facebook::glean::cpp::schema::Cxx1::ObjcMethodDefinition>>, Alt<4, Fact<facebook::glean::cpp::schema::Cxx1::ObjcContainerDefinition>>, Alt<5, Fact<facebook::glean::cpp::schema::Cxx1::VariableDeclaration>>, Alt<6, Fact<facebook::glean::cpp::schema::Cxx1::NamespaceDefinition>>> GLEAN_value;

  static Definition record_(const Fact<facebook::glean::cpp::schema::Cxx1::RecordDefinition>& a) {
    return Definition{Alt<0, Fact<facebook::glean::cpp::schema::Cxx1::RecordDefinition>>(a)};
  }
  static Definition function_(const Fact<facebook::glean::cpp::schema::Cxx1::FunctionDefinition>& a) {
    return Definition{Alt<1, Fact<facebook::glean::cpp::schema::Cxx1::FunctionDefinition>>(a)};
  }
  static Definition enum_(const Fact<facebook::glean::cpp::schema::Cxx1::EnumDefinition>& a) {
    return Definition{Alt<2, Fact<facebook::glean::cpp::schema::Cxx1::EnumDefinition>>(a)};
  }
  static Definition objcMethod(const Fact<facebook::glean::cpp::schema::Cxx1::ObjcMethodDefinition>& a) {
    return Definition{Alt<3, Fact<facebook::glean::cpp::schema::Cxx1::ObjcMethodDefinition>>(a)};
  }
  static Definition objcContainer(const Fact<facebook::glean::cpp::schema::Cxx1::ObjcContainerDefinition>& a) {
    return Definition{Alt<4, Fact<facebook::glean::cpp::schema::Cxx1::ObjcContainerDefinition>>(a)};
  }
  static Definition variable(const Fact<facebook::glean::cpp::schema::Cxx1::VariableDeclaration>& a) {
    return Definition{Alt<5, Fact<facebook::glean::cpp::schema::Cxx1::VariableDeclaration>>(a)};
  }
  static Definition namespace_(const Fact<facebook::glean::cpp::schema::Cxx1::NamespaceDefinition>& a) {
    return Definition{Alt<6, Fact<facebook::glean::cpp::schema::Cxx1::NamespaceDefinition>>(a)};
  }

  bool operator==(const Definition& other) const {
    return std::tie(GLEAN_value)
             == std::tie(other.GLEAN_value);
  }
  bool operator!=(const Definition& other) const {
    return std::tie(GLEAN_value)
             != std::tie(other.GLEAN_value);
  }
  bool operator<(const Definition& other) const {
    return std::tie(GLEAN_value)
             < std::tie(other.GLEAN_value);
  }
  bool operator<=(const Definition& other) const {
    return std::tie(GLEAN_value)
             <= std::tie(other.GLEAN_value);
  }
  bool operator>(const Definition& other) const {
    return std::tie(GLEAN_value)
             > std::tie(other.GLEAN_value);
  }
  bool operator>=(const Definition& other) const {
    return std::tie(GLEAN_value)
             >= std::tie(other.GLEAN_value);
  }

  void outputRepr(Output<Repr<Definition>> out) const {
    outputValue(out, GLEAN_value);
  }
}; // struct Definition

} // namespace Cxx

} // namespace Code

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Code::Cxx::Entity> {
  using Type = Sum<Repr<facebook::glean::cpp::schema::Cxx1::Declaration>, Repr<facebook::glean::cpp::schema::Code::Cxx::Definition>, facebook::glean::cpp::schema::Cxx1::Enumerator, Repr<facebook::glean::cpp::schema::Code::Cxx::ObjcSelectorSlotEntity>>;
};


namespace schema {

namespace Code {

namespace Cxx {

struct Entity {
  boost::variant<Alt<0, facebook::glean::cpp::schema::Cxx1::Declaration>, Alt<1, Definition>, Alt<2, Fact<facebook::glean::cpp::schema::Cxx1::Enumerator>>, Alt<3, ObjcSelectorSlotEntity>> GLEAN_value;

  static Entity decl(const facebook::glean::cpp::schema::Cxx1::Declaration& a) {
    return Entity{Alt<0, facebook::glean::cpp::schema::Cxx1::Declaration>(a)};
  }
  static Entity defn(const Definition& a) {
    return Entity{Alt<1, Definition>(a)};
  }
  static Entity enumerator(const Fact<facebook::glean::cpp::schema::Cxx1::Enumerator>& a) {
    return Entity{Alt<2, Fact<facebook::glean::cpp::schema::Cxx1::Enumerator>>(a)};
  }
  static Entity objcSelectorSlot(const ObjcSelectorSlotEntity& a) {
    return Entity{Alt<3, ObjcSelectorSlotEntity>(a)};
  }

  bool operator==(const Entity& other) const {
    return std::tie(GLEAN_value)
             == std::tie(other.GLEAN_value);
  }
  bool operator!=(const Entity& other) const {
    return std::tie(GLEAN_value)
             != std::tie(other.GLEAN_value);
  }
  bool operator<(const Entity& other) const {
    return std::tie(GLEAN_value)
             < std::tie(other.GLEAN_value);
  }
  bool operator<=(const Entity& other) const {
    return std::tie(GLEAN_value)
             <= std::tie(other.GLEAN_value);
  }
  bool operator>(const Entity& other) const {
    return std::tie(GLEAN_value)
             > std::tie(other.GLEAN_value);
  }
  bool operator>=(const Entity& other) const {
    return std::tie(GLEAN_value)
             >= std::tie(other.GLEAN_value);
  }

  void outputRepr(Output<Repr<Entity>> out) const {
    outputValue(out, GLEAN_value);
  }
}; // struct Entity

} // namespace Cxx

} // namespace Code

namespace Codemarkup {

namespace Cxx {

struct CxxContainsChildEntity : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Cxx::Entity, facebook::glean::cpp::schema::Code::Cxx::Entity>> {
  static const char* GLEAN_name() {
    return "codemarkup.cxx.CxxContainsChildEntity";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct CxxContainsChildEntity

struct CxxContainsParentEntity : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Cxx::Entity, facebook::glean::cpp::schema::Code::Cxx::Entity>> {
  static const char* GLEAN_name() {
    return "codemarkup.cxx.CxxContainsParentEntity";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct CxxContainsParentEntity

struct CxxDeclToDefXRefTargetLocation : Predicate<std::tuple<facebook::glean::cpp::schema::Cxx1::Declaration, facebook::glean::cpp::schema::Code::Cxx::Entity, facebook::glean::cpp::schema::Codemarkup::Types::Location>> {
  static const char* GLEAN_name() {
    return "codemarkup.cxx.CxxDeclToDefXRefTargetLocation";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct CxxDeclToDefXRefTargetLocation

struct CxxDeclarationContainsChild : Predicate<std::tuple<facebook::glean::cpp::schema::Cxx1::Declaration, facebook::glean::cpp::schema::Code::Cxx::Entity>> {
  static const char* GLEAN_name() {
    return "codemarkup.cxx.CxxDeclarationContainsChild";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct CxxDeclarationContainsChild

struct CxxDeclarationContainsParent : Predicate<std::tuple<facebook::glean::cpp::schema::Cxx1::Declaration, facebook::glean::cpp::schema::Code::Cxx::Entity>> {
  static const char* GLEAN_name() {
    return "codemarkup.cxx.CxxDeclarationContainsParent";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct CxxDeclarationContainsParent

struct CxxDeclarationExtendsChild : Predicate<std::tuple<facebook::glean::cpp::schema::Cxx1::Declaration, facebook::glean::cpp::schema::Code::Cxx::Entity>> {
  static const char* GLEAN_name() {
    return "codemarkup.cxx.CxxDeclarationExtendsChild";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct CxxDeclarationExtendsChild

struct CxxDeclarationExtendsParent : Predicate<std::tuple<facebook::glean::cpp::schema::Cxx1::Declaration, facebook::glean::cpp::schema::Code::Cxx::Entity>> {
  static const char* GLEAN_name() {
    return "codemarkup.cxx.CxxDeclarationExtendsParent";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct CxxDeclarationExtendsParent

struct CxxDeclarationSource : Predicate<std::tuple<facebook::glean::cpp::schema::Cxx1::Declaration, facebook::glean::cpp::schema::Code::Cxx::Entity>> {
  static const char* GLEAN_name() {
    return "codemarkup.cxx.CxxDeclarationSource";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct CxxDeclarationSource

struct CxxDefToDeclFamilyXRefTargetLocation : Predicate<std::tuple<facebook::glean::cpp::schema::Cxx1::Declaration, facebook::glean::cpp::schema::Code::Cxx::Entity, facebook::glean::cpp::schema::Codemarkup::Types::Location>> {
  static const char* GLEAN_name() {
    return "codemarkup.cxx.CxxDefToDeclFamilyXRefTargetLocation";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct CxxDefToDeclFamilyXRefTargetLocation

struct CxxEntityDocumentation : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Cxx::Entity, Fact<facebook::glean::cpp::schema::Src::File>, facebook::glean::cpp::schema::Src::ByteSpan>> {
  static const char* GLEAN_name() {
    return "codemarkup.cxx.CxxEntityDocumentation";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct CxxEntityDocumentation

struct CxxEntityInfo : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Cxx::Entity, facebook::glean::cpp::schema::Codemarkup::Types::SymbolInfo>> {
  static const char* GLEAN_name() {
    return "codemarkup.cxx.CxxEntityInfo";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct CxxEntityInfo

struct CxxEntityKind : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Cxx::Entity, facebook::glean::cpp::schema::Codemarkup::Types::SymbolKind>> {
  static const char* GLEAN_name() {
    return "codemarkup.cxx.CxxEntityKind";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct CxxEntityKind

struct CxxEntityLocation : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Cxx::Entity, facebook::glean::cpp::schema::Codemarkup::Types::Location>> {
  static const char* GLEAN_name() {
    return "codemarkup.cxx.CxxEntityLocation";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct CxxEntityLocation

struct CxxEntitySource : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Cxx::Entity, facebook::glean::cpp::schema::Code::Cxx::Entity>> {
  static const char* GLEAN_name() {
    return "codemarkup.cxx.CxxEntitySource";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct CxxEntitySource

struct CxxEntityUSR : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Cxx::Entity, facebook::glean::cpp::schema::Cxx1::USR>> {
  static const char* GLEAN_name() {
    return "codemarkup.cxx.CxxEntityUSR";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct CxxEntityUSR

struct CxxEntityUses : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Cxx::Entity, Fact<facebook::glean::cpp::schema::Src::File>, facebook::glean::cpp::schema::Src::ByteSpan>> {
  static const char* GLEAN_name() {
    return "codemarkup.cxx.CxxEntityUses";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct CxxEntityUses

struct CxxExtendsChildEntity : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Cxx::Entity, facebook::glean::cpp::schema::Code::Cxx::Entity>> {
  static const char* GLEAN_name() {
    return "codemarkup.cxx.CxxExtendsChildEntity";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct CxxExtendsChildEntity

struct CxxExtendsParentEntity : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Cxx::Entity, facebook::glean::cpp::schema::Code::Cxx::Entity>> {
  static const char* GLEAN_name() {
    return "codemarkup.cxx.CxxExtendsParentEntity";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct CxxExtendsParentEntity

struct CxxFileEntitySpellingXRefLocations : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Src::File>, facebook::glean::cpp::schema::Codemarkup::Types::XRefLocation, facebook::glean::cpp::schema::Code::Cxx::Entity>> {
  static const char* GLEAN_name() {
    return "codemarkup.cxx.CxxFileEntitySpellingXRefLocations";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct CxxFileEntitySpellingXRefLocations

struct CxxFileEntityTraceDeclToDefXRefLocations : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Src::File>, Fact<facebook::glean::cpp::schema::Cxx1::Trace>, facebook::glean::cpp::schema::Codemarkup::Types::XRefLocation, facebook::glean::cpp::schema::Code::Cxx::Entity>> {
  static const char* GLEAN_name() {
    return "codemarkup.cxx.CxxFileEntityTraceDeclToDefXRefLocations";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct CxxFileEntityTraceDeclToDefXRefLocations

struct CxxFileEntityXMapFixedXRefLocations : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Cxx1::FileXRefs>, facebook::glean::cpp::schema::Codemarkup::Types::XRefLocation, facebook::glean::cpp::schema::Code::Cxx::Entity>> {
  static const char* GLEAN_name() {
    return "codemarkup.cxx.CxxFileEntityXMapFixedXRefLocations";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct CxxFileEntityXMapFixedXRefLocations

struct CxxFileEntityXMapVariableXRefDeclToDefs : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Cxx1::FileXRefs>, facebook::glean::cpp::schema::Cxx1::Declaration, facebook::glean::cpp::schema::Code::Cxx::Entity, facebook::glean::cpp::schema::Codemarkup::Types::Location>> {
  static const char* GLEAN_name() {
    return "codemarkup.cxx.CxxFileEntityXMapVariableXRefDeclToDefs";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct CxxFileEntityXMapVariableXRefDeclToDefs

struct CxxFileEntityXRefLocations : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Src::File>, facebook::glean::cpp::schema::Codemarkup::Types::XRefLocation, facebook::glean::cpp::schema::Code::Cxx::Entity>> {
  static const char* GLEAN_name() {
    return "codemarkup.cxx.CxxFileEntityXRefLocations";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct CxxFileEntityXRefLocations

struct CxxFindDefinitionOfEntity : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Cxx::Entity, facebook::glean::cpp::schema::Code::Cxx::Entity>> {
  static const char* GLEAN_name() {
    return "codemarkup.cxx.CxxFindDefinitionOfEntity";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct CxxFindDefinitionOfEntity

struct CxxModifiers : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Cxx::Entity, facebook::glean::cpp::schema::Codemarkup::Types::Modifiers>> {
  static const char* GLEAN_name() {
    return "codemarkup.cxx.CxxModifiers";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct CxxModifiers

struct CxxNamespaceDeclarationContainsChild : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Cxx1::NamespaceDeclaration>, facebook::glean::cpp::schema::Code::Cxx::Entity>> {
  static const char* GLEAN_name() {
    return "codemarkup.cxx.CxxNamespaceDeclarationContainsChild";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct CxxNamespaceDeclarationContainsChild

struct CxxResolveDeclarationToEntity : Predicate<std::tuple<facebook::glean::cpp::schema::Cxx1::Declaration, facebook::glean::cpp::schema::Code::Cxx::Entity>> {
  static const char* GLEAN_name() {
    return "codemarkup.cxx.CxxResolveDeclarationToEntity";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct CxxResolveDeclarationToEntity

struct CxxResolveLocation : Predicate<std::tuple<facebook::glean::cpp::schema::Codemarkup::Types::Location, facebook::glean::cpp::schema::Code::Cxx::Entity>> {
  static const char* GLEAN_name() {
    return "codemarkup.cxx.CxxResolveLocation";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct CxxResolveLocation

struct CxxResolveTraceLocation : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Cxx1::Trace>, facebook::glean::cpp::schema::Codemarkup::Types::Location, facebook::glean::cpp::schema::Code::Cxx::Entity>> {
  static const char* GLEAN_name() {
    return "codemarkup.cxx.CxxResolveTraceLocation";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct CxxResolveTraceLocation

struct CxxVisibility : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Cxx::Entity, facebook::glean::cpp::schema::Codemarkup::Types::Visibility>> {
  static const char* GLEAN_name() {
    return "codemarkup.cxx.CxxVisibility";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct CxxVisibility

struct CxxXRefTargetLocation : Predicate<std::tuple<facebook::glean::cpp::schema::Cxx1::XRefTarget, facebook::glean::cpp::schema::Code::Cxx::Entity, facebook::glean::cpp::schema::Codemarkup::Types::Location>> {
  static const char* GLEAN_name() {
    return "codemarkup.cxx.CxxXRefTargetLocation";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct CxxXRefTargetLocation

struct EntityToXRefTarget : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Cxx::Entity, facebook::glean::cpp::schema::Cxx1::XRefTarget>> {
  static const char* GLEAN_name() {
    return "codemarkup.cxx.EntityToXRefTarget";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct EntityToXRefTarget

struct XRefTargetToEntity : Predicate<std::tuple<facebook::glean::cpp::schema::Cxx1::XRefTarget, facebook::glean::cpp::schema::Code::Cxx::Entity>> {
  static const char* GLEAN_name() {
    return "codemarkup.cxx.XRefTargetToEntity";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct XRefTargetToEntity

} // namespace Cxx

} // namespace Codemarkup

namespace Codemetrics {

struct CxxReferencesFrom : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Cxx::Entity, facebook::glean::cpp::schema::Code::Cxx::Entity>> {
  static const char* GLEAN_name() {
    return "codemetrics.CxxReferencesFrom";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct CxxReferencesFrom

struct CxxReferencesTo : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Cxx::Entity, facebook::glean::cpp::schema::Code::Cxx::Entity>> {
  static const char* GLEAN_name() {
    return "codemetrics.CxxReferencesTo";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct CxxReferencesTo

} // namespace Codemetrics

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Glean::Test::Entity> {
  using Type = Sum<Repr<facebook::glean::cpp::schema::Code::Cxx::Entity>, facebook::glean::cpp::schema::Pp1::Define>;
};


namespace schema {

namespace Glean {

namespace Test {

struct Entity {
  boost::variant<Alt<0, facebook::glean::cpp::schema::Code::Cxx::Entity>, Alt<1, Fact<facebook::glean::cpp::schema::Pp1::Define>>> GLEAN_value;

  static Entity cxx(const facebook::glean::cpp::schema::Code::Cxx::Entity& a) {
    return Entity{Alt<0, facebook::glean::cpp::schema::Code::Cxx::Entity>(a)};
  }
  static Entity pp(const Fact<facebook::glean::cpp::schema::Pp1::Define>& a) {
    return Entity{Alt<1, Fact<facebook::glean::cpp::schema::Pp1::Define>>(a)};
  }

  bool operator==(const Entity& other) const {
    return std::tie(GLEAN_value)
             == std::tie(other.GLEAN_value);
  }
  bool operator!=(const Entity& other) const {
    return std::tie(GLEAN_value)
             != std::tie(other.GLEAN_value);
  }
  bool operator<(const Entity& other) const {
    return std::tie(GLEAN_value)
             < std::tie(other.GLEAN_value);
  }
  bool operator<=(const Entity& other) const {
    return std::tie(GLEAN_value)
             <= std::tie(other.GLEAN_value);
  }
  bool operator>(const Entity& other) const {
    return std::tie(GLEAN_value)
             > std::tie(other.GLEAN_value);
  }
  bool operator>=(const Entity& other) const {
    return std::tie(GLEAN_value)
             >= std::tie(other.GLEAN_value);
  }

  void outputRepr(Output<Repr<Entity>> out) const {
    outputValue(out, GLEAN_value);
  }
}; // struct Entity

} // namespace Test

} // namespace Glean

namespace Search {

namespace Cxx {

struct EntityUses : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Cxx::Entity, Fact<facebook::glean::cpp::schema::Cxx1::TargetUses>>> {
  static const char* GLEAN_name() {
    return "search.cxx.EntityUses";
  }

  static constexpr size_t GLEAN_version() {
     return 5;
  }
}; // struct EntityUses

struct SearchBySelector : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Cxx1::ObjcSelector>, facebook::glean::cpp::schema::Code::Cxx::Entity>> {
  static const char* GLEAN_name() {
    return "search.cxx.SearchBySelector";
  }

  static constexpr size_t GLEAN_version() {
     return 5;
  }
}; // struct SearchBySelector

} // namespace Cxx

} // namespace Search

namespace Symbolid {

namespace Cxx {

struct DefinitionOfDecl : Predicate<std::tuple<facebook::glean::cpp::schema::Cxx1::Declaration, facebook::glean::cpp::schema::Code::Cxx::Entity>> {
  static const char* GLEAN_name() {
    return "symbolid.cxx.DefinitionOfDecl";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct DefinitionOfDecl

struct LookupNamespaceDefinition : Predicate<std::tuple<boost::variant<Alt<0, std::tuple<>>, Alt<1, Fact<facebook::glean::cpp::schema::Cxx1::Name>>>, boost::variant<Alt<0, std::tuple<>>, Alt<1, Fact<facebook::glean::cpp::schema::Cxx1::NamespaceQName>>>, facebook::glean::cpp::schema::Code::Cxx::Entity>> {
  static const char* GLEAN_name() {
    return "symbolid.cxx.LookupNamespaceDefinition";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct LookupNamespaceDefinition

} // namespace Cxx

} // namespace Symbolid

namespace Codemarkup {

namespace Cxx {

struct CxxDefinitionContainsChild : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Cxx::Definition, facebook::glean::cpp::schema::Code::Cxx::Entity>> {
  static const char* GLEAN_name() {
    return "codemarkup.cxx.CxxDefinitionContainsChild";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct CxxDefinitionContainsChild

struct CxxDefinitionContainsParent : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Cxx::Definition, facebook::glean::cpp::schema::Code::Cxx::Entity>> {
  static const char* GLEAN_name() {
    return "codemarkup.cxx.CxxDefinitionContainsParent";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct CxxDefinitionContainsParent

struct CxxDefinitionExtendsChild : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Cxx::Definition, facebook::glean::cpp::schema::Code::Cxx::Entity>> {
  static const char* GLEAN_name() {
    return "codemarkup.cxx.CxxDefinitionExtendsChild";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct CxxDefinitionExtendsChild

struct CxxDefinitionExtendsParent : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Cxx::Definition, facebook::glean::cpp::schema::Code::Cxx::Entity>> {
  static const char* GLEAN_name() {
    return "codemarkup.cxx.CxxDefinitionExtendsParent";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct CxxDefinitionExtendsParent

struct CxxDefinitionModifiers : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Cxx::Definition, facebook::glean::cpp::schema::Codemarkup::Types::Modifiers>> {
  static const char* GLEAN_name() {
    return "codemarkup.cxx.CxxDefinitionModifiers";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct CxxDefinitionModifiers

struct CxxDefnVisibility : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Cxx::Definition, facebook::glean::cpp::schema::Codemarkup::Types::Visibility>> {
  static const char* GLEAN_name() {
    return "codemarkup.cxx.CxxDefnVisibility";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct CxxDefnVisibility

struct CxxEntityDefinitionBase : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Cxx::Definition, facebook::glean::cpp::schema::Cxx1::Declaration>> {
  static const char* GLEAN_name() {
    return "codemarkup.cxx.CxxEntityDefinitionBase";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct CxxEntityDefinitionBase

} // namespace Cxx

} // namespace Codemarkup

namespace Search {

namespace Cxx {

struct DeclIsDefn : Predicate<std::tuple<facebook::glean::cpp::schema::Cxx1::Declaration, facebook::glean::cpp::schema::Code::Cxx::Definition>> {
  static const char* GLEAN_name() {
    return "search.cxx.DeclIsDefn";
  }

  static constexpr size_t GLEAN_version() {
     return 5;
  }
}; // struct DeclIsDefn

} // namespace Cxx

} // namespace Search

namespace Code {

namespace Cxx {

struct DeclToDef : Predicate<std::tuple<facebook::glean::cpp::schema::Cxx1::Declaration, Definition>> {
  static const char* GLEAN_name() {
    return "code.cxx.DeclToDef";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct DeclToDef

} // namespace Cxx

} // namespace Code

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Code::Cxx::Annotations> {
  using Type = Sum<Array<facebook::glean::cpp::schema::Cxx1::Attribute>>;
};


namespace schema {

namespace Code {

namespace Cxx {

struct Annotations {
  boost::variant<Alt<0, std::vector<Fact<facebook::glean::cpp::schema::Cxx1::Attribute>>>> GLEAN_value;

  static Annotations attributes(const std::vector<Fact<facebook::glean::cpp::schema::Cxx1::Attribute>>& a) {
    return Annotations{Alt<0, std::vector<Fact<facebook::glean::cpp::schema::Cxx1::Attribute>>>(a)};
  }

  bool operator==(const Annotations& other) const {
    return std::tie(GLEAN_value)
             == std::tie(other.GLEAN_value);
  }
  bool operator!=(const Annotations& other) const {
    return std::tie(GLEAN_value)
             != std::tie(other.GLEAN_value);
  }
  bool operator<(const Annotations& other) const {
    return std::tie(GLEAN_value)
             < std::tie(other.GLEAN_value);
  }
  bool operator<=(const Annotations& other) const {
    return std::tie(GLEAN_value)
             <= std::tie(other.GLEAN_value);
  }
  bool operator>(const Annotations& other) const {
    return std::tie(GLEAN_value)
             > std::tie(other.GLEAN_value);
  }
  bool operator>=(const Annotations& other) const {
    return std::tie(GLEAN_value)
             >= std::tie(other.GLEAN_value);
  }

  void outputRepr(Output<Repr<Annotations>> out) const {
    outputValue(out, GLEAN_value);
  }
}; // struct Annotations

} // namespace Cxx

} // namespace Code

namespace Codemarkup {

namespace Cxx {

struct CxxAnnotation : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Cxx::Entity, facebook::glean::cpp::schema::Code::Cxx::Annotations>> {
  static const char* GLEAN_name() {
    return "codemarkup.cxx.CxxAnnotation";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct CxxAnnotation

} // namespace Cxx

} // namespace Codemarkup

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Code::Csharp::Entity> {
  using Type = Sum<Repr<facebook::glean::cpp::schema::Csharp::Definition>>;
};


namespace schema {

namespace Code {

namespace Csharp {

struct Entity {
  boost::variant<Alt<0, facebook::glean::cpp::schema::Csharp::Definition>> GLEAN_value;

  static Entity decl(const facebook::glean::cpp::schema::Csharp::Definition& a) {
    return Entity{Alt<0, facebook::glean::cpp::schema::Csharp::Definition>(a)};
  }

  bool operator==(const Entity& other) const {
    return std::tie(GLEAN_value)
             == std::tie(other.GLEAN_value);
  }
  bool operator!=(const Entity& other) const {
    return std::tie(GLEAN_value)
             != std::tie(other.GLEAN_value);
  }
  bool operator<(const Entity& other) const {
    return std::tie(GLEAN_value)
             < std::tie(other.GLEAN_value);
  }
  bool operator<=(const Entity& other) const {
    return std::tie(GLEAN_value)
             <= std::tie(other.GLEAN_value);
  }
  bool operator>(const Entity& other) const {
    return std::tie(GLEAN_value)
             > std::tie(other.GLEAN_value);
  }
  bool operator>=(const Entity& other) const {
    return std::tie(GLEAN_value)
             >= std::tie(other.GLEAN_value);
  }

  void outputRepr(Output<Repr<Entity>> out) const {
    outputValue(out, GLEAN_value);
  }
}; // struct Entity

} // namespace Csharp

} // namespace Code

namespace Codemarkup {

namespace Csharp {

struct CSharpEntityKind : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Csharp::Entity, facebook::glean::cpp::schema::Codemarkup::Types::SymbolKind>> {
  static const char* GLEAN_name() {
    return "codemarkup.csharp.CSharpEntityKind";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct CSharpEntityKind

struct CSharpEntityLocation : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Csharp::Entity, facebook::glean::cpp::schema::Codemarkup::Types::Location>> {
  static const char* GLEAN_name() {
    return "codemarkup.csharp.CSharpEntityLocation";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct CSharpEntityLocation

struct CSharpEntityUses : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Csharp::Entity, Fact<facebook::glean::cpp::schema::Src::File>, facebook::glean::cpp::schema::Src::ByteSpan>> {
  static const char* GLEAN_name() {
    return "codemarkup.csharp.CSharpEntityUses";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct CSharpEntityUses

struct CSharpFileEntityXRefLocations : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Src::File>, facebook::glean::cpp::schema::Codemarkup::Types::XRefLocation, facebook::glean::cpp::schema::Code::Csharp::Entity>> {
  static const char* GLEAN_name() {
    return "codemarkup.csharp.CSharpFileEntityXRefLocations";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct CSharpFileEntityXRefLocations

struct CSharpResolveLocation : Predicate<std::tuple<facebook::glean::cpp::schema::Codemarkup::Types::Location, facebook::glean::cpp::schema::Code::Csharp::Entity>> {
  static const char* GLEAN_name() {
    return "codemarkup.csharp.CSharpResolveLocation";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct CSharpResolveLocation

} // namespace Csharp

} // namespace Codemarkup

namespace Code {

namespace Compose {

struct CxxContainerChildSignatures : Predicate<std::tuple<std::string, facebook::glean::cpp::schema::Codemarkup::Types::SymbolKind, std::string, std::string, std::vector<facebook::glean::cpp::schema::Cxx1::Parameter>>> {
  static const char* GLEAN_name() {
    return "code.compose.CxxContainerChildSignatures";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct CxxContainerChildSignatures

} // namespace Compose

} // namespace Code

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Code::Buck::Entity> {
  using Type = Sum<facebook::glean::cpp::schema::Buck::Locator, facebook::glean::cpp::schema::Src::File, facebook::glean::cpp::schema::Buck::Definition>;
};


namespace schema {

namespace Code {

namespace Buck {

struct Entity {
  boost::variant<Alt<0, Fact<facebook::glean::cpp::schema::Buck::Locator>>, Alt<1, Fact<facebook::glean::cpp::schema::Src::File>>, Alt<2, Fact<facebook::glean::cpp::schema::Buck::Definition>>> GLEAN_value;

  static Entity locator(const Fact<facebook::glean::cpp::schema::Buck::Locator>& a) {
    return Entity{Alt<0, Fact<facebook::glean::cpp::schema::Buck::Locator>>(a)};
  }
  static Entity file(const Fact<facebook::glean::cpp::schema::Src::File>& a) {
    return Entity{Alt<1, Fact<facebook::glean::cpp::schema::Src::File>>(a)};
  }
  static Entity definition(const Fact<facebook::glean::cpp::schema::Buck::Definition>& a) {
    return Entity{Alt<2, Fact<facebook::glean::cpp::schema::Buck::Definition>>(a)};
  }

  bool operator==(const Entity& other) const {
    return std::tie(GLEAN_value)
             == std::tie(other.GLEAN_value);
  }
  bool operator!=(const Entity& other) const {
    return std::tie(GLEAN_value)
             != std::tie(other.GLEAN_value);
  }
  bool operator<(const Entity& other) const {
    return std::tie(GLEAN_value)
             < std::tie(other.GLEAN_value);
  }
  bool operator<=(const Entity& other) const {
    return std::tie(GLEAN_value)
             <= std::tie(other.GLEAN_value);
  }
  bool operator>(const Entity& other) const {
    return std::tie(GLEAN_value)
             > std::tie(other.GLEAN_value);
  }
  bool operator>=(const Entity& other) const {
    return std::tie(GLEAN_value)
             >= std::tie(other.GLEAN_value);
  }

  void outputRepr(Output<Repr<Entity>> out) const {
    outputValue(out, GLEAN_value);
  }
}; // struct Entity

} // namespace Buck

} // namespace Code

namespace Codemarkup {

namespace Buck {

struct BuckEntityKind : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Buck::Entity, facebook::glean::cpp::schema::Codemarkup::Types::SymbolKind>> {
  static const char* GLEAN_name() {
    return "codemarkup.buck.BuckEntityKind";
  }

  static constexpr size_t GLEAN_version() {
     return 2;
  }
}; // struct BuckEntityKind

struct BuckEntityLocation : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Buck::Entity, facebook::glean::cpp::schema::Codemarkup::Types::Location>> {
  static const char* GLEAN_name() {
    return "codemarkup.buck.BuckEntityLocation";
  }

  static constexpr size_t GLEAN_version() {
     return 2;
  }
}; // struct BuckEntityLocation

struct BuckEntityUses : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Buck::Entity, Fact<facebook::glean::cpp::schema::Src::File>, facebook::glean::cpp::schema::Src::ByteSpan>> {
  static const char* GLEAN_name() {
    return "codemarkup.buck.BuckEntityUses";
  }

  static constexpr size_t GLEAN_version() {
     return 2;
  }
}; // struct BuckEntityUses

struct BuckFileEntityXRefLocations : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Src::File>, facebook::glean::cpp::schema::Codemarkup::Types::XRefLocation, facebook::glean::cpp::schema::Code::Buck::Entity>> {
  static const char* GLEAN_name() {
    return "codemarkup.buck.BuckFileEntityXRefLocations";
  }

  static constexpr size_t GLEAN_version() {
     return 2;
  }
}; // struct BuckFileEntityXRefLocations

struct BuckResolveLocation : Predicate<std::tuple<facebook::glean::cpp::schema::Codemarkup::Types::Location, facebook::glean::cpp::schema::Code::Buck::Entity>> {
  static const char* GLEAN_name() {
    return "codemarkup.buck.BuckResolveLocation";
  }

  static constexpr size_t GLEAN_version() {
     return 2;
  }
}; // struct BuckResolveLocation

} // namespace Buck

} // namespace Codemarkup

namespace Search {

namespace Buck {

struct SearchByFQN : Predicate<std::tuple<boost::variant<Alt<0, std::tuple<>>, Alt<1, std::string>>, std::string, std::string, facebook::glean::cpp::schema::Code::Buck::Entity>> {
  static const char* GLEAN_name() {
    return "search.buck.SearchByFQN";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct SearchByFQN

struct SearchDefinition : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Src::File>, std::string, facebook::glean::cpp::schema::Code::Buck::Entity>> {
  static const char* GLEAN_name() {
    return "search.buck.SearchDefinition";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct SearchDefinition

struct SearchFile : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Src::File>, facebook::glean::cpp::schema::Code::Buck::Entity>> {
  static const char* GLEAN_name() {
    return "search.buck.SearchFile";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct SearchFile

} // namespace Buck

} // namespace Search

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Code::Language> {
  using Type = Enum<20>;
};


namespace schema {

namespace Code {

enum class Language { Cpp, PreProcessor, Java, Haskell, Python, Hack, JavaScript, Rust, Thrift, Buck, Erlang, FSharp, Go, Kotlin, OCaml, Scala, Swift, TypeScript, CSharp, GraphQL };

struct EntityLanguageSCIP : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Scip::Entity, Language>> {
  static const char* GLEAN_name() {
    return "code.EntityLanguageSCIP";
  }

  static constexpr size_t GLEAN_version() {
     return 24;
  }
}; // struct EntityLanguageSCIP

struct EntityLanguageLSIF : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Lsif::Entity, Language>> {
  static const char* GLEAN_name() {
    return "code.EntityLanguageLSIF";
  }

  static constexpr size_t GLEAN_version() {
     return 24;
  }
}; // struct EntityLanguageLSIF

} // namespace Code

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Code::Entity> {
  using Type = Sum<Repr<facebook::glean::cpp::schema::Code::Cxx::Entity>, Repr<facebook::glean::cpp::schema::Code::Pp::Entity>, Repr<facebook::glean::cpp::schema::Code::Java::Entity>, Repr<facebook::glean::cpp::schema::Code::Kotlin::Entity>, Repr<facebook::glean::cpp::schema::Code::Hs::Entity>, Repr<facebook::glean::cpp::schema::Code::Python::Entity>, Repr<facebook::glean::cpp::schema::Code::Hack::Entity>, Repr<facebook::glean::cpp::schema::Code::Flow::Entity>, Repr<facebook::glean::cpp::schema::Code::Fbthrift::Entity>, Repr<facebook::glean::cpp::schema::Code::Buck::Entity>, Repr<facebook::glean::cpp::schema::Code::Erlang::Entity>, Repr<facebook::glean::cpp::schema::Code::Lsif::Entity>, Repr<facebook::glean::cpp::schema::Code::Scip::Entity>, Repr<facebook::glean::cpp::schema::Code::Csharp::Entity>, Repr<facebook::glean::cpp::schema::Code::Graphql::Entity>>;
};


namespace schema {

namespace Code {

struct Entity {
  boost::variant<Alt<0, facebook::glean::cpp::schema::Code::Cxx::Entity>, Alt<1, facebook::glean::cpp::schema::Code::Pp::Entity>, Alt<2, facebook::glean::cpp::schema::Code::Java::Entity>, Alt<3, facebook::glean::cpp::schema::Code::Kotlin::Entity>, Alt<4, facebook::glean::cpp::schema::Code::Hs::Entity>, Alt<5, facebook::glean::cpp::schema::Code::Python::Entity>, Alt<6, facebook::glean::cpp::schema::Code::Hack::Entity>, Alt<7, facebook::glean::cpp::schema::Code::Flow::Entity>, Alt<8, facebook::glean::cpp::schema::Code::Fbthrift::Entity>, Alt<9, facebook::glean::cpp::schema::Code::Buck::Entity>, Alt<10, facebook::glean::cpp::schema::Code::Erlang::Entity>, Alt<11, facebook::glean::cpp::schema::Code::Lsif::Entity>, Alt<12, facebook::glean::cpp::schema::Code::Scip::Entity>, Alt<13, facebook::glean::cpp::schema::Code::Csharp::Entity>, Alt<14, facebook::glean::cpp::schema::Code::Graphql::Entity>> GLEAN_value;

  static Entity cxx(const facebook::glean::cpp::schema::Code::Cxx::Entity& a) {
    return Entity{Alt<0, facebook::glean::cpp::schema::Code::Cxx::Entity>(a)};
  }
  static Entity pp(const facebook::glean::cpp::schema::Code::Pp::Entity& a) {
    return Entity{Alt<1, facebook::glean::cpp::schema::Code::Pp::Entity>(a)};
  }
  static Entity java(const facebook::glean::cpp::schema::Code::Java::Entity& a) {
    return Entity{Alt<2, facebook::glean::cpp::schema::Code::Java::Entity>(a)};
  }
  static Entity kotlin(const facebook::glean::cpp::schema::Code::Kotlin::Entity& a) {
    return Entity{Alt<3, facebook::glean::cpp::schema::Code::Kotlin::Entity>(a)};
  }
  static Entity hs(const facebook::glean::cpp::schema::Code::Hs::Entity& a) {
    return Entity{Alt<4, facebook::glean::cpp::schema::Code::Hs::Entity>(a)};
  }
  static Entity python(const facebook::glean::cpp::schema::Code::Python::Entity& a) {
    return Entity{Alt<5, facebook::glean::cpp::schema::Code::Python::Entity>(a)};
  }
  static Entity hack(const facebook::glean::cpp::schema::Code::Hack::Entity& a) {
    return Entity{Alt<6, facebook::glean::cpp::schema::Code::Hack::Entity>(a)};
  }
  static Entity flow(const facebook::glean::cpp::schema::Code::Flow::Entity& a) {
    return Entity{Alt<7, facebook::glean::cpp::schema::Code::Flow::Entity>(a)};
  }
  static Entity fbthrift(const facebook::glean::cpp::schema::Code::Fbthrift::Entity& a) {
    return Entity{Alt<8, facebook::glean::cpp::schema::Code::Fbthrift::Entity>(a)};
  }
  static Entity buck(const facebook::glean::cpp::schema::Code::Buck::Entity& a) {
    return Entity{Alt<9, facebook::glean::cpp::schema::Code::Buck::Entity>(a)};
  }
  static Entity erlang(const facebook::glean::cpp::schema::Code::Erlang::Entity& a) {
    return Entity{Alt<10, facebook::glean::cpp::schema::Code::Erlang::Entity>(a)};
  }
  static Entity lsif(const facebook::glean::cpp::schema::Code::Lsif::Entity& a) {
    return Entity{Alt<11, facebook::glean::cpp::schema::Code::Lsif::Entity>(a)};
  }
  static Entity scip(const facebook::glean::cpp::schema::Code::Scip::Entity& a) {
    return Entity{Alt<12, facebook::glean::cpp::schema::Code::Scip::Entity>(a)};
  }
  static Entity csharp(const facebook::glean::cpp::schema::Code::Csharp::Entity& a) {
    return Entity{Alt<13, facebook::glean::cpp::schema::Code::Csharp::Entity>(a)};
  }
  static Entity graphql(const facebook::glean::cpp::schema::Code::Graphql::Entity& a) {
    return Entity{Alt<14, facebook::glean::cpp::schema::Code::Graphql::Entity>(a)};
  }

  bool operator==(const Entity& other) const {
    return std::tie(GLEAN_value)
             == std::tie(other.GLEAN_value);
  }
  bool operator!=(const Entity& other) const {
    return std::tie(GLEAN_value)
             != std::tie(other.GLEAN_value);
  }
  bool operator<(const Entity& other) const {
    return std::tie(GLEAN_value)
             < std::tie(other.GLEAN_value);
  }
  bool operator<=(const Entity& other) const {
    return std::tie(GLEAN_value)
             <= std::tie(other.GLEAN_value);
  }
  bool operator>(const Entity& other) const {
    return std::tie(GLEAN_value)
             > std::tie(other.GLEAN_value);
  }
  bool operator>=(const Entity& other) const {
    return std::tie(GLEAN_value)
             >= std::tie(other.GLEAN_value);
  }

  void outputRepr(Output<Repr<Entity>> out) const {
    outputValue(out, GLEAN_value);
  }
}; // struct Entity

struct EntityLanguage : Predicate<std::tuple<Entity, Language>> {
  static const char* GLEAN_name() {
    return "code.EntityLanguage";
  }

  static constexpr size_t GLEAN_version() {
     return 24;
  }
}; // struct EntityLanguage

} // namespace Code

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Code::IdlEntity> {
  using Type = Tuple<Repr<facebook::glean::cpp::schema::Code::Language>, facebook::glean::cpp::schema::Src::File, Maybe<Repr<facebook::glean::cpp::schema::Code::Entity>>, Maybe<Repr<facebook::glean::cpp::schema::Src::Range>>>;
};


namespace schema {

namespace Code {

struct IdlEntity {
  Language lang;
  Fact<facebook::glean::cpp::schema::Src::File> file;
  boost::variant<Alt<0, std::tuple<>>, Alt<1, Entity>> entity;
  boost::variant<Alt<0, std::tuple<>>, Alt<1, facebook::glean::cpp::schema::Src::Range>> range;

  bool operator==(const IdlEntity& other) const {
    return std::tie(lang,file,entity,range)
             == std::tie(other.lang,other.file,other.entity,other.range);
  }
  bool operator!=(const IdlEntity& other) const {
    return std::tie(lang,file,entity,range)
             != std::tie(other.lang,other.file,other.entity,other.range);
  }
  bool operator<(const IdlEntity& other) const {
    return std::tie(lang,file,entity,range)
             < std::tie(other.lang,other.file,other.entity,other.range);
  }
  bool operator<=(const IdlEntity& other) const {
    return std::tie(lang,file,entity,range)
             <= std::tie(other.lang,other.file,other.entity,other.range);
  }
  bool operator>(const IdlEntity& other) const {
    return std::tie(lang,file,entity,range)
             > std::tie(other.lang,other.file,other.entity,other.range);
  }
  bool operator>=(const IdlEntity& other) const {
    return std::tie(lang,file,entity,range)
             >= std::tie(other.lang,other.file,other.entity,other.range);
  }
  void outputRepr(Output<Repr<IdlEntity>> out) const {
    outputValue(out, std::make_tuple(lang, file, entity, range));
  }
}; // struct IdlEntity

} // namespace Code

namespace Codemarkup {

namespace Cxx {

struct CxxEntityIdl : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Cxx::Entity, facebook::glean::cpp::schema::Code::IdlEntity>> {
  static const char* GLEAN_name() {
    return "codemarkup.cxx.CxxEntityIdl";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct CxxEntityIdl

} // namespace Cxx

namespace Hack {

struct HackEntityIdl : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Hack::Entity, facebook::glean::cpp::schema::Code::IdlEntity>> {
  static const char* GLEAN_name() {
    return "codemarkup.hack.HackEntityIdl";
  }

  static constexpr size_t GLEAN_version() {
     return 2;
  }
}; // struct HackEntityIdl

} // namespace Hack

} // namespace Codemarkup

namespace Code {

namespace Compose {

struct CxxSearchContainerKind : Predicate<std::tuple<std::string, facebook::glean::cpp::schema::Code::Entity, facebook::glean::cpp::schema::Codemarkup::Types::SymbolKind>> {
  static const char* GLEAN_name() {
    return "code.compose.CxxSearchContainerKind";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct CxxSearchContainerKind

} // namespace Compose

} // namespace Code

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Codemarkup::ChildEntity> {
  using Type = Tuple<Repr<facebook::glean::cpp::schema::Code::Entity>, Repr<facebook::glean::cpp::schema::Codemarkup::Types::Location>>;
};


namespace schema {

namespace Codemarkup {

struct ChildEntity {
  facebook::glean::cpp::schema::Code::Entity child;
  facebook::glean::cpp::schema::Codemarkup::Types::Location location;

  bool operator==(const ChildEntity& other) const {
    return std::tie(child,location)
             == std::tie(other.child,other.location);
  }
  bool operator!=(const ChildEntity& other) const {
    return std::tie(child,location)
             != std::tie(other.child,other.location);
  }
  bool operator<(const ChildEntity& other) const {
    return std::tie(child,location)
             < std::tie(other.child,other.location);
  }
  bool operator<=(const ChildEntity& other) const {
    return std::tie(child,location)
             <= std::tie(other.child,other.location);
  }
  bool operator>(const ChildEntity& other) const {
    return std::tie(child,location)
             > std::tie(other.child,other.location);
  }
  bool operator>=(const ChildEntity& other) const {
    return std::tie(child,location)
             >= std::tie(other.child,other.location);
  }
  void outputRepr(Output<Repr<ChildEntity>> out) const {
    outputValue(out, std::make_tuple(child, location));
  }
}; // struct ChildEntity

struct ContainsChildEntity : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Entity, facebook::glean::cpp::schema::Code::Entity>> {
  static const char* GLEAN_name() {
    return "codemarkup.ContainsChildEntity";
  }

  static constexpr size_t GLEAN_version() {
     return 30;
  }
}; // struct ContainsChildEntity

struct ContainsParentEntity : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Entity, facebook::glean::cpp::schema::Code::Entity>> {
  static const char* GLEAN_name() {
    return "codemarkup.ContainsParentEntity";
  }

  static constexpr size_t GLEAN_version() {
     return 30;
  }
}; // struct ContainsParentEntity

struct EntityComments : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Entity, Fact<facebook::glean::cpp::schema::Src::File>, facebook::glean::cpp::schema::Src::ByteSpan, boost::variant<Alt<0, std::tuple<>>, Alt<1, std::string>>>> {
  static const char* GLEAN_name() {
    return "codemarkup.EntityComments";
  }

  static constexpr size_t GLEAN_version() {
     return 30;
  }
}; // struct EntityComments

struct EntityIdl : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Entity, facebook::glean::cpp::schema::Code::IdlEntity>> {
  static const char* GLEAN_name() {
    return "codemarkup.EntityIdl";
  }

  static constexpr size_t GLEAN_version() {
     return 30;
  }
}; // struct EntityIdl

struct EntityInfo : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Entity, facebook::glean::cpp::schema::Codemarkup::Types::SymbolInfo>> {
  static const char* GLEAN_name() {
    return "codemarkup.EntityInfo";
  }

  static constexpr size_t GLEAN_version() {
     return 30;
  }
}; // struct EntityInfo

struct EntityIsDefinition : Predicate<facebook::glean::cpp::schema::Code::Entity> {
  static const char* GLEAN_name() {
    return "codemarkup.EntityIsDefinition";
  }

  static constexpr size_t GLEAN_version() {
     return 30;
  }
}; // struct EntityIsDefinition

struct EntityKind : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Entity, facebook::glean::cpp::schema::Codemarkup::Types::SymbolKind>> {
  static const char* GLEAN_name() {
    return "codemarkup.EntityKind";
  }

  static constexpr size_t GLEAN_version() {
     return 30;
  }
}; // struct EntityKind

struct EntityLocation : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Entity, facebook::glean::cpp::schema::Codemarkup::Types::Location>> {
  static const char* GLEAN_name() {
    return "codemarkup.EntityLocation";
  }

  static constexpr size_t GLEAN_version() {
     return 30;
  }
}; // struct EntityLocation

struct EntityModifiers : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Entity, facebook::glean::cpp::schema::Codemarkup::Types::Modifiers>> {
  static const char* GLEAN_name() {
    return "codemarkup.EntityModifiers";
  }

  static constexpr size_t GLEAN_version() {
     return 30;
  }
}; // struct EntityModifiers

struct EntityModuleName : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Entity, std::string>> {
  static const char* GLEAN_name() {
    return "codemarkup.EntityModuleName";
  }

  static constexpr size_t GLEAN_version() {
     return 30;
  }
}; // struct EntityModuleName

struct EntityReferences : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Entity, Fact<facebook::glean::cpp::schema::Src::File>, facebook::glean::cpp::schema::Codemarkup::Types::RangeSpan>> {
  static const char* GLEAN_name() {
    return "codemarkup.EntityReferences";
  }

  static constexpr size_t GLEAN_version() {
     return 30;
  }
}; // struct EntityReferences

struct EntitySource : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Entity, facebook::glean::cpp::schema::Code::Entity>> {
  static const char* GLEAN_name() {
    return "codemarkup.EntitySource";
  }

  static constexpr size_t GLEAN_version() {
     return 30;
  }
}; // struct EntitySource

struct EntityUses : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Entity, Fact<facebook::glean::cpp::schema::Src::File>, facebook::glean::cpp::schema::Src::ByteSpan>> {
  static const char* GLEAN_name() {
    return "codemarkup.EntityUses";
  }

  static constexpr size_t GLEAN_version() {
     return 30;
  }
}; // struct EntityUses

struct EntityVisibility : Predicate<facebook::glean::cpp::schema::Code::Entity, facebook::glean::cpp::schema::Codemarkup::Types::Visibility> {
  static const char* GLEAN_name() {
    return "codemarkup.EntityVisibility";
  }

  static constexpr size_t GLEAN_version() {
     return 30;
  }
}; // struct EntityVisibility

struct ExtendsChildEntity : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Entity, facebook::glean::cpp::schema::Code::Entity>> {
  static const char* GLEAN_name() {
    return "codemarkup.ExtendsChildEntity";
  }

  static constexpr size_t GLEAN_version() {
     return 30;
  }
}; // struct ExtendsChildEntity

struct ExtendsParentEntity : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Entity, facebook::glean::cpp::schema::Code::Entity>> {
  static const char* GLEAN_name() {
    return "codemarkup.ExtendsParentEntity";
  }

  static constexpr size_t GLEAN_version() {
     return 30;
  }
}; // struct ExtendsParentEntity

struct ExtendsParentEntityConcise : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Entity, facebook::glean::cpp::schema::Code::Entity>> {
  static const char* GLEAN_name() {
    return "codemarkup.ExtendsParentEntityConcise";
  }

  static constexpr size_t GLEAN_version() {
     return 30;
  }
}; // struct ExtendsParentEntityConcise

struct FileEntityDigest : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Src::File>, facebook::glean::cpp::schema::Code::Entity>, std::string> {
  static const char* GLEAN_name() {
    return "codemarkup.FileEntityDigest";
  }

  static constexpr size_t GLEAN_version() {
     return 30;
  }
}; // struct FileEntityDigest

struct FileEntityInfos : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Src::File>, facebook::glean::cpp::schema::Code::Entity, facebook::glean::cpp::schema::Codemarkup::Types::SymbolInfo>> {
  static const char* GLEAN_name() {
    return "codemarkup.FileEntityInfos";
  }

  static constexpr size_t GLEAN_version() {
     return 30;
  }
}; // struct FileEntityInfos

struct FileEntityKinds : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Src::File>, facebook::glean::cpp::schema::Code::Entity, facebook::glean::cpp::schema::Codemarkup::Types::SymbolKind>> {
  static const char* GLEAN_name() {
    return "codemarkup.FileEntityKinds";
  }

  static constexpr size_t GLEAN_version() {
     return 30;
  }
}; // struct FileEntityKinds

struct FileEntityLocations : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Src::File>, facebook::glean::cpp::schema::Codemarkup::Types::Location, facebook::glean::cpp::schema::Code::Entity>> {
  static const char* GLEAN_name() {
    return "codemarkup.FileEntityLocations";
  }

  static constexpr size_t GLEAN_version() {
     return 30;
  }
}; // struct FileEntityLocations

struct FileEntityXRefInfos : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Src::File>, facebook::glean::cpp::schema::Code::Entity, facebook::glean::cpp::schema::Codemarkup::Types::SymbolInfo>> {
  static const char* GLEAN_name() {
    return "codemarkup.FileEntityXRefInfos";
  }

  static constexpr size_t GLEAN_version() {
     return 30;
  }
}; // struct FileEntityXRefInfos

struct FileEntityXRefKinds : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Src::File>, facebook::glean::cpp::schema::Code::Entity, facebook::glean::cpp::schema::Codemarkup::Types::SymbolKind>> {
  static const char* GLEAN_name() {
    return "codemarkup.FileEntityXRefKinds";
  }

  static constexpr size_t GLEAN_version() {
     return 30;
  }
}; // struct FileEntityXRefKinds

struct FileEntityXRefLocations : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Src::File>, facebook::glean::cpp::schema::Codemarkup::Types::XRefLocation, facebook::glean::cpp::schema::Code::Entity>> {
  static const char* GLEAN_name() {
    return "codemarkup.FileEntityXRefLocations";
  }

  static constexpr size_t GLEAN_version() {
     return 30;
  }
}; // struct FileEntityXRefLocations

struct FileEntityXRefRangeSpans : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Src::File>, facebook::glean::cpp::schema::Codemarkup::Types::RangeSpan, facebook::glean::cpp::schema::Code::Entity>> {
  static const char* GLEAN_name() {
    return "codemarkup.FileEntityXRefRangeSpans";
  }

  static constexpr size_t GLEAN_version() {
     return 30;
  }
}; // struct FileEntityXRefRangeSpans

struct FileEntityXRefSpans : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Src::File>, facebook::glean::cpp::schema::Src::ByteSpan, facebook::glean::cpp::schema::Code::Entity>> {
  static const char* GLEAN_name() {
    return "codemarkup.FileEntityXRefSpans";
  }

  static constexpr size_t GLEAN_version() {
     return 30;
  }
}; // struct FileEntityXRefSpans

struct FindEntityDefinition : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Entity, facebook::glean::cpp::schema::Code::Entity>> {
  static const char* GLEAN_name() {
    return "codemarkup.FindEntityDefinition";
  }

  static constexpr size_t GLEAN_version() {
     return 30;
  }
}; // struct FindEntityDefinition

} // namespace Codemarkup

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Codemarkup::ParentEntity> {
  using Type = Tuple<Repr<facebook::glean::cpp::schema::Code::Entity>, Repr<facebook::glean::cpp::schema::Codemarkup::Types::Location>>;
};


namespace schema {

namespace Codemarkup {

struct ParentEntity {
  facebook::glean::cpp::schema::Code::Entity parent;
  facebook::glean::cpp::schema::Codemarkup::Types::Location location;

  bool operator==(const ParentEntity& other) const {
    return std::tie(parent,location)
             == std::tie(other.parent,other.location);
  }
  bool operator!=(const ParentEntity& other) const {
    return std::tie(parent,location)
             != std::tie(other.parent,other.location);
  }
  bool operator<(const ParentEntity& other) const {
    return std::tie(parent,location)
             < std::tie(other.parent,other.location);
  }
  bool operator<=(const ParentEntity& other) const {
    return std::tie(parent,location)
             <= std::tie(other.parent,other.location);
  }
  bool operator>(const ParentEntity& other) const {
    return std::tie(parent,location)
             > std::tie(other.parent,other.location);
  }
  bool operator>=(const ParentEntity& other) const {
    return std::tie(parent,location)
             >= std::tie(other.parent,other.location);
  }
  void outputRepr(Output<Repr<ParentEntity>> out) const {
    outputValue(out, std::make_tuple(parent, location));
  }
}; // struct ParentEntity

struct SearchRelatedEntities : Predicate<std::tuple<RelationType, ParentEntity, ChildEntity, SearchStyle>> {
  static const char* GLEAN_name() {
    return "codemarkup.SearchRelatedEntities";
  }

  static constexpr size_t GLEAN_version() {
     return 30;
  }
}; // struct SearchRelatedEntities

struct ReferencingEntity : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Entity, facebook::glean::cpp::schema::Code::Entity, Fact<facebook::glean::cpp::schema::Src::File>, facebook::glean::cpp::schema::Codemarkup::Types::RangeSpan, facebook::glean::cpp::schema::Codemarkup::Types::Location>> {
  static const char* GLEAN_name() {
    return "codemarkup.ReferencingEntity";
  }

  static constexpr size_t GLEAN_version() {
     return 30;
  }
}; // struct ReferencingEntity

struct ResolveLocation : Predicate<std::tuple<facebook::glean::cpp::schema::Codemarkup::Types::Location, facebook::glean::cpp::schema::Code::Entity>> {
  static const char* GLEAN_name() {
    return "codemarkup.ResolveLocation";
  }

  static constexpr size_t GLEAN_version() {
     return 30;
  }
}; // struct ResolveLocation

namespace Cxx {

struct CxxFileEntityIdl : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Cxx1::FileXRefs>, facebook::glean::cpp::schema::Code::Entity, facebook::glean::cpp::schema::Code::IdlEntity>> {
  static const char* GLEAN_name() {
    return "codemarkup.cxx.CxxFileEntityIdl";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct CxxFileEntityIdl

} // namespace Cxx

namespace Hack {

struct ConvertCallee : Predicate<std::tuple<boost::variant<Alt<0, std::tuple<>>, Alt<1, facebook::glean::cpp::schema::Hack::XRefTarget>>, boost::variant<Alt<0, std::tuple<>>, Alt<1, facebook::glean::cpp::schema::Code::Entity>>>> {
  static const char* GLEAN_name() {
    return "codemarkup.hack.ConvertCallee";
  }

  static constexpr size_t GLEAN_version() {
     return 2;
  }
}; // struct ConvertCallee

struct ConvertCalleeForFileCall : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Src::File>, facebook::glean::cpp::schema::Src::ByteSpan, boost::variant<Alt<0, std::tuple<>>, Alt<1, facebook::glean::cpp::schema::Hack::XRefTarget>>, boost::variant<Alt<0, std::tuple<>>, Alt<1, facebook::glean::cpp::schema::Code::Entity>>>> {
  static const char* GLEAN_name() {
    return "codemarkup.hack.ConvertCalleeForFileCall";
  }

  static constexpr size_t GLEAN_version() {
     return 2;
  }
}; // struct ConvertCalleeForFileCall

struct ConvertStaticType : Predicate<std::tuple<boost::variant<Alt<0, std::tuple<>>, Alt<1, facebook::glean::cpp::schema::Hack::Declaration>>, boost::variant<Alt<0, std::tuple<>>, Alt<1, facebook::glean::cpp::schema::Code::Entity>>>> {
  static const char* GLEAN_name() {
    return "codemarkup.hack.ConvertStaticType";
  }

  static constexpr size_t GLEAN_version() {
     return 2;
  }
}; // struct ConvertStaticType

} // namespace Hack

namespace Search {

struct EntityLocationAndKind : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Entity, facebook::glean::cpp::schema::Codemarkup::Types::Location, boost::variant<Alt<0, std::tuple<>>, Alt<1, facebook::glean::cpp::schema::Codemarkup::Types::SymbolKind>>>> {
  static const char* GLEAN_name() {
    return "codemarkup.search.EntityLocationAndKind";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct EntityLocationAndKind

struct SearchByName : Predicate<std::tuple<SearchCase, std::string, facebook::glean::cpp::schema::Code::Entity, facebook::glean::cpp::schema::Codemarkup::Types::Location, boost::variant<Alt<0, std::tuple<>>, Alt<1, facebook::glean::cpp::schema::Codemarkup::Types::SymbolKind>>, facebook::glean::cpp::schema::Code::Language>> {
  static const char* GLEAN_name() {
    return "codemarkup.search.SearchByName";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct SearchByName

struct SearchByScope : Predicate<std::tuple<SearchCase, std::string, std::vector<std::string>, facebook::glean::cpp::schema::Code::Entity, facebook::glean::cpp::schema::Codemarkup::Types::Location, boost::variant<Alt<0, std::tuple<>>, Alt<1, facebook::glean::cpp::schema::Codemarkup::Types::SymbolKind>>, facebook::glean::cpp::schema::Code::Language>> {
  static const char* GLEAN_name() {
    return "codemarkup.search.SearchByScope";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct SearchByScope

} // namespace Search

} // namespace Codemarkup

namespace Codemetrics {

struct ReferencesFrom : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Entity, facebook::glean::cpp::schema::Code::Entity>> {
  static const char* GLEAN_name() {
    return "codemetrics.ReferencesFrom";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct ReferencesFrom

struct ReferencesTo : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Entity, facebook::glean::cpp::schema::Code::Entity>> {
  static const char* GLEAN_name() {
    return "codemetrics.ReferencesTo";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct ReferencesTo

} // namespace Codemetrics

namespace Deadcode {

struct GraphEntity : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Entity, Fact<facebook::glean::cpp::schema::Src::File>, facebook::glean::cpp::schema::Src::ByteSpan>> {
  static const char* GLEAN_name() {
    return "deadcode.GraphEntity";
  }

  static constexpr size_t GLEAN_version() {
     return 7;
  }
}; // struct GraphEntity

} // namespace Deadcode

namespace Deletthis {

struct FileReverseDeps : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Src::File>, Fact<facebook::glean::cpp::schema::Src::File>, facebook::glean::cpp::schema::Code::Entity>> {
  static const char* GLEAN_name() {
    return "deletthis.FileReverseDeps";
  }

  static constexpr size_t GLEAN_version() {
     return 15;
  }
}; // struct FileReverseDeps

} // namespace Deletthis

namespace Dyn {

struct EntityUsage : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Entity, Observer, Usage, boost::variant<Alt<0, std::tuple<>>, Alt<1, Fact<Environment>>>>> {
  static const char* GLEAN_name() {
    return "dyn.EntityUsage";
  }

  static constexpr size_t GLEAN_version() {
     return 6;
  }
}; // struct EntityUsage

} // namespace Dyn

namespace Monk {

struct BestPiiFunc : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Entity, boost::variant<Alt<0, std::tuple<>>, Alt<1, facebook::glean::cpp::schema::Code::Entity>>, Fact<PiiFunc>>> {
  static const char* GLEAN_name() {
    return "monk.BestPiiFunc";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct BestPiiFunc

struct PiiCallerFunc : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Entity, Fact<PiiFunc>>> {
  static const char* GLEAN_name() {
    return "monk.PiiCallerFunc";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct PiiCallerFunc

struct PiiFunc : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Entity, boost::variant<Alt<0, std::tuple<>>, Alt<1, facebook::glean::cpp::schema::Code::Entity>>, Fact<Xid>, PrivacySensitivityKind>> {
  static const char* GLEAN_name() {
    return "monk.PiiFunc";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct PiiFunc

} // namespace Monk

namespace Search {

namespace Code {

struct BuckSearchByLocalNameFact : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Buck::LocalName>, facebook::glean::cpp::schema::Code::Entity>> {
  static const char* GLEAN_name() {
    return "search.code.BuckSearchByLocalNameFact";
  }

  static constexpr size_t GLEAN_version() {
     return 16;
  }
}; // struct BuckSearchByLocalNameFact

struct BuckSearchByLowerCaseName : Predicate<std::tuple<std::string, facebook::glean::cpp::schema::Code::Entity>> {
  static const char* GLEAN_name() {
    return "search.code.BuckSearchByLowerCaseName";
  }

  static constexpr size_t GLEAN_version() {
     return 16;
  }
}; // struct BuckSearchByLowerCaseName

struct BuckSearchByName : Predicate<std::tuple<std::string, facebook::glean::cpp::schema::Code::Entity>> {
  static const char* GLEAN_name() {
    return "search.code.BuckSearchByName";
  }

  static constexpr size_t GLEAN_version() {
     return 16;
  }
}; // struct BuckSearchByName

struct CSharpSearchByLowerCaseName : Predicate<std::tuple<std::string, facebook::glean::cpp::schema::Code::Entity>> {
  static const char* GLEAN_name() {
    return "search.code.CSharpSearchByLowerCaseName";
  }

  static constexpr size_t GLEAN_version() {
     return 16;
  }
}; // struct CSharpSearchByLowerCaseName

struct CSharpSearchByName : Predicate<std::tuple<std::string, facebook::glean::cpp::schema::Code::Entity>> {
  static const char* GLEAN_name() {
    return "search.code.CSharpSearchByName";
  }

  static constexpr size_t GLEAN_version() {
     return 16;
  }
}; // struct CSharpSearchByName

struct CxxSearchByLowerCaseName : Predicate<std::tuple<std::string, facebook::glean::cpp::schema::Code::Entity>> {
  static const char* GLEAN_name() {
    return "search.code.CxxSearchByLowerCaseName";
  }

  static constexpr size_t GLEAN_version() {
     return 16;
  }
}; // struct CxxSearchByLowerCaseName

struct CxxSearchByLowerCaseScope : Predicate<std::tuple<std::string, std::vector<std::string>, facebook::glean::cpp::schema::Code::Entity>> {
  static const char* GLEAN_name() {
    return "search.code.CxxSearchByLowerCaseScope";
  }

  static constexpr size_t GLEAN_version() {
     return 16;
  }
}; // struct CxxSearchByLowerCaseScope

struct CxxSearchByName : Predicate<std::tuple<std::string, facebook::glean::cpp::schema::Code::Entity>> {
  static const char* GLEAN_name() {
    return "search.code.CxxSearchByName";
  }

  static constexpr size_t GLEAN_version() {
     return 16;
  }
}; // struct CxxSearchByName

struct CxxSearchByScope : Predicate<std::tuple<std::string, std::vector<std::string>, facebook::glean::cpp::schema::Code::Entity>> {
  static const char* GLEAN_name() {
    return "search.code.CxxSearchByScope";
  }

  static constexpr size_t GLEAN_version() {
     return 16;
  }
}; // struct CxxSearchByScope

struct ErlangSearchByLowerCaseName : Predicate<std::tuple<std::string, facebook::glean::cpp::schema::Code::Entity>> {
  static const char* GLEAN_name() {
    return "search.code.ErlangSearchByLowerCaseName";
  }

  static constexpr size_t GLEAN_version() {
     return 16;
  }
}; // struct ErlangSearchByLowerCaseName

struct ErlangSearchByName : Predicate<std::tuple<std::string, facebook::glean::cpp::schema::Code::Entity>> {
  static const char* GLEAN_name() {
    return "search.code.ErlangSearchByName";
  }

  static constexpr size_t GLEAN_version() {
     return 16;
  }
}; // struct ErlangSearchByName

struct FbthriftSearchByNameFact : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Fbthrift::Identifier>, facebook::glean::cpp::schema::Code::Entity>> {
  static const char* GLEAN_name() {
    return "search.code.FbthriftSearchByNameFact";
  }

  static constexpr size_t GLEAN_version() {
     return 16;
  }
}; // struct FbthriftSearchByNameFact

struct FlowSearchByLowerCaseName : Predicate<std::tuple<std::string, facebook::glean::cpp::schema::Code::Entity>> {
  static const char* GLEAN_name() {
    return "search.code.FlowSearchByLowerCaseName";
  }

  static constexpr size_t GLEAN_version() {
     return 16;
  }
}; // struct FlowSearchByLowerCaseName

struct FlowSearchByLowerCaseScope : Predicate<std::tuple<std::string, std::vector<std::string>, facebook::glean::cpp::schema::Code::Entity>> {
  static const char* GLEAN_name() {
    return "search.code.FlowSearchByLowerCaseScope";
  }

  static constexpr size_t GLEAN_version() {
     return 16;
  }
}; // struct FlowSearchByLowerCaseScope

struct FlowSearchByName : Predicate<std::tuple<std::string, facebook::glean::cpp::schema::Code::Entity>> {
  static const char* GLEAN_name() {
    return "search.code.FlowSearchByName";
  }

  static constexpr size_t GLEAN_version() {
     return 16;
  }
}; // struct FlowSearchByName

struct FlowSearchByNameWithFact : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Flow::Name>, facebook::glean::cpp::schema::Code::Entity>> {
  static const char* GLEAN_name() {
    return "search.code.FlowSearchByNameWithFact";
  }

  static constexpr size_t GLEAN_version() {
     return 16;
  }
}; // struct FlowSearchByNameWithFact

struct FlowSearchByScope : Predicate<std::tuple<std::string, std::vector<std::string>, facebook::glean::cpp::schema::Code::Entity>> {
  static const char* GLEAN_name() {
    return "search.code.FlowSearchByScope";
  }

  static constexpr size_t GLEAN_version() {
     return 16;
  }
}; // struct FlowSearchByScope

struct FlowSearchByScopeWithName : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Flow::Name>, bool, std::vector<std::string>, facebook::glean::cpp::schema::Code::Entity>> {
  static const char* GLEAN_name() {
    return "search.code.FlowSearchByScopeWithName";
  }

  static constexpr size_t GLEAN_version() {
     return 16;
  }
}; // struct FlowSearchByScopeWithName

struct GraphQLSearchByLowerCaseName : Predicate<std::tuple<std::string, facebook::glean::cpp::schema::Code::Entity>> {
  static const char* GLEAN_name() {
    return "search.code.GraphQLSearchByLowerCaseName";
  }

  static constexpr size_t GLEAN_version() {
     return 16;
  }
}; // struct GraphQLSearchByLowerCaseName

struct GraphQLSearchByName : Predicate<std::tuple<std::string, facebook::glean::cpp::schema::Code::Entity>> {
  static const char* GLEAN_name() {
    return "search.code.GraphQLSearchByName";
  }

  static constexpr size_t GLEAN_version() {
     return 16;
  }
}; // struct GraphQLSearchByName

struct HackSearchByLowerCaseName : Predicate<std::tuple<std::string, facebook::glean::cpp::schema::Code::Entity>> {
  static const char* GLEAN_name() {
    return "search.code.HackSearchByLowerCaseName";
  }

  static constexpr size_t GLEAN_version() {
     return 16;
  }
}; // struct HackSearchByLowerCaseName

struct HackSearchByLowerCaseScope : Predicate<std::tuple<std::string, std::vector<std::string>, facebook::glean::cpp::schema::Code::Entity>> {
  static const char* GLEAN_name() {
    return "search.code.HackSearchByLowerCaseScope";
  }

  static constexpr size_t GLEAN_version() {
     return 16;
  }
}; // struct HackSearchByLowerCaseScope

struct HackSearchByName : Predicate<std::tuple<std::string, facebook::glean::cpp::schema::Code::Entity>> {
  static const char* GLEAN_name() {
    return "search.code.HackSearchByName";
  }

  static constexpr size_t GLEAN_version() {
     return 16;
  }
}; // struct HackSearchByName

struct HackSearchByNameWithName : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Hack::Name>, facebook::glean::cpp::schema::Code::Entity>> {
  static const char* GLEAN_name() {
    return "search.code.HackSearchByNameWithName";
  }

  static constexpr size_t GLEAN_version() {
     return 16;
  }
}; // struct HackSearchByNameWithName

struct HackSearchByScope : Predicate<std::tuple<std::string, std::vector<std::string>, facebook::glean::cpp::schema::Code::Entity>> {
  static const char* GLEAN_name() {
    return "search.code.HackSearchByScope";
  }

  static constexpr size_t GLEAN_version() {
     return 16;
  }
}; // struct HackSearchByScope

struct HackSearchByScopeWithName : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Hack::Name>, bool, std::vector<std::string>, facebook::glean::cpp::schema::Code::Entity>> {
  static const char* GLEAN_name() {
    return "search.code.HackSearchByScopeWithName";
  }

  static constexpr size_t GLEAN_version() {
     return 16;
  }
}; // struct HackSearchByScopeWithName

struct HsSearchByLowerCaseName : Predicate<std::tuple<std::string, facebook::glean::cpp::schema::Code::Entity>> {
  static const char* GLEAN_name() {
    return "search.code.HsSearchByLowerCaseName";
  }

  static constexpr size_t GLEAN_version() {
     return 16;
  }
}; // struct HsSearchByLowerCaseName

struct HsSearchByName : Predicate<std::tuple<std::string, facebook::glean::cpp::schema::Code::Entity>> {
  static const char* GLEAN_name() {
    return "search.code.HsSearchByName";
  }

  static constexpr size_t GLEAN_version() {
     return 16;
  }
}; // struct HsSearchByName

struct JavaSearchByLowerCaseName : Predicate<std::tuple<std::string, facebook::glean::cpp::schema::Code::Entity>> {
  static const char* GLEAN_name() {
    return "search.code.JavaSearchByLowerCaseName";
  }

  static constexpr size_t GLEAN_version() {
     return 16;
  }
}; // struct JavaSearchByLowerCaseName

struct JavaSearchByLowerCaseScope : Predicate<std::tuple<std::string, std::vector<std::string>, facebook::glean::cpp::schema::Code::Entity>> {
  static const char* GLEAN_name() {
    return "search.code.JavaSearchByLowerCaseScope";
  }

  static constexpr size_t GLEAN_version() {
     return 16;
  }
}; // struct JavaSearchByLowerCaseScope

struct JavaSearchByName : Predicate<std::tuple<std::string, facebook::glean::cpp::schema::Code::Entity>> {
  static const char* GLEAN_name() {
    return "search.code.JavaSearchByName";
  }

  static constexpr size_t GLEAN_version() {
     return 16;
  }
}; // struct JavaSearchByName

struct JavaSearchByNameWithFact : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Javakotlin::Alpha::QName>, facebook::glean::cpp::schema::Code::Entity>> {
  static const char* GLEAN_name() {
    return "search.code.JavaSearchByNameWithFact";
  }

  static constexpr size_t GLEAN_version() {
     return 16;
  }
}; // struct JavaSearchByNameWithFact

struct JavaSearchByScope : Predicate<std::tuple<std::string, std::vector<std::string>, facebook::glean::cpp::schema::Code::Entity>> {
  static const char* GLEAN_name() {
    return "search.code.JavaSearchByScope";
  }

  static constexpr size_t GLEAN_version() {
     return 16;
  }
}; // struct JavaSearchByScope

struct JavaSearchByScopeWithName : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Javakotlin::Alpha::Name>, bool, std::vector<std::string>, facebook::glean::cpp::schema::Code::Entity>> {
  static const char* GLEAN_name() {
    return "search.code.JavaSearchByScopeWithName";
  }

  static constexpr size_t GLEAN_version() {
     return 16;
  }
}; // struct JavaSearchByScopeWithName

struct KotlinSearchByLowerCaseName : Predicate<std::tuple<std::string, facebook::glean::cpp::schema::Code::Entity>> {
  static const char* GLEAN_name() {
    return "search.code.KotlinSearchByLowerCaseName";
  }

  static constexpr size_t GLEAN_version() {
     return 16;
  }
}; // struct KotlinSearchByLowerCaseName

struct KotlinSearchByLowerCaseScope : Predicate<std::tuple<std::string, std::vector<std::string>, facebook::glean::cpp::schema::Code::Entity>> {
  static const char* GLEAN_name() {
    return "search.code.KotlinSearchByLowerCaseScope";
  }

  static constexpr size_t GLEAN_version() {
     return 16;
  }
}; // struct KotlinSearchByLowerCaseScope

struct KotlinSearchByName : Predicate<std::tuple<std::string, facebook::glean::cpp::schema::Code::Entity>> {
  static const char* GLEAN_name() {
    return "search.code.KotlinSearchByName";
  }

  static constexpr size_t GLEAN_version() {
     return 16;
  }
}; // struct KotlinSearchByName

struct KotlinSearchByNameWithFact : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Javakotlin::Alpha::QName>, facebook::glean::cpp::schema::Code::Entity>> {
  static const char* GLEAN_name() {
    return "search.code.KotlinSearchByNameWithFact";
  }

  static constexpr size_t GLEAN_version() {
     return 16;
  }
}; // struct KotlinSearchByNameWithFact

struct KotlinSearchByScope : Predicate<std::tuple<std::string, std::vector<std::string>, facebook::glean::cpp::schema::Code::Entity>> {
  static const char* GLEAN_name() {
    return "search.code.KotlinSearchByScope";
  }

  static constexpr size_t GLEAN_version() {
     return 16;
  }
}; // struct KotlinSearchByScope

struct KotlinSearchByScopeWithName : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Javakotlin::Alpha::Name>, bool, std::vector<std::string>, facebook::glean::cpp::schema::Code::Entity>> {
  static const char* GLEAN_name() {
    return "search.code.KotlinSearchByScopeWithName";
  }

  static constexpr size_t GLEAN_version() {
     return 16;
  }
}; // struct KotlinSearchByScopeWithName

struct LsifSearchByLowerCaseName : Predicate<std::tuple<std::string, facebook::glean::cpp::schema::Code::Entity>> {
  static const char* GLEAN_name() {
    return "search.code.LsifSearchByLowerCaseName";
  }

  static constexpr size_t GLEAN_version() {
     return 16;
  }
}; // struct LsifSearchByLowerCaseName

struct LsifSearchByName : Predicate<std::tuple<std::string, facebook::glean::cpp::schema::Code::Entity>> {
  static const char* GLEAN_name() {
    return "search.code.LsifSearchByName";
  }

  static constexpr size_t GLEAN_version() {
     return 16;
  }
}; // struct LsifSearchByName

struct PpSearchByLowerCaseName : Predicate<std::tuple<std::string, facebook::glean::cpp::schema::Code::Entity>> {
  static const char* GLEAN_name() {
    return "search.code.PpSearchByLowerCaseName";
  }

  static constexpr size_t GLEAN_version() {
     return 16;
  }
}; // struct PpSearchByLowerCaseName

struct PpSearchByMacroFact : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Pp1::Macro>, facebook::glean::cpp::schema::Code::Entity>> {
  static const char* GLEAN_name() {
    return "search.code.PpSearchByMacroFact";
  }

  static constexpr size_t GLEAN_version() {
     return 16;
  }
}; // struct PpSearchByMacroFact

struct PpSearchByName : Predicate<std::tuple<std::string, facebook::glean::cpp::schema::Code::Entity>> {
  static const char* GLEAN_name() {
    return "search.code.PpSearchByName";
  }

  static constexpr size_t GLEAN_version() {
     return 16;
  }
}; // struct PpSearchByName

struct PythonSearchByLocalNameFact : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Python::LocalName>, facebook::glean::cpp::schema::Code::Entity>> {
  static const char* GLEAN_name() {
    return "search.code.PythonSearchByLocalNameFact";
  }

  static constexpr size_t GLEAN_version() {
     return 16;
  }
}; // struct PythonSearchByLocalNameFact

struct PythonSearchByLowerCaseName : Predicate<std::tuple<std::string, facebook::glean::cpp::schema::Code::Entity>> {
  static const char* GLEAN_name() {
    return "search.code.PythonSearchByLowerCaseName";
  }

  static constexpr size_t GLEAN_version() {
     return 16;
  }
}; // struct PythonSearchByLowerCaseName

struct PythonSearchByLowerCaseScope : Predicate<std::tuple<std::string, std::vector<std::string>, facebook::glean::cpp::schema::Code::Entity>> {
  static const char* GLEAN_name() {
    return "search.code.PythonSearchByLowerCaseScope";
  }

  static constexpr size_t GLEAN_version() {
     return 16;
  }
}; // struct PythonSearchByLowerCaseScope

struct PythonSearchByName : Predicate<std::tuple<std::string, facebook::glean::cpp::schema::Code::Entity>> {
  static const char* GLEAN_name() {
    return "search.code.PythonSearchByName";
  }

  static constexpr size_t GLEAN_version() {
     return 16;
  }
}; // struct PythonSearchByName

struct PythonSearchByScope : Predicate<std::tuple<std::string, std::vector<std::string>, facebook::glean::cpp::schema::Code::Entity>> {
  static const char* GLEAN_name() {
    return "search.code.PythonSearchByScope";
  }

  static constexpr size_t GLEAN_version() {
     return 16;
  }
}; // struct PythonSearchByScope

struct PythonSearchByScopeWithName : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Python::LocalName>, bool, std::vector<std::string>, facebook::glean::cpp::schema::Code::Entity>> {
  static const char* GLEAN_name() {
    return "search.code.PythonSearchByScopeWithName";
  }

  static constexpr size_t GLEAN_version() {
     return 16;
  }
}; // struct PythonSearchByScopeWithName

struct SearchByLowerCaseNameAndLanguage : Predicate<std::tuple<std::string, facebook::glean::cpp::schema::Code::Language, facebook::glean::cpp::schema::Code::Entity>> {
  static const char* GLEAN_name() {
    return "search.code.SearchByLowerCaseNameAndLanguage";
  }

  static constexpr size_t GLEAN_version() {
     return 16;
  }
}; // struct SearchByLowerCaseNameAndLanguage

struct SearchByLowerCaseScope : Predicate<std::tuple<std::string, std::vector<std::string>, facebook::glean::cpp::schema::Code::Language, facebook::glean::cpp::schema::Code::Entity>> {
  static const char* GLEAN_name() {
    return "search.code.SearchByLowerCaseScope";
  }

  static constexpr size_t GLEAN_version() {
     return 16;
  }
}; // struct SearchByLowerCaseScope

struct SearchByNameAndLanguage : Predicate<std::tuple<std::string, facebook::glean::cpp::schema::Code::Language, facebook::glean::cpp::schema::Code::Entity>> {
  static const char* GLEAN_name() {
    return "search.code.SearchByNameAndLanguage";
  }

  static constexpr size_t GLEAN_version() {
     return 16;
  }
}; // struct SearchByNameAndLanguage

struct SearchByScope : Predicate<std::tuple<std::string, std::vector<std::string>, facebook::glean::cpp::schema::Code::Language, facebook::glean::cpp::schema::Code::Entity>> {
  static const char* GLEAN_name() {
    return "search.code.SearchByScope";
  }

  static constexpr size_t GLEAN_version() {
     return 16;
  }
}; // struct SearchByScope

struct ThriftSearchByLowerCaseName : Predicate<std::tuple<std::string, facebook::glean::cpp::schema::Code::Entity>> {
  static const char* GLEAN_name() {
    return "search.code.ThriftSearchByLowerCaseName";
  }

  static constexpr size_t GLEAN_version() {
     return 16;
  }
}; // struct ThriftSearchByLowerCaseName

struct ThriftSearchByName : Predicate<std::tuple<std::string, facebook::glean::cpp::schema::Code::Entity>> {
  static const char* GLEAN_name() {
    return "search.code.ThriftSearchByName";
  }

  static constexpr size_t GLEAN_version() {
     return 16;
  }
}; // struct ThriftSearchByName

} // namespace Code

} // namespace Search

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Code::Argument> {
  using Type = Sum<String, Repr<facebook::glean::cpp::schema::Code::Entity>>;
};


namespace schema {

namespace Code {

struct Argument {
  boost::variant<Alt<0, std::string>, Alt<1, Entity>> GLEAN_value;

  static Argument lit(const std::string& a) {
    return Argument{Alt<0, std::string>(a)};
  }
  static Argument xref(const Entity& a) {
    return Argument{Alt<1, Entity>(a)};
  }

  bool operator==(const Argument& other) const {
    return std::tie(GLEAN_value)
             == std::tie(other.GLEAN_value);
  }
  bool operator!=(const Argument& other) const {
    return std::tie(GLEAN_value)
             != std::tie(other.GLEAN_value);
  }
  bool operator<(const Argument& other) const {
    return std::tie(GLEAN_value)
             < std::tie(other.GLEAN_value);
  }
  bool operator<=(const Argument& other) const {
    return std::tie(GLEAN_value)
             <= std::tie(other.GLEAN_value);
  }
  bool operator>(const Argument& other) const {
    return std::tie(GLEAN_value)
             > std::tie(other.GLEAN_value);
  }
  bool operator>=(const Argument& other) const {
    return std::tie(GLEAN_value)
             >= std::tie(other.GLEAN_value);
  }

  void outputRepr(Output<Repr<Argument>> out) const {
    outputValue(out, GLEAN_value);
  }
}; // struct Argument

} // namespace Code

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Code::CallArgument> {
  using Type = Tuple<Maybe<String>, Repr<facebook::glean::cpp::schema::Src::ByteSpan>, Maybe<Repr<facebook::glean::cpp::schema::Code::Argument>>>;
};


namespace schema {

namespace Code {

struct CallArgument {
  boost::variant<Alt<0, std::tuple<>>, Alt<1, std::string>> label;
  facebook::glean::cpp::schema::Src::ByteSpan span;
  boost::variant<Alt<0, std::tuple<>>, Alt<1, Argument>> argument;

  bool operator==(const CallArgument& other) const {
    return std::tie(label,span,argument)
             == std::tie(other.label,other.span,other.argument);
  }
  bool operator!=(const CallArgument& other) const {
    return std::tie(label,span,argument)
             != std::tie(other.label,other.span,other.argument);
  }
  bool operator<(const CallArgument& other) const {
    return std::tie(label,span,argument)
             < std::tie(other.label,other.span,other.argument);
  }
  bool operator<=(const CallArgument& other) const {
    return std::tie(label,span,argument)
             <= std::tie(other.label,other.span,other.argument);
  }
  bool operator>(const CallArgument& other) const {
    return std::tie(label,span,argument)
             > std::tie(other.label,other.span,other.argument);
  }
  bool operator>=(const CallArgument& other) const {
    return std::tie(label,span,argument)
             >= std::tie(other.label,other.span,other.argument);
  }
  void outputRepr(Output<Repr<CallArgument>> out) const {
    outputValue(out, std::make_tuple(label, span, argument));
  }
}; // struct CallArgument

} // namespace Code

namespace Codemarkup {

struct FileCall : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Src::File>, facebook::glean::cpp::schema::Src::ByteSpan, std::vector<facebook::glean::cpp::schema::Code::CallArgument>, boost::variant<Alt<0, std::tuple<>>, Alt<1, facebook::glean::cpp::schema::Code::Entity>>, boost::variant<Alt<0, std::tuple<>>, Alt<1, facebook::glean::cpp::schema::Code::CallArgument>>, boost::variant<Alt<0, std::tuple<>>, Alt<1, facebook::glean::cpp::schema::Code::Entity>>>> {
  static const char* GLEAN_name() {
    return "codemarkup.FileCall";
  }

  static constexpr size_t GLEAN_version() {
     return 30;
  }
}; // struct FileCall

namespace Hack {

struct ConvertCallArguments : Predicate<std::tuple<std::vector<facebook::glean::cpp::schema::Hack::CallArgument>, std::vector<facebook::glean::cpp::schema::Code::CallArgument>>> {
  static const char* GLEAN_name() {
    return "codemarkup.hack.ConvertCallArguments";
  }

  static constexpr size_t GLEAN_version() {
     return 2;
  }
}; // struct ConvertCallArguments

struct ConvertMaybeCallArguments : Predicate<std::tuple<boost::variant<Alt<0, std::tuple<>>, Alt<1, facebook::glean::cpp::schema::Hack::CallArgument>>, boost::variant<Alt<0, std::tuple<>>, Alt<1, facebook::glean::cpp::schema::Code::CallArgument>>>> {
  static const char* GLEAN_name() {
    return "codemarkup.hack.ConvertMaybeCallArguments";
  }

  static constexpr size_t GLEAN_version() {
     return 2;
  }
}; // struct ConvertMaybeCallArguments

struct HackFileCall : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Src::File>, facebook::glean::cpp::schema::Src::ByteSpan, std::vector<facebook::glean::cpp::schema::Code::CallArgument>, boost::variant<Alt<0, std::tuple<>>, Alt<1, facebook::glean::cpp::schema::Code::Entity>>, boost::variant<Alt<0, std::tuple<>>, Alt<1, facebook::glean::cpp::schema::Code::CallArgument>>, boost::variant<Alt<0, std::tuple<>>, Alt<1, facebook::glean::cpp::schema::Code::Entity>>>> {
  static const char* GLEAN_name() {
    return "codemarkup.hack.HackFileCall";
  }

  static constexpr size_t GLEAN_version() {
     return 2;
  }
}; // struct HackFileCall

} // namespace Hack

namespace Python {

struct ConvertCallArguments : Predicate<std::tuple<std::vector<facebook::glean::cpp::schema::Python::CallArgument>, std::vector<facebook::glean::cpp::schema::Code::CallArgument>>> {
  static const char* GLEAN_name() {
    return "codemarkup.python.ConvertCallArguments";
  }

  static constexpr size_t GLEAN_version() {
     return 2;
  }
}; // struct ConvertCallArguments

struct PythonFileCall : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Src::File>, facebook::glean::cpp::schema::Src::ByteSpan, std::vector<facebook::glean::cpp::schema::Code::CallArgument>>> {
  static const char* GLEAN_name() {
    return "codemarkup.python.PythonFileCall";
  }

  static constexpr size_t GLEAN_version() {
     return 2;
  }
}; // struct PythonFileCall

} // namespace Python

namespace Hack {

struct ConvertArgument : Predicate<std::tuple<boost::variant<Alt<0, std::tuple<>>, Alt<1, facebook::glean::cpp::schema::Hack::Argument>>, boost::variant<Alt<0, std::tuple<>>, Alt<1, facebook::glean::cpp::schema::Code::Argument>>>> {
  static const char* GLEAN_name() {
    return "codemarkup.hack.ConvertArgument";
  }

  static constexpr size_t GLEAN_version() {
     return 2;
  }
}; // struct ConvertArgument

} // namespace Hack

namespace Python {

struct ConvertArgument : Predicate<std::tuple<boost::variant<Alt<0, std::tuple<>>, Alt<1, facebook::glean::cpp::schema::Python::Argument>>, boost::variant<Alt<0, std::tuple<>>, Alt<1, facebook::glean::cpp::schema::Code::Argument>>>> {
  static const char* GLEAN_name() {
    return "codemarkup.python.ConvertArgument";
  }

  static constexpr size_t GLEAN_version() {
     return 2;
  }
}; // struct ConvertArgument

} // namespace Python

} // namespace Codemarkup

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Code::Annotations> {
  using Type = Sum<Repr<facebook::glean::cpp::schema::Code::Cxx::Annotations>, Repr<facebook::glean::cpp::schema::Code::Java::Annotations>, Repr<facebook::glean::cpp::schema::Code::Python::Annotations>, Repr<facebook::glean::cpp::schema::Code::Hack::Annotations>, Repr<facebook::glean::cpp::schema::Code::Fbthrift::Annotations>>;
};


namespace schema {

namespace Code {

struct Annotations {
  boost::variant<Alt<0, facebook::glean::cpp::schema::Code::Cxx::Annotations>, Alt<1, facebook::glean::cpp::schema::Code::Java::Annotations>, Alt<2, facebook::glean::cpp::schema::Code::Python::Annotations>, Alt<3, facebook::glean::cpp::schema::Code::Hack::Annotations>, Alt<4, facebook::glean::cpp::schema::Code::Fbthrift::Annotations>> GLEAN_value;

  static Annotations cxx(const facebook::glean::cpp::schema::Code::Cxx::Annotations& a) {
    return Annotations{Alt<0, facebook::glean::cpp::schema::Code::Cxx::Annotations>(a)};
  }
  static Annotations java(const facebook::glean::cpp::schema::Code::Java::Annotations& a) {
    return Annotations{Alt<1, facebook::glean::cpp::schema::Code::Java::Annotations>(a)};
  }
  static Annotations python(const facebook::glean::cpp::schema::Code::Python::Annotations& a) {
    return Annotations{Alt<2, facebook::glean::cpp::schema::Code::Python::Annotations>(a)};
  }
  static Annotations hack(const facebook::glean::cpp::schema::Code::Hack::Annotations& a) {
    return Annotations{Alt<3, facebook::glean::cpp::schema::Code::Hack::Annotations>(a)};
  }
  static Annotations fbthrift(const facebook::glean::cpp::schema::Code::Fbthrift::Annotations& a) {
    return Annotations{Alt<4, facebook::glean::cpp::schema::Code::Fbthrift::Annotations>(a)};
  }

  bool operator==(const Annotations& other) const {
    return std::tie(GLEAN_value)
             == std::tie(other.GLEAN_value);
  }
  bool operator!=(const Annotations& other) const {
    return std::tie(GLEAN_value)
             != std::tie(other.GLEAN_value);
  }
  bool operator<(const Annotations& other) const {
    return std::tie(GLEAN_value)
             < std::tie(other.GLEAN_value);
  }
  bool operator<=(const Annotations& other) const {
    return std::tie(GLEAN_value)
             <= std::tie(other.GLEAN_value);
  }
  bool operator>(const Annotations& other) const {
    return std::tie(GLEAN_value)
             > std::tie(other.GLEAN_value);
  }
  bool operator>=(const Annotations& other) const {
    return std::tie(GLEAN_value)
             >= std::tie(other.GLEAN_value);
  }

  void outputRepr(Output<Repr<Annotations>> out) const {
    outputValue(out, GLEAN_value);
  }
}; // struct Annotations

} // namespace Code

namespace Codemarkup {

struct EntityToAnnotations : Predicate<std::tuple<facebook::glean::cpp::schema::Code::Entity, facebook::glean::cpp::schema::Code::Annotations>> {
  static const char* GLEAN_name() {
    return "codemarkup.EntityToAnnotations";
  }

  static constexpr size_t GLEAN_version() {
     return 30;
  }
}; // struct EntityToAnnotations

} // namespace Codemarkup

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Code::Quality::Position> {
  using Type = Sum<Unit, Nat, Repr<facebook::glean::cpp::schema::Code::Quality::Point>, Repr<facebook::glean::cpp::schema::Code::Quality::Range>>;
};


namespace schema {

namespace Code {

namespace Quality {

struct Position {
  boost::variant<Alt<0, std::tuple<>>, Alt<1, uint64_t>, Alt<2, Point>, Alt<3, Range>> GLEAN_value;

  static Position file() {
    return Position{Alt<0, std::tuple<>>(std::make_tuple())};
  }
  static Position line(const uint64_t& a) {
    return Position{Alt<1, uint64_t>(a)};
  }
  static Position point(const Point& a) {
    return Position{Alt<2, Point>(a)};
  }
  static Position range(const Range& a) {
    return Position{Alt<3, Range>(a)};
  }

  bool operator==(const Position& other) const {
    return std::tie(GLEAN_value)
             == std::tie(other.GLEAN_value);
  }
  bool operator!=(const Position& other) const {
    return std::tie(GLEAN_value)
             != std::tie(other.GLEAN_value);
  }
  bool operator<(const Position& other) const {
    return std::tie(GLEAN_value)
             < std::tie(other.GLEAN_value);
  }
  bool operator<=(const Position& other) const {
    return std::tie(GLEAN_value)
             <= std::tie(other.GLEAN_value);
  }
  bool operator>(const Position& other) const {
    return std::tie(GLEAN_value)
             > std::tie(other.GLEAN_value);
  }
  bool operator>=(const Position& other) const {
    return std::tie(GLEAN_value)
             >= std::tie(other.GLEAN_value);
  }

  void outputRepr(Output<Repr<Position>> out) const {
    outputValue(out, GLEAN_value);
  }
}; // struct Position

} // namespace Quality

} // namespace Code

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Code::Quality::Location> {
  using Type = Tuple<facebook::glean::cpp::schema::Src::File, Repr<facebook::glean::cpp::schema::Code::Quality::Position>>;
};


namespace schema {

namespace Code {

namespace Quality {

struct Location {
  Fact<facebook::glean::cpp::schema::Src::File> file;
  Position position;

  bool operator==(const Location& other) const {
    return std::tie(file,position)
             == std::tie(other.file,other.position);
  }
  bool operator!=(const Location& other) const {
    return std::tie(file,position)
             != std::tie(other.file,other.position);
  }
  bool operator<(const Location& other) const {
    return std::tie(file,position)
             < std::tie(other.file,other.position);
  }
  bool operator<=(const Location& other) const {
    return std::tie(file,position)
             <= std::tie(other.file,other.position);
  }
  bool operator>(const Location& other) const {
    return std::tie(file,position)
             > std::tie(other.file,other.position);
  }
  bool operator>=(const Location& other) const {
    return std::tie(file,position)
             >= std::tie(other.file,other.position);
  }
  void outputRepr(Output<Repr<Location>> out) const {
    outputValue(out, std::make_tuple(file, position));
  }
}; // struct Location

struct Issue : Predicate<std::tuple<Location, Fact<FlagName>, Fact<Detail>, CommitId>> {
  static const char* GLEAN_name() {
    return "code.quality.Issue";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct Issue

} // namespace Quality

} // namespace Code

namespace Cxx1 {

struct FunctionName : Predicate<boost::variant<Alt<0, Fact<Name>>, Alt<1, Operator>, Alt<2, LiteralOperator>, Alt<3, std::tuple<>>, Alt<4, std::tuple<>>, Alt<5, Fact<Type>>>> {
  static const char* GLEAN_name() {
    return "cxx1.FunctionName";
  }

  static constexpr size_t GLEAN_version() {
     return 5;
  }
}; // struct FunctionName

} // namespace Cxx1

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Cxx1::RecordKind> {
  using Type = Sum<Unit, Unit, Unit>;
};


namespace schema {

namespace Cxx1 {

struct RecordKind {
  boost::variant<Alt<0, std::tuple<>>, Alt<1, std::tuple<>>, Alt<2, std::tuple<>>> GLEAN_value;

  static RecordKind struct_() {
    return RecordKind{Alt<0, std::tuple<>>(std::make_tuple())};
  }
  static RecordKind class_() {
    return RecordKind{Alt<1, std::tuple<>>(std::make_tuple())};
  }
  static RecordKind union_() {
    return RecordKind{Alt<2, std::tuple<>>(std::make_tuple())};
  }

  bool operator==(const RecordKind& other) const {
    return std::tie(GLEAN_value)
             == std::tie(other.GLEAN_value);
  }
  bool operator!=(const RecordKind& other) const {
    return std::tie(GLEAN_value)
             != std::tie(other.GLEAN_value);
  }
  bool operator<(const RecordKind& other) const {
    return std::tie(GLEAN_value)
             < std::tie(other.GLEAN_value);
  }
  bool operator<=(const RecordKind& other) const {
    return std::tie(GLEAN_value)
             <= std::tie(other.GLEAN_value);
  }
  bool operator>(const RecordKind& other) const {
    return std::tie(GLEAN_value)
             > std::tie(other.GLEAN_value);
  }
  bool operator>=(const RecordKind& other) const {
    return std::tie(GLEAN_value)
             >= std::tie(other.GLEAN_value);
  }

  void outputRepr(Output<Repr<RecordKind>> out) const {
    outputValue(out, GLEAN_value);
  }
}; // struct RecordKind

struct RecordDeclaration : Predicate<std::tuple<Fact<QName>, RecordKind, facebook::glean::cpp::schema::Src::Range>> {
  static const char* GLEAN_name() {
    return "cxx1.RecordDeclaration";
  }

  static constexpr size_t GLEAN_version() {
     return 5;
  }
}; // struct RecordDeclaration

} // namespace Cxx1

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Cxx1::Scope> {
  using Type = Sum<Unit, facebook::glean::cpp::schema::Cxx1::NamespaceQName, Tuple<facebook::glean::cpp::schema::Cxx1::QName, Repr<facebook::glean::cpp::schema::Cxx1::Access>>, facebook::glean::cpp::schema::Cxx1::FunctionQName>;
};


namespace schema {

namespace Cxx1 {

struct Scope {
  boost::variant<Alt<0, std::tuple<>>, Alt<1, Fact<NamespaceQName>>, Alt<2, std::tuple<Fact<QName>, Access>>, Alt<3, Fact<FunctionQName>>> GLEAN_value;

  static Scope global_() {
    return Scope{Alt<0, std::tuple<>>(std::make_tuple())};
  }
  static Scope namespace_(const Fact<NamespaceQName>& a) {
    return Scope{Alt<1, Fact<NamespaceQName>>(a)};
  }
  static Scope recordWithAccess(const Fact<QName>& record, const Access& access) {
    return Scope{Alt<2, std::tuple<Fact<QName>, Access>>(std::make_tuple(record, access))};
  }
  static Scope local(const Fact<FunctionQName>& a) {
    return Scope{Alt<3, Fact<FunctionQName>>(a)};
  }

  bool operator==(const Scope& other) const {
    return std::tie(GLEAN_value)
             == std::tie(other.GLEAN_value);
  }
  bool operator!=(const Scope& other) const {
    return std::tie(GLEAN_value)
             != std::tie(other.GLEAN_value);
  }
  bool operator<(const Scope& other) const {
    return std::tie(GLEAN_value)
             < std::tie(other.GLEAN_value);
  }
  bool operator<=(const Scope& other) const {
    return std::tie(GLEAN_value)
             <= std::tie(other.GLEAN_value);
  }
  bool operator>(const Scope& other) const {
    return std::tie(GLEAN_value)
             > std::tie(other.GLEAN_value);
  }
  bool operator>=(const Scope& other) const {
    return std::tie(GLEAN_value)
             >= std::tie(other.GLEAN_value);
  }

  void outputRepr(Output<Repr<Scope>> out) const {
    outputValue(out, GLEAN_value);
  }
}; // struct Scope

struct DeclarationScope : Predicate<std::tuple<Declaration, Scope>> {
  static const char* GLEAN_name() {
    return "cxx1.DeclarationScope";
  }

  static constexpr size_t GLEAN_version() {
     return 5;
  }
}; // struct DeclarationScope

struct FunctionQName : Predicate<std::tuple<Fact<FunctionName>, Scope>> {
  static const char* GLEAN_name() {
    return "cxx1.FunctionQName";
  }

  static constexpr size_t GLEAN_version() {
     return 5;
  }
}; // struct FunctionQName

struct QName : Predicate<std::tuple<Fact<Name>, Scope>> {
  static const char* GLEAN_name() {
    return "cxx1.QName";
  }

  static constexpr size_t GLEAN_version() {
     return 5;
  }
}; // struct QName

} // namespace Cxx1

namespace Search {

namespace Code {

struct CxxSearchByNameAndScopeFact : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Cxx1::Name>, facebook::glean::cpp::schema::Cxx1::Scope, facebook::glean::cpp::schema::Code::Entity>> {
  static const char* GLEAN_name() {
    return "search.code.CxxSearchByNameAndScopeFact";
  }

  static constexpr size_t GLEAN_version() {
     return 16;
  }
}; // struct CxxSearchByNameAndScopeFact

} // namespace Code

namespace Cxx {

struct QueryToScopeCase : Predicate<std::tuple<std::vector<std::string>, bool, facebook::glean::cpp::schema::Cxx1::Scope>> {
  static const char* GLEAN_name() {
    return "search.cxx.QueryToScopeCase";
  }

  static constexpr size_t GLEAN_version() {
     return 5;
  }
}; // struct QueryToScopeCase

struct SearchByNameAndScope : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Cxx1::Name>, facebook::glean::cpp::schema::Cxx1::Scope, facebook::glean::cpp::schema::Code::Cxx::Entity>> {
  static const char* GLEAN_name() {
    return "search.cxx.SearchByNameAndScope";
  }

  static constexpr size_t GLEAN_version() {
     return 5;
  }
}; // struct SearchByNameAndScope

struct SearchByScope : Predicate<std::tuple<facebook::glean::cpp::schema::Cxx1::Scope, facebook::glean::cpp::schema::Code::Cxx::Entity>> {
  static const char* GLEAN_name() {
    return "search.cxx.SearchByScope";
  }

  static constexpr size_t GLEAN_version() {
     return 5;
  }
}; // struct SearchByScope

} // namespace Cxx

} // namespace Search

namespace Symbolid {

namespace Cxx {

struct LookupDeclaration : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Cxx1::Name>, facebook::glean::cpp::schema::Cxx1::Scope, facebook::glean::cpp::schema::Cxx1::Declaration>> {
  static const char* GLEAN_name() {
    return "symbolid.cxx.LookupDeclaration";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct LookupDeclaration

struct LookupDefinition : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Cxx1::Name>, facebook::glean::cpp::schema::Cxx1::Scope, facebook::glean::cpp::schema::Code::Cxx::Entity>> {
  static const char* GLEAN_name() {
    return "symbolid.cxx.LookupDefinition";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct LookupDefinition

struct LookupEnumerator : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Cxx1::Name>, Fact<facebook::glean::cpp::schema::Cxx1::Name>, facebook::glean::cpp::schema::Cxx1::Scope, Fact<facebook::glean::cpp::schema::Cxx1::Enumerator>>> {
  static const char* GLEAN_name() {
    return "symbolid.cxx.LookupEnumerator";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct LookupEnumerator

struct LookupFunctionDeclaration : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Cxx1::FunctionName>, facebook::glean::cpp::schema::Cxx1::Scope, facebook::glean::cpp::schema::Cxx1::Declaration>> {
  static const char* GLEAN_name() {
    return "symbolid.cxx.LookupFunctionDeclaration";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct LookupFunctionDeclaration

struct LookupFunctionDefinition : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Cxx1::FunctionName>, facebook::glean::cpp::schema::Cxx1::Scope, facebook::glean::cpp::schema::Code::Cxx::Entity>> {
  static const char* GLEAN_name() {
    return "symbolid.cxx.LookupFunctionDefinition";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct LookupFunctionDefinition

struct LookupFunctionSignatureDeclaration : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Cxx1::FunctionName>, facebook::glean::cpp::schema::Cxx1::Scope, Fact<facebook::glean::cpp::schema::Cxx1::Signature>, facebook::glean::cpp::schema::Cxx1::Declaration>> {
  static const char* GLEAN_name() {
    return "symbolid.cxx.LookupFunctionSignatureDeclaration";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct LookupFunctionSignatureDeclaration

struct LookupFunctionSignatureDefinition : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Cxx1::FunctionName>, facebook::glean::cpp::schema::Cxx1::Scope, Fact<facebook::glean::cpp::schema::Cxx1::Signature>, facebook::glean::cpp::schema::Code::Cxx::Entity>> {
  static const char* GLEAN_name() {
    return "symbolid.cxx.LookupFunctionSignatureDefinition";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct LookupFunctionSignatureDefinition

struct LookupFunctionSignatureQualifierDeclaration : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Cxx1::FunctionName>, facebook::glean::cpp::schema::Cxx1::Scope, Fact<facebook::glean::cpp::schema::Cxx1::Signature>, boost::variant<Alt<0, std::tuple<>>, Alt<1, facebook::glean::cpp::schema::Cxx1::MethodSignature>>, facebook::glean::cpp::schema::Cxx1::Declaration>> {
  static const char* GLEAN_name() {
    return "symbolid.cxx.LookupFunctionSignatureQualifierDeclaration";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct LookupFunctionSignatureQualifierDeclaration

struct LookupFunctionSignatureQualifierDefinition : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Cxx1::FunctionName>, facebook::glean::cpp::schema::Cxx1::Scope, Fact<facebook::glean::cpp::schema::Cxx1::Signature>, boost::variant<Alt<0, std::tuple<>>, Alt<1, facebook::glean::cpp::schema::Cxx1::MethodSignature>>, facebook::glean::cpp::schema::Code::Cxx::Entity>> {
  static const char* GLEAN_name() {
    return "symbolid.cxx.LookupFunctionSignatureQualifierDefinition";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct LookupFunctionSignatureQualifierDefinition

} // namespace Cxx

} // namespace Symbolid

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Fbthrift::ResultType> {
  using Type = Sum<Unit, Unit, facebook::glean::cpp::schema::Fbthrift::TypeSpecification, Repr<facebook::glean::cpp::schema::Fbthrift::ResultStream>, facebook::glean::cpp::schema::Fbthrift::ServiceName, Repr<facebook::glean::cpp::schema::Fbthrift::ResultSink>>;
};


namespace schema {

namespace Fbthrift {

struct ResultType {
  boost::variant<Alt<0, std::tuple<>>, Alt<1, std::tuple<>>, Alt<2, Fact<TypeSpecification>>, Alt<3, ResultStream>, Alt<4, Fact<ServiceName>>, Alt<5, ResultSink>> GLEAN_value;

  static ResultType oneway_() {
    return ResultType{Alt<0, std::tuple<>>(std::make_tuple())};
  }
  static ResultType void_() {
    return ResultType{Alt<1, std::tuple<>>(std::make_tuple())};
  }
  static ResultType result(const Fact<TypeSpecification>& a) {
    return ResultType{Alt<2, Fact<TypeSpecification>>(a)};
  }
  static ResultType stream_(const ResultStream& a) {
    return ResultType{Alt<3, ResultStream>(a)};
  }
  static ResultType service_(const Fact<ServiceName>& a) {
    return ResultType{Alt<4, Fact<ServiceName>>(a)};
  }
  static ResultType sink_(const ResultSink& a) {
    return ResultType{Alt<5, ResultSink>(a)};
  }

  bool operator==(const ResultType& other) const {
    return std::tie(GLEAN_value)
             == std::tie(other.GLEAN_value);
  }
  bool operator!=(const ResultType& other) const {
    return std::tie(GLEAN_value)
             != std::tie(other.GLEAN_value);
  }
  bool operator<(const ResultType& other) const {
    return std::tie(GLEAN_value)
             < std::tie(other.GLEAN_value);
  }
  bool operator<=(const ResultType& other) const {
    return std::tie(GLEAN_value)
             <= std::tie(other.GLEAN_value);
  }
  bool operator>(const ResultType& other) const {
    return std::tie(GLEAN_value)
             > std::tie(other.GLEAN_value);
  }
  bool operator>=(const ResultType& other) const {
    return std::tie(GLEAN_value)
             >= std::tie(other.GLEAN_value);
  }

  void outputRepr(Output<Repr<ResultType>> out) const {
    outputValue(out, GLEAN_value);
  }
}; // struct ResultType

struct FunctionSpecification : Predicate<std::tuple<Fact<FunctionName>, ResultType, std::vector<UnqualField>, std::vector<ExceptionSpecification>, std::vector<Fact<StructuredAnnotation>>>> {
  static const char* GLEAN_name() {
    return "fbthrift.FunctionSpecification";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct FunctionSpecification

} // namespace Fbthrift

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Thrift::ResultType> {
  using Type = Sum<Unit, Unit, facebook::glean::cpp::schema::Thrift::TypeSpecification, Repr<facebook::glean::cpp::schema::Thrift::ResultStream>>;
};


namespace schema {

namespace Thrift {

struct ResultType {
  boost::variant<Alt<0, std::tuple<>>, Alt<1, std::tuple<>>, Alt<2, Fact<TypeSpecification>>, Alt<3, ResultStream>> GLEAN_value;

  static ResultType oneway_() {
    return ResultType{Alt<0, std::tuple<>>(std::make_tuple())};
  }
  static ResultType void_() {
    return ResultType{Alt<1, std::tuple<>>(std::make_tuple())};
  }
  static ResultType result(const Fact<TypeSpecification>& a) {
    return ResultType{Alt<2, Fact<TypeSpecification>>(a)};
  }
  static ResultType stream_(const ResultStream& a) {
    return ResultType{Alt<3, ResultStream>(a)};
  }

  bool operator==(const ResultType& other) const {
    return std::tie(GLEAN_value)
             == std::tie(other.GLEAN_value);
  }
  bool operator!=(const ResultType& other) const {
    return std::tie(GLEAN_value)
             != std::tie(other.GLEAN_value);
  }
  bool operator<(const ResultType& other) const {
    return std::tie(GLEAN_value)
             < std::tie(other.GLEAN_value);
  }
  bool operator<=(const ResultType& other) const {
    return std::tie(GLEAN_value)
             <= std::tie(other.GLEAN_value);
  }
  bool operator>(const ResultType& other) const {
    return std::tie(GLEAN_value)
             > std::tie(other.GLEAN_value);
  }
  bool operator>=(const ResultType& other) const {
    return std::tie(GLEAN_value)
             >= std::tie(other.GLEAN_value);
  }

  void outputRepr(Output<Repr<ResultType>> out) const {
    outputValue(out, GLEAN_value);
  }
}; // struct ResultType

struct FunctionSpecification : Predicate<std::tuple<Fact<FunctionName>, ResultType, std::vector<UnqualField>, std::vector<ExceptionSpecification>>> {
  static const char* GLEAN_name() {
    return "thrift.FunctionSpecification";
  }

  static constexpr size_t GLEAN_version() {
     return 7;
  }
}; // struct FunctionSpecification

} // namespace Thrift

namespace Buckuses {

struct UsesOfTargetHeader : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Buck::Locator>, Fact<facebook::glean::cpp::schema::Src::File>>> {
  static const char* GLEAN_name() {
    return "buckuses.UsesOfTargetHeader";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct UsesOfTargetHeader

struct UsesOfTarget : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Buck::Locator>, facebook::glean::cpp::schema::Cxx1::XRefTarget, Fact<facebook::glean::cpp::schema::Src::File>>> {
  static const char* GLEAN_name() {
    return "buckuses.UsesOfTarget";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct UsesOfTarget

} // namespace Buckuses

namespace Buck {

namespace Meta {

struct Oncall : Predicate<std::string> {
  static const char* GLEAN_name() {
    return "buck.meta.Oncall";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct Oncall

struct ModeType : Predicate<std::string> {
  static const char* GLEAN_name() {
    return "buck.meta.ModeType";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct ModeType

using ModeFile = Fact<facebook::glean::cpp::schema::Src::File>;

struct TargetModes : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Buck::Locator>, Fact<ModeType>, std::vector<ModeFile>>> {
  static const char* GLEAN_name() {
    return "buck.meta.TargetModes";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct TargetModes

struct LocatorOncall : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Buck::Locator>, Fact<Oncall>>> {
  static const char* GLEAN_name() {
    return "buck.meta.LocatorOncall";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct LocatorOncall

struct FileOncall : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Src::File>, Fact<Oncall>>> {
  static const char* GLEAN_name() {
    return "buck.meta.FileOncall";
  }

  static constexpr size_t GLEAN_version() {
     return 1;
  }
}; // struct FileOncall

} // namespace Meta

} // namespace Buck

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Buck::XRefDestination> {
  using Type = Sum<facebook::glean::cpp::schema::Buck::Locator, facebook::glean::cpp::schema::Src::File, facebook::glean::cpp::schema::Buck::Definition>;
};


namespace schema {

namespace Buck {

struct XRefDestination {
  boost::variant<Alt<0, Fact<Locator>>, Alt<1, Fact<facebook::glean::cpp::schema::Src::File>>, Alt<2, Fact<Definition>>> GLEAN_value;

  static XRefDestination locator(const Fact<Locator>& a) {
    return XRefDestination{Alt<0, Fact<Locator>>(a)};
  }
  static XRefDestination file(const Fact<facebook::glean::cpp::schema::Src::File>& a) {
    return XRefDestination{Alt<1, Fact<facebook::glean::cpp::schema::Src::File>>(a)};
  }
  static XRefDestination definition(const Fact<Definition>& a) {
    return XRefDestination{Alt<2, Fact<Definition>>(a)};
  }

  bool operator==(const XRefDestination& other) const {
    return std::tie(GLEAN_value)
             == std::tie(other.GLEAN_value);
  }
  bool operator!=(const XRefDestination& other) const {
    return std::tie(GLEAN_value)
             != std::tie(other.GLEAN_value);
  }
  bool operator<(const XRefDestination& other) const {
    return std::tie(GLEAN_value)
             < std::tie(other.GLEAN_value);
  }
  bool operator<=(const XRefDestination& other) const {
    return std::tie(GLEAN_value)
             <= std::tie(other.GLEAN_value);
  }
  bool operator>(const XRefDestination& other) const {
    return std::tie(GLEAN_value)
             > std::tie(other.GLEAN_value);
  }
  bool operator>=(const XRefDestination& other) const {
    return std::tie(GLEAN_value)
             >= std::tie(other.GLEAN_value);
  }

  void outputRepr(Output<Repr<XRefDestination>> out) const {
    outputValue(out, GLEAN_value);
  }
}; // struct XRefDestination

} // namespace Buck

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Buck::XRef> {
  using Type = Tuple<Repr<facebook::glean::cpp::schema::Buck::XRefDestination>, Array<Repr<facebook::glean::cpp::schema::Src::ByteSpan>>>;
};


namespace schema {

namespace Buck {

struct XRef {
  XRefDestination destination;
  std::vector<facebook::glean::cpp::schema::Src::ByteSpan> ranges;

  bool operator==(const XRef& other) const {
    return std::tie(destination,ranges)
             == std::tie(other.destination,other.ranges);
  }
  bool operator!=(const XRef& other) const {
    return std::tie(destination,ranges)
             != std::tie(other.destination,other.ranges);
  }
  bool operator<(const XRef& other) const {
    return std::tie(destination,ranges)
             < std::tie(other.destination,other.ranges);
  }
  bool operator<=(const XRef& other) const {
    return std::tie(destination,ranges)
             <= std::tie(other.destination,other.ranges);
  }
  bool operator>(const XRef& other) const {
    return std::tie(destination,ranges)
             > std::tie(other.destination,other.ranges);
  }
  bool operator>=(const XRef& other) const {
    return std::tie(destination,ranges)
             >= std::tie(other.destination,other.ranges);
  }
  void outputRepr(Output<Repr<XRef>> out) const {
    outputValue(out, std::make_tuple(destination, ranges));
  }
}; // struct XRef

struct Type : Predicate<std::string> {
  static const char* GLEAN_name() {
    return "buck.Type";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct Type

struct TranslationUnit : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Src::File>, Fact<Locator>, boost::variant<Alt<0, std::tuple<>>, Alt<1, Fact<Platform>>>>> {
  static const char* GLEAN_name() {
    return "buck.TranslationUnit";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct TranslationUnit

struct TargetUses : Predicate<std::tuple<Fact<Locator>, Fact<facebook::glean::cpp::schema::Src::File>, std::vector<facebook::glean::cpp::schema::Src::ByteSpan>>> {
  static const char* GLEAN_name() {
    return "buck.TargetUses";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct TargetUses

struct TargetSourcesBaseModule : Predicate<std::tuple<Fact<Target>, std::vector<Fact<File>>, boost::variant<Alt<0, std::tuple<>>, Alt<1, Fact<AttributeValue>>>>> {
  static const char* GLEAN_name() {
    return "buck.TargetSourcesBaseModule";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct TargetSourcesBaseModule

struct TargetSources : Predicate<std::tuple<Fact<Target>, std::vector<Fact<File>>, std::vector<Fact<File>>, std::vector<Fact<File>>>> {
  static const char* GLEAN_name() {
    return "buck.TargetSources";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct TargetSources

struct TargetOuts : Predicate<std::tuple<Fact<Target>, boost::variant<Alt<0, std::tuple<>>, Alt<1, Fact<OutputLabel>>>, Fact<facebook::glean::cpp::schema::Src::File>>> {
  static const char* GLEAN_name() {
    return "buck.TargetOuts";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct TargetOuts

struct TargetOut : Predicate<std::tuple<Fact<Target>, Fact<facebook::glean::cpp::schema::Src::File>>> {
  static const char* GLEAN_name() {
    return "buck.TargetOut";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct TargetOut

struct TargetMode : Predicate<std::tuple<Fact<Target>, std::string>> {
  static const char* GLEAN_name() {
    return "buck.TargetMode";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct TargetMode

struct TargetLocation : Predicate<std::tuple<Fact<Locator>, Fact<facebook::glean::cpp::schema::Src::File>, facebook::glean::cpp::schema::Src::ByteSpan>> {
  static const char* GLEAN_name() {
    return "buck.TargetLocation";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct TargetLocation

struct TargetLinkWhole : Predicate<Fact<Target>> {
  static const char* GLEAN_name() {
    return "buck.TargetLinkWhole";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct TargetLinkWhole

struct TargetIndexerName : Predicate<std::string> {
  static const char* GLEAN_name() {
    return "buck.TargetIndexerName";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct TargetIndexerName

struct TargetIndexer : Predicate<std::tuple<Fact<TargetIndexerName>, Fact<Target>>> {
  static const char* GLEAN_name() {
    return "buck.TargetIndexer";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct TargetIndexer

struct TargetHash : Predicate<std::tuple<Fact<Locator>, std::string>> {
  static const char* GLEAN_name() {
    return "buck.TargetHash";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct TargetHash

struct TargetCall : Predicate<std::tuple<Fact<Locator>, std::vector<Fact<CallArgument>>, Fact<facebook::glean::cpp::schema::Src::File>, facebook::glean::cpp::schema::Src::ByteSpan>> {
  static const char* GLEAN_name() {
    return "buck.TargetCall";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct TargetCall

struct TargetByType : Predicate<std::tuple<Fact<Type>, Fact<Target>>> {
  static const char* GLEAN_name() {
    return "buck.TargetByType";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct TargetByType

struct TargetAttribute : Predicate<std::tuple<Fact<Target>, Fact<AttributeName>, Fact<AttributeValue>>> {
  static const char* GLEAN_name() {
    return "buck.TargetAttribute";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct TargetAttribute

struct Target : Predicate<std::tuple<Fact<Locator>, Fact<Type>, boost::variant<Alt<0, std::tuple<>>, Alt<1, Fact<Platform>>>, Fact<Labels>>> {
  static const char* GLEAN_name() {
    return "buck.Target";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct Target

struct SourceFileLocation : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Src::File>, facebook::glean::cpp::schema::Src::ByteSpan>> {
  static const char* GLEAN_name() {
    return "buck.SourceFileLocation";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct SourceFileLocation

struct SearchByLocalName : Predicate<std::tuple<Fact<LocalName>, XRefDestination>> {
  static const char* GLEAN_name() {
    return "buck.SearchByLocalName";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct SearchByLocalName

struct RuleKey : Predicate<std::tuple<Fact<Locator>, std::string>> {
  static const char* GLEAN_name() {
    return "buck.RuleKey";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct RuleKey

struct Platform : Predicate<std::string> {
  static const char* GLEAN_name() {
    return "buck.Platform";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct Platform

struct Owner : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Src::File>, Fact<TargetSources>>> {
  static const char* GLEAN_name() {
    return "buck.Owner";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct Owner

struct OutsTarget : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Src::File>, Fact<Target>, boost::variant<Alt<0, std::tuple<>>, Alt<1, Fact<OutputLabel>>>>> {
  static const char* GLEAN_name() {
    return "buck.OutsTarget";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct OutsTarget

struct OutputLabel : Predicate<std::string> {
  static const char* GLEAN_name() {
    return "buck.OutputLabel";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct OutputLabel

struct OutTarget : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Src::File>, Fact<Target>>> {
  static const char* GLEAN_name() {
    return "buck.OutTarget";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct OutTarget

struct LocatorWithLabel : Predicate<std::tuple<Fact<Locator>, Fact<OutputLabel>>> {
  static const char* GLEAN_name() {
    return "buck.LocatorWithLabel";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct LocatorWithLabel

struct LocatorReverseDeps : Predicate<std::tuple<Fact<Locator>, std::vector<Fact<Locator>>>> {
  static const char* GLEAN_name() {
    return "buck.LocatorReverseDeps";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct LocatorReverseDeps

struct LocatorReverseDep : Predicate<std::tuple<Fact<Locator>, Fact<Locator>>> {
  static const char* GLEAN_name() {
    return "buck.LocatorReverseDep";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct LocatorReverseDep

struct Locator : Predicate<std::tuple<boost::variant<Alt<0, std::tuple<>>, Alt<1, std::string>>, std::string, std::string>> {
  static const char* GLEAN_name() {
    return "buck.Locator";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct Locator

struct LocalNameLowerCase : Predicate<std::tuple<std::string, Fact<LocalName>>> {
  static const char* GLEAN_name() {
    return "buck.LocalNameLowerCase";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct LocalNameLowerCase

struct LocalName : Predicate<std::string> {
  static const char* GLEAN_name() {
    return "buck.LocalName";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct LocalName

struct Labels : Predicate<std::vector<Fact<Label>>> {
  static const char* GLEAN_name() {
    return "buck.Labels";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct Labels

struct Label : Predicate<std::string> {
  static const char* GLEAN_name() {
    return "buck.Label";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct Label

struct IndexerName : Predicate<std::string> {
  static const char* GLEAN_name() {
    return "buck.IndexerName";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct IndexerName

struct FileXRefs : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Src::File>, std::vector<XRef>>> {
  static const char* GLEAN_name() {
    return "buck.FileXRefs";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct FileXRefs

struct FileToTarget : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Src::File>, Fact<Locator>>> {
  static const char* GLEAN_name() {
    return "buck.FileToTarget";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct FileToTarget

struct FileTarget : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Src::File>, Fact<Locator>>> {
  static const char* GLEAN_name() {
    return "buck.FileTarget";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct FileTarget

struct FileResolved : Predicate<std::tuple<Fact<File>, Fact<facebook::glean::cpp::schema::Src::File>>> {
  static const char* GLEAN_name() {
    return "buck.FileResolved";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct FileResolved

struct FileEntity : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Src::File>, XRefDestination>> {
  static const char* GLEAN_name() {
    return "buck.FileEntity";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct FileEntity

struct FileDefinition : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Src::File>, Fact<Definition>>> {
  static const char* GLEAN_name() {
    return "buck.FileDefinition";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct FileDefinition

struct File : Predicate<boost::variant<Alt<0, Fact<facebook::glean::cpp::schema::Src::File>>, Alt<1, Fact<Locator>>, Alt<2, Fact<LocatorWithLabel>>>> {
  static const char* GLEAN_name() {
    return "buck.File";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct File

struct FailureSources : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Src::File>, Fact<IndexFailureX>>> {
  static const char* GLEAN_name() {
    return "buck.FailureSources";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct FailureSources

} // namespace Buck

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Buck::FailureReason> {
  using Type = Enum<6>;
};


namespace schema {

namespace Buck {

enum class FailureReason { Skipped, Blocked, EmptyCdb, FailedCdb, QueryFailed, Unclassified };

struct IndexFailureX : Predicate<std::tuple<boost::variant<Alt<0, Fact<Locator>>, Alt<1, Fact<facebook::glean::cpp::schema::Src::File>>>, Fact<IndexerName>, FailureReason, std::string, boost::variant<Alt<0, std::tuple<>>, Alt<1, std::string>>>> {
  static const char* GLEAN_name() {
    return "buck.IndexFailureX";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct IndexFailureX

struct DestinationUses : Predicate<std::tuple<XRefDestination, Fact<facebook::glean::cpp::schema::Src::File>, std::vector<facebook::glean::cpp::schema::Src::ByteSpan>>> {
  static const char* GLEAN_name() {
    return "buck.DestinationUses";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct DestinationUses

} // namespace Buck

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Buck::Dependency> {
  using Type = Tuple<facebook::glean::cpp::schema::Buck::Locator, Bool, Bool>;
};


namespace schema {

namespace Buck {

struct Dependency {
  Fact<Locator> target;
  bool explicit_;
  bool exported;

  bool operator==(const Dependency& other) const {
    return std::tie(target,explicit_,exported)
             == std::tie(other.target,other.explicit_,other.exported);
  }
  bool operator!=(const Dependency& other) const {
    return std::tie(target,explicit_,exported)
             != std::tie(other.target,other.explicit_,other.exported);
  }
  bool operator<(const Dependency& other) const {
    return std::tie(target,explicit_,exported)
             < std::tie(other.target,other.explicit_,other.exported);
  }
  bool operator<=(const Dependency& other) const {
    return std::tie(target,explicit_,exported)
             <= std::tie(other.target,other.explicit_,other.exported);
  }
  bool operator>(const Dependency& other) const {
    return std::tie(target,explicit_,exported)
             > std::tie(other.target,other.explicit_,other.exported);
  }
  bool operator>=(const Dependency& other) const {
    return std::tie(target,explicit_,exported)
             >= std::tie(other.target,other.explicit_,other.exported);
  }
  void outputRepr(Output<Repr<Dependency>> out) const {
    outputValue(out, std::make_tuple(target, explicit_, exported));
  }
}; // struct Dependency

struct TargetDependencies : Predicate<std::tuple<Fact<Target>, std::vector<Dependency>>> {
  static const char* GLEAN_name() {
    return "buck.TargetDependencies";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct TargetDependencies

struct DefinitionLocation : Predicate<std::tuple<Fact<Definition>, Fact<facebook::glean::cpp::schema::Src::File>, facebook::glean::cpp::schema::Src::ByteSpan>> {
  static const char* GLEAN_name() {
    return "buck.DefinitionLocation";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct DefinitionLocation

struct Definition : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Src::File>, std::string>> {
  static const char* GLEAN_name() {
    return "buck.Definition";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct Definition

struct Consumer : Predicate<std::tuple<Fact<facebook::glean::cpp::schema::Src::File>, Fact<TargetSources>>> {
  static const char* GLEAN_name() {
    return "buck.Consumer";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct Consumer

struct CallArgument : Predicate<std::tuple<boost::variant<Alt<0, std::tuple<>>, Alt<1, std::string>>, Fact<ArgumentValue>, Fact<facebook::glean::cpp::schema::Src::File>, facebook::glean::cpp::schema::Src::ByteSpan>> {
  static const char* GLEAN_name() {
    return "buck.CallArgument";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct CallArgument

struct AttributeName : Predicate<std::string> {
  static const char* GLEAN_name() {
    return "buck.AttributeName";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct AttributeName

} // namespace Buck

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Buck::AttributeMapping> {
  using Type = Tuple<String, facebook::glean::cpp::schema::Buck::AttributeValue>;
};


namespace schema {

namespace Buck {

struct AttributeMapping {
  std::string key;
  Fact<AttributeValue> value;

  bool operator==(const AttributeMapping& other) const {
    return std::tie(key,value)
             == std::tie(other.key,other.value);
  }
  bool operator!=(const AttributeMapping& other) const {
    return std::tie(key,value)
             != std::tie(other.key,other.value);
  }
  bool operator<(const AttributeMapping& other) const {
    return std::tie(key,value)
             < std::tie(other.key,other.value);
  }
  bool operator<=(const AttributeMapping& other) const {
    return std::tie(key,value)
             <= std::tie(other.key,other.value);
  }
  bool operator>(const AttributeMapping& other) const {
    return std::tie(key,value)
             > std::tie(other.key,other.value);
  }
  bool operator>=(const AttributeMapping& other) const {
    return std::tie(key,value)
             >= std::tie(other.key,other.value);
  }
  void outputRepr(Output<Repr<AttributeMapping>> out) const {
    outputValue(out, std::make_tuple(key, value));
  }
}; // struct AttributeMapping

struct AttributeValue : Predicate<boost::variant<Alt<0, std::string>, Alt<1, std::vector<Fact<AttributeValue>>>, Alt<2, std::vector<AttributeMapping>>>> {
  static const char* GLEAN_name() {
    return "buck.AttributeValue";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct AttributeValue

} // namespace Buck

} // namespace schema

template<> struct Repr_<facebook::glean::cpp::schema::Buck::ArgumentMapping> {
  using Type = Tuple<String, facebook::glean::cpp::schema::Buck::ArgumentValue>;
};


namespace schema {

namespace Buck {

struct ArgumentMapping {
  std::string key;
  Fact<ArgumentValue> value;

  bool operator==(const ArgumentMapping& other) const {
    return std::tie(key,value)
             == std::tie(other.key,other.value);
  }
  bool operator!=(const ArgumentMapping& other) const {
    return std::tie(key,value)
             != std::tie(other.key,other.value);
  }
  bool operator<(const ArgumentMapping& other) const {
    return std::tie(key,value)
             < std::tie(other.key,other.value);
  }
  bool operator<=(const ArgumentMapping& other) const {
    return std::tie(key,value)
             <= std::tie(other.key,other.value);
  }
  bool operator>(const ArgumentMapping& other) const {
    return std::tie(key,value)
             > std::tie(other.key,other.value);
  }
  bool operator>=(const ArgumentMapping& other) const {
    return std::tie(key,value)
             >= std::tie(other.key,other.value);
  }
  void outputRepr(Output<Repr<ArgumentMapping>> out) const {
    outputValue(out, std::make_tuple(key, value));
  }
}; // struct ArgumentMapping

struct ArgumentValue : Predicate<boost::variant<Alt<0, std::string>, Alt<1, std::vector<Fact<ArgumentValue>>>, Alt<2, std::vector<ArgumentMapping>>>> {
  static const char* GLEAN_name() {
    return "buck.ArgumentValue";
  }

  static constexpr size_t GLEAN_version() {
     return 4;
  }
}; // struct ArgumentValue

} // namespace Buck

struct SCHEMA {
  template<typename P> struct index;
  static constexpr size_t count = 1288;
  template<size_t i> struct predicate;
};

template<> struct SCHEMA::index<facebook::glean::cpp::schema::Thrift::UnionVal> { static constexpr size_t value = 0; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Thrift::TypeDefType> { static constexpr size_t value = 1; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Thrift::ToPython> { static constexpr size_t value = 2; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Thrift::ToHack> { static constexpr size_t value = 3; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Thrift::ToCpp2> { static constexpr size_t value = 4; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Thrift::StructuredAnnotation> { static constexpr size_t value = 5; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Thrift::StructVal> { static constexpr size_t value = 6; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Thrift::ServiceParent> { static constexpr size_t value = 7; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Thrift::ServiceDefinition> { static constexpr size_t value = 8; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Thrift::ServiceChild> { static constexpr size_t value = 9; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Thrift::SearchByName> { static constexpr size_t value = 10; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Thrift::QualName> { static constexpr size_t value = 11; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Thrift::PythonValue> { static constexpr size_t value = 12; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Thrift::PythonName> { static constexpr size_t value = 13; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Thrift::PythonModuleFile> { static constexpr size_t value = 14; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Thrift::PythonModuleContains> { static constexpr size_t value = 15; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Thrift::PythonModule> { static constexpr size_t value = 16; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Thrift::PythonMethod> { static constexpr size_t value = 17; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Thrift::PythonFunction> { static constexpr size_t value = 18; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Thrift::PythonFileModule> { static constexpr size_t value = 19; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Thrift::PythonField> { static constexpr size_t value = 20; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Thrift::PythonClassContains> { static constexpr size_t value = 21; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Thrift::PythonClass> { static constexpr size_t value = 22; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Thrift::OutputTarget> { static constexpr size_t value = 23; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Thrift::NamespaceValue> { static constexpr size_t value = 24; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Thrift::NamespaceName> { static constexpr size_t value = 25; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Thrift::Namespace> { static constexpr size_t value = 26; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Thrift::NameLowerCase> { static constexpr size_t value = 27; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Thrift::MangleLang> { static constexpr size_t value = 28; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Thrift::Mangle> { static constexpr size_t value = 29; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Thrift::NamedDecl> { static constexpr size_t value = 30; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Thrift::ServiceName> { static constexpr size_t value = 31; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Thrift::TargetX> { static constexpr size_t value = 32; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Thrift::Lang> { static constexpr size_t value = 33; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Thrift::Includes> { static constexpr size_t value = 34; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Thrift::IncludeStatement> { static constexpr size_t value = 35; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Thrift::IncludeSplice> { static constexpr size_t value = 36; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Thrift::IncludeSpecial> { static constexpr size_t value = 37; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Thrift::Identifier> { static constexpr size_t value = 38; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Thrift::HackRecordContains> { static constexpr size_t value = 39; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Thrift::HackRecord> { static constexpr size_t value = 40; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Thrift::HackName> { static constexpr size_t value = 41; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Thrift::HackMethod> { static constexpr size_t value = 42; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Thrift::HackMap> { static constexpr size_t value = 43; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Thrift::FunctionName> { static constexpr size_t value = 44; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Thrift::FromPython> { static constexpr size_t value = 45; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Thrift::FromHack> { static constexpr size_t value = 46; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Thrift::Literal> { static constexpr size_t value = 47; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Thrift::FileXRefs> { static constexpr size_t value = 48; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Thrift::FileTarget> { static constexpr size_t value = 49; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Thrift::FileOutput> { static constexpr size_t value = 50; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Thrift::FileError> { static constexpr size_t value = 51; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Thrift::File> { static constexpr size_t value = 52; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Thrift::StructType> { static constexpr size_t value = 53; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Thrift::UnionType> { static constexpr size_t value = 54; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Thrift::ExceptionVal> { static constexpr size_t value = 55; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Thrift::ExceptionType> { static constexpr size_t value = 56; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Thrift::TypeDefException> { static constexpr size_t value = 57; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Thrift::ExceptionName> { static constexpr size_t value = 58; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Thrift::EnumerationType> { static constexpr size_t value = 59; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Thrift::EnumValueDef> { static constexpr size_t value = 60; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Thrift::EnumValue> { static constexpr size_t value = 61; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Thrift::EnumVal> { static constexpr size_t value = 62; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Thrift::DeclarationName> { static constexpr size_t value = 63; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Thrift::DeclarationNameSpan> { static constexpr size_t value = 64; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Thrift::FileDeclaration> { static constexpr size_t value = 65; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Thrift::FunctionDeclarationName> { static constexpr size_t value = 66; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Thrift::TypeSpecification> { static constexpr size_t value = 67; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Thrift::ConstantType> { static constexpr size_t value = 68; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Thrift::Constant> { static constexpr size_t value = 69; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Thrift::CompileTarget> { static constexpr size_t value = 70; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Testinfra::TestId> { static constexpr size_t value = 71; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Testinfra::TaggedAssembly> { static constexpr size_t value = 72; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Testinfra::Tag> { static constexpr size_t value = 73; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Testinfra::MeasuredFileOnly> { static constexpr size_t value = 74; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Testinfra::MeasuredFile> { static constexpr size_t value = 75; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Testinfra::Folder> { static constexpr size_t value = 76; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Testinfra::FbId> { static constexpr size_t value = 77; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Testinfra::DatabaseMetadataField> { static constexpr size_t value = 78; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Testinfra::DatabaseMetadata> { static constexpr size_t value = 79; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Testinfra::CoveredOrLoadedFileTestIds> { static constexpr size_t value = 80; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Testinfra::CoveredFolder> { static constexpr size_t value = 81; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Testinfra::CoveredFileTestIds> { static constexpr size_t value = 82; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Testinfra::CoveredFileTestIds_4> { static constexpr size_t value = 83; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Testinfra::CoveredFileOnly> { static constexpr size_t value = 84; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Testinfra::CoveredFileByTagAndAssembly> { static constexpr size_t value = 85; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Testinfra::CoveredFileByPushBlockingAssembly> { static constexpr size_t value = 86; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Testinfra::CoveredFileAssemblies> { static constexpr size_t value = 87; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Testinfra::CoveredAssembly> { static constexpr size_t value = 88; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Testinfra::FileMetadata_2> { static constexpr size_t value = 89; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Testinfra::FileMetadata> { static constexpr size_t value = 90; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Testinfra::CoveredFile> { static constexpr size_t value = 91; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Testinfra::ContainsPushBlockingAssembly> { static constexpr size_t value = 92; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Testinfra::AssemblyId> { static constexpr size_t value = 93; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Testinfra::AssemblyByTag> { static constexpr size_t value = 94; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Testinfra::Assemblies> { static constexpr size_t value = 95; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Sys::Blob> { static constexpr size_t value = 96; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Src::RangeContains> { static constexpr size_t value = 97; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Src::IndexFailure> { static constexpr size_t value = 98; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Src::FileLines> { static constexpr size_t value = 99; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Src::FileLanguage> { static constexpr size_t value = 100; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Src::FileDigest> { static constexpr size_t value = 101; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Src::File> { static constexpr size_t value = 102; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Src::ByteSpanContains> { static constexpr size_t value = 103; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Spark::Ts::VersionedCapability> { static constexpr size_t value = 104; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Spark::Ts::Version> { static constexpr size_t value = 105; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Spark::Ts::Type> { static constexpr size_t value = 106; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Spark::Ts::SymbolName> { static constexpr size_t value = 107; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Spark::Ts::SymbolVersions> { static constexpr size_t value = 108; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Spark::Ts::SymbolCapabilities> { static constexpr size_t value = 109; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Spark::Ts::SymbolInfo> { static constexpr size_t value = 110; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Spark::Ts::SymbolLocation> { static constexpr size_t value = 111; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Spark::Ts::SymbolLocationInherited> { static constexpr size_t value = 112; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Spark::Ts::SparkModule> { static constexpr size_t value = 113; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Spark::Ts::SignatureXRefs> { static constexpr size_t value = 114; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Spark::Ts::Signature> { static constexpr size_t value = 115; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Spark::Ts::SymbolStatus> { static constexpr size_t value = 116; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Spark::Ts::PropertyExtDecl> { static constexpr size_t value = 117; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Spark::Ts::PropertyInfo> { static constexpr size_t value = 118; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Spark::Ts::Name> { static constexpr size_t value = 119; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Spark::Ts::ModuleSymbol> { static constexpr size_t value = 120; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Spark::Ts::ModuleFiles> { static constexpr size_t value = 121; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Spark::Ts::ModuleExports> { static constexpr size_t value = 122; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Spark::Ts::ModuleBase> { static constexpr size_t value = 123; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Spark::Ts::MethodExtDecl> { static constexpr size_t value = 124; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Spark::Ts::MethodInfo> { static constexpr size_t value = 125; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Spark::Ts::InheritsFrom> { static constexpr size_t value = 126; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Spark::Ts::ExtDeclScope> { static constexpr size_t value = 127; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Spark::Ts::ExampleCode> { static constexpr size_t value = 128; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Spark::Ts::EnumeratorInfo> { static constexpr size_t value = 129; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Spark::Ts::EnumeratorDecl> { static constexpr size_t value = 130; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Spark::Ts::EnumInfo> { static constexpr size_t value = 131; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Spark::Ts::EnumDecl> { static constexpr size_t value = 132; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Spark::Ts::GatingInfo> { static constexpr size_t value = 133; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Spark::Ts::DocXRefs> { static constexpr size_t value = 134; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Spark::Ts::DocString> { static constexpr size_t value = 135; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Spark::Ts::DocLocationInherited> { static constexpr size_t value = 136; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Spark::Ts::DocLocation> { static constexpr size_t value = 137; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Spark::Ts::Doc> { static constexpr size_t value = 138; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Spark::Ts::Contains> { static constexpr size_t value = 139; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Spark::Ts::MethodDecl> { static constexpr size_t value = 140; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Spark::Ts::PropertyDecl> { static constexpr size_t value = 141; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Spark::Ts::ClassInfo> { static constexpr size_t value = 142; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Spark::Ts::ClassDecl> { static constexpr size_t value = 143; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Spark::Ts::ChangeKeyVersion> { static constexpr size_t value = 144; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Spark::Ts::ChangeKeyInfo> { static constexpr size_t value = 145; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Spark::Ts::ChangeKey> { static constexpr size_t value = 146; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Spark::Ts::CapabilityName> { static constexpr size_t value = 147; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Spark::Ts::CapabilityConditionResult> { static constexpr size_t value = 148; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Spark::Ts::CapabilityCondition> { static constexpr size_t value = 149; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Spark::Ts::Capability> { static constexpr size_t value = 150; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Spark::Ts::AccessorExtDecl> { static constexpr size_t value = 151; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Spark::Ts::AccessorInfo> { static constexpr size_t value = 152; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Spark::Ts::AccessorDecl> { static constexpr size_t value = 153; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Search::Python::QueryToScopeCase> { static constexpr size_t value = 154; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Search::Python::PythonNameCase> { static constexpr size_t value = 155; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Search::Pp::SearchByName> { static constexpr size_t value = 156; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Search::Pp::SearchByName_1> { static constexpr size_t value = 157; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Search::Java::QueryToScopeCase> { static constexpr size_t value = 158; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Search::Java::NameCase> { static constexpr size_t value = 159; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Search::Hack::QueryToScopeCase> { static constexpr size_t value = 160; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Search::Hack::HackNameCase> { static constexpr size_t value = 161; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Search::Hack::HackInAutoImportedNamespace> { static constexpr size_t value = 162; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Search::Flow::TypeDeclarationAsDeclaration> { static constexpr size_t value = 163; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Search::Flow::QueryToScopeCase> { static constexpr size_t value = 164; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Search::Flow::FlowModuleNameCase> { static constexpr size_t value = 165; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Search::Cxx::QueryToQNameCase> { static constexpr size_t value = 166; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Search::Cxx::QueryToNSQNameCase> { static constexpr size_t value = 167; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Search::Cxx::CxxNameCase> { static constexpr size_t value = 168; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Scm::Timestamp> { static constexpr size_t value = 169; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Scm::Rev> { static constexpr size_t value = 170; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Scm::RepoType> { static constexpr size_t value = 171; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Scm::RepoName> { static constexpr size_t value = 172; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Scm::Repo> { static constexpr size_t value = 173; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Scm::Commit> { static constexpr size_t value = 174; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Scip::SymbolName> { static constexpr size_t value = 175; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Scip::SymbolDocumentation> { static constexpr size_t value = 176; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Scip::Symbol> { static constexpr size_t value = 177; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Scip::ReferenceTarget> { static constexpr size_t value = 178; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Scip::Reference> { static constexpr size_t value = 179; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Scip::LocalName> { static constexpr size_t value = 180; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Scip::EntityDefinition> { static constexpr size_t value = 181; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Scip::EntityLocation> { static constexpr size_t value = 182; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Scip::EntityUses> { static constexpr size_t value = 183; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Scip::FileEntityXRefLocation> { static constexpr size_t value = 184; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Scip::ResolveLocation> { static constexpr size_t value = 185; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Scip::SearchBySymbol> { static constexpr size_t value = 186; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Scip::Documentation> { static constexpr size_t value = 187; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Scip::DefinitionUses> { static constexpr size_t value = 188; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Scip::DefinitionName> { static constexpr size_t value = 189; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Scip::DefinitionDocumentation> { static constexpr size_t value = 190; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Scip::Definition> { static constexpr size_t value = 191; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Python::XRefsViaNameByFile> { static constexpr size_t value = 192; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Python::VariableDeclaration> { static constexpr size_t value = 193; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Python::VariableBySName> { static constexpr size_t value = 194; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Python::Type> { static constexpr size_t value = 195; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Python::StringLiteral> { static constexpr size_t value = 196; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Python::SNameToName> { static constexpr size_t value = 197; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Python::SName> { static constexpr size_t value = 198; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Python::ResolveOriginalName> { static constexpr size_t value = 199; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Python::NameToSName> { static constexpr size_t value = 200; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Python::Name> { static constexpr size_t value = 201; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Python::ModuleDefinition> { static constexpr size_t value = 202; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Python::ModuleBySName> { static constexpr size_t value = 203; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Python::Module> { static constexpr size_t value = 204; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Python::MethodWithLocalName> { static constexpr size_t value = 205; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Python::MethodOverrides> { static constexpr size_t value = 206; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Python::MethodOverriden> { static constexpr size_t value = 207; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Python::LocalNameLowerCase> { static constexpr size_t value = 208; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Python::LocalName> { static constexpr size_t value = 209; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Python::ImportStatementByAsSName> { static constexpr size_t value = 210; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Python::ImportStatementByAsName> { static constexpr size_t value = 211; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Python::ImportStatement> { static constexpr size_t value = 212; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Python::ImportStarsByFile> { static constexpr size_t value = 213; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Python::ImportStarStatement> { static constexpr size_t value = 214; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Python::ImportStarLocation> { static constexpr size_t value = 215; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Python::FunctionDeclaration> { static constexpr size_t value = 216; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Python::FunctionBySName> { static constexpr size_t value = 217; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Python::DerivedClassToBase> { static constexpr size_t value = 218; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Python::DefinitionLocation> { static constexpr size_t value = 219; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Python::DefinitionsByFile> { static constexpr size_t value = 220; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Python::IsTopLevelDefinition> { static constexpr size_t value = 221; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Python::FunctionDefinition> { static constexpr size_t value = 222; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Python::VariableDefinition> { static constexpr size_t value = 223; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Python::DeclarationDefinition> { static constexpr size_t value = 224; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Python::DeclarationDocstring> { static constexpr size_t value = 225; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Python::DeclarationLocation> { static constexpr size_t value = 226; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Python::DeclarationReference> { static constexpr size_t value = 227; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Python::DeclarationToName> { static constexpr size_t value = 228; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Python::DeclarationUses> { static constexpr size_t value = 229; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Python::DeclarationWithLocalName> { static constexpr size_t value = 230; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Python::DeclarationWithName> { static constexpr size_t value = 231; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Python::DeclarationWithSName> { static constexpr size_t value = 232; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Python::DeclarationsByFile> { static constexpr size_t value = 233; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Python::DefinitionDeclaration> { static constexpr size_t value = 234; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Python::DirectXRefsByFile> { static constexpr size_t value = 235; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Python::IsAbstract> { static constexpr size_t value = 236; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Python::IsTopLevelDeclaration> { static constexpr size_t value = 237; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Python::NonImportDeclaration> { static constexpr size_t value = 238; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Python::SNameWithDeclaration> { static constexpr size_t value = 239; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Python::SearchByLocalName> { static constexpr size_t value = 240; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Python::Contains> { static constexpr size_t value = 241; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Python::ContainingTopLevelDeclaration> { static constexpr size_t value = 242; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Python::ContainedByTopLevelDeclaration> { static constexpr size_t value = 243; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Python::ContainedBy> { static constexpr size_t value = 244; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Python::ClassDefinition> { static constexpr size_t value = 245; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Python::ClassDeclaration> { static constexpr size_t value = 246; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Python::ClassBySName> { static constexpr size_t value = 247; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Python::CalleeToCaller> { static constexpr size_t value = 248; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Python::BaseClassToDerived> { static constexpr size_t value = 249; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Python::FileCall> { static constexpr size_t value = 250; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Pp1::Use> { static constexpr size_t value = 251; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Pp1::Undef> { static constexpr size_t value = 252; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Pp1::Macro> { static constexpr size_t value = 253; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Pp1::Include> { static constexpr size_t value = 254; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Pp1::DefineUse> { static constexpr size_t value = 255; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Pp1::Define> { static constexpr size_t value = 256; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Perf::Hack::ReturnPercentages> { static constexpr size_t value = 257; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Perf::Hack::LoopCounts> { static constexpr size_t value = 258; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Perf::Hack::FunctionData> { static constexpr size_t value = 259; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Omegaanalyser::PolicyOncall> { static constexpr size_t value = 260; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Omegaanalyser::OncallName> { static constexpr size_t value = 261; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Omegaanalyser::OmegaPolicy> { static constexpr size_t value = 262; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Omegaanalyser::OmegaEndpoint> { static constexpr size_t value = 263; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Omegaanalyser::Method> { static constexpr size_t value = 264; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Omegaanalyser::Function_> { static constexpr size_t value = 265; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Omegaanalyser::EndpointOncall> { static constexpr size_t value = 266; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Omegaanalyser::DependencyPathByCoreNode> { static constexpr size_t value = 267; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Omegaanalyser::DependencyPath> { static constexpr size_t value = 268; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Omegaanalyser::DependencyList> { static constexpr size_t value = 269; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Omegaanalyser::Config> { static constexpr size_t value = 270; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Omegaanalyser::Class_> { static constexpr size_t value = 271; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Omega::Oncall> { static constexpr size_t value = 272; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Omega::OmegaPolicy> { static constexpr size_t value = 273; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Omega::OmegaExecutionNode> { static constexpr size_t value = 274; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Omega::OmegaEntityMetadata> { static constexpr size_t value = 275; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Omega::OmegaEndpoint> { static constexpr size_t value = 276; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Omega::OmegaBlock> { static constexpr size_t value = 277; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Omega::OmegaAction> { static constexpr size_t value = 278; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Omega::Name> { static constexpr size_t value = 279; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Omega::Method> { static constexpr size_t value = 280; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Omega::Function_> { static constexpr size_t value = 281; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Omega::Enum_> { static constexpr size_t value = 282; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Omega::DependencyPathByEntity> { static constexpr size_t value = 283; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Omega::DependencyPath> { static constexpr size_t value = 284; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Omega::DependencyList> { static constexpr size_t value = 285; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Omega::Config> { static constexpr size_t value = 286; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Omega::Class_> { static constexpr size_t value = 287; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Monk::Xid> { static constexpr size_t value = 288; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Monk::PiiLoggerXid> { static constexpr size_t value = 289; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Monk::HackPiiLoggerTraitXid> { static constexpr size_t value = 290; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Monk::HackPiiLoggerSetterXid> { static constexpr size_t value = 291; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Monk::HackPiiLoggerSetterCallXid> { static constexpr size_t value = 292; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Monk::HackPiiLoggerClassXid> { static constexpr size_t value = 293; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Monk::HackPiiLogCallXid> { static constexpr size_t value = 294; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Monk::HackPiiLog> { static constexpr size_t value = 295; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Monk::HackPiiFunc> { static constexpr size_t value = 296; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Monk::HackMethodByName> { static constexpr size_t value = 297; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Monk::HackLoggerMethod> { static constexpr size_t value = 298; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Scip::Metadata> { static constexpr size_t value = 299; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Scip::EntityKind> { static constexpr size_t value = 300; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Scip::SymbolKind> { static constexpr size_t value = 301; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Lsif::Types::ToSrcRange> { static constexpr size_t value = 302; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Scip::DefinitionLocation> { static constexpr size_t value = 303; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Scip::FileRange> { static constexpr size_t value = 304; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Scip::ReferenceLocation> { static constexpr size_t value = 305; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Scip::FileLanguage> { static constexpr size_t value = 306; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Scip::TagDefinition> { static constexpr size_t value = 307; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Lsif::Types::FromSrcRange> { static constexpr size_t value = 308; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Lsif::Reference> { static constexpr size_t value = 309; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Lsif::Range> { static constexpr size_t value = 310; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Lsif::ProjectDocument> { static constexpr size_t value = 311; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Lsif::Project> { static constexpr size_t value = 312; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Lsif::PackageInformation> { static constexpr size_t value = 313; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Lsif::NameLowerCase> { static constexpr size_t value = 314; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Lsif::NameDefinition> { static constexpr size_t value = 315; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Lsif::Name> { static constexpr size_t value = 316; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Lsif::MonikerSymbolKind> { static constexpr size_t value = 317; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Lsif::MonikerScheme> { static constexpr size_t value = 318; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Lsif::MonikerId> { static constexpr size_t value = 319; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Lsif::MonikerDefinition> { static constexpr size_t value = 320; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Lsif::Moniker> { static constexpr size_t value = 321; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Lsif::Metadata> { static constexpr size_t value = 322; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Lsif::HoverText> { static constexpr size_t value = 323; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Lsif::HoverContent> { static constexpr size_t value = 324; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Lsif::EntityDefinition> { static constexpr size_t value = 325; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Lsif::EntityKind> { static constexpr size_t value = 326; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Lsif::EntityLocation> { static constexpr size_t value = 327; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Lsif::EntityUses> { static constexpr size_t value = 328; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Lsif::FileEntityXRefLocation> { static constexpr size_t value = 329; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Lsif::ResolveLocation> { static constexpr size_t value = 330; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Lsif::SearchByExactLocation> { static constexpr size_t value = 331; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Lsif::SearchByExactLocationAndName> { static constexpr size_t value = 332; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Lsif::SearchByMoniker> { static constexpr size_t value = 333; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Lsif::SearchByName> { static constexpr size_t value = 334; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Lsif::SearchNonLocalByLocation> { static constexpr size_t value = 335; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Lsif::TagDefinition> { static constexpr size_t value = 336; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Lsif::Document> { static constexpr size_t value = 337; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Lsif::DefinitionUse> { static constexpr size_t value = 338; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Lsif::DefinitionMoniker> { static constexpr size_t value = 339; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Lsif::DefinitionLocation> { static constexpr size_t value = 340; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Lsif::DefinitionKind> { static constexpr size_t value = 341; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Lsif::DefinitionHover> { static constexpr size_t value = 342; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Lsif::Definition> { static constexpr size_t value = 343; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Lsif::Declaration> { static constexpr size_t value = 344; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Kotlin::Alpha::VariableParent> { static constexpr size_t value = 345; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Kotlin::Alpha::VariableDeclaration> { static constexpr size_t value = 346; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Kotlin::Alpha::TypeArg> { static constexpr size_t value = 347; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Kotlin::Alpha::Type> { static constexpr size_t value = 348; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Kotlin::Alpha::DeclarationLocation> { static constexpr size_t value = 349; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Kotlin::Alpha::DeclarationFileLocation> { static constexpr size_t value = 350; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Kotlin::Alpha::ExtendsDeclaration> { static constexpr size_t value = 351; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Kotlin::Alpha::FileDeclarations> { static constexpr size_t value = 352; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Kotlin::Alpha::MethodDeclaration> { static constexpr size_t value = 353; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Kotlin::Alpha::ParentDeclaration> { static constexpr size_t value = 354; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Search::Kotlin::SearchByQName> { static constexpr size_t value = 355; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Symbolid::Kotlin::LookupDeclaration> { static constexpr size_t value = 356; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Symbolid::Kotlin::LookupMethodDeclaration> { static constexpr size_t value = 357; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Kotlin::Alpha::ContainsDeclaration> { static constexpr size_t value = 358; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Kotlin::Alpha::ClassMember> { static constexpr size_t value = 359; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Kotlin::Alpha::ClassDeclaration> { static constexpr size_t value = 360; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Javakotlin::Alpha::Type> { static constexpr size_t value = 361; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Javakotlin::Alpha::QName> { static constexpr size_t value = 362; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Javakotlin::Alpha::Path> { static constexpr size_t value = 363; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Javakotlin::Alpha::NameLowerCase> { static constexpr size_t value = 364; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Javakotlin::Alpha::Name> { static constexpr size_t value = 365; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Javakotlin::Alpha::MethodName> { static constexpr size_t value = 366; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Java::Alpha::XRefFile> { static constexpr size_t value = 367; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Java::Alpha::XRef> { static constexpr size_t value = 368; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Java::Alpha::TypeVar> { static constexpr size_t value = 369; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Java::Alpha::TypeParam> { static constexpr size_t value = 370; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Java::Alpha::TypeOfTypeArgs> { static constexpr size_t value = 371; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Java::Alpha::TypeArg> { static constexpr size_t value = 372; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Java::Alpha::PrimitiveType> { static constexpr size_t value = 373; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Java::Alpha::PackageDeclaration> { static constexpr size_t value = 374; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Java::Alpha::ObjectType> { static constexpr size_t value = 375; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Java::Alpha::ParameterDeclaration> { static constexpr size_t value = 376; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Java::Alpha::InterfaceInheritance> { static constexpr size_t value = 377; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Java::Alpha::Inheritance> { static constexpr size_t value = 378; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Java::Alpha::ImportDeclaration> { static constexpr size_t value = 379; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Java::Alpha::FileXRefs> { static constexpr size_t value = 380; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Java::Alpha::ExecutableDefnLocation> { static constexpr size_t value = 381; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Java::Alpha::LocalDeclaration> { static constexpr size_t value = 382; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Java::Alpha::DefinitionLocation> { static constexpr size_t value = 383; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Java::Alpha::EnumDeclaration> { static constexpr size_t value = 384; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Java::Alpha::FieldDeclaration> { static constexpr size_t value = 385; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Java::Alpha::InterfaceDeclaration> { static constexpr size_t value = 386; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Java::Alpha::MethodDeclaration> { static constexpr size_t value = 387; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Java::Alpha::DeclarationAnnotations> { static constexpr size_t value = 388; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Java::Alpha::DeclarationComment> { static constexpr size_t value = 389; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Java::Alpha::DeclarationLocation> { static constexpr size_t value = 390; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Java::Alpha::DeclarationType> { static constexpr size_t value = 391; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Java::Alpha::DeclarationUses> { static constexpr size_t value = 392; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Java::Alpha::DeclarationXRefTarget> { static constexpr size_t value = 393; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Java::Alpha::ExtendedByDeclaration> { static constexpr size_t value = 394; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Java::Alpha::ExtendsDeclaration> { static constexpr size_t value = 395; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Java::Alpha::FileDeclarations> { static constexpr size_t value = 396; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Java::Alpha::ParentDeclaration> { static constexpr size_t value = 397; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Java::Alpha::QNameToDefinition> { static constexpr size_t value = 398; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Java::Alpha::XRefOfType> { static constexpr size_t value = 399; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Java::Alpha::XRefTargetDeclaration> { static constexpr size_t value = 400; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Search::Java::SearchByQName> { static constexpr size_t value = 401; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Symbolid::Java::LookupDeclaration> { static constexpr size_t value = 402; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Symbolid::Java::LookupMethodDeclaration> { static constexpr size_t value = 403; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Java::Alpha::DeclOfExecutableDefn> { static constexpr size_t value = 404; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Java::Alpha::DeclOfDefn> { static constexpr size_t value = 405; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Java::Alpha::ContainsDeclaration> { static constexpr size_t value = 406; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Java::Alpha::ConstructorDeclaration> { static constexpr size_t value = 407; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Java::Alpha::ClassDeclaration> { static constexpr size_t value = 408; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Java::Alpha::Type> { static constexpr size_t value = 409; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Java::Alpha::ArrayType> { static constexpr size_t value = 410; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Java::Alpha::Annotation> { static constexpr size_t value = 411; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Java::Alpha::AnnotatedClass> { static constexpr size_t value = 412; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Indexer::Config> { static constexpr size_t value = 413; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Hs::XRef> { static constexpr size_t value = 414; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Hs::Type> { static constexpr size_t value = 415; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Hs::TargetUses> { static constexpr size_t value = 416; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Hs::SourceModule> { static constexpr size_t value = 417; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Hs::PackageId> { static constexpr size_t value = 418; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Hs::ModuleNameLowerCase> { static constexpr size_t value = 419; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Hs::ModuleName> { static constexpr size_t value = 420; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Hs::ModuleDefinitions> { static constexpr size_t value = 421; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Hs::Module> { static constexpr size_t value = 422; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Hs::FunctionNameLowerCase> { static constexpr size_t value = 423; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Hs::FunctionName> { static constexpr size_t value = 424; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Hs::FunctionDefinition> { static constexpr size_t value = 425; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Hs::FileXRefMap> { static constexpr size_t value = 426; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Hs::DefinitionNameLowerCase> { static constexpr size_t value = 427; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Hs::DefinitionName> { static constexpr size_t value = 428; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Hs::DefinitionLocation> { static constexpr size_t value = 429; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Hs::FileDefinition> { static constexpr size_t value = 430; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Hs::Definition> { static constexpr size_t value = 431; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Hs::Definition_1> { static constexpr size_t value = 432; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Hs::ClassNameLowerCase> { static constexpr size_t value = 433; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Hs::ClassName> { static constexpr size_t value = 434; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Hs::ClassInstance> { static constexpr size_t value = 435; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Hs::Class> { static constexpr size_t value = 436; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Haxlanalyser::ThriftResponse> { static constexpr size_t value = 437; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Haxlanalyser::ThriftFetch> { static constexpr size_t value = 438; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Haxlanalyser::TestFile> { static constexpr size_t value = 439; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Haxlanalyser::TallyName> { static constexpr size_t value = 440; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Haxlanalyser::TallyConfig> { static constexpr size_t value = 441; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Haxlanalyser::TallyFetch> { static constexpr size_t value = 442; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Haxlanalyser::TallyResponse> { static constexpr size_t value = 443; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Haxlanalyser::SitevarFetch> { static constexpr size_t value = 444; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Haxlanalyser::ScubaResponse> { static constexpr size_t value = 445; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Haxlanalyser::ScribeResponse> { static constexpr size_t value = 446; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Haxlanalyser::RestrictionResponse> { static constexpr size_t value = 447; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Haxlanalyser::PolicyName> { static constexpr size_t value = 448; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Haxlanalyser::Policy> { static constexpr size_t value = 449; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Haxlanalyser::PiranhaResponse> { static constexpr size_t value = 450; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Haxlanalyser::LogFeatureResponse> { static constexpr size_t value = 451; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Haxlanalyser::LaserDataset> { static constexpr size_t value = 452; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Haxlanalyser::JankyJSONResponse> { static constexpr size_t value = 453; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Haxlanalyser::InputKey> { static constexpr size_t value = 454; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Haxlanalyser::InputFetch> { static constexpr size_t value = 455; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Haxlanalyser::HiveResponse> { static constexpr size_t value = 456; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Haxlanalyser::FeatureSetFeature> { static constexpr size_t value = 457; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Haxlanalyser::EndpointName> { static constexpr size_t value = 458; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Haxlanalyser::Endpoint> { static constexpr size_t value = 459; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Haxlanalyser::Edge> { static constexpr size_t value = 460; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Haxlanalyser::ContextName> { static constexpr size_t value = 461; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Haxlanalyser::Context> { static constexpr size_t value = 462; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Haxlanalyser::ConfigeratorFetch> { static constexpr size_t value = 463; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Haxlanalyser::ClassifierRead> { static constexpr size_t value = 464; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Haxlanalyser::ClassifierFetch> { static constexpr size_t value = 465; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Haxlanalyser::Call> { static constexpr size_t value = 466; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Haxlanalyser::ACDCPropertyAccess> { static constexpr size_t value = 467; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Haxlanalyser::ACDCProperty> { static constexpr size_t value = 468; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Hackdependency::name> { static constexpr size_t value = 469; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Hackdependency::inheritance> { static constexpr size_t value = 470; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Hack::UserAttribute> { static constexpr size_t value = 471; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Hack::TypedefDeclaration> { static constexpr size_t value = 472; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Hack::TypeConstDefinition> { static constexpr size_t value = 473; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Hack::Type> { static constexpr size_t value = 474; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Hack::TraitDeclaration> { static constexpr size_t value = 475; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Hack::StringLiteral> { static constexpr size_t value = 476; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Hack::QName> { static constexpr size_t value = 477; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Hack::PropertyDefinition> { static constexpr size_t value = 478; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Hack::Signature> { static constexpr size_t value = 479; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Hack::NamespaceQName> { static constexpr size_t value = 480; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Hack::NamespaceDeclaration> { static constexpr size_t value = 481; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Hack::NameLowerCase> { static constexpr size_t value = 482; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Hack::Name> { static constexpr size_t value = 483; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Hack::ModuleDefinition> { static constexpr size_t value = 484; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Hack::ModuleDeclaration> { static constexpr size_t value = 485; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Hack::MethodOverrides> { static constexpr size_t value = 486; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Hack::MethodOverridden> { static constexpr size_t value = 487; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Hack::MethodOccurrence> { static constexpr size_t value = 488; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Hack::InterfaceDeclaration> { static constexpr size_t value = 489; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Hack::IndexerInputsHash> { static constexpr size_t value = 490; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Hack::GlobalNamespaceAlias> { static constexpr size_t value = 491; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Hack::GlobalConstDefinition> { static constexpr size_t value = 492; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Hack::GlobalConstDeclaration> { static constexpr size_t value = 493; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Hack::FunctionDeclaration> { static constexpr size_t value = 494; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Hack::Enumerator> { static constexpr size_t value = 495; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Hack::EnumDefinition> { static constexpr size_t value = 496; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Hack::EnumDeclaration> { static constexpr size_t value = 497; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Hack::Context_> { static constexpr size_t value = 498; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Hack::ContainerDeclarationQName> { static constexpr size_t value = 499; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Hack::ContainerParent> { static constexpr size_t value = 500; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Hack::DeclarationComment> { static constexpr size_t value = 501; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Hack::DeclarationLocation> { static constexpr size_t value = 502; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Hack::DeclarationName> { static constexpr size_t value = 503; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Hack::DeclarationNamespace> { static constexpr size_t value = 504; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Hack::DeclarationSource> { static constexpr size_t value = 505; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Hack::DeclarationSpan> { static constexpr size_t value = 506; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Hack::DeclarationTarget> { static constexpr size_t value = 507; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Hack::FileDeclarations> { static constexpr size_t value = 508; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Hack::MemberCluster> { static constexpr size_t value = 509; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Hack::ModuleChild> { static constexpr size_t value = 510; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Hack::ModuleParent> { static constexpr size_t value = 511; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Hack::NamespaceMember> { static constexpr size_t value = 512; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Hack::TargetUses> { static constexpr size_t value = 513; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Hack::TargetUsesAbs> { static constexpr size_t value = 514; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Hack::FileXRefs> { static constexpr size_t value = 515; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Hack::TypeInfo> { static constexpr size_t value = 516; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Monk::HackCaller> { static constexpr size_t value = 517; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Monk::HackIsCaller> { static constexpr size_t value = 518; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Omega::TargetNodeLocations> { static constexpr size_t value = 519; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Omegaanalyser::ClassStaticMethodReferences> { static constexpr size_t value = 520; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Omegaanalyser::TargetNodeLocations> { static constexpr size_t value = 521; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Search::Hack::SearchByName> { static constexpr size_t value = 522; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Search::Hack::SearchFunctionInNamespace> { static constexpr size_t value = 523; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Search::Hack::SearchGlobalConstInNamespace> { static constexpr size_t value = 524; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Search::Hack::SearchInContainer> { static constexpr size_t value = 525; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Search::Hack::SearchInContainerNoProperty> { static constexpr size_t value = 526; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Search::Hack::SearchInContainerOrEnum> { static constexpr size_t value = 527; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Search::Hack::SearchInContainerOrEnumNoProperty> { static constexpr size_t value = 528; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Search::Hack::SearchInContext> { static constexpr size_t value = 529; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Search::Hack::SearchInEnum> { static constexpr size_t value = 530; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Search::Hack::SearchInNamespace> { static constexpr size_t value = 531; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Search::Hack::SearchModule> { static constexpr size_t value = 532; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Search::Hack::SearchNamespace> { static constexpr size_t value = 533; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Search::Hack::SearchNamespacedDecl> { static constexpr size_t value = 534; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Search::Hack::SearchPropertyInContainer> { static constexpr size_t value = 535; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Search::Hack::SearchTypeInNamespace> { static constexpr size_t value = 536; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Hack::InheritedMembers> { static constexpr size_t value = 537; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Hack::MethodDeclaration> { static constexpr size_t value = 538; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Hack::PropertyDeclaration> { static constexpr size_t value = 539; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Hack::TypeConstDeclaration> { static constexpr size_t value = 540; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Hack::ContainerChild> { static constexpr size_t value = 541; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Hack::FunctionDefinition> { static constexpr size_t value = 542; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Hack::InterfaceDefinition> { static constexpr size_t value = 543; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Hack::MethodDefinition> { static constexpr size_t value = 544; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Hack::TraitDefinition> { static constexpr size_t value = 545; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Hack::TypedefDefinition> { static constexpr size_t value = 546; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Hack::ClassDefinition> { static constexpr size_t value = 547; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Hack::ClassDeclaration> { static constexpr size_t value = 548; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Hack::ClassConstDefinition> { static constexpr size_t value = 549; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Hack::ClassConstDeclaration> { static constexpr size_t value = 550; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Hack::AttributeToDefinition> { static constexpr size_t value = 551; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Hack::AttributeToDeclaration> { static constexpr size_t value = 552; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Hack::AttributeHasParameter> { static constexpr size_t value = 553; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Hack::FileCall> { static constexpr size_t value = 554; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Graphql::VariableDef> { static constexpr size_t value = 555; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Graphql::Value> { static constexpr size_t value = 556; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Graphql::UnionTypeDef> { static constexpr size_t value = 557; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Graphql::ScalarTypeDef> { static constexpr size_t value = 558; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Graphql::Operation> { static constexpr size_t value = 559; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Graphql::ObjectTypeDef> { static constexpr size_t value = 560; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Graphql::NameLowerCase> { static constexpr size_t value = 561; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Graphql::InterfaceTypeDef> { static constexpr size_t value = 562; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Graphql::InputValueDef> { static constexpr size_t value = 563; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Graphql::InputObjectTypeDef> { static constexpr size_t value = 564; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Graphql::InlineFragment> { static constexpr size_t value = 565; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Graphql::FragmentSpread> { static constexpr size_t value = 566; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Graphql::Fragment> { static constexpr size_t value = 567; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Graphql::FieldDef> { static constexpr size_t value = 568; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Graphql::Field> { static constexpr size_t value = 569; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Graphql::EnumTypeDef> { static constexpr size_t value = 570; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Graphql::DirectiveDef> { static constexpr size_t value = 571; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Graphql::Directive> { static constexpr size_t value = 572; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Graphql::DeclarationLocation> { static constexpr size_t value = 573; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Graphql::DeclarationName> { static constexpr size_t value = 574; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Graphql::DeclarationUses> { static constexpr size_t value = 575; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Graphql::FileDeclarations> { static constexpr size_t value = 576; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Graphql::SearchByName> { static constexpr size_t value = 577; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Graphql::FileXRefs> { static constexpr size_t value = 578; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Graphql::DeclHasName> { static constexpr size_t value = 579; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Graphql::BelongToConfig> { static constexpr size_t value = 580; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Graphql::Argument> { static constexpr size_t value = 581; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Glean::Test::nothingTest> { static constexpr size_t value = 582; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Glean::Test::ViaStringPair> { static constexpr size_t value = 583; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Glean::Test::Unbound2> { static constexpr size_t value = 584; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Glean::Test::Unbound> { static constexpr size_t value = 585; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Glean::Test::TreeToTree> { static constexpr size_t value = 586; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Glean::Test::Tree> { static constexpr size_t value = 587; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Glean::Test::StringPairBox> { static constexpr size_t value = 588; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Glean::Test::StringPair> { static constexpr size_t value = 589; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Glean::Test::StoredRevStringPairWithRev> { static constexpr size_t value = 590; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Glean::Test::StoredRevStringPairWithA> { static constexpr size_t value = 591; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Glean::Test::StoredRevStringPairSum> { static constexpr size_t value = 592; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Glean::Test::StoredRevStringPair> { static constexpr size_t value = 593; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Glean::Test::StoredDualStringPair> { static constexpr size_t value = 594; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Glean::Test::SkipRevEdge> { static constexpr size_t value = 595; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Glean::Test::SameString> { static constexpr size_t value = 596; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Glean::Test::RevStringPairs> { static constexpr size_t value = 597; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Glean::Test::RevStringPairRec> { static constexpr size_t value = 598; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Glean::Test::RevStringPair> { static constexpr size_t value = 599; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Glean::Test::RevRevStringPair> { static constexpr size_t value = 600; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Glean::Test::RevEdge> { static constexpr size_t value = 601; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Glean::Test::ReflStringPair> { static constexpr size_t value = 602; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Glean::Test::RefRef> { static constexpr size_t value = 603; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Glean::Test::Ref> { static constexpr size_t value = 604; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Glean::Test::Qux> { static constexpr size_t value = 605; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Glean::Test::NodePair> { static constexpr size_t value = 606; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Glean::Test::Node> { static constexpr size_t value = 607; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Glean::Test::Name> { static constexpr size_t value = 608; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Glean::Test::MatchOneAlt> { static constexpr size_t value = 609; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Glean::Test::LeftOr2> { static constexpr size_t value = 610; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Glean::Test::LeftOr> { static constexpr size_t value = 611; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Glean::Test::KeyValue> { static constexpr size_t value = 612; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Glean::Test::IsThree> { static constexpr size_t value = 613; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Glean::Test::IsParent> { static constexpr size_t value = 614; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Glean::Test::IsGlean> { static constexpr size_t value = 615; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Glean::Test::FooToFoo> { static constexpr size_t value = 616; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Glean::Test::Foo> { static constexpr size_t value = 617; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Glean::Test::Expr> { static constexpr size_t value = 618; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Glean::Test::Predicate_1> { static constexpr size_t value = 619; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Glean::Test::EmptyStoredStringPair> { static constexpr size_t value = 620; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Glean::Test::EdgeWrapper> { static constexpr size_t value = 621; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Glean::Test::Edge> { static constexpr size_t value = 622; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Glean::Test::DualStringPair> { static constexpr size_t value = 623; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Glean::Test::DerivedKeyValue2> { static constexpr size_t value = 624; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Glean::Test::DerivedKeyValue> { static constexpr size_t value = 625; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Glean::Test::Bar> { static constexpr size_t value = 626; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Glean::Test::Predicate_> { static constexpr size_t value = 627; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Gencode::GenCodeSignature> { static constexpr size_t value = 628; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Gencode::GenCodeCommand> { static constexpr size_t value = 629; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Gencode::GenCodeClass> { static constexpr size_t value = 630; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Gencode::GenCodeBySource> { static constexpr size_t value = 631; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Gencode::GenCode> { static constexpr size_t value = 632; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Flow::TypeImportDeclaration> { static constexpr size_t value = 633; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Flow::TypeExport> { static constexpr size_t value = 634; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Flow::TypeDeclarationReference> { static constexpr size_t value = 635; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Flow::TypeDeclarationInfo> { static constexpr size_t value = 636; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Flow::TypeDeclaration> { static constexpr size_t value = 637; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Flow::Type> { static constexpr size_t value = 638; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Flow::StringToFileModule> { static constexpr size_t value = 639; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Flow::SourceOfTypeExport> { static constexpr size_t value = 640; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Flow::SourceOfExport> { static constexpr size_t value = 641; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Search::Flow::FlowSearchByNameNonImport> { static constexpr size_t value = 642; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Flow::SearchTypeByModuleExport> { static constexpr size_t value = 643; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Flow::SearchByNameModule> { static constexpr size_t value = 644; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Flow::SearchByName> { static constexpr size_t value = 645; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Flow::SearchByModule> { static constexpr size_t value = 646; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Flow::SearchByFileModule> { static constexpr size_t value = 647; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Flow::Range> { static constexpr size_t value = 648; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Flow::NameLowerCase> { static constexpr size_t value = 649; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Flow::Name> { static constexpr size_t value = 650; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Flow::ModuleTypeExport> { static constexpr size_t value = 651; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Flow::ModuleNameLowerCase> { static constexpr size_t value = 652; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Flow::ModuleLocationByFile> { static constexpr size_t value = 653; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Flow::ModuleLocation> { static constexpr size_t value = 654; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Flow::ModuleExport> { static constexpr size_t value = 655; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Flow::ModuleDoc> { static constexpr size_t value = 656; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Flow::ModuleContains> { static constexpr size_t value = 657; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Flow::ModuleComments> { static constexpr size_t value = 658; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Flow::Module> { static constexpr size_t value = 659; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Flow::MemberDeclarationReference> { static constexpr size_t value = 660; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Flow::MemberDeclarationInfo> { static constexpr size_t value = 661; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Flow::MemberDeclaration> { static constexpr size_t value = 662; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Flow::LocalDeclarationReference> { static constexpr size_t value = 663; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Flow::ImportDeclaration> { static constexpr size_t value = 664; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Flow::FlowXRefDeclInfo> { static constexpr size_t value = 665; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Flow::FlowTypeImportXRef> { static constexpr size_t value = 666; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Flow::FlowTypeExportLocation> { static constexpr size_t value = 667; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Flow::FlowTypeEntityImportUses> { static constexpr size_t value = 668; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Flow::FlowSameModule> { static constexpr size_t value = 669; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Flow::FlowModuleNamespaceXRef> { static constexpr size_t value = 670; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Flow::FlowImportXRef> { static constexpr size_t value = 671; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Flow::FlowExportLocation> { static constexpr size_t value = 672; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Flow::FlowEntityUsesAll> { static constexpr size_t value = 673; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Flow::FlowEntityImportUses> { static constexpr size_t value = 674; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Flow::FlowCompatibleExport> { static constexpr size_t value = 675; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Flow::FileXRef> { static constexpr size_t value = 676; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Flow::FileOfStringModule> { static constexpr size_t value = 677; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Flow::FileDeclaration> { static constexpr size_t value = 678; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Flow::Export> { static constexpr size_t value = 679; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Flow::Documentation> { static constexpr size_t value = 680; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Flow::DeclarationUses> { static constexpr size_t value = 681; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Flow::DeclarationSignature> { static constexpr size_t value = 682; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Flow::DeclarationNameSpan> { static constexpr size_t value = 683; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Flow::DeclarationLocation> { static constexpr size_t value = 684; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Flow::DeclarationInfo> { static constexpr size_t value = 685; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Flow::Declaration> { static constexpr size_t value = 686; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Fbthrift::UnionVal> { static constexpr size_t value = 687; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Fbthrift::StructuredAnnotation> { static constexpr size_t value = 688; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Fbthrift::StructVal> { static constexpr size_t value = 689; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Fbthrift::ServiceParent> { static constexpr size_t value = 690; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Fbthrift::ServiceName> { static constexpr size_t value = 691; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Fbthrift::ServiceInteractionFunctions> { static constexpr size_t value = 692; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Fbthrift::ServiceDefinition> { static constexpr size_t value = 693; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Fbthrift::ServiceChild> { static constexpr size_t value = 694; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Fbthrift::SearchByName> { static constexpr size_t value = 695; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Fbthrift::QualName> { static constexpr size_t value = 696; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Fbthrift::PackageName> { static constexpr size_t value = 697; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Fbthrift::Package> { static constexpr size_t value = 698; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Fbthrift::NamespaceValue> { static constexpr size_t value = 699; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Fbthrift::NamespaceName> { static constexpr size_t value = 700; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Fbthrift::Namespace> { static constexpr size_t value = 701; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Fbthrift::NamedDecl> { static constexpr size_t value = 702; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Fbthrift::NameLowerCase> { static constexpr size_t value = 703; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Fbthrift::InteractionName> { static constexpr size_t value = 704; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Fbthrift::InteractionDefinition> { static constexpr size_t value = 705; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Fbthrift::Identifier> { static constexpr size_t value = 706; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Fbthrift::FunctionName> { static constexpr size_t value = 707; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Fbthrift::Literal> { static constexpr size_t value = 708; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Fbthrift::FileXRefs> { static constexpr size_t value = 709; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Fbthrift::File> { static constexpr size_t value = 710; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Fbthrift::StructType> { static constexpr size_t value = 711; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Fbthrift::UnionType> { static constexpr size_t value = 712; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Fbthrift::ExceptionVal> { static constexpr size_t value = 713; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Fbthrift::ExceptionType> { static constexpr size_t value = 714; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Fbthrift::TypeDefException> { static constexpr size_t value = 715; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Fbthrift::ExceptionName> { static constexpr size_t value = 716; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Fbthrift::EnumerationType> { static constexpr size_t value = 717; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Fbthrift::EnumValueDef> { static constexpr size_t value = 718; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Fbthrift::EnumValue> { static constexpr size_t value = 719; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Fbthrift::EnumVal> { static constexpr size_t value = 720; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Fbthrift::DeclarationComment> { static constexpr size_t value = 721; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Fbthrift::DeclarationFile> { static constexpr size_t value = 722; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Fbthrift::DeclarationName> { static constexpr size_t value = 723; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Fbthrift::DeclarationNameSpan> { static constexpr size_t value = 724; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Fbthrift::DeclarationUses> { static constexpr size_t value = 725; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Fbthrift::FileDeclaration> { static constexpr size_t value = 726; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Fbthrift::FunctionDeclarationName> { static constexpr size_t value = 727; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Hack::HackToThrift> { static constexpr size_t value = 728; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Hack::ThriftToHack> { static constexpr size_t value = 729; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Fbthrift::TypeSpecification> { static constexpr size_t value = 730; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Fbthrift::Constant> { static constexpr size_t value = 731; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Erlang::NameLowerCase> { static constexpr size_t value = 732; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Erlang::FunctionDeclaration> { static constexpr size_t value = 733; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Erlang::XRefsViaFqnByFile> { static constexpr size_t value = 734; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Erlang::DeclarationComment> { static constexpr size_t value = 735; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Erlang::DeclarationLocation> { static constexpr size_t value = 736; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Erlang::DeclarationReference> { static constexpr size_t value = 737; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Erlang::DeclarationToFqn> { static constexpr size_t value = 738; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Erlang::DeclarationUses> { static constexpr size_t value = 739; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Erlang::DeclarationWithFqn> { static constexpr size_t value = 740; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Erlang::DeclarationsByFile> { static constexpr size_t value = 741; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Erlang::SearchByName> { static constexpr size_t value = 742; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Dyn::ObserverIdentifier> { static constexpr size_t value = 743; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Dyn::Environment> { static constexpr size_t value = 744; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Dyn::EntityDynamicReference> { static constexpr size_t value = 745; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Digest::FileDigest> { static constexpr size_t value = 746; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Glass::FileInfo> { static constexpr size_t value = 747; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Deadcode::GraphNodeByEntity> { static constexpr size_t value = 748; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Deadcode::GraphNode> { static constexpr size_t value = 749; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Deadcode::GraphInverseEdge> { static constexpr size_t value = 750; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Deadcode::GraphEntityByFile> { static constexpr size_t value = 751; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Deadcode::GraphEdge> { static constexpr size_t value = 752; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Cxx1::UsingDirective> { static constexpr size_t value = 753; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Cxx1::UsingDeclaration> { static constexpr size_t value = 754; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Cxx1::TypeAliasDeclaration> { static constexpr size_t value = 755; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Cxx1::Type> { static constexpr size_t value = 756; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Cxx1::TranslationUnitXRefs> { static constexpr size_t value = 757; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Cxx1::TranslationUnitTrace> { static constexpr size_t value = 758; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Cxx1::TranslationUnitIncludeTree> { static constexpr size_t value = 759; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Cxx1::Trace> { static constexpr size_t value = 760; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Cxx1::RecordDerived> { static constexpr size_t value = 761; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Cxx1::Signature> { static constexpr size_t value = 762; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Cxx1::PPDefineLocation> { static constexpr size_t value = 763; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Cxx1::ObjcSelector> { static constexpr size_t value = 764; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Cxx1::ObjcPropertyImplementation> { static constexpr size_t value = 765; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Cxx1::ObjcPropertyIVar> { static constexpr size_t value = 766; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Cxx1::ObjcMethodDefinition> { static constexpr size_t value = 767; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Cxx1::ObjcMethodDeclarationName> { static constexpr size_t value = 768; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Cxx1::ObjcInterfaceToImplementation> { static constexpr size_t value = 769; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Cxx1::ObjcImplements> { static constexpr size_t value = 770; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Cxx1::ObjcContainerInheritance> { static constexpr size_t value = 771; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Cxx1::ObjcContainerDefinition> { static constexpr size_t value = 772; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Cxx1::ObjcContainerBase> { static constexpr size_t value = 773; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Cxx1::ObjcContainerDeclaration> { static constexpr size_t value = 774; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Cxx1::ObjcMethodDeclaration> { static constexpr size_t value = 775; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Cxx1::ObjcPropertyDeclaration> { static constexpr size_t value = 776; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Cxx1::ObjContainerIdName> { static constexpr size_t value = 777; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Cxx1::NamespaceQName> { static constexpr size_t value = 778; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Cxx1::NamespaceDefinition> { static constexpr size_t value = 779; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Cxx1::NamespaceDeclarationName> { static constexpr size_t value = 780; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Cxx1::NamespaceDeclaration> { static constexpr size_t value = 781; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Cxx1::NamespaceAliasDeclaration> { static constexpr size_t value = 782; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Cxx1::Name> { static constexpr size_t value = 783; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Cxx1::MethodOverrides> { static constexpr size_t value = 784; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Cxx1::MethodOverridden> { static constexpr size_t value = 785; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Cxx1::IncludeTree> { static constexpr size_t value = 786; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Cxx1::PPTrace> { static constexpr size_t value = 787; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Cxx1::FunctionDefinition> { static constexpr size_t value = 788; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Cxx1::FunctionDeclarationNameString> { static constexpr size_t value = 789; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Cxx1::FunctionDeclarationName> { static constexpr size_t value = 790; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Cxx1::FunctionDeclaration> { static constexpr size_t value = 791; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Cxx1::FunctionDeclAttribute> { static constexpr size_t value = 792; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Cxx1::FunctionAttribute> { static constexpr size_t value = 793; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Cxx1::FileXRefs> { static constexpr size_t value = 794; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Cxx1::FilePPUseXRefs> { static constexpr size_t value = 795; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Cxx1::FilePPUseTraceXRefs> { static constexpr size_t value = 796; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Cxx1::FilePPTraceXRefs> { static constexpr size_t value = 797; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Cxx1::VariableDeclaration> { static constexpr size_t value = 798; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Cxx1::EnumeratorInEnum> { static constexpr size_t value = 799; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Cxx1::Enumerator> { static constexpr size_t value = 800; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Cxx1::EnumDefinition> { static constexpr size_t value = 801; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Cxx1::EnumDeclaration> { static constexpr size_t value = 802; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Cxx1::DefnInRecord> { static constexpr size_t value = 803; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Cxx1::DeclarationComment> { static constexpr size_t value = 804; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Cxx1::DeclarationInTrace> { static constexpr size_t value = 805; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Cxx1::DeclarationLocationName> { static constexpr size_t value = 806; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Cxx1::DeclarationLocationNameSpan> { static constexpr size_t value = 807; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Cxx1::DeclarationNameSpan> { static constexpr size_t value = 808; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Cxx1::DeclarationSources> { static constexpr size_t value = 809; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Cxx1::DeclarationSrcRange> { static constexpr size_t value = 810; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Cxx1::DeclarationTargets> { static constexpr size_t value = 811; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Cxx1::DeclarationToUSR> { static constexpr size_t value = 812; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Cxx1::Declarations> { static constexpr size_t value = 813; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Cxx1::DefToBaseDecl> { static constexpr size_t value = 814; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Cxx1::Same> { static constexpr size_t value = 815; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Cxx1::USRToDeclaration> { static constexpr size_t value = 816; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Cxx1::FileXRefMap> { static constexpr size_t value = 817; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Cxx1::SpellingXRef> { static constexpr size_t value = 818; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Cxx1::TargetUses> { static constexpr size_t value = 819; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Cxx1::XRefIndirectTarget> { static constexpr size_t value = 820; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Cxx1::XRefTargets> { static constexpr size_t value = 821; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Search::Cxx::GlobalDeclarationWithName> { static constexpr size_t value = 822; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Symbolid::Cxx::LookupNamespaceDeclaration> { static constexpr size_t value = 823; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Thrift::FromCpp2> { static constexpr size_t value = 824; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Cxx1::DeclToFamily> { static constexpr size_t value = 825; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Cxx1::DeclInRecord> { static constexpr size_t value = 826; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Cxx1::DeclInObjcContainer> { static constexpr size_t value = 827; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Cxx1::DeclFamilyOf> { static constexpr size_t value = 828; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Cxx1::DeclFamily> { static constexpr size_t value = 829; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Cxx1::DeclByName> { static constexpr size_t value = 830; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Cxx1::CxxToThrift> { static constexpr size_t value = 831; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Cxx1::Attribute> { static constexpr size_t value = 832; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Cxx1::RecordDefinition> { static constexpr size_t value = 833; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Csharp::UnityPackageToProject> { static constexpr size_t value = 834; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Csharp::UnityPackage> { static constexpr size_t value = 835; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Csharp::UnityProjectSource> { static constexpr size_t value = 836; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Csharp::TypeParameter> { static constexpr size_t value = 837; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Csharp::SourceFileToProject> { static constexpr size_t value = 838; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Csharp::SolutionToProject> { static constexpr size_t value = 839; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Csharp::Solution> { static constexpr size_t value = 840; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Csharp::ProjectToSourceFile> { static constexpr size_t value = 841; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Csharp::ProjectToSolution> { static constexpr size_t value = 842; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Csharp::Project> { static constexpr size_t value = 843; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Csharp::Namespace> { static constexpr size_t value = 844; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Csharp::NameLowerCase> { static constexpr size_t value = 845; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Csharp::Name> { static constexpr size_t value = 846; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Csharp::MSBuildProjectSource> { static constexpr size_t value = 847; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Csharp::MemberAccessLocation> { static constexpr size_t value = 848; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Csharp::MethodInvocationLocation> { static constexpr size_t value = 849; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Csharp::Implements> { static constexpr size_t value = 850; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Csharp::FunctionPointerType> { static constexpr size_t value = 851; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Csharp::FullName> { static constexpr size_t value = 852; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Csharp::Class> { static constexpr size_t value = 853; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Csharp::Interface> { static constexpr size_t value = 854; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Csharp::Record> { static constexpr size_t value = 855; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Csharp::Struct> { static constexpr size_t value = 856; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Csharp::ArrayType> { static constexpr size_t value = 857; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Csharp::DefinitionLocation> { static constexpr size_t value = 858; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Csharp::DefinitionLocationName> { static constexpr size_t value = 859; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Csharp::FileDefinitions> { static constexpr size_t value = 860; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Csharp::FileEntityXRefs> { static constexpr size_t value = 861; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Csharp::SearchByName> { static constexpr size_t value = 862; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Csharp::Field> { static constexpr size_t value = 863; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Csharp::Local> { static constexpr size_t value = 864; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Csharp::Method> { static constexpr size_t value = 865; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Csharp::ObjectCreationLocation> { static constexpr size_t value = 866; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Csharp::Parameter> { static constexpr size_t value = 867; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Csharp::PointerType> { static constexpr size_t value = 868; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Csharp::Property> { static constexpr size_t value = 869; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Csharp::TypeLocation> { static constexpr size_t value = 870; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Contbuild::Owner> { static constexpr size_t value = 871; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Contbuild::IndexerName> { static constexpr size_t value = 872; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Contbuild::FileToContbuild> { static constexpr size_t value = 873; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Contbuild::IndexFailure> { static constexpr size_t value = 874; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Contbuild::ContbuildName> { static constexpr size_t value = 875; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Contbuild::ContbuildLocator> { static constexpr size_t value = 876; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Contbuild::ContbuildFbpkg> { static constexpr size_t value = 877; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Configerator::ImportFilesStatement> { static constexpr size_t value = 878; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codexref::SymbolName> { static constexpr size_t value = 879; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemetrics::CxxRecordReferenceTo> { static constexpr size_t value = 880; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemetrics::CxxRecordReference> { static constexpr size_t value = 881; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codexref::IncomingXRefs> { static constexpr size_t value = 882; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codexref::OutgoingXRefs> { static constexpr size_t value = 883; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Types::RangeSpanContains> { static constexpr size_t value = 884; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Scip::LsifKindToKind> { static constexpr size_t value = 885; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Python::NonImportPythonDeclarationKind> { static constexpr size_t value = 886; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Python::NonImportPythonDeclarationInfo> { static constexpr size_t value = 887; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Python::ConvertLabel> { static constexpr size_t value = 888; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Pp::PpIncludeXRefLocations> { static constexpr size_t value = 889; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Lsif::LsifKindToKind> { static constexpr size_t value = 890; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Hack::HackEnumInheritedMembers> { static constexpr size_t value = 891; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Hack::FromHackVisibility> { static constexpr size_t value = 892; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Flow::FlowDocumentationSpan> { static constexpr size_t value = 893; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Flow::FlowDeclarationDocumentation> { static constexpr size_t value = 894; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Cxx::FromCxxVisibility> { static constexpr size_t value = 895; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Cxx::CxxFileEntityXMapVariableXRefDeclLocations> { static constexpr size_t value = 896; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Cxx::CxxDeclarationModifiers> { static constexpr size_t value = 897; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Cxx::CxxDeclVisibility> { static constexpr size_t value = 898; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Cxx::CxxDeclKind> { static constexpr size_t value = 899; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Cxx::CxxDeclInfo> { static constexpr size_t value = 900; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Cxx::CxxDataAvailable> { static constexpr size_t value = 901; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::IndexedFile> { static constexpr size_t value = 902; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::EntityDataAvailable> { static constexpr size_t value = 903; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Scip::EntityInfo> { static constexpr size_t value = 904; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Scip::ScipEntityLocation> { static constexpr size_t value = 905; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Scip::ScipEntityUses> { static constexpr size_t value = 906; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Scip::ScipFileEntityXRefLocations> { static constexpr size_t value = 907; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Scip::ScipResolveLocation> { static constexpr size_t value = 908; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Code::Quality::Repository> { static constexpr size_t value = 909; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Code::Quality::Producer> { static constexpr size_t value = 910; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Code::Quality::Integration> { static constexpr size_t value = 911; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Code::Quality::FlagType> { static constexpr size_t value = 912; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Code::Quality::FlagName> { static constexpr size_t value = 913; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Code::Quality::FlagInfo> { static constexpr size_t value = 914; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Code::Quality::Detail> { static constexpr size_t value = 915; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Code::Quality::Category> { static constexpr size_t value = 916; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Python::PythonContainsChildEntity> { static constexpr size_t value = 917; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Python::PythonContainsParentEntity> { static constexpr size_t value = 918; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Python::PythonEntityComments> { static constexpr size_t value = 919; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Python::PythonEntityInfo> { static constexpr size_t value = 920; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Python::PythonEntityKind> { static constexpr size_t value = 921; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Python::PythonEntityLocation> { static constexpr size_t value = 922; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Python::PythonEntityModuleName> { static constexpr size_t value = 923; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Python::PythonEntityUses> { static constexpr size_t value = 924; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Python::PythonExtendsChildEntity> { static constexpr size_t value = 925; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Python::PythonExtendsParentEntity> { static constexpr size_t value = 926; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Python::PythonFileEntityXRefLocations> { static constexpr size_t value = 927; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Python::PythonModifiers> { static constexpr size_t value = 928; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Python::PythonResolveLocation> { static constexpr size_t value = 929; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Python::PythonVisibility> { static constexpr size_t value = 930; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Python::PythonAnnotation> { static constexpr size_t value = 931; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Pp::PPEntityLocation> { static constexpr size_t value = 932; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Pp::PpEntityInfo> { static constexpr size_t value = 933; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Pp::PpEntityKind> { static constexpr size_t value = 934; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Pp::PpEntityTraceXRefLocations> { static constexpr size_t value = 935; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Pp::PpEntityUses> { static constexpr size_t value = 936; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Pp::PpFileEntityXRefLocations> { static constexpr size_t value = 937; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Pp::PpResolveLocation> { static constexpr size_t value = 938; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Pp::PpResolveTraceLocation> { static constexpr size_t value = 939; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Lsif::EntityInfo> { static constexpr size_t value = 940; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Lsif::LsifEntityLocation> { static constexpr size_t value = 941; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Lsif::LsifEntityModuleName> { static constexpr size_t value = 942; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Lsif::LsifEntityUses> { static constexpr size_t value = 943; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Lsif::LsifFileEntityXRefLocations> { static constexpr size_t value = 944; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Lsif::LsifResolveLocation> { static constexpr size_t value = 945; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Kotlin::KotlinContainsChildEntity> { static constexpr size_t value = 946; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Kotlin::KotlinContainsParentEntity> { static constexpr size_t value = 947; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Kotlin::KotlinEntityKind> { static constexpr size_t value = 948; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Kotlin::KotlinEntityLocation> { static constexpr size_t value = 949; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Kotlin::KotlinEntityUses> { static constexpr size_t value = 950; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Kotlin::KotlinExtendsParentEntity> { static constexpr size_t value = 951; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Kotlin::KotlinFileEntityXRefLocations> { static constexpr size_t value = 952; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Kotlin::KotlinResolveLocation> { static constexpr size_t value = 953; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Java::JavaContainsChildEntity> { static constexpr size_t value = 954; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Java::JavaContainsParentEntity> { static constexpr size_t value = 955; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Java::JavaEntityDocumentation> { static constexpr size_t value = 956; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Java::JavaEntityKind> { static constexpr size_t value = 957; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Java::JavaEntityLocation> { static constexpr size_t value = 958; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Java::JavaEntityUses> { static constexpr size_t value = 959; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Java::JavaExtendsChildEntity> { static constexpr size_t value = 960; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Java::JavaExtendsParentEntity> { static constexpr size_t value = 961; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Java::JavaModifiers> { static constexpr size_t value = 962; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Java::JavaResolveLocation> { static constexpr size_t value = 963; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Java::JavaVisibility> { static constexpr size_t value = 964; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Java::JavalFileEntityXRefLocations> { static constexpr size_t value = 965; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Java::JavaAnnotation> { static constexpr size_t value = 966; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Haskell::HaskellEntityLocation> { static constexpr size_t value = 967; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Haskell::HaskellEntityUses> { static constexpr size_t value = 968; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Haskell::HaskellFileEntityXRefLocations> { static constexpr size_t value = 969; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Haskell::HaskellResolveLocation> { static constexpr size_t value = 970; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Search::Hs::SearchByName> { static constexpr size_t value = 971; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Hack::EntityHasHideFromDocsAttr> { static constexpr size_t value = 972; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Hack::HackContainsChildEntity> { static constexpr size_t value = 973; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Hack::HackContainsParentEntity> { static constexpr size_t value = 974; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Hack::HackEntityDocumentation> { static constexpr size_t value = 975; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Hack::HackEntityInfo> { static constexpr size_t value = 976; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Hack::HackEntityKind> { static constexpr size_t value = 977; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Hack::HackEntityLocation> { static constexpr size_t value = 978; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Hack::HackEntityModuleName> { static constexpr size_t value = 979; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Hack::HackEntitySource> { static constexpr size_t value = 980; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Hack::HackEntityUses> { static constexpr size_t value = 981; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Hack::HackExtendsChildEntity> { static constexpr size_t value = 982; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Hack::HackExtendsParentEntity> { static constexpr size_t value = 983; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Hack::HackExtendsParentEntityConcise> { static constexpr size_t value = 984; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Hack::HackFileEntityXRefLocations> { static constexpr size_t value = 985; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Hack::HackFileEntityXRefSpans> { static constexpr size_t value = 986; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Hack::HackModifiers> { static constexpr size_t value = 987; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Hack::HackRequiredConstraint> { static constexpr size_t value = 988; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Hack::HackResolveLocation> { static constexpr size_t value = 989; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Hack::HackVisibility> { static constexpr size_t value = 990; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemetrics::HackReferencesFrom> { static constexpr size_t value = 991; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemetrics::HackReferencesTo> { static constexpr size_t value = 992; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Hack::HackAnnotation> { static constexpr size_t value = 993; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Graphql::GraphQLEntityKind> { static constexpr size_t value = 994; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Graphql::GraphQLEntityLocation> { static constexpr size_t value = 995; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Graphql::GraphQLEntityUses> { static constexpr size_t value = 996; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Graphql::GraphQLFileEntityXRefLocations> { static constexpr size_t value = 997; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Graphql::GraphQLResolveLocation> { static constexpr size_t value = 998; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Flow::FlowContainsChildEntity> { static constexpr size_t value = 999; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Flow::FlowContainsParentEntity> { static constexpr size_t value = 1000; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Flow::FlowEntityDocumentation> { static constexpr size_t value = 1001; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Flow::FlowEntityKind> { static constexpr size_t value = 1002; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Flow::FlowEntityLocation> { static constexpr size_t value = 1003; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Flow::FlowEntityModuleName> { static constexpr size_t value = 1004; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Flow::FlowEntityUses> { static constexpr size_t value = 1005; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Flow::FlowFileEntityXRefLocations> { static constexpr size_t value = 1006; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Flow::FlowFileImportDeclEntityXRefLocations> { static constexpr size_t value = 1007; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Flow::FlowFileReferenceEntityXRefLocations> { static constexpr size_t value = 1008; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Flow::FlowResolveLocation> { static constexpr size_t value = 1009; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Fbthrift::FbthriftEntityDocumentation> { static constexpr size_t value = 1010; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Fbthrift::ThriftContainsChildEntity> { static constexpr size_t value = 1011; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Fbthrift::ThriftContainsParentEntity> { static constexpr size_t value = 1012; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Fbthrift::ThriftEntityKind> { static constexpr size_t value = 1013; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Fbthrift::ThriftEntityLocation> { static constexpr size_t value = 1014; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Fbthrift::ThriftExtendsChildEntity> { static constexpr size_t value = 1015; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Fbthrift::ThriftExtendsParentEntity> { static constexpr size_t value = 1016; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Fbthrift::ThriftFileEntityXRefLocations> { static constexpr size_t value = 1017; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Fbthrift::ThriftResolveLocation> { static constexpr size_t value = 1018; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Erlang::ErlangEntityDocumentation> { static constexpr size_t value = 1019; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Erlang::ErlangEntityInfo> { static constexpr size_t value = 1020; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Erlang::ErlangEntityKind> { static constexpr size_t value = 1021; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Erlang::ErlangEntityLocation> { static constexpr size_t value = 1022; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Erlang::ErlangEntityUses> { static constexpr size_t value = 1023; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Erlang::ErlangFileEntityXRefLocations> { static constexpr size_t value = 1024; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Erlang::ErlangResolveLocation> { static constexpr size_t value = 1025; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Search::Erlang::SearchByFQN> { static constexpr size_t value = 1026; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Search::Erlang::SearchByName> { static constexpr size_t value = 1027; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Cxx::CxxContainsChildEntity> { static constexpr size_t value = 1028; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Cxx::CxxContainsParentEntity> { static constexpr size_t value = 1029; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Cxx::CxxDeclToDefXRefTargetLocation> { static constexpr size_t value = 1030; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Cxx::CxxDeclarationContainsChild> { static constexpr size_t value = 1031; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Cxx::CxxDeclarationContainsParent> { static constexpr size_t value = 1032; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Cxx::CxxDeclarationExtendsChild> { static constexpr size_t value = 1033; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Cxx::CxxDeclarationExtendsParent> { static constexpr size_t value = 1034; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Cxx::CxxDeclarationSource> { static constexpr size_t value = 1035; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Cxx::CxxDefToDeclFamilyXRefTargetLocation> { static constexpr size_t value = 1036; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Cxx::CxxEntityDocumentation> { static constexpr size_t value = 1037; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Cxx::CxxEntityInfo> { static constexpr size_t value = 1038; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Cxx::CxxEntityKind> { static constexpr size_t value = 1039; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Cxx::CxxEntityLocation> { static constexpr size_t value = 1040; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Cxx::CxxEntitySource> { static constexpr size_t value = 1041; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Cxx::CxxEntityUSR> { static constexpr size_t value = 1042; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Cxx::CxxEntityUses> { static constexpr size_t value = 1043; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Cxx::CxxExtendsChildEntity> { static constexpr size_t value = 1044; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Cxx::CxxExtendsParentEntity> { static constexpr size_t value = 1045; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Cxx::CxxFileEntitySpellingXRefLocations> { static constexpr size_t value = 1046; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Cxx::CxxFileEntityTraceDeclToDefXRefLocations> { static constexpr size_t value = 1047; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Cxx::CxxFileEntityXMapFixedXRefLocations> { static constexpr size_t value = 1048; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Cxx::CxxFileEntityXMapVariableXRefDeclToDefs> { static constexpr size_t value = 1049; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Cxx::CxxFileEntityXRefLocations> { static constexpr size_t value = 1050; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Cxx::CxxFindDefinitionOfEntity> { static constexpr size_t value = 1051; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Cxx::CxxModifiers> { static constexpr size_t value = 1052; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Cxx::CxxNamespaceDeclarationContainsChild> { static constexpr size_t value = 1053; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Cxx::CxxResolveDeclarationToEntity> { static constexpr size_t value = 1054; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Cxx::CxxResolveLocation> { static constexpr size_t value = 1055; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Cxx::CxxResolveTraceLocation> { static constexpr size_t value = 1056; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Cxx::CxxVisibility> { static constexpr size_t value = 1057; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Cxx::CxxXRefTargetLocation> { static constexpr size_t value = 1058; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Cxx::EntityToXRefTarget> { static constexpr size_t value = 1059; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Cxx::XRefTargetToEntity> { static constexpr size_t value = 1060; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemetrics::CxxReferencesFrom> { static constexpr size_t value = 1061; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemetrics::CxxReferencesTo> { static constexpr size_t value = 1062; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Search::Cxx::EntityUses> { static constexpr size_t value = 1063; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Search::Cxx::SearchBySelector> { static constexpr size_t value = 1064; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Symbolid::Cxx::DefinitionOfDecl> { static constexpr size_t value = 1065; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Symbolid::Cxx::LookupNamespaceDefinition> { static constexpr size_t value = 1066; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Cxx::CxxDefinitionContainsChild> { static constexpr size_t value = 1067; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Cxx::CxxDefinitionContainsParent> { static constexpr size_t value = 1068; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Cxx::CxxDefinitionExtendsChild> { static constexpr size_t value = 1069; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Cxx::CxxDefinitionExtendsParent> { static constexpr size_t value = 1070; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Cxx::CxxDefinitionModifiers> { static constexpr size_t value = 1071; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Cxx::CxxDefnVisibility> { static constexpr size_t value = 1072; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Cxx::CxxEntityDefinitionBase> { static constexpr size_t value = 1073; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Search::Cxx::DeclIsDefn> { static constexpr size_t value = 1074; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Code::Cxx::DeclToDef> { static constexpr size_t value = 1075; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Cxx::CxxAnnotation> { static constexpr size_t value = 1076; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Csharp::CSharpEntityKind> { static constexpr size_t value = 1077; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Csharp::CSharpEntityLocation> { static constexpr size_t value = 1078; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Csharp::CSharpEntityUses> { static constexpr size_t value = 1079; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Csharp::CSharpFileEntityXRefLocations> { static constexpr size_t value = 1080; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Csharp::CSharpResolveLocation> { static constexpr size_t value = 1081; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Code::Compose::CxxContainerChildSignatures> { static constexpr size_t value = 1082; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Buck::BuckEntityKind> { static constexpr size_t value = 1083; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Buck::BuckEntityLocation> { static constexpr size_t value = 1084; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Buck::BuckEntityUses> { static constexpr size_t value = 1085; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Buck::BuckFileEntityXRefLocations> { static constexpr size_t value = 1086; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Buck::BuckResolveLocation> { static constexpr size_t value = 1087; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Search::Buck::SearchByFQN> { static constexpr size_t value = 1088; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Search::Buck::SearchDefinition> { static constexpr size_t value = 1089; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Search::Buck::SearchFile> { static constexpr size_t value = 1090; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Code::EntityLanguageSCIP> { static constexpr size_t value = 1091; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Code::EntityLanguageLSIF> { static constexpr size_t value = 1092; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Code::EntityLanguage> { static constexpr size_t value = 1093; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Cxx::CxxEntityIdl> { static constexpr size_t value = 1094; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Hack::HackEntityIdl> { static constexpr size_t value = 1095; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Code::Compose::CxxSearchContainerKind> { static constexpr size_t value = 1096; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::ContainsChildEntity> { static constexpr size_t value = 1097; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::ContainsParentEntity> { static constexpr size_t value = 1098; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::EntityComments> { static constexpr size_t value = 1099; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::EntityIdl> { static constexpr size_t value = 1100; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::EntityInfo> { static constexpr size_t value = 1101; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::EntityIsDefinition> { static constexpr size_t value = 1102; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::EntityKind> { static constexpr size_t value = 1103; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::EntityLocation> { static constexpr size_t value = 1104; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::EntityModifiers> { static constexpr size_t value = 1105; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::EntityModuleName> { static constexpr size_t value = 1106; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::EntityReferences> { static constexpr size_t value = 1107; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::EntitySource> { static constexpr size_t value = 1108; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::EntityUses> { static constexpr size_t value = 1109; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::EntityVisibility> { static constexpr size_t value = 1110; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::ExtendsChildEntity> { static constexpr size_t value = 1111; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::ExtendsParentEntity> { static constexpr size_t value = 1112; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::ExtendsParentEntityConcise> { static constexpr size_t value = 1113; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::FileEntityDigest> { static constexpr size_t value = 1114; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::FileEntityInfos> { static constexpr size_t value = 1115; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::FileEntityKinds> { static constexpr size_t value = 1116; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::FileEntityLocations> { static constexpr size_t value = 1117; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::FileEntityXRefInfos> { static constexpr size_t value = 1118; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::FileEntityXRefKinds> { static constexpr size_t value = 1119; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::FileEntityXRefLocations> { static constexpr size_t value = 1120; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::FileEntityXRefRangeSpans> { static constexpr size_t value = 1121; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::FileEntityXRefSpans> { static constexpr size_t value = 1122; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::FindEntityDefinition> { static constexpr size_t value = 1123; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::SearchRelatedEntities> { static constexpr size_t value = 1124; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::ReferencingEntity> { static constexpr size_t value = 1125; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::ResolveLocation> { static constexpr size_t value = 1126; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Cxx::CxxFileEntityIdl> { static constexpr size_t value = 1127; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Hack::ConvertCallee> { static constexpr size_t value = 1128; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Hack::ConvertCalleeForFileCall> { static constexpr size_t value = 1129; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Hack::ConvertStaticType> { static constexpr size_t value = 1130; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Search::EntityLocationAndKind> { static constexpr size_t value = 1131; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Search::SearchByName> { static constexpr size_t value = 1132; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Search::SearchByScope> { static constexpr size_t value = 1133; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemetrics::ReferencesFrom> { static constexpr size_t value = 1134; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemetrics::ReferencesTo> { static constexpr size_t value = 1135; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Deadcode::GraphEntity> { static constexpr size_t value = 1136; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Deletthis::FileReverseDeps> { static constexpr size_t value = 1137; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Dyn::EntityUsage> { static constexpr size_t value = 1138; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Monk::BestPiiFunc> { static constexpr size_t value = 1139; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Monk::PiiCallerFunc> { static constexpr size_t value = 1140; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Monk::PiiFunc> { static constexpr size_t value = 1141; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Search::Code::BuckSearchByLocalNameFact> { static constexpr size_t value = 1142; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Search::Code::BuckSearchByLowerCaseName> { static constexpr size_t value = 1143; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Search::Code::BuckSearchByName> { static constexpr size_t value = 1144; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Search::Code::CSharpSearchByLowerCaseName> { static constexpr size_t value = 1145; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Search::Code::CSharpSearchByName> { static constexpr size_t value = 1146; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Search::Code::CxxSearchByLowerCaseName> { static constexpr size_t value = 1147; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Search::Code::CxxSearchByLowerCaseScope> { static constexpr size_t value = 1148; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Search::Code::CxxSearchByName> { static constexpr size_t value = 1149; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Search::Code::CxxSearchByScope> { static constexpr size_t value = 1150; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Search::Code::ErlangSearchByLowerCaseName> { static constexpr size_t value = 1151; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Search::Code::ErlangSearchByName> { static constexpr size_t value = 1152; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Search::Code::FbthriftSearchByNameFact> { static constexpr size_t value = 1153; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Search::Code::FlowSearchByLowerCaseName> { static constexpr size_t value = 1154; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Search::Code::FlowSearchByLowerCaseScope> { static constexpr size_t value = 1155; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Search::Code::FlowSearchByName> { static constexpr size_t value = 1156; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Search::Code::FlowSearchByNameWithFact> { static constexpr size_t value = 1157; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Search::Code::FlowSearchByScope> { static constexpr size_t value = 1158; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Search::Code::FlowSearchByScopeWithName> { static constexpr size_t value = 1159; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Search::Code::GraphQLSearchByLowerCaseName> { static constexpr size_t value = 1160; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Search::Code::GraphQLSearchByName> { static constexpr size_t value = 1161; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Search::Code::HackSearchByLowerCaseName> { static constexpr size_t value = 1162; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Search::Code::HackSearchByLowerCaseScope> { static constexpr size_t value = 1163; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Search::Code::HackSearchByName> { static constexpr size_t value = 1164; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Search::Code::HackSearchByNameWithName> { static constexpr size_t value = 1165; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Search::Code::HackSearchByScope> { static constexpr size_t value = 1166; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Search::Code::HackSearchByScopeWithName> { static constexpr size_t value = 1167; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Search::Code::HsSearchByLowerCaseName> { static constexpr size_t value = 1168; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Search::Code::HsSearchByName> { static constexpr size_t value = 1169; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Search::Code::JavaSearchByLowerCaseName> { static constexpr size_t value = 1170; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Search::Code::JavaSearchByLowerCaseScope> { static constexpr size_t value = 1171; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Search::Code::JavaSearchByName> { static constexpr size_t value = 1172; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Search::Code::JavaSearchByNameWithFact> { static constexpr size_t value = 1173; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Search::Code::JavaSearchByScope> { static constexpr size_t value = 1174; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Search::Code::JavaSearchByScopeWithName> { static constexpr size_t value = 1175; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Search::Code::KotlinSearchByLowerCaseName> { static constexpr size_t value = 1176; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Search::Code::KotlinSearchByLowerCaseScope> { static constexpr size_t value = 1177; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Search::Code::KotlinSearchByName> { static constexpr size_t value = 1178; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Search::Code::KotlinSearchByNameWithFact> { static constexpr size_t value = 1179; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Search::Code::KotlinSearchByScope> { static constexpr size_t value = 1180; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Search::Code::KotlinSearchByScopeWithName> { static constexpr size_t value = 1181; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Search::Code::LsifSearchByLowerCaseName> { static constexpr size_t value = 1182; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Search::Code::LsifSearchByName> { static constexpr size_t value = 1183; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Search::Code::PpSearchByLowerCaseName> { static constexpr size_t value = 1184; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Search::Code::PpSearchByMacroFact> { static constexpr size_t value = 1185; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Search::Code::PpSearchByName> { static constexpr size_t value = 1186; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Search::Code::PythonSearchByLocalNameFact> { static constexpr size_t value = 1187; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Search::Code::PythonSearchByLowerCaseName> { static constexpr size_t value = 1188; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Search::Code::PythonSearchByLowerCaseScope> { static constexpr size_t value = 1189; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Search::Code::PythonSearchByName> { static constexpr size_t value = 1190; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Search::Code::PythonSearchByScope> { static constexpr size_t value = 1191; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Search::Code::PythonSearchByScopeWithName> { static constexpr size_t value = 1192; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Search::Code::SearchByLowerCaseNameAndLanguage> { static constexpr size_t value = 1193; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Search::Code::SearchByLowerCaseScope> { static constexpr size_t value = 1194; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Search::Code::SearchByNameAndLanguage> { static constexpr size_t value = 1195; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Search::Code::SearchByScope> { static constexpr size_t value = 1196; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Search::Code::ThriftSearchByLowerCaseName> { static constexpr size_t value = 1197; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Search::Code::ThriftSearchByName> { static constexpr size_t value = 1198; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::FileCall> { static constexpr size_t value = 1199; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Hack::ConvertCallArguments> { static constexpr size_t value = 1200; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Hack::ConvertMaybeCallArguments> { static constexpr size_t value = 1201; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Hack::HackFileCall> { static constexpr size_t value = 1202; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Python::ConvertCallArguments> { static constexpr size_t value = 1203; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Python::PythonFileCall> { static constexpr size_t value = 1204; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Hack::ConvertArgument> { static constexpr size_t value = 1205; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::Python::ConvertArgument> { static constexpr size_t value = 1206; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Codemarkup::EntityToAnnotations> { static constexpr size_t value = 1207; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Code::Quality::Issue> { static constexpr size_t value = 1208; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Cxx1::FunctionName> { static constexpr size_t value = 1209; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Cxx1::RecordDeclaration> { static constexpr size_t value = 1210; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Cxx1::DeclarationScope> { static constexpr size_t value = 1211; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Cxx1::FunctionQName> { static constexpr size_t value = 1212; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Cxx1::QName> { static constexpr size_t value = 1213; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Search::Code::CxxSearchByNameAndScopeFact> { static constexpr size_t value = 1214; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Search::Cxx::QueryToScopeCase> { static constexpr size_t value = 1215; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Search::Cxx::SearchByNameAndScope> { static constexpr size_t value = 1216; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Search::Cxx::SearchByScope> { static constexpr size_t value = 1217; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Symbolid::Cxx::LookupDeclaration> { static constexpr size_t value = 1218; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Symbolid::Cxx::LookupDefinition> { static constexpr size_t value = 1219; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Symbolid::Cxx::LookupEnumerator> { static constexpr size_t value = 1220; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Symbolid::Cxx::LookupFunctionDeclaration> { static constexpr size_t value = 1221; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Symbolid::Cxx::LookupFunctionDefinition> { static constexpr size_t value = 1222; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Symbolid::Cxx::LookupFunctionSignatureDeclaration> { static constexpr size_t value = 1223; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Symbolid::Cxx::LookupFunctionSignatureDefinition> { static constexpr size_t value = 1224; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Symbolid::Cxx::LookupFunctionSignatureQualifierDeclaration> { static constexpr size_t value = 1225; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Symbolid::Cxx::LookupFunctionSignatureQualifierDefinition> { static constexpr size_t value = 1226; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Fbthrift::FunctionSpecification> { static constexpr size_t value = 1227; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Thrift::FunctionSpecification> { static constexpr size_t value = 1228; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Buckuses::UsesOfTargetHeader> { static constexpr size_t value = 1229; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Buckuses::UsesOfTarget> { static constexpr size_t value = 1230; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Buck::Meta::Oncall> { static constexpr size_t value = 1231; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Buck::Meta::ModeType> { static constexpr size_t value = 1232; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Buck::Meta::TargetModes> { static constexpr size_t value = 1233; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Buck::Meta::LocatorOncall> { static constexpr size_t value = 1234; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Buck::Meta::FileOncall> { static constexpr size_t value = 1235; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Buck::Type> { static constexpr size_t value = 1236; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Buck::TranslationUnit> { static constexpr size_t value = 1237; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Buck::TargetUses> { static constexpr size_t value = 1238; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Buck::TargetSourcesBaseModule> { static constexpr size_t value = 1239; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Buck::TargetSources> { static constexpr size_t value = 1240; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Buck::TargetOuts> { static constexpr size_t value = 1241; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Buck::TargetOut> { static constexpr size_t value = 1242; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Buck::TargetMode> { static constexpr size_t value = 1243; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Buck::TargetLocation> { static constexpr size_t value = 1244; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Buck::TargetLinkWhole> { static constexpr size_t value = 1245; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Buck::TargetIndexerName> { static constexpr size_t value = 1246; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Buck::TargetIndexer> { static constexpr size_t value = 1247; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Buck::TargetHash> { static constexpr size_t value = 1248; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Buck::TargetCall> { static constexpr size_t value = 1249; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Buck::TargetByType> { static constexpr size_t value = 1250; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Buck::TargetAttribute> { static constexpr size_t value = 1251; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Buck::Target> { static constexpr size_t value = 1252; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Buck::SourceFileLocation> { static constexpr size_t value = 1253; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Buck::SearchByLocalName> { static constexpr size_t value = 1254; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Buck::RuleKey> { static constexpr size_t value = 1255; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Buck::Platform> { static constexpr size_t value = 1256; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Buck::Owner> { static constexpr size_t value = 1257; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Buck::OutsTarget> { static constexpr size_t value = 1258; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Buck::OutputLabel> { static constexpr size_t value = 1259; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Buck::OutTarget> { static constexpr size_t value = 1260; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Buck::LocatorWithLabel> { static constexpr size_t value = 1261; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Buck::LocatorReverseDeps> { static constexpr size_t value = 1262; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Buck::LocatorReverseDep> { static constexpr size_t value = 1263; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Buck::Locator> { static constexpr size_t value = 1264; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Buck::LocalNameLowerCase> { static constexpr size_t value = 1265; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Buck::LocalName> { static constexpr size_t value = 1266; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Buck::Labels> { static constexpr size_t value = 1267; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Buck::Label> { static constexpr size_t value = 1268; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Buck::IndexerName> { static constexpr size_t value = 1269; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Buck::FileXRefs> { static constexpr size_t value = 1270; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Buck::FileToTarget> { static constexpr size_t value = 1271; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Buck::FileTarget> { static constexpr size_t value = 1272; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Buck::FileResolved> { static constexpr size_t value = 1273; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Buck::FileEntity> { static constexpr size_t value = 1274; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Buck::FileDefinition> { static constexpr size_t value = 1275; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Buck::File> { static constexpr size_t value = 1276; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Buck::FailureSources> { static constexpr size_t value = 1277; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Buck::IndexFailureX> { static constexpr size_t value = 1278; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Buck::DestinationUses> { static constexpr size_t value = 1279; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Buck::TargetDependencies> { static constexpr size_t value = 1280; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Buck::DefinitionLocation> { static constexpr size_t value = 1281; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Buck::Definition> { static constexpr size_t value = 1282; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Buck::Consumer> { static constexpr size_t value = 1283; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Buck::CallArgument> { static constexpr size_t value = 1284; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Buck::AttributeName> { static constexpr size_t value = 1285; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Buck::AttributeValue> { static constexpr size_t value = 1286; };
template<> struct SCHEMA::index<facebook::glean::cpp::schema::Buck::ArgumentValue> { static constexpr size_t value = 1287; };

template<> struct SCHEMA::predicate<0> { using type = facebook::glean::cpp::schema::Thrift::UnionVal; };
template<> struct SCHEMA::predicate<1> { using type = facebook::glean::cpp::schema::Thrift::TypeDefType; };
template<> struct SCHEMA::predicate<2> { using type = facebook::glean::cpp::schema::Thrift::ToPython; };
template<> struct SCHEMA::predicate<3> { using type = facebook::glean::cpp::schema::Thrift::ToHack; };
template<> struct SCHEMA::predicate<4> { using type = facebook::glean::cpp::schema::Thrift::ToCpp2; };
template<> struct SCHEMA::predicate<5> { using type = facebook::glean::cpp::schema::Thrift::StructuredAnnotation; };
template<> struct SCHEMA::predicate<6> { using type = facebook::glean::cpp::schema::Thrift::StructVal; };
template<> struct SCHEMA::predicate<7> { using type = facebook::glean::cpp::schema::Thrift::ServiceParent; };
template<> struct SCHEMA::predicate<8> { using type = facebook::glean::cpp::schema::Thrift::ServiceDefinition; };
template<> struct SCHEMA::predicate<9> { using type = facebook::glean::cpp::schema::Thrift::ServiceChild; };
template<> struct SCHEMA::predicate<10> { using type = facebook::glean::cpp::schema::Thrift::SearchByName; };
template<> struct SCHEMA::predicate<11> { using type = facebook::glean::cpp::schema::Thrift::QualName; };
template<> struct SCHEMA::predicate<12> { using type = facebook::glean::cpp::schema::Thrift::PythonValue; };
template<> struct SCHEMA::predicate<13> { using type = facebook::glean::cpp::schema::Thrift::PythonName; };
template<> struct SCHEMA::predicate<14> { using type = facebook::glean::cpp::schema::Thrift::PythonModuleFile; };
template<> struct SCHEMA::predicate<15> { using type = facebook::glean::cpp::schema::Thrift::PythonModuleContains; };
template<> struct SCHEMA::predicate<16> { using type = facebook::glean::cpp::schema::Thrift::PythonModule; };
template<> struct SCHEMA::predicate<17> { using type = facebook::glean::cpp::schema::Thrift::PythonMethod; };
template<> struct SCHEMA::predicate<18> { using type = facebook::glean::cpp::schema::Thrift::PythonFunction; };
template<> struct SCHEMA::predicate<19> { using type = facebook::glean::cpp::schema::Thrift::PythonFileModule; };
template<> struct SCHEMA::predicate<20> { using type = facebook::glean::cpp::schema::Thrift::PythonField; };
template<> struct SCHEMA::predicate<21> { using type = facebook::glean::cpp::schema::Thrift::PythonClassContains; };
template<> struct SCHEMA::predicate<22> { using type = facebook::glean::cpp::schema::Thrift::PythonClass; };
template<> struct SCHEMA::predicate<23> { using type = facebook::glean::cpp::schema::Thrift::OutputTarget; };
template<> struct SCHEMA::predicate<24> { using type = facebook::glean::cpp::schema::Thrift::NamespaceValue; };
template<> struct SCHEMA::predicate<25> { using type = facebook::glean::cpp::schema::Thrift::NamespaceName; };
template<> struct SCHEMA::predicate<26> { using type = facebook::glean::cpp::schema::Thrift::Namespace; };
template<> struct SCHEMA::predicate<27> { using type = facebook::glean::cpp::schema::Thrift::NameLowerCase; };
template<> struct SCHEMA::predicate<28> { using type = facebook::glean::cpp::schema::Thrift::MangleLang; };
template<> struct SCHEMA::predicate<29> { using type = facebook::glean::cpp::schema::Thrift::Mangle; };
template<> struct SCHEMA::predicate<30> { using type = facebook::glean::cpp::schema::Thrift::NamedDecl; };
template<> struct SCHEMA::predicate<31> { using type = facebook::glean::cpp::schema::Thrift::ServiceName; };
template<> struct SCHEMA::predicate<32> { using type = facebook::glean::cpp::schema::Thrift::TargetX; };
template<> struct SCHEMA::predicate<33> { using type = facebook::glean::cpp::schema::Thrift::Lang; };
template<> struct SCHEMA::predicate<34> { using type = facebook::glean::cpp::schema::Thrift::Includes; };
template<> struct SCHEMA::predicate<35> { using type = facebook::glean::cpp::schema::Thrift::IncludeStatement; };
template<> struct SCHEMA::predicate<36> { using type = facebook::glean::cpp::schema::Thrift::IncludeSplice; };
template<> struct SCHEMA::predicate<37> { using type = facebook::glean::cpp::schema::Thrift::IncludeSpecial; };
template<> struct SCHEMA::predicate<38> { using type = facebook::glean::cpp::schema::Thrift::Identifier; };
template<> struct SCHEMA::predicate<39> { using type = facebook::glean::cpp::schema::Thrift::HackRecordContains; };
template<> struct SCHEMA::predicate<40> { using type = facebook::glean::cpp::schema::Thrift::HackRecord; };
template<> struct SCHEMA::predicate<41> { using type = facebook::glean::cpp::schema::Thrift::HackName; };
template<> struct SCHEMA::predicate<42> { using type = facebook::glean::cpp::schema::Thrift::HackMethod; };
template<> struct SCHEMA::predicate<43> { using type = facebook::glean::cpp::schema::Thrift::HackMap; };
template<> struct SCHEMA::predicate<44> { using type = facebook::glean::cpp::schema::Thrift::FunctionName; };
template<> struct SCHEMA::predicate<45> { using type = facebook::glean::cpp::schema::Thrift::FromPython; };
template<> struct SCHEMA::predicate<46> { using type = facebook::glean::cpp::schema::Thrift::FromHack; };
template<> struct SCHEMA::predicate<47> { using type = facebook::glean::cpp::schema::Thrift::Literal; };
template<> struct SCHEMA::predicate<48> { using type = facebook::glean::cpp::schema::Thrift::FileXRefs; };
template<> struct SCHEMA::predicate<49> { using type = facebook::glean::cpp::schema::Thrift::FileTarget; };
template<> struct SCHEMA::predicate<50> { using type = facebook::glean::cpp::schema::Thrift::FileOutput; };
template<> struct SCHEMA::predicate<51> { using type = facebook::glean::cpp::schema::Thrift::FileError; };
template<> struct SCHEMA::predicate<52> { using type = facebook::glean::cpp::schema::Thrift::File; };
template<> struct SCHEMA::predicate<53> { using type = facebook::glean::cpp::schema::Thrift::StructType; };
template<> struct SCHEMA::predicate<54> { using type = facebook::glean::cpp::schema::Thrift::UnionType; };
template<> struct SCHEMA::predicate<55> { using type = facebook::glean::cpp::schema::Thrift::ExceptionVal; };
template<> struct SCHEMA::predicate<56> { using type = facebook::glean::cpp::schema::Thrift::ExceptionType; };
template<> struct SCHEMA::predicate<57> { using type = facebook::glean::cpp::schema::Thrift::TypeDefException; };
template<> struct SCHEMA::predicate<58> { using type = facebook::glean::cpp::schema::Thrift::ExceptionName; };
template<> struct SCHEMA::predicate<59> { using type = facebook::glean::cpp::schema::Thrift::EnumerationType; };
template<> struct SCHEMA::predicate<60> { using type = facebook::glean::cpp::schema::Thrift::EnumValueDef; };
template<> struct SCHEMA::predicate<61> { using type = facebook::glean::cpp::schema::Thrift::EnumValue; };
template<> struct SCHEMA::predicate<62> { using type = facebook::glean::cpp::schema::Thrift::EnumVal; };
template<> struct SCHEMA::predicate<63> { using type = facebook::glean::cpp::schema::Thrift::DeclarationName; };
template<> struct SCHEMA::predicate<64> { using type = facebook::glean::cpp::schema::Thrift::DeclarationNameSpan; };
template<> struct SCHEMA::predicate<65> { using type = facebook::glean::cpp::schema::Thrift::FileDeclaration; };
template<> struct SCHEMA::predicate<66> { using type = facebook::glean::cpp::schema::Thrift::FunctionDeclarationName; };
template<> struct SCHEMA::predicate<67> { using type = facebook::glean::cpp::schema::Thrift::TypeSpecification; };
template<> struct SCHEMA::predicate<68> { using type = facebook::glean::cpp::schema::Thrift::ConstantType; };
template<> struct SCHEMA::predicate<69> { using type = facebook::glean::cpp::schema::Thrift::Constant; };
template<> struct SCHEMA::predicate<70> { using type = facebook::glean::cpp::schema::Thrift::CompileTarget; };
template<> struct SCHEMA::predicate<71> { using type = facebook::glean::cpp::schema::Testinfra::TestId; };
template<> struct SCHEMA::predicate<72> { using type = facebook::glean::cpp::schema::Testinfra::TaggedAssembly; };
template<> struct SCHEMA::predicate<73> { using type = facebook::glean::cpp::schema::Testinfra::Tag; };
template<> struct SCHEMA::predicate<74> { using type = facebook::glean::cpp::schema::Testinfra::MeasuredFileOnly; };
template<> struct SCHEMA::predicate<75> { using type = facebook::glean::cpp::schema::Testinfra::MeasuredFile; };
template<> struct SCHEMA::predicate<76> { using type = facebook::glean::cpp::schema::Testinfra::Folder; };
template<> struct SCHEMA::predicate<77> { using type = facebook::glean::cpp::schema::Testinfra::FbId; };
template<> struct SCHEMA::predicate<78> { using type = facebook::glean::cpp::schema::Testinfra::DatabaseMetadataField; };
template<> struct SCHEMA::predicate<79> { using type = facebook::glean::cpp::schema::Testinfra::DatabaseMetadata; };
template<> struct SCHEMA::predicate<80> { using type = facebook::glean::cpp::schema::Testinfra::CoveredOrLoadedFileTestIds; };
template<> struct SCHEMA::predicate<81> { using type = facebook::glean::cpp::schema::Testinfra::CoveredFolder; };
template<> struct SCHEMA::predicate<82> { using type = facebook::glean::cpp::schema::Testinfra::CoveredFileTestIds; };
template<> struct SCHEMA::predicate<83> { using type = facebook::glean::cpp::schema::Testinfra::CoveredFileTestIds_4; };
template<> struct SCHEMA::predicate<84> { using type = facebook::glean::cpp::schema::Testinfra::CoveredFileOnly; };
template<> struct SCHEMA::predicate<85> { using type = facebook::glean::cpp::schema::Testinfra::CoveredFileByTagAndAssembly; };
template<> struct SCHEMA::predicate<86> { using type = facebook::glean::cpp::schema::Testinfra::CoveredFileByPushBlockingAssembly; };
template<> struct SCHEMA::predicate<87> { using type = facebook::glean::cpp::schema::Testinfra::CoveredFileAssemblies; };
template<> struct SCHEMA::predicate<88> { using type = facebook::glean::cpp::schema::Testinfra::CoveredAssembly; };
template<> struct SCHEMA::predicate<89> { using type = facebook::glean::cpp::schema::Testinfra::FileMetadata_2; };
template<> struct SCHEMA::predicate<90> { using type = facebook::glean::cpp::schema::Testinfra::FileMetadata; };
template<> struct SCHEMA::predicate<91> { using type = facebook::glean::cpp::schema::Testinfra::CoveredFile; };
template<> struct SCHEMA::predicate<92> { using type = facebook::glean::cpp::schema::Testinfra::ContainsPushBlockingAssembly; };
template<> struct SCHEMA::predicate<93> { using type = facebook::glean::cpp::schema::Testinfra::AssemblyId; };
template<> struct SCHEMA::predicate<94> { using type = facebook::glean::cpp::schema::Testinfra::AssemblyByTag; };
template<> struct SCHEMA::predicate<95> { using type = facebook::glean::cpp::schema::Testinfra::Assemblies; };
template<> struct SCHEMA::predicate<96> { using type = facebook::glean::cpp::schema::Sys::Blob; };
template<> struct SCHEMA::predicate<97> { using type = facebook::glean::cpp::schema::Src::RangeContains; };
template<> struct SCHEMA::predicate<98> { using type = facebook::glean::cpp::schema::Src::IndexFailure; };
template<> struct SCHEMA::predicate<99> { using type = facebook::glean::cpp::schema::Src::FileLines; };
template<> struct SCHEMA::predicate<100> { using type = facebook::glean::cpp::schema::Src::FileLanguage; };
template<> struct SCHEMA::predicate<101> { using type = facebook::glean::cpp::schema::Src::FileDigest; };
template<> struct SCHEMA::predicate<102> { using type = facebook::glean::cpp::schema::Src::File; };
template<> struct SCHEMA::predicate<103> { using type = facebook::glean::cpp::schema::Src::ByteSpanContains; };
template<> struct SCHEMA::predicate<104> { using type = facebook::glean::cpp::schema::Spark::Ts::VersionedCapability; };
template<> struct SCHEMA::predicate<105> { using type = facebook::glean::cpp::schema::Spark::Ts::Version; };
template<> struct SCHEMA::predicate<106> { using type = facebook::glean::cpp::schema::Spark::Ts::Type; };
template<> struct SCHEMA::predicate<107> { using type = facebook::glean::cpp::schema::Spark::Ts::SymbolName; };
template<> struct SCHEMA::predicate<108> { using type = facebook::glean::cpp::schema::Spark::Ts::SymbolVersions; };
template<> struct SCHEMA::predicate<109> { using type = facebook::glean::cpp::schema::Spark::Ts::SymbolCapabilities; };
template<> struct SCHEMA::predicate<110> { using type = facebook::glean::cpp::schema::Spark::Ts::SymbolInfo; };
template<> struct SCHEMA::predicate<111> { using type = facebook::glean::cpp::schema::Spark::Ts::SymbolLocation; };
template<> struct SCHEMA::predicate<112> { using type = facebook::glean::cpp::schema::Spark::Ts::SymbolLocationInherited; };
template<> struct SCHEMA::predicate<113> { using type = facebook::glean::cpp::schema::Spark::Ts::SparkModule; };
template<> struct SCHEMA::predicate<114> { using type = facebook::glean::cpp::schema::Spark::Ts::SignatureXRefs; };
template<> struct SCHEMA::predicate<115> { using type = facebook::glean::cpp::schema::Spark::Ts::Signature; };
template<> struct SCHEMA::predicate<116> { using type = facebook::glean::cpp::schema::Spark::Ts::SymbolStatus; };
template<> struct SCHEMA::predicate<117> { using type = facebook::glean::cpp::schema::Spark::Ts::PropertyExtDecl; };
template<> struct SCHEMA::predicate<118> { using type = facebook::glean::cpp::schema::Spark::Ts::PropertyInfo; };
template<> struct SCHEMA::predicate<119> { using type = facebook::glean::cpp::schema::Spark::Ts::Name; };
template<> struct SCHEMA::predicate<120> { using type = facebook::glean::cpp::schema::Spark::Ts::ModuleSymbol; };
template<> struct SCHEMA::predicate<121> { using type = facebook::glean::cpp::schema::Spark::Ts::ModuleFiles; };
template<> struct SCHEMA::predicate<122> { using type = facebook::glean::cpp::schema::Spark::Ts::ModuleExports; };
template<> struct SCHEMA::predicate<123> { using type = facebook::glean::cpp::schema::Spark::Ts::ModuleBase; };
template<> struct SCHEMA::predicate<124> { using type = facebook::glean::cpp::schema::Spark::Ts::MethodExtDecl; };
template<> struct SCHEMA::predicate<125> { using type = facebook::glean::cpp::schema::Spark::Ts::MethodInfo; };
template<> struct SCHEMA::predicate<126> { using type = facebook::glean::cpp::schema::Spark::Ts::InheritsFrom; };
template<> struct SCHEMA::predicate<127> { using type = facebook::glean::cpp::schema::Spark::Ts::ExtDeclScope; };
template<> struct SCHEMA::predicate<128> { using type = facebook::glean::cpp::schema::Spark::Ts::ExampleCode; };
template<> struct SCHEMA::predicate<129> { using type = facebook::glean::cpp::schema::Spark::Ts::EnumeratorInfo; };
template<> struct SCHEMA::predicate<130> { using type = facebook::glean::cpp::schema::Spark::Ts::EnumeratorDecl; };
template<> struct SCHEMA::predicate<131> { using type = facebook::glean::cpp::schema::Spark::Ts::EnumInfo; };
template<> struct SCHEMA::predicate<132> { using type = facebook::glean::cpp::schema::Spark::Ts::EnumDecl; };
template<> struct SCHEMA::predicate<133> { using type = facebook::glean::cpp::schema::Spark::Ts::GatingInfo; };
template<> struct SCHEMA::predicate<134> { using type = facebook::glean::cpp::schema::Spark::Ts::DocXRefs; };
template<> struct SCHEMA::predicate<135> { using type = facebook::glean::cpp::schema::Spark::Ts::DocString; };
template<> struct SCHEMA::predicate<136> { using type = facebook::glean::cpp::schema::Spark::Ts::DocLocationInherited; };
template<> struct SCHEMA::predicate<137> { using type = facebook::glean::cpp::schema::Spark::Ts::DocLocation; };
template<> struct SCHEMA::predicate<138> { using type = facebook::glean::cpp::schema::Spark::Ts::Doc; };
template<> struct SCHEMA::predicate<139> { using type = facebook::glean::cpp::schema::Spark::Ts::Contains; };
template<> struct SCHEMA::predicate<140> { using type = facebook::glean::cpp::schema::Spark::Ts::MethodDecl; };
template<> struct SCHEMA::predicate<141> { using type = facebook::glean::cpp::schema::Spark::Ts::PropertyDecl; };
template<> struct SCHEMA::predicate<142> { using type = facebook::glean::cpp::schema::Spark::Ts::ClassInfo; };
template<> struct SCHEMA::predicate<143> { using type = facebook::glean::cpp::schema::Spark::Ts::ClassDecl; };
template<> struct SCHEMA::predicate<144> { using type = facebook::glean::cpp::schema::Spark::Ts::ChangeKeyVersion; };
template<> struct SCHEMA::predicate<145> { using type = facebook::glean::cpp::schema::Spark::Ts::ChangeKeyInfo; };
template<> struct SCHEMA::predicate<146> { using type = facebook::glean::cpp::schema::Spark::Ts::ChangeKey; };
template<> struct SCHEMA::predicate<147> { using type = facebook::glean::cpp::schema::Spark::Ts::CapabilityName; };
template<> struct SCHEMA::predicate<148> { using type = facebook::glean::cpp::schema::Spark::Ts::CapabilityConditionResult; };
template<> struct SCHEMA::predicate<149> { using type = facebook::glean::cpp::schema::Spark::Ts::CapabilityCondition; };
template<> struct SCHEMA::predicate<150> { using type = facebook::glean::cpp::schema::Spark::Ts::Capability; };
template<> struct SCHEMA::predicate<151> { using type = facebook::glean::cpp::schema::Spark::Ts::AccessorExtDecl; };
template<> struct SCHEMA::predicate<152> { using type = facebook::glean::cpp::schema::Spark::Ts::AccessorInfo; };
template<> struct SCHEMA::predicate<153> { using type = facebook::glean::cpp::schema::Spark::Ts::AccessorDecl; };
template<> struct SCHEMA::predicate<154> { using type = facebook::glean::cpp::schema::Search::Python::QueryToScopeCase; };
template<> struct SCHEMA::predicate<155> { using type = facebook::glean::cpp::schema::Search::Python::PythonNameCase; };
template<> struct SCHEMA::predicate<156> { using type = facebook::glean::cpp::schema::Search::Pp::SearchByName; };
template<> struct SCHEMA::predicate<157> { using type = facebook::glean::cpp::schema::Search::Pp::SearchByName_1; };
template<> struct SCHEMA::predicate<158> { using type = facebook::glean::cpp::schema::Search::Java::QueryToScopeCase; };
template<> struct SCHEMA::predicate<159> { using type = facebook::glean::cpp::schema::Search::Java::NameCase; };
template<> struct SCHEMA::predicate<160> { using type = facebook::glean::cpp::schema::Search::Hack::QueryToScopeCase; };
template<> struct SCHEMA::predicate<161> { using type = facebook::glean::cpp::schema::Search::Hack::HackNameCase; };
template<> struct SCHEMA::predicate<162> { using type = facebook::glean::cpp::schema::Search::Hack::HackInAutoImportedNamespace; };
template<> struct SCHEMA::predicate<163> { using type = facebook::glean::cpp::schema::Search::Flow::TypeDeclarationAsDeclaration; };
template<> struct SCHEMA::predicate<164> { using type = facebook::glean::cpp::schema::Search::Flow::QueryToScopeCase; };
template<> struct SCHEMA::predicate<165> { using type = facebook::glean::cpp::schema::Search::Flow::FlowModuleNameCase; };
template<> struct SCHEMA::predicate<166> { using type = facebook::glean::cpp::schema::Search::Cxx::QueryToQNameCase; };
template<> struct SCHEMA::predicate<167> { using type = facebook::glean::cpp::schema::Search::Cxx::QueryToNSQNameCase; };
template<> struct SCHEMA::predicate<168> { using type = facebook::glean::cpp::schema::Search::Cxx::CxxNameCase; };
template<> struct SCHEMA::predicate<169> { using type = facebook::glean::cpp::schema::Scm::Timestamp; };
template<> struct SCHEMA::predicate<170> { using type = facebook::glean::cpp::schema::Scm::Rev; };
template<> struct SCHEMA::predicate<171> { using type = facebook::glean::cpp::schema::Scm::RepoType; };
template<> struct SCHEMA::predicate<172> { using type = facebook::glean::cpp::schema::Scm::RepoName; };
template<> struct SCHEMA::predicate<173> { using type = facebook::glean::cpp::schema::Scm::Repo; };
template<> struct SCHEMA::predicate<174> { using type = facebook::glean::cpp::schema::Scm::Commit; };
template<> struct SCHEMA::predicate<175> { using type = facebook::glean::cpp::schema::Scip::SymbolName; };
template<> struct SCHEMA::predicate<176> { using type = facebook::glean::cpp::schema::Scip::SymbolDocumentation; };
template<> struct SCHEMA::predicate<177> { using type = facebook::glean::cpp::schema::Scip::Symbol; };
template<> struct SCHEMA::predicate<178> { using type = facebook::glean::cpp::schema::Scip::ReferenceTarget; };
template<> struct SCHEMA::predicate<179> { using type = facebook::glean::cpp::schema::Scip::Reference; };
template<> struct SCHEMA::predicate<180> { using type = facebook::glean::cpp::schema::Scip::LocalName; };
template<> struct SCHEMA::predicate<181> { using type = facebook::glean::cpp::schema::Scip::EntityDefinition; };
template<> struct SCHEMA::predicate<182> { using type = facebook::glean::cpp::schema::Scip::EntityLocation; };
template<> struct SCHEMA::predicate<183> { using type = facebook::glean::cpp::schema::Scip::EntityUses; };
template<> struct SCHEMA::predicate<184> { using type = facebook::glean::cpp::schema::Scip::FileEntityXRefLocation; };
template<> struct SCHEMA::predicate<185> { using type = facebook::glean::cpp::schema::Scip::ResolveLocation; };
template<> struct SCHEMA::predicate<186> { using type = facebook::glean::cpp::schema::Scip::SearchBySymbol; };
template<> struct SCHEMA::predicate<187> { using type = facebook::glean::cpp::schema::Scip::Documentation; };
template<> struct SCHEMA::predicate<188> { using type = facebook::glean::cpp::schema::Scip::DefinitionUses; };
template<> struct SCHEMA::predicate<189> { using type = facebook::glean::cpp::schema::Scip::DefinitionName; };
template<> struct SCHEMA::predicate<190> { using type = facebook::glean::cpp::schema::Scip::DefinitionDocumentation; };
template<> struct SCHEMA::predicate<191> { using type = facebook::glean::cpp::schema::Scip::Definition; };
template<> struct SCHEMA::predicate<192> { using type = facebook::glean::cpp::schema::Python::XRefsViaNameByFile; };
template<> struct SCHEMA::predicate<193> { using type = facebook::glean::cpp::schema::Python::VariableDeclaration; };
template<> struct SCHEMA::predicate<194> { using type = facebook::glean::cpp::schema::Python::VariableBySName; };
template<> struct SCHEMA::predicate<195> { using type = facebook::glean::cpp::schema::Python::Type; };
template<> struct SCHEMA::predicate<196> { using type = facebook::glean::cpp::schema::Python::StringLiteral; };
template<> struct SCHEMA::predicate<197> { using type = facebook::glean::cpp::schema::Python::SNameToName; };
template<> struct SCHEMA::predicate<198> { using type = facebook::glean::cpp::schema::Python::SName; };
template<> struct SCHEMA::predicate<199> { using type = facebook::glean::cpp::schema::Python::ResolveOriginalName; };
template<> struct SCHEMA::predicate<200> { using type = facebook::glean::cpp::schema::Python::NameToSName; };
template<> struct SCHEMA::predicate<201> { using type = facebook::glean::cpp::schema::Python::Name; };
template<> struct SCHEMA::predicate<202> { using type = facebook::glean::cpp::schema::Python::ModuleDefinition; };
template<> struct SCHEMA::predicate<203> { using type = facebook::glean::cpp::schema::Python::ModuleBySName; };
template<> struct SCHEMA::predicate<204> { using type = facebook::glean::cpp::schema::Python::Module; };
template<> struct SCHEMA::predicate<205> { using type = facebook::glean::cpp::schema::Python::MethodWithLocalName; };
template<> struct SCHEMA::predicate<206> { using type = facebook::glean::cpp::schema::Python::MethodOverrides; };
template<> struct SCHEMA::predicate<207> { using type = facebook::glean::cpp::schema::Python::MethodOverriden; };
template<> struct SCHEMA::predicate<208> { using type = facebook::glean::cpp::schema::Python::LocalNameLowerCase; };
template<> struct SCHEMA::predicate<209> { using type = facebook::glean::cpp::schema::Python::LocalName; };
template<> struct SCHEMA::predicate<210> { using type = facebook::glean::cpp::schema::Python::ImportStatementByAsSName; };
template<> struct SCHEMA::predicate<211> { using type = facebook::glean::cpp::schema::Python::ImportStatementByAsName; };
template<> struct SCHEMA::predicate<212> { using type = facebook::glean::cpp::schema::Python::ImportStatement; };
template<> struct SCHEMA::predicate<213> { using type = facebook::glean::cpp::schema::Python::ImportStarsByFile; };
template<> struct SCHEMA::predicate<214> { using type = facebook::glean::cpp::schema::Python::ImportStarStatement; };
template<> struct SCHEMA::predicate<215> { using type = facebook::glean::cpp::schema::Python::ImportStarLocation; };
template<> struct SCHEMA::predicate<216> { using type = facebook::glean::cpp::schema::Python::FunctionDeclaration; };
template<> struct SCHEMA::predicate<217> { using type = facebook::glean::cpp::schema::Python::FunctionBySName; };
template<> struct SCHEMA::predicate<218> { using type = facebook::glean::cpp::schema::Python::DerivedClassToBase; };
template<> struct SCHEMA::predicate<219> { using type = facebook::glean::cpp::schema::Python::DefinitionLocation; };
template<> struct SCHEMA::predicate<220> { using type = facebook::glean::cpp::schema::Python::DefinitionsByFile; };
template<> struct SCHEMA::predicate<221> { using type = facebook::glean::cpp::schema::Python::IsTopLevelDefinition; };
template<> struct SCHEMA::predicate<222> { using type = facebook::glean::cpp::schema::Python::FunctionDefinition; };
template<> struct SCHEMA::predicate<223> { using type = facebook::glean::cpp::schema::Python::VariableDefinition; };
template<> struct SCHEMA::predicate<224> { using type = facebook::glean::cpp::schema::Python::DeclarationDefinition; };
template<> struct SCHEMA::predicate<225> { using type = facebook::glean::cpp::schema::Python::DeclarationDocstring; };
template<> struct SCHEMA::predicate<226> { using type = facebook::glean::cpp::schema::Python::DeclarationLocation; };
template<> struct SCHEMA::predicate<227> { using type = facebook::glean::cpp::schema::Python::DeclarationReference; };
template<> struct SCHEMA::predicate<228> { using type = facebook::glean::cpp::schema::Python::DeclarationToName; };
template<> struct SCHEMA::predicate<229> { using type = facebook::glean::cpp::schema::Python::DeclarationUses; };
template<> struct SCHEMA::predicate<230> { using type = facebook::glean::cpp::schema::Python::DeclarationWithLocalName; };
template<> struct SCHEMA::predicate<231> { using type = facebook::glean::cpp::schema::Python::DeclarationWithName; };
template<> struct SCHEMA::predicate<232> { using type = facebook::glean::cpp::schema::Python::DeclarationWithSName; };
template<> struct SCHEMA::predicate<233> { using type = facebook::glean::cpp::schema::Python::DeclarationsByFile; };
template<> struct SCHEMA::predicate<234> { using type = facebook::glean::cpp::schema::Python::DefinitionDeclaration; };
template<> struct SCHEMA::predicate<235> { using type = facebook::glean::cpp::schema::Python::DirectXRefsByFile; };
template<> struct SCHEMA::predicate<236> { using type = facebook::glean::cpp::schema::Python::IsAbstract; };
template<> struct SCHEMA::predicate<237> { using type = facebook::glean::cpp::schema::Python::IsTopLevelDeclaration; };
template<> struct SCHEMA::predicate<238> { using type = facebook::glean::cpp::schema::Python::NonImportDeclaration; };
template<> struct SCHEMA::predicate<239> { using type = facebook::glean::cpp::schema::Python::SNameWithDeclaration; };
template<> struct SCHEMA::predicate<240> { using type = facebook::glean::cpp::schema::Python::SearchByLocalName; };
template<> struct SCHEMA::predicate<241> { using type = facebook::glean::cpp::schema::Python::Contains; };
template<> struct SCHEMA::predicate<242> { using type = facebook::glean::cpp::schema::Python::ContainingTopLevelDeclaration; };
template<> struct SCHEMA::predicate<243> { using type = facebook::glean::cpp::schema::Python::ContainedByTopLevelDeclaration; };
template<> struct SCHEMA::predicate<244> { using type = facebook::glean::cpp::schema::Python::ContainedBy; };
template<> struct SCHEMA::predicate<245> { using type = facebook::glean::cpp::schema::Python::ClassDefinition; };
template<> struct SCHEMA::predicate<246> { using type = facebook::glean::cpp::schema::Python::ClassDeclaration; };
template<> struct SCHEMA::predicate<247> { using type = facebook::glean::cpp::schema::Python::ClassBySName; };
template<> struct SCHEMA::predicate<248> { using type = facebook::glean::cpp::schema::Python::CalleeToCaller; };
template<> struct SCHEMA::predicate<249> { using type = facebook::glean::cpp::schema::Python::BaseClassToDerived; };
template<> struct SCHEMA::predicate<250> { using type = facebook::glean::cpp::schema::Python::FileCall; };
template<> struct SCHEMA::predicate<251> { using type = facebook::glean::cpp::schema::Pp1::Use; };
template<> struct SCHEMA::predicate<252> { using type = facebook::glean::cpp::schema::Pp1::Undef; };
template<> struct SCHEMA::predicate<253> { using type = facebook::glean::cpp::schema::Pp1::Macro; };
template<> struct SCHEMA::predicate<254> { using type = facebook::glean::cpp::schema::Pp1::Include; };
template<> struct SCHEMA::predicate<255> { using type = facebook::glean::cpp::schema::Pp1::DefineUse; };
template<> struct SCHEMA::predicate<256> { using type = facebook::glean::cpp::schema::Pp1::Define; };
template<> struct SCHEMA::predicate<257> { using type = facebook::glean::cpp::schema::Perf::Hack::ReturnPercentages; };
template<> struct SCHEMA::predicate<258> { using type = facebook::glean::cpp::schema::Perf::Hack::LoopCounts; };
template<> struct SCHEMA::predicate<259> { using type = facebook::glean::cpp::schema::Perf::Hack::FunctionData; };
template<> struct SCHEMA::predicate<260> { using type = facebook::glean::cpp::schema::Omegaanalyser::PolicyOncall; };
template<> struct SCHEMA::predicate<261> { using type = facebook::glean::cpp::schema::Omegaanalyser::OncallName; };
template<> struct SCHEMA::predicate<262> { using type = facebook::glean::cpp::schema::Omegaanalyser::OmegaPolicy; };
template<> struct SCHEMA::predicate<263> { using type = facebook::glean::cpp::schema::Omegaanalyser::OmegaEndpoint; };
template<> struct SCHEMA::predicate<264> { using type = facebook::glean::cpp::schema::Omegaanalyser::Method; };
template<> struct SCHEMA::predicate<265> { using type = facebook::glean::cpp::schema::Omegaanalyser::Function_; };
template<> struct SCHEMA::predicate<266> { using type = facebook::glean::cpp::schema::Omegaanalyser::EndpointOncall; };
template<> struct SCHEMA::predicate<267> { using type = facebook::glean::cpp::schema::Omegaanalyser::DependencyPathByCoreNode; };
template<> struct SCHEMA::predicate<268> { using type = facebook::glean::cpp::schema::Omegaanalyser::DependencyPath; };
template<> struct SCHEMA::predicate<269> { using type = facebook::glean::cpp::schema::Omegaanalyser::DependencyList; };
template<> struct SCHEMA::predicate<270> { using type = facebook::glean::cpp::schema::Omegaanalyser::Config; };
template<> struct SCHEMA::predicate<271> { using type = facebook::glean::cpp::schema::Omegaanalyser::Class_; };
template<> struct SCHEMA::predicate<272> { using type = facebook::glean::cpp::schema::Omega::Oncall; };
template<> struct SCHEMA::predicate<273> { using type = facebook::glean::cpp::schema::Omega::OmegaPolicy; };
template<> struct SCHEMA::predicate<274> { using type = facebook::glean::cpp::schema::Omega::OmegaExecutionNode; };
template<> struct SCHEMA::predicate<275> { using type = facebook::glean::cpp::schema::Omega::OmegaEntityMetadata; };
template<> struct SCHEMA::predicate<276> { using type = facebook::glean::cpp::schema::Omega::OmegaEndpoint; };
template<> struct SCHEMA::predicate<277> { using type = facebook::glean::cpp::schema::Omega::OmegaBlock; };
template<> struct SCHEMA::predicate<278> { using type = facebook::glean::cpp::schema::Omega::OmegaAction; };
template<> struct SCHEMA::predicate<279> { using type = facebook::glean::cpp::schema::Omega::Name; };
template<> struct SCHEMA::predicate<280> { using type = facebook::glean::cpp::schema::Omega::Method; };
template<> struct SCHEMA::predicate<281> { using type = facebook::glean::cpp::schema::Omega::Function_; };
template<> struct SCHEMA::predicate<282> { using type = facebook::glean::cpp::schema::Omega::Enum_; };
template<> struct SCHEMA::predicate<283> { using type = facebook::glean::cpp::schema::Omega::DependencyPathByEntity; };
template<> struct SCHEMA::predicate<284> { using type = facebook::glean::cpp::schema::Omega::DependencyPath; };
template<> struct SCHEMA::predicate<285> { using type = facebook::glean::cpp::schema::Omega::DependencyList; };
template<> struct SCHEMA::predicate<286> { using type = facebook::glean::cpp::schema::Omega::Config; };
template<> struct SCHEMA::predicate<287> { using type = facebook::glean::cpp::schema::Omega::Class_; };
template<> struct SCHEMA::predicate<288> { using type = facebook::glean::cpp::schema::Monk::Xid; };
template<> struct SCHEMA::predicate<289> { using type = facebook::glean::cpp::schema::Monk::PiiLoggerXid; };
template<> struct SCHEMA::predicate<290> { using type = facebook::glean::cpp::schema::Monk::HackPiiLoggerTraitXid; };
template<> struct SCHEMA::predicate<291> { using type = facebook::glean::cpp::schema::Monk::HackPiiLoggerSetterXid; };
template<> struct SCHEMA::predicate<292> { using type = facebook::glean::cpp::schema::Monk::HackPiiLoggerSetterCallXid; };
template<> struct SCHEMA::predicate<293> { using type = facebook::glean::cpp::schema::Monk::HackPiiLoggerClassXid; };
template<> struct SCHEMA::predicate<294> { using type = facebook::glean::cpp::schema::Monk::HackPiiLogCallXid; };
template<> struct SCHEMA::predicate<295> { using type = facebook::glean::cpp::schema::Monk::HackPiiLog; };
template<> struct SCHEMA::predicate<296> { using type = facebook::glean::cpp::schema::Monk::HackPiiFunc; };
template<> struct SCHEMA::predicate<297> { using type = facebook::glean::cpp::schema::Monk::HackMethodByName; };
template<> struct SCHEMA::predicate<298> { using type = facebook::glean::cpp::schema::Monk::HackLoggerMethod; };
template<> struct SCHEMA::predicate<299> { using type = facebook::glean::cpp::schema::Scip::Metadata; };
template<> struct SCHEMA::predicate<300> { using type = facebook::glean::cpp::schema::Scip::EntityKind; };
template<> struct SCHEMA::predicate<301> { using type = facebook::glean::cpp::schema::Scip::SymbolKind; };
template<> struct SCHEMA::predicate<302> { using type = facebook::glean::cpp::schema::Lsif::Types::ToSrcRange; };
template<> struct SCHEMA::predicate<303> { using type = facebook::glean::cpp::schema::Scip::DefinitionLocation; };
template<> struct SCHEMA::predicate<304> { using type = facebook::glean::cpp::schema::Scip::FileRange; };
template<> struct SCHEMA::predicate<305> { using type = facebook::glean::cpp::schema::Scip::ReferenceLocation; };
template<> struct SCHEMA::predicate<306> { using type = facebook::glean::cpp::schema::Scip::FileLanguage; };
template<> struct SCHEMA::predicate<307> { using type = facebook::glean::cpp::schema::Scip::TagDefinition; };
template<> struct SCHEMA::predicate<308> { using type = facebook::glean::cpp::schema::Lsif::Types::FromSrcRange; };
template<> struct SCHEMA::predicate<309> { using type = facebook::glean::cpp::schema::Lsif::Reference; };
template<> struct SCHEMA::predicate<310> { using type = facebook::glean::cpp::schema::Lsif::Range; };
template<> struct SCHEMA::predicate<311> { using type = facebook::glean::cpp::schema::Lsif::ProjectDocument; };
template<> struct SCHEMA::predicate<312> { using type = facebook::glean::cpp::schema::Lsif::Project; };
template<> struct SCHEMA::predicate<313> { using type = facebook::glean::cpp::schema::Lsif::PackageInformation; };
template<> struct SCHEMA::predicate<314> { using type = facebook::glean::cpp::schema::Lsif::NameLowerCase; };
template<> struct SCHEMA::predicate<315> { using type = facebook::glean::cpp::schema::Lsif::NameDefinition; };
template<> struct SCHEMA::predicate<316> { using type = facebook::glean::cpp::schema::Lsif::Name; };
template<> struct SCHEMA::predicate<317> { using type = facebook::glean::cpp::schema::Lsif::MonikerSymbolKind; };
template<> struct SCHEMA::predicate<318> { using type = facebook::glean::cpp::schema::Lsif::MonikerScheme; };
template<> struct SCHEMA::predicate<319> { using type = facebook::glean::cpp::schema::Lsif::MonikerId; };
template<> struct SCHEMA::predicate<320> { using type = facebook::glean::cpp::schema::Lsif::MonikerDefinition; };
template<> struct SCHEMA::predicate<321> { using type = facebook::glean::cpp::schema::Lsif::Moniker; };
template<> struct SCHEMA::predicate<322> { using type = facebook::glean::cpp::schema::Lsif::Metadata; };
template<> struct SCHEMA::predicate<323> { using type = facebook::glean::cpp::schema::Lsif::HoverText; };
template<> struct SCHEMA::predicate<324> { using type = facebook::glean::cpp::schema::Lsif::HoverContent; };
template<> struct SCHEMA::predicate<325> { using type = facebook::glean::cpp::schema::Lsif::EntityDefinition; };
template<> struct SCHEMA::predicate<326> { using type = facebook::glean::cpp::schema::Lsif::EntityKind; };
template<> struct SCHEMA::predicate<327> { using type = facebook::glean::cpp::schema::Lsif::EntityLocation; };
template<> struct SCHEMA::predicate<328> { using type = facebook::glean::cpp::schema::Lsif::EntityUses; };
template<> struct SCHEMA::predicate<329> { using type = facebook::glean::cpp::schema::Lsif::FileEntityXRefLocation; };
template<> struct SCHEMA::predicate<330> { using type = facebook::glean::cpp::schema::Lsif::ResolveLocation; };
template<> struct SCHEMA::predicate<331> { using type = facebook::glean::cpp::schema::Lsif::SearchByExactLocation; };
template<> struct SCHEMA::predicate<332> { using type = facebook::glean::cpp::schema::Lsif::SearchByExactLocationAndName; };
template<> struct SCHEMA::predicate<333> { using type = facebook::glean::cpp::schema::Lsif::SearchByMoniker; };
template<> struct SCHEMA::predicate<334> { using type = facebook::glean::cpp::schema::Lsif::SearchByName; };
template<> struct SCHEMA::predicate<335> { using type = facebook::glean::cpp::schema::Lsif::SearchNonLocalByLocation; };
template<> struct SCHEMA::predicate<336> { using type = facebook::glean::cpp::schema::Lsif::TagDefinition; };
template<> struct SCHEMA::predicate<337> { using type = facebook::glean::cpp::schema::Lsif::Document; };
template<> struct SCHEMA::predicate<338> { using type = facebook::glean::cpp::schema::Lsif::DefinitionUse; };
template<> struct SCHEMA::predicate<339> { using type = facebook::glean::cpp::schema::Lsif::DefinitionMoniker; };
template<> struct SCHEMA::predicate<340> { using type = facebook::glean::cpp::schema::Lsif::DefinitionLocation; };
template<> struct SCHEMA::predicate<341> { using type = facebook::glean::cpp::schema::Lsif::DefinitionKind; };
template<> struct SCHEMA::predicate<342> { using type = facebook::glean::cpp::schema::Lsif::DefinitionHover; };
template<> struct SCHEMA::predicate<343> { using type = facebook::glean::cpp::schema::Lsif::Definition; };
template<> struct SCHEMA::predicate<344> { using type = facebook::glean::cpp::schema::Lsif::Declaration; };
template<> struct SCHEMA::predicate<345> { using type = facebook::glean::cpp::schema::Kotlin::Alpha::VariableParent; };
template<> struct SCHEMA::predicate<346> { using type = facebook::glean::cpp::schema::Kotlin::Alpha::VariableDeclaration; };
template<> struct SCHEMA::predicate<347> { using type = facebook::glean::cpp::schema::Kotlin::Alpha::TypeArg; };
template<> struct SCHEMA::predicate<348> { using type = facebook::glean::cpp::schema::Kotlin::Alpha::Type; };
template<> struct SCHEMA::predicate<349> { using type = facebook::glean::cpp::schema::Kotlin::Alpha::DeclarationLocation; };
template<> struct SCHEMA::predicate<350> { using type = facebook::glean::cpp::schema::Kotlin::Alpha::DeclarationFileLocation; };
template<> struct SCHEMA::predicate<351> { using type = facebook::glean::cpp::schema::Kotlin::Alpha::ExtendsDeclaration; };
template<> struct SCHEMA::predicate<352> { using type = facebook::glean::cpp::schema::Kotlin::Alpha::FileDeclarations; };
template<> struct SCHEMA::predicate<353> { using type = facebook::glean::cpp::schema::Kotlin::Alpha::MethodDeclaration; };
template<> struct SCHEMA::predicate<354> { using type = facebook::glean::cpp::schema::Kotlin::Alpha::ParentDeclaration; };
template<> struct SCHEMA::predicate<355> { using type = facebook::glean::cpp::schema::Search::Kotlin::SearchByQName; };
template<> struct SCHEMA::predicate<356> { using type = facebook::glean::cpp::schema::Symbolid::Kotlin::LookupDeclaration; };
template<> struct SCHEMA::predicate<357> { using type = facebook::glean::cpp::schema::Symbolid::Kotlin::LookupMethodDeclaration; };
template<> struct SCHEMA::predicate<358> { using type = facebook::glean::cpp::schema::Kotlin::Alpha::ContainsDeclaration; };
template<> struct SCHEMA::predicate<359> { using type = facebook::glean::cpp::schema::Kotlin::Alpha::ClassMember; };
template<> struct SCHEMA::predicate<360> { using type = facebook::glean::cpp::schema::Kotlin::Alpha::ClassDeclaration; };
template<> struct SCHEMA::predicate<361> { using type = facebook::glean::cpp::schema::Javakotlin::Alpha::Type; };
template<> struct SCHEMA::predicate<362> { using type = facebook::glean::cpp::schema::Javakotlin::Alpha::QName; };
template<> struct SCHEMA::predicate<363> { using type = facebook::glean::cpp::schema::Javakotlin::Alpha::Path; };
template<> struct SCHEMA::predicate<364> { using type = facebook::glean::cpp::schema::Javakotlin::Alpha::NameLowerCase; };
template<> struct SCHEMA::predicate<365> { using type = facebook::glean::cpp::schema::Javakotlin::Alpha::Name; };
template<> struct SCHEMA::predicate<366> { using type = facebook::glean::cpp::schema::Javakotlin::Alpha::MethodName; };
template<> struct SCHEMA::predicate<367> { using type = facebook::glean::cpp::schema::Java::Alpha::XRefFile; };
template<> struct SCHEMA::predicate<368> { using type = facebook::glean::cpp::schema::Java::Alpha::XRef; };
template<> struct SCHEMA::predicate<369> { using type = facebook::glean::cpp::schema::Java::Alpha::TypeVar; };
template<> struct SCHEMA::predicate<370> { using type = facebook::glean::cpp::schema::Java::Alpha::TypeParam; };
template<> struct SCHEMA::predicate<371> { using type = facebook::glean::cpp::schema::Java::Alpha::TypeOfTypeArgs; };
template<> struct SCHEMA::predicate<372> { using type = facebook::glean::cpp::schema::Java::Alpha::TypeArg; };
template<> struct SCHEMA::predicate<373> { using type = facebook::glean::cpp::schema::Java::Alpha::PrimitiveType; };
template<> struct SCHEMA::predicate<374> { using type = facebook::glean::cpp::schema::Java::Alpha::PackageDeclaration; };
template<> struct SCHEMA::predicate<375> { using type = facebook::glean::cpp::schema::Java::Alpha::ObjectType; };
template<> struct SCHEMA::predicate<376> { using type = facebook::glean::cpp::schema::Java::Alpha::ParameterDeclaration; };
template<> struct SCHEMA::predicate<377> { using type = facebook::glean::cpp::schema::Java::Alpha::InterfaceInheritance; };
template<> struct SCHEMA::predicate<378> { using type = facebook::glean::cpp::schema::Java::Alpha::Inheritance; };
template<> struct SCHEMA::predicate<379> { using type = facebook::glean::cpp::schema::Java::Alpha::ImportDeclaration; };
template<> struct SCHEMA::predicate<380> { using type = facebook::glean::cpp::schema::Java::Alpha::FileXRefs; };
template<> struct SCHEMA::predicate<381> { using type = facebook::glean::cpp::schema::Java::Alpha::ExecutableDefnLocation; };
template<> struct SCHEMA::predicate<382> { using type = facebook::glean::cpp::schema::Java::Alpha::LocalDeclaration; };
template<> struct SCHEMA::predicate<383> { using type = facebook::glean::cpp::schema::Java::Alpha::DefinitionLocation; };
template<> struct SCHEMA::predicate<384> { using type = facebook::glean::cpp::schema::Java::Alpha::EnumDeclaration; };
template<> struct SCHEMA::predicate<385> { using type = facebook::glean::cpp::schema::Java::Alpha::FieldDeclaration; };
template<> struct SCHEMA::predicate<386> { using type = facebook::glean::cpp::schema::Java::Alpha::InterfaceDeclaration; };
template<> struct SCHEMA::predicate<387> { using type = facebook::glean::cpp::schema::Java::Alpha::MethodDeclaration; };
template<> struct SCHEMA::predicate<388> { using type = facebook::glean::cpp::schema::Java::Alpha::DeclarationAnnotations; };
template<> struct SCHEMA::predicate<389> { using type = facebook::glean::cpp::schema::Java::Alpha::DeclarationComment; };
template<> struct SCHEMA::predicate<390> { using type = facebook::glean::cpp::schema::Java::Alpha::DeclarationLocation; };
template<> struct SCHEMA::predicate<391> { using type = facebook::glean::cpp::schema::Java::Alpha::DeclarationType; };
template<> struct SCHEMA::predicate<392> { using type = facebook::glean::cpp::schema::Java::Alpha::DeclarationUses; };
template<> struct SCHEMA::predicate<393> { using type = facebook::glean::cpp::schema::Java::Alpha::DeclarationXRefTarget; };
template<> struct SCHEMA::predicate<394> { using type = facebook::glean::cpp::schema::Java::Alpha::ExtendedByDeclaration; };
template<> struct SCHEMA::predicate<395> { using type = facebook::glean::cpp::schema::Java::Alpha::ExtendsDeclaration; };
template<> struct SCHEMA::predicate<396> { using type = facebook::glean::cpp::schema::Java::Alpha::FileDeclarations; };
template<> struct SCHEMA::predicate<397> { using type = facebook::glean::cpp::schema::Java::Alpha::ParentDeclaration; };
template<> struct SCHEMA::predicate<398> { using type = facebook::glean::cpp::schema::Java::Alpha::QNameToDefinition; };
template<> struct SCHEMA::predicate<399> { using type = facebook::glean::cpp::schema::Java::Alpha::XRefOfType; };
template<> struct SCHEMA::predicate<400> { using type = facebook::glean::cpp::schema::Java::Alpha::XRefTargetDeclaration; };
template<> struct SCHEMA::predicate<401> { using type = facebook::glean::cpp::schema::Search::Java::SearchByQName; };
template<> struct SCHEMA::predicate<402> { using type = facebook::glean::cpp::schema::Symbolid::Java::LookupDeclaration; };
template<> struct SCHEMA::predicate<403> { using type = facebook::glean::cpp::schema::Symbolid::Java::LookupMethodDeclaration; };
template<> struct SCHEMA::predicate<404> { using type = facebook::glean::cpp::schema::Java::Alpha::DeclOfExecutableDefn; };
template<> struct SCHEMA::predicate<405> { using type = facebook::glean::cpp::schema::Java::Alpha::DeclOfDefn; };
template<> struct SCHEMA::predicate<406> { using type = facebook::glean::cpp::schema::Java::Alpha::ContainsDeclaration; };
template<> struct SCHEMA::predicate<407> { using type = facebook::glean::cpp::schema::Java::Alpha::ConstructorDeclaration; };
template<> struct SCHEMA::predicate<408> { using type = facebook::glean::cpp::schema::Java::Alpha::ClassDeclaration; };
template<> struct SCHEMA::predicate<409> { using type = facebook::glean::cpp::schema::Java::Alpha::Type; };
template<> struct SCHEMA::predicate<410> { using type = facebook::glean::cpp::schema::Java::Alpha::ArrayType; };
template<> struct SCHEMA::predicate<411> { using type = facebook::glean::cpp::schema::Java::Alpha::Annotation; };
template<> struct SCHEMA::predicate<412> { using type = facebook::glean::cpp::schema::Java::Alpha::AnnotatedClass; };
template<> struct SCHEMA::predicate<413> { using type = facebook::glean::cpp::schema::Indexer::Config; };
template<> struct SCHEMA::predicate<414> { using type = facebook::glean::cpp::schema::Hs::XRef; };
template<> struct SCHEMA::predicate<415> { using type = facebook::glean::cpp::schema::Hs::Type; };
template<> struct SCHEMA::predicate<416> { using type = facebook::glean::cpp::schema::Hs::TargetUses; };
template<> struct SCHEMA::predicate<417> { using type = facebook::glean::cpp::schema::Hs::SourceModule; };
template<> struct SCHEMA::predicate<418> { using type = facebook::glean::cpp::schema::Hs::PackageId; };
template<> struct SCHEMA::predicate<419> { using type = facebook::glean::cpp::schema::Hs::ModuleNameLowerCase; };
template<> struct SCHEMA::predicate<420> { using type = facebook::glean::cpp::schema::Hs::ModuleName; };
template<> struct SCHEMA::predicate<421> { using type = facebook::glean::cpp::schema::Hs::ModuleDefinitions; };
template<> struct SCHEMA::predicate<422> { using type = facebook::glean::cpp::schema::Hs::Module; };
template<> struct SCHEMA::predicate<423> { using type = facebook::glean::cpp::schema::Hs::FunctionNameLowerCase; };
template<> struct SCHEMA::predicate<424> { using type = facebook::glean::cpp::schema::Hs::FunctionName; };
template<> struct SCHEMA::predicate<425> { using type = facebook::glean::cpp::schema::Hs::FunctionDefinition; };
template<> struct SCHEMA::predicate<426> { using type = facebook::glean::cpp::schema::Hs::FileXRefMap; };
template<> struct SCHEMA::predicate<427> { using type = facebook::glean::cpp::schema::Hs::DefinitionNameLowerCase; };
template<> struct SCHEMA::predicate<428> { using type = facebook::glean::cpp::schema::Hs::DefinitionName; };
template<> struct SCHEMA::predicate<429> { using type = facebook::glean::cpp::schema::Hs::DefinitionLocation; };
template<> struct SCHEMA::predicate<430> { using type = facebook::glean::cpp::schema::Hs::FileDefinition; };
template<> struct SCHEMA::predicate<431> { using type = facebook::glean::cpp::schema::Hs::Definition; };
template<> struct SCHEMA::predicate<432> { using type = facebook::glean::cpp::schema::Hs::Definition_1; };
template<> struct SCHEMA::predicate<433> { using type = facebook::glean::cpp::schema::Hs::ClassNameLowerCase; };
template<> struct SCHEMA::predicate<434> { using type = facebook::glean::cpp::schema::Hs::ClassName; };
template<> struct SCHEMA::predicate<435> { using type = facebook::glean::cpp::schema::Hs::ClassInstance; };
template<> struct SCHEMA::predicate<436> { using type = facebook::glean::cpp::schema::Hs::Class; };
template<> struct SCHEMA::predicate<437> { using type = facebook::glean::cpp::schema::Haxlanalyser::ThriftResponse; };
template<> struct SCHEMA::predicate<438> { using type = facebook::glean::cpp::schema::Haxlanalyser::ThriftFetch; };
template<> struct SCHEMA::predicate<439> { using type = facebook::glean::cpp::schema::Haxlanalyser::TestFile; };
template<> struct SCHEMA::predicate<440> { using type = facebook::glean::cpp::schema::Haxlanalyser::TallyName; };
template<> struct SCHEMA::predicate<441> { using type = facebook::glean::cpp::schema::Haxlanalyser::TallyConfig; };
template<> struct SCHEMA::predicate<442> { using type = facebook::glean::cpp::schema::Haxlanalyser::TallyFetch; };
template<> struct SCHEMA::predicate<443> { using type = facebook::glean::cpp::schema::Haxlanalyser::TallyResponse; };
template<> struct SCHEMA::predicate<444> { using type = facebook::glean::cpp::schema::Haxlanalyser::SitevarFetch; };
template<> struct SCHEMA::predicate<445> { using type = facebook::glean::cpp::schema::Haxlanalyser::ScubaResponse; };
template<> struct SCHEMA::predicate<446> { using type = facebook::glean::cpp::schema::Haxlanalyser::ScribeResponse; };
template<> struct SCHEMA::predicate<447> { using type = facebook::glean::cpp::schema::Haxlanalyser::RestrictionResponse; };
template<> struct SCHEMA::predicate<448> { using type = facebook::glean::cpp::schema::Haxlanalyser::PolicyName; };
template<> struct SCHEMA::predicate<449> { using type = facebook::glean::cpp::schema::Haxlanalyser::Policy; };
template<> struct SCHEMA::predicate<450> { using type = facebook::glean::cpp::schema::Haxlanalyser::PiranhaResponse; };
template<> struct SCHEMA::predicate<451> { using type = facebook::glean::cpp::schema::Haxlanalyser::LogFeatureResponse; };
template<> struct SCHEMA::predicate<452> { using type = facebook::glean::cpp::schema::Haxlanalyser::LaserDataset; };
template<> struct SCHEMA::predicate<453> { using type = facebook::glean::cpp::schema::Haxlanalyser::JankyJSONResponse; };
template<> struct SCHEMA::predicate<454> { using type = facebook::glean::cpp::schema::Haxlanalyser::InputKey; };
template<> struct SCHEMA::predicate<455> { using type = facebook::glean::cpp::schema::Haxlanalyser::InputFetch; };
template<> struct SCHEMA::predicate<456> { using type = facebook::glean::cpp::schema::Haxlanalyser::HiveResponse; };
template<> struct SCHEMA::predicate<457> { using type = facebook::glean::cpp::schema::Haxlanalyser::FeatureSetFeature; };
template<> struct SCHEMA::predicate<458> { using type = facebook::glean::cpp::schema::Haxlanalyser::EndpointName; };
template<> struct SCHEMA::predicate<459> { using type = facebook::glean::cpp::schema::Haxlanalyser::Endpoint; };
template<> struct SCHEMA::predicate<460> { using type = facebook::glean::cpp::schema::Haxlanalyser::Edge; };
template<> struct SCHEMA::predicate<461> { using type = facebook::glean::cpp::schema::Haxlanalyser::ContextName; };
template<> struct SCHEMA::predicate<462> { using type = facebook::glean::cpp::schema::Haxlanalyser::Context; };
template<> struct SCHEMA::predicate<463> { using type = facebook::glean::cpp::schema::Haxlanalyser::ConfigeratorFetch; };
template<> struct SCHEMA::predicate<464> { using type = facebook::glean::cpp::schema::Haxlanalyser::ClassifierRead; };
template<> struct SCHEMA::predicate<465> { using type = facebook::glean::cpp::schema::Haxlanalyser::ClassifierFetch; };
template<> struct SCHEMA::predicate<466> { using type = facebook::glean::cpp::schema::Haxlanalyser::Call; };
template<> struct SCHEMA::predicate<467> { using type = facebook::glean::cpp::schema::Haxlanalyser::ACDCPropertyAccess; };
template<> struct SCHEMA::predicate<468> { using type = facebook::glean::cpp::schema::Haxlanalyser::ACDCProperty; };
template<> struct SCHEMA::predicate<469> { using type = facebook::glean::cpp::schema::Hackdependency::name; };
template<> struct SCHEMA::predicate<470> { using type = facebook::glean::cpp::schema::Hackdependency::inheritance; };
template<> struct SCHEMA::predicate<471> { using type = facebook::glean::cpp::schema::Hack::UserAttribute; };
template<> struct SCHEMA::predicate<472> { using type = facebook::glean::cpp::schema::Hack::TypedefDeclaration; };
template<> struct SCHEMA::predicate<473> { using type = facebook::glean::cpp::schema::Hack::TypeConstDefinition; };
template<> struct SCHEMA::predicate<474> { using type = facebook::glean::cpp::schema::Hack::Type; };
template<> struct SCHEMA::predicate<475> { using type = facebook::glean::cpp::schema::Hack::TraitDeclaration; };
template<> struct SCHEMA::predicate<476> { using type = facebook::glean::cpp::schema::Hack::StringLiteral; };
template<> struct SCHEMA::predicate<477> { using type = facebook::glean::cpp::schema::Hack::QName; };
template<> struct SCHEMA::predicate<478> { using type = facebook::glean::cpp::schema::Hack::PropertyDefinition; };
template<> struct SCHEMA::predicate<479> { using type = facebook::glean::cpp::schema::Hack::Signature; };
template<> struct SCHEMA::predicate<480> { using type = facebook::glean::cpp::schema::Hack::NamespaceQName; };
template<> struct SCHEMA::predicate<481> { using type = facebook::glean::cpp::schema::Hack::NamespaceDeclaration; };
template<> struct SCHEMA::predicate<482> { using type = facebook::glean::cpp::schema::Hack::NameLowerCase; };
template<> struct SCHEMA::predicate<483> { using type = facebook::glean::cpp::schema::Hack::Name; };
template<> struct SCHEMA::predicate<484> { using type = facebook::glean::cpp::schema::Hack::ModuleDefinition; };
template<> struct SCHEMA::predicate<485> { using type = facebook::glean::cpp::schema::Hack::ModuleDeclaration; };
template<> struct SCHEMA::predicate<486> { using type = facebook::glean::cpp::schema::Hack::MethodOverrides; };
template<> struct SCHEMA::predicate<487> { using type = facebook::glean::cpp::schema::Hack::MethodOverridden; };
template<> struct SCHEMA::predicate<488> { using type = facebook::glean::cpp::schema::Hack::MethodOccurrence; };
template<> struct SCHEMA::predicate<489> { using type = facebook::glean::cpp::schema::Hack::InterfaceDeclaration; };
template<> struct SCHEMA::predicate<490> { using type = facebook::glean::cpp::schema::Hack::IndexerInputsHash; };
template<> struct SCHEMA::predicate<491> { using type = facebook::glean::cpp::schema::Hack::GlobalNamespaceAlias; };
template<> struct SCHEMA::predicate<492> { using type = facebook::glean::cpp::schema::Hack::GlobalConstDefinition; };
template<> struct SCHEMA::predicate<493> { using type = facebook::glean::cpp::schema::Hack::GlobalConstDeclaration; };
template<> struct SCHEMA::predicate<494> { using type = facebook::glean::cpp::schema::Hack::FunctionDeclaration; };
template<> struct SCHEMA::predicate<495> { using type = facebook::glean::cpp::schema::Hack::Enumerator; };
template<> struct SCHEMA::predicate<496> { using type = facebook::glean::cpp::schema::Hack::EnumDefinition; };
template<> struct SCHEMA::predicate<497> { using type = facebook::glean::cpp::schema::Hack::EnumDeclaration; };
template<> struct SCHEMA::predicate<498> { using type = facebook::glean::cpp::schema::Hack::Context_; };
template<> struct SCHEMA::predicate<499> { using type = facebook::glean::cpp::schema::Hack::ContainerDeclarationQName; };
template<> struct SCHEMA::predicate<500> { using type = facebook::glean::cpp::schema::Hack::ContainerParent; };
template<> struct SCHEMA::predicate<501> { using type = facebook::glean::cpp::schema::Hack::DeclarationComment; };
template<> struct SCHEMA::predicate<502> { using type = facebook::glean::cpp::schema::Hack::DeclarationLocation; };
template<> struct SCHEMA::predicate<503> { using type = facebook::glean::cpp::schema::Hack::DeclarationName; };
template<> struct SCHEMA::predicate<504> { using type = facebook::glean::cpp::schema::Hack::DeclarationNamespace; };
template<> struct SCHEMA::predicate<505> { using type = facebook::glean::cpp::schema::Hack::DeclarationSource; };
template<> struct SCHEMA::predicate<506> { using type = facebook::glean::cpp::schema::Hack::DeclarationSpan; };
template<> struct SCHEMA::predicate<507> { using type = facebook::glean::cpp::schema::Hack::DeclarationTarget; };
template<> struct SCHEMA::predicate<508> { using type = facebook::glean::cpp::schema::Hack::FileDeclarations; };
template<> struct SCHEMA::predicate<509> { using type = facebook::glean::cpp::schema::Hack::MemberCluster; };
template<> struct SCHEMA::predicate<510> { using type = facebook::glean::cpp::schema::Hack::ModuleChild; };
template<> struct SCHEMA::predicate<511> { using type = facebook::glean::cpp::schema::Hack::ModuleParent; };
template<> struct SCHEMA::predicate<512> { using type = facebook::glean::cpp::schema::Hack::NamespaceMember; };
template<> struct SCHEMA::predicate<513> { using type = facebook::glean::cpp::schema::Hack::TargetUses; };
template<> struct SCHEMA::predicate<514> { using type = facebook::glean::cpp::schema::Hack::TargetUsesAbs; };
template<> struct SCHEMA::predicate<515> { using type = facebook::glean::cpp::schema::Hack::FileXRefs; };
template<> struct SCHEMA::predicate<516> { using type = facebook::glean::cpp::schema::Hack::TypeInfo; };
template<> struct SCHEMA::predicate<517> { using type = facebook::glean::cpp::schema::Monk::HackCaller; };
template<> struct SCHEMA::predicate<518> { using type = facebook::glean::cpp::schema::Monk::HackIsCaller; };
template<> struct SCHEMA::predicate<519> { using type = facebook::glean::cpp::schema::Omega::TargetNodeLocations; };
template<> struct SCHEMA::predicate<520> { using type = facebook::glean::cpp::schema::Omegaanalyser::ClassStaticMethodReferences; };
template<> struct SCHEMA::predicate<521> { using type = facebook::glean::cpp::schema::Omegaanalyser::TargetNodeLocations; };
template<> struct SCHEMA::predicate<522> { using type = facebook::glean::cpp::schema::Search::Hack::SearchByName; };
template<> struct SCHEMA::predicate<523> { using type = facebook::glean::cpp::schema::Search::Hack::SearchFunctionInNamespace; };
template<> struct SCHEMA::predicate<524> { using type = facebook::glean::cpp::schema::Search::Hack::SearchGlobalConstInNamespace; };
template<> struct SCHEMA::predicate<525> { using type = facebook::glean::cpp::schema::Search::Hack::SearchInContainer; };
template<> struct SCHEMA::predicate<526> { using type = facebook::glean::cpp::schema::Search::Hack::SearchInContainerNoProperty; };
template<> struct SCHEMA::predicate<527> { using type = facebook::glean::cpp::schema::Search::Hack::SearchInContainerOrEnum; };
template<> struct SCHEMA::predicate<528> { using type = facebook::glean::cpp::schema::Search::Hack::SearchInContainerOrEnumNoProperty; };
template<> struct SCHEMA::predicate<529> { using type = facebook::glean::cpp::schema::Search::Hack::SearchInContext; };
template<> struct SCHEMA::predicate<530> { using type = facebook::glean::cpp::schema::Search::Hack::SearchInEnum; };
template<> struct SCHEMA::predicate<531> { using type = facebook::glean::cpp::schema::Search::Hack::SearchInNamespace; };
template<> struct SCHEMA::predicate<532> { using type = facebook::glean::cpp::schema::Search::Hack::SearchModule; };
template<> struct SCHEMA::predicate<533> { using type = facebook::glean::cpp::schema::Search::Hack::SearchNamespace; };
template<> struct SCHEMA::predicate<534> { using type = facebook::glean::cpp::schema::Search::Hack::SearchNamespacedDecl; };
template<> struct SCHEMA::predicate<535> { using type = facebook::glean::cpp::schema::Search::Hack::SearchPropertyInContainer; };
template<> struct SCHEMA::predicate<536> { using type = facebook::glean::cpp::schema::Search::Hack::SearchTypeInNamespace; };
template<> struct SCHEMA::predicate<537> { using type = facebook::glean::cpp::schema::Hack::InheritedMembers; };
template<> struct SCHEMA::predicate<538> { using type = facebook::glean::cpp::schema::Hack::MethodDeclaration; };
template<> struct SCHEMA::predicate<539> { using type = facebook::glean::cpp::schema::Hack::PropertyDeclaration; };
template<> struct SCHEMA::predicate<540> { using type = facebook::glean::cpp::schema::Hack::TypeConstDeclaration; };
template<> struct SCHEMA::predicate<541> { using type = facebook::glean::cpp::schema::Hack::ContainerChild; };
template<> struct SCHEMA::predicate<542> { using type = facebook::glean::cpp::schema::Hack::FunctionDefinition; };
template<> struct SCHEMA::predicate<543> { using type = facebook::glean::cpp::schema::Hack::InterfaceDefinition; };
template<> struct SCHEMA::predicate<544> { using type = facebook::glean::cpp::schema::Hack::MethodDefinition; };
template<> struct SCHEMA::predicate<545> { using type = facebook::glean::cpp::schema::Hack::TraitDefinition; };
template<> struct SCHEMA::predicate<546> { using type = facebook::glean::cpp::schema::Hack::TypedefDefinition; };
template<> struct SCHEMA::predicate<547> { using type = facebook::glean::cpp::schema::Hack::ClassDefinition; };
template<> struct SCHEMA::predicate<548> { using type = facebook::glean::cpp::schema::Hack::ClassDeclaration; };
template<> struct SCHEMA::predicate<549> { using type = facebook::glean::cpp::schema::Hack::ClassConstDefinition; };
template<> struct SCHEMA::predicate<550> { using type = facebook::glean::cpp::schema::Hack::ClassConstDeclaration; };
template<> struct SCHEMA::predicate<551> { using type = facebook::glean::cpp::schema::Hack::AttributeToDefinition; };
template<> struct SCHEMA::predicate<552> { using type = facebook::glean::cpp::schema::Hack::AttributeToDeclaration; };
template<> struct SCHEMA::predicate<553> { using type = facebook::glean::cpp::schema::Hack::AttributeHasParameter; };
template<> struct SCHEMA::predicate<554> { using type = facebook::glean::cpp::schema::Hack::FileCall; };
template<> struct SCHEMA::predicate<555> { using type = facebook::glean::cpp::schema::Graphql::VariableDef; };
template<> struct SCHEMA::predicate<556> { using type = facebook::glean::cpp::schema::Graphql::Value; };
template<> struct SCHEMA::predicate<557> { using type = facebook::glean::cpp::schema::Graphql::UnionTypeDef; };
template<> struct SCHEMA::predicate<558> { using type = facebook::glean::cpp::schema::Graphql::ScalarTypeDef; };
template<> struct SCHEMA::predicate<559> { using type = facebook::glean::cpp::schema::Graphql::Operation; };
template<> struct SCHEMA::predicate<560> { using type = facebook::glean::cpp::schema::Graphql::ObjectTypeDef; };
template<> struct SCHEMA::predicate<561> { using type = facebook::glean::cpp::schema::Graphql::NameLowerCase; };
template<> struct SCHEMA::predicate<562> { using type = facebook::glean::cpp::schema::Graphql::InterfaceTypeDef; };
template<> struct SCHEMA::predicate<563> { using type = facebook::glean::cpp::schema::Graphql::InputValueDef; };
template<> struct SCHEMA::predicate<564> { using type = facebook::glean::cpp::schema::Graphql::InputObjectTypeDef; };
template<> struct SCHEMA::predicate<565> { using type = facebook::glean::cpp::schema::Graphql::InlineFragment; };
template<> struct SCHEMA::predicate<566> { using type = facebook::glean::cpp::schema::Graphql::FragmentSpread; };
template<> struct SCHEMA::predicate<567> { using type = facebook::glean::cpp::schema::Graphql::Fragment; };
template<> struct SCHEMA::predicate<568> { using type = facebook::glean::cpp::schema::Graphql::FieldDef; };
template<> struct SCHEMA::predicate<569> { using type = facebook::glean::cpp::schema::Graphql::Field; };
template<> struct SCHEMA::predicate<570> { using type = facebook::glean::cpp::schema::Graphql::EnumTypeDef; };
template<> struct SCHEMA::predicate<571> { using type = facebook::glean::cpp::schema::Graphql::DirectiveDef; };
template<> struct SCHEMA::predicate<572> { using type = facebook::glean::cpp::schema::Graphql::Directive; };
template<> struct SCHEMA::predicate<573> { using type = facebook::glean::cpp::schema::Graphql::DeclarationLocation; };
template<> struct SCHEMA::predicate<574> { using type = facebook::glean::cpp::schema::Graphql::DeclarationName; };
template<> struct SCHEMA::predicate<575> { using type = facebook::glean::cpp::schema::Graphql::DeclarationUses; };
template<> struct SCHEMA::predicate<576> { using type = facebook::glean::cpp::schema::Graphql::FileDeclarations; };
template<> struct SCHEMA::predicate<577> { using type = facebook::glean::cpp::schema::Graphql::SearchByName; };
template<> struct SCHEMA::predicate<578> { using type = facebook::glean::cpp::schema::Graphql::FileXRefs; };
template<> struct SCHEMA::predicate<579> { using type = facebook::glean::cpp::schema::Graphql::DeclHasName; };
template<> struct SCHEMA::predicate<580> { using type = facebook::glean::cpp::schema::Graphql::BelongToConfig; };
template<> struct SCHEMA::predicate<581> { using type = facebook::glean::cpp::schema::Graphql::Argument; };
template<> struct SCHEMA::predicate<582> { using type = facebook::glean::cpp::schema::Glean::Test::nothingTest; };
template<> struct SCHEMA::predicate<583> { using type = facebook::glean::cpp::schema::Glean::Test::ViaStringPair; };
template<> struct SCHEMA::predicate<584> { using type = facebook::glean::cpp::schema::Glean::Test::Unbound2; };
template<> struct SCHEMA::predicate<585> { using type = facebook::glean::cpp::schema::Glean::Test::Unbound; };
template<> struct SCHEMA::predicate<586> { using type = facebook::glean::cpp::schema::Glean::Test::TreeToTree; };
template<> struct SCHEMA::predicate<587> { using type = facebook::glean::cpp::schema::Glean::Test::Tree; };
template<> struct SCHEMA::predicate<588> { using type = facebook::glean::cpp::schema::Glean::Test::StringPairBox; };
template<> struct SCHEMA::predicate<589> { using type = facebook::glean::cpp::schema::Glean::Test::StringPair; };
template<> struct SCHEMA::predicate<590> { using type = facebook::glean::cpp::schema::Glean::Test::StoredRevStringPairWithRev; };
template<> struct SCHEMA::predicate<591> { using type = facebook::glean::cpp::schema::Glean::Test::StoredRevStringPairWithA; };
template<> struct SCHEMA::predicate<592> { using type = facebook::glean::cpp::schema::Glean::Test::StoredRevStringPairSum; };
template<> struct SCHEMA::predicate<593> { using type = facebook::glean::cpp::schema::Glean::Test::StoredRevStringPair; };
template<> struct SCHEMA::predicate<594> { using type = facebook::glean::cpp::schema::Glean::Test::StoredDualStringPair; };
template<> struct SCHEMA::predicate<595> { using type = facebook::glean::cpp::schema::Glean::Test::SkipRevEdge; };
template<> struct SCHEMA::predicate<596> { using type = facebook::glean::cpp::schema::Glean::Test::SameString; };
template<> struct SCHEMA::predicate<597> { using type = facebook::glean::cpp::schema::Glean::Test::RevStringPairs; };
template<> struct SCHEMA::predicate<598> { using type = facebook::glean::cpp::schema::Glean::Test::RevStringPairRec; };
template<> struct SCHEMA::predicate<599> { using type = facebook::glean::cpp::schema::Glean::Test::RevStringPair; };
template<> struct SCHEMA::predicate<600> { using type = facebook::glean::cpp::schema::Glean::Test::RevRevStringPair; };
template<> struct SCHEMA::predicate<601> { using type = facebook::glean::cpp::schema::Glean::Test::RevEdge; };
template<> struct SCHEMA::predicate<602> { using type = facebook::glean::cpp::schema::Glean::Test::ReflStringPair; };
template<> struct SCHEMA::predicate<603> { using type = facebook::glean::cpp::schema::Glean::Test::RefRef; };
template<> struct SCHEMA::predicate<604> { using type = facebook::glean::cpp::schema::Glean::Test::Ref; };
template<> struct SCHEMA::predicate<605> { using type = facebook::glean::cpp::schema::Glean::Test::Qux; };
template<> struct SCHEMA::predicate<606> { using type = facebook::glean::cpp::schema::Glean::Test::NodePair; };
template<> struct SCHEMA::predicate<607> { using type = facebook::glean::cpp::schema::Glean::Test::Node; };
template<> struct SCHEMA::predicate<608> { using type = facebook::glean::cpp::schema::Glean::Test::Name; };
template<> struct SCHEMA::predicate<609> { using type = facebook::glean::cpp::schema::Glean::Test::MatchOneAlt; };
template<> struct SCHEMA::predicate<610> { using type = facebook::glean::cpp::schema::Glean::Test::LeftOr2; };
template<> struct SCHEMA::predicate<611> { using type = facebook::glean::cpp::schema::Glean::Test::LeftOr; };
template<> struct SCHEMA::predicate<612> { using type = facebook::glean::cpp::schema::Glean::Test::KeyValue; };
template<> struct SCHEMA::predicate<613> { using type = facebook::glean::cpp::schema::Glean::Test::IsThree; };
template<> struct SCHEMA::predicate<614> { using type = facebook::glean::cpp::schema::Glean::Test::IsParent; };
template<> struct SCHEMA::predicate<615> { using type = facebook::glean::cpp::schema::Glean::Test::IsGlean; };
template<> struct SCHEMA::predicate<616> { using type = facebook::glean::cpp::schema::Glean::Test::FooToFoo; };
template<> struct SCHEMA::predicate<617> { using type = facebook::glean::cpp::schema::Glean::Test::Foo; };
template<> struct SCHEMA::predicate<618> { using type = facebook::glean::cpp::schema::Glean::Test::Expr; };
template<> struct SCHEMA::predicate<619> { using type = facebook::glean::cpp::schema::Glean::Test::Predicate_1; };
template<> struct SCHEMA::predicate<620> { using type = facebook::glean::cpp::schema::Glean::Test::EmptyStoredStringPair; };
template<> struct SCHEMA::predicate<621> { using type = facebook::glean::cpp::schema::Glean::Test::EdgeWrapper; };
template<> struct SCHEMA::predicate<622> { using type = facebook::glean::cpp::schema::Glean::Test::Edge; };
template<> struct SCHEMA::predicate<623> { using type = facebook::glean::cpp::schema::Glean::Test::DualStringPair; };
template<> struct SCHEMA::predicate<624> { using type = facebook::glean::cpp::schema::Glean::Test::DerivedKeyValue2; };
template<> struct SCHEMA::predicate<625> { using type = facebook::glean::cpp::schema::Glean::Test::DerivedKeyValue; };
template<> struct SCHEMA::predicate<626> { using type = facebook::glean::cpp::schema::Glean::Test::Bar; };
template<> struct SCHEMA::predicate<627> { using type = facebook::glean::cpp::schema::Glean::Test::Predicate_; };
template<> struct SCHEMA::predicate<628> { using type = facebook::glean::cpp::schema::Gencode::GenCodeSignature; };
template<> struct SCHEMA::predicate<629> { using type = facebook::glean::cpp::schema::Gencode::GenCodeCommand; };
template<> struct SCHEMA::predicate<630> { using type = facebook::glean::cpp::schema::Gencode::GenCodeClass; };
template<> struct SCHEMA::predicate<631> { using type = facebook::glean::cpp::schema::Gencode::GenCodeBySource; };
template<> struct SCHEMA::predicate<632> { using type = facebook::glean::cpp::schema::Gencode::GenCode; };
template<> struct SCHEMA::predicate<633> { using type = facebook::glean::cpp::schema::Flow::TypeImportDeclaration; };
template<> struct SCHEMA::predicate<634> { using type = facebook::glean::cpp::schema::Flow::TypeExport; };
template<> struct SCHEMA::predicate<635> { using type = facebook::glean::cpp::schema::Flow::TypeDeclarationReference; };
template<> struct SCHEMA::predicate<636> { using type = facebook::glean::cpp::schema::Flow::TypeDeclarationInfo; };
template<> struct SCHEMA::predicate<637> { using type = facebook::glean::cpp::schema::Flow::TypeDeclaration; };
template<> struct SCHEMA::predicate<638> { using type = facebook::glean::cpp::schema::Flow::Type; };
template<> struct SCHEMA::predicate<639> { using type = facebook::glean::cpp::schema::Flow::StringToFileModule; };
template<> struct SCHEMA::predicate<640> { using type = facebook::glean::cpp::schema::Flow::SourceOfTypeExport; };
template<> struct SCHEMA::predicate<641> { using type = facebook::glean::cpp::schema::Flow::SourceOfExport; };
template<> struct SCHEMA::predicate<642> { using type = facebook::glean::cpp::schema::Search::Flow::FlowSearchByNameNonImport; };
template<> struct SCHEMA::predicate<643> { using type = facebook::glean::cpp::schema::Flow::SearchTypeByModuleExport; };
template<> struct SCHEMA::predicate<644> { using type = facebook::glean::cpp::schema::Flow::SearchByNameModule; };
template<> struct SCHEMA::predicate<645> { using type = facebook::glean::cpp::schema::Flow::SearchByName; };
template<> struct SCHEMA::predicate<646> { using type = facebook::glean::cpp::schema::Flow::SearchByModule; };
template<> struct SCHEMA::predicate<647> { using type = facebook::glean::cpp::schema::Flow::SearchByFileModule; };
template<> struct SCHEMA::predicate<648> { using type = facebook::glean::cpp::schema::Flow::Range; };
template<> struct SCHEMA::predicate<649> { using type = facebook::glean::cpp::schema::Flow::NameLowerCase; };
template<> struct SCHEMA::predicate<650> { using type = facebook::glean::cpp::schema::Flow::Name; };
template<> struct SCHEMA::predicate<651> { using type = facebook::glean::cpp::schema::Flow::ModuleTypeExport; };
template<> struct SCHEMA::predicate<652> { using type = facebook::glean::cpp::schema::Flow::ModuleNameLowerCase; };
template<> struct SCHEMA::predicate<653> { using type = facebook::glean::cpp::schema::Flow::ModuleLocationByFile; };
template<> struct SCHEMA::predicate<654> { using type = facebook::glean::cpp::schema::Flow::ModuleLocation; };
template<> struct SCHEMA::predicate<655> { using type = facebook::glean::cpp::schema::Flow::ModuleExport; };
template<> struct SCHEMA::predicate<656> { using type = facebook::glean::cpp::schema::Flow::ModuleDoc; };
template<> struct SCHEMA::predicate<657> { using type = facebook::glean::cpp::schema::Flow::ModuleContains; };
template<> struct SCHEMA::predicate<658> { using type = facebook::glean::cpp::schema::Flow::ModuleComments; };
template<> struct SCHEMA::predicate<659> { using type = facebook::glean::cpp::schema::Flow::Module; };
template<> struct SCHEMA::predicate<660> { using type = facebook::glean::cpp::schema::Flow::MemberDeclarationReference; };
template<> struct SCHEMA::predicate<661> { using type = facebook::glean::cpp::schema::Flow::MemberDeclarationInfo; };
template<> struct SCHEMA::predicate<662> { using type = facebook::glean::cpp::schema::Flow::MemberDeclaration; };
template<> struct SCHEMA::predicate<663> { using type = facebook::glean::cpp::schema::Flow::LocalDeclarationReference; };
template<> struct SCHEMA::predicate<664> { using type = facebook::glean::cpp::schema::Flow::ImportDeclaration; };
template<> struct SCHEMA::predicate<665> { using type = facebook::glean::cpp::schema::Flow::FlowXRefDeclInfo; };
template<> struct SCHEMA::predicate<666> { using type = facebook::glean::cpp::schema::Flow::FlowTypeImportXRef; };
template<> struct SCHEMA::predicate<667> { using type = facebook::glean::cpp::schema::Flow::FlowTypeExportLocation; };
template<> struct SCHEMA::predicate<668> { using type = facebook::glean::cpp::schema::Flow::FlowTypeEntityImportUses; };
template<> struct SCHEMA::predicate<669> { using type = facebook::glean::cpp::schema::Flow::FlowSameModule; };
template<> struct SCHEMA::predicate<670> { using type = facebook::glean::cpp::schema::Flow::FlowModuleNamespaceXRef; };
template<> struct SCHEMA::predicate<671> { using type = facebook::glean::cpp::schema::Flow::FlowImportXRef; };
template<> struct SCHEMA::predicate<672> { using type = facebook::glean::cpp::schema::Flow::FlowExportLocation; };
template<> struct SCHEMA::predicate<673> { using type = facebook::glean::cpp::schema::Flow::FlowEntityUsesAll; };
template<> struct SCHEMA::predicate<674> { using type = facebook::glean::cpp::schema::Flow::FlowEntityImportUses; };
template<> struct SCHEMA::predicate<675> { using type = facebook::glean::cpp::schema::Flow::FlowCompatibleExport; };
template<> struct SCHEMA::predicate<676> { using type = facebook::glean::cpp::schema::Flow::FileXRef; };
template<> struct SCHEMA::predicate<677> { using type = facebook::glean::cpp::schema::Flow::FileOfStringModule; };
template<> struct SCHEMA::predicate<678> { using type = facebook::glean::cpp::schema::Flow::FileDeclaration; };
template<> struct SCHEMA::predicate<679> { using type = facebook::glean::cpp::schema::Flow::Export; };
template<> struct SCHEMA::predicate<680> { using type = facebook::glean::cpp::schema::Flow::Documentation; };
template<> struct SCHEMA::predicate<681> { using type = facebook::glean::cpp::schema::Flow::DeclarationUses; };
template<> struct SCHEMA::predicate<682> { using type = facebook::glean::cpp::schema::Flow::DeclarationSignature; };
template<> struct SCHEMA::predicate<683> { using type = facebook::glean::cpp::schema::Flow::DeclarationNameSpan; };
template<> struct SCHEMA::predicate<684> { using type = facebook::glean::cpp::schema::Flow::DeclarationLocation; };
template<> struct SCHEMA::predicate<685> { using type = facebook::glean::cpp::schema::Flow::DeclarationInfo; };
template<> struct SCHEMA::predicate<686> { using type = facebook::glean::cpp::schema::Flow::Declaration; };
template<> struct SCHEMA::predicate<687> { using type = facebook::glean::cpp::schema::Fbthrift::UnionVal; };
template<> struct SCHEMA::predicate<688> { using type = facebook::glean::cpp::schema::Fbthrift::StructuredAnnotation; };
template<> struct SCHEMA::predicate<689> { using type = facebook::glean::cpp::schema::Fbthrift::StructVal; };
template<> struct SCHEMA::predicate<690> { using type = facebook::glean::cpp::schema::Fbthrift::ServiceParent; };
template<> struct SCHEMA::predicate<691> { using type = facebook::glean::cpp::schema::Fbthrift::ServiceName; };
template<> struct SCHEMA::predicate<692> { using type = facebook::glean::cpp::schema::Fbthrift::ServiceInteractionFunctions; };
template<> struct SCHEMA::predicate<693> { using type = facebook::glean::cpp::schema::Fbthrift::ServiceDefinition; };
template<> struct SCHEMA::predicate<694> { using type = facebook::glean::cpp::schema::Fbthrift::ServiceChild; };
template<> struct SCHEMA::predicate<695> { using type = facebook::glean::cpp::schema::Fbthrift::SearchByName; };
template<> struct SCHEMA::predicate<696> { using type = facebook::glean::cpp::schema::Fbthrift::QualName; };
template<> struct SCHEMA::predicate<697> { using type = facebook::glean::cpp::schema::Fbthrift::PackageName; };
template<> struct SCHEMA::predicate<698> { using type = facebook::glean::cpp::schema::Fbthrift::Package; };
template<> struct SCHEMA::predicate<699> { using type = facebook::glean::cpp::schema::Fbthrift::NamespaceValue; };
template<> struct SCHEMA::predicate<700> { using type = facebook::glean::cpp::schema::Fbthrift::NamespaceName; };
template<> struct SCHEMA::predicate<701> { using type = facebook::glean::cpp::schema::Fbthrift::Namespace; };
template<> struct SCHEMA::predicate<702> { using type = facebook::glean::cpp::schema::Fbthrift::NamedDecl; };
template<> struct SCHEMA::predicate<703> { using type = facebook::glean::cpp::schema::Fbthrift::NameLowerCase; };
template<> struct SCHEMA::predicate<704> { using type = facebook::glean::cpp::schema::Fbthrift::InteractionName; };
template<> struct SCHEMA::predicate<705> { using type = facebook::glean::cpp::schema::Fbthrift::InteractionDefinition; };
template<> struct SCHEMA::predicate<706> { using type = facebook::glean::cpp::schema::Fbthrift::Identifier; };
template<> struct SCHEMA::predicate<707> { using type = facebook::glean::cpp::schema::Fbthrift::FunctionName; };
template<> struct SCHEMA::predicate<708> { using type = facebook::glean::cpp::schema::Fbthrift::Literal; };
template<> struct SCHEMA::predicate<709> { using type = facebook::glean::cpp::schema::Fbthrift::FileXRefs; };
template<> struct SCHEMA::predicate<710> { using type = facebook::glean::cpp::schema::Fbthrift::File; };
template<> struct SCHEMA::predicate<711> { using type = facebook::glean::cpp::schema::Fbthrift::StructType; };
template<> struct SCHEMA::predicate<712> { using type = facebook::glean::cpp::schema::Fbthrift::UnionType; };
template<> struct SCHEMA::predicate<713> { using type = facebook::glean::cpp::schema::Fbthrift::ExceptionVal; };
template<> struct SCHEMA::predicate<714> { using type = facebook::glean::cpp::schema::Fbthrift::ExceptionType; };
template<> struct SCHEMA::predicate<715> { using type = facebook::glean::cpp::schema::Fbthrift::TypeDefException; };
template<> struct SCHEMA::predicate<716> { using type = facebook::glean::cpp::schema::Fbthrift::ExceptionName; };
template<> struct SCHEMA::predicate<717> { using type = facebook::glean::cpp::schema::Fbthrift::EnumerationType; };
template<> struct SCHEMA::predicate<718> { using type = facebook::glean::cpp::schema::Fbthrift::EnumValueDef; };
template<> struct SCHEMA::predicate<719> { using type = facebook::glean::cpp::schema::Fbthrift::EnumValue; };
template<> struct SCHEMA::predicate<720> { using type = facebook::glean::cpp::schema::Fbthrift::EnumVal; };
template<> struct SCHEMA::predicate<721> { using type = facebook::glean::cpp::schema::Fbthrift::DeclarationComment; };
template<> struct SCHEMA::predicate<722> { using type = facebook::glean::cpp::schema::Fbthrift::DeclarationFile; };
template<> struct SCHEMA::predicate<723> { using type = facebook::glean::cpp::schema::Fbthrift::DeclarationName; };
template<> struct SCHEMA::predicate<724> { using type = facebook::glean::cpp::schema::Fbthrift::DeclarationNameSpan; };
template<> struct SCHEMA::predicate<725> { using type = facebook::glean::cpp::schema::Fbthrift::DeclarationUses; };
template<> struct SCHEMA::predicate<726> { using type = facebook::glean::cpp::schema::Fbthrift::FileDeclaration; };
template<> struct SCHEMA::predicate<727> { using type = facebook::glean::cpp::schema::Fbthrift::FunctionDeclarationName; };
template<> struct SCHEMA::predicate<728> { using type = facebook::glean::cpp::schema::Hack::HackToThrift; };
template<> struct SCHEMA::predicate<729> { using type = facebook::glean::cpp::schema::Hack::ThriftToHack; };
template<> struct SCHEMA::predicate<730> { using type = facebook::glean::cpp::schema::Fbthrift::TypeSpecification; };
template<> struct SCHEMA::predicate<731> { using type = facebook::glean::cpp::schema::Fbthrift::Constant; };
template<> struct SCHEMA::predicate<732> { using type = facebook::glean::cpp::schema::Erlang::NameLowerCase; };
template<> struct SCHEMA::predicate<733> { using type = facebook::glean::cpp::schema::Erlang::FunctionDeclaration; };
template<> struct SCHEMA::predicate<734> { using type = facebook::glean::cpp::schema::Erlang::XRefsViaFqnByFile; };
template<> struct SCHEMA::predicate<735> { using type = facebook::glean::cpp::schema::Erlang::DeclarationComment; };
template<> struct SCHEMA::predicate<736> { using type = facebook::glean::cpp::schema::Erlang::DeclarationLocation; };
template<> struct SCHEMA::predicate<737> { using type = facebook::glean::cpp::schema::Erlang::DeclarationReference; };
template<> struct SCHEMA::predicate<738> { using type = facebook::glean::cpp::schema::Erlang::DeclarationToFqn; };
template<> struct SCHEMA::predicate<739> { using type = facebook::glean::cpp::schema::Erlang::DeclarationUses; };
template<> struct SCHEMA::predicate<740> { using type = facebook::glean::cpp::schema::Erlang::DeclarationWithFqn; };
template<> struct SCHEMA::predicate<741> { using type = facebook::glean::cpp::schema::Erlang::DeclarationsByFile; };
template<> struct SCHEMA::predicate<742> { using type = facebook::glean::cpp::schema::Erlang::SearchByName; };
template<> struct SCHEMA::predicate<743> { using type = facebook::glean::cpp::schema::Dyn::ObserverIdentifier; };
template<> struct SCHEMA::predicate<744> { using type = facebook::glean::cpp::schema::Dyn::Environment; };
template<> struct SCHEMA::predicate<745> { using type = facebook::glean::cpp::schema::Dyn::EntityDynamicReference; };
template<> struct SCHEMA::predicate<746> { using type = facebook::glean::cpp::schema::Digest::FileDigest; };
template<> struct SCHEMA::predicate<747> { using type = facebook::glean::cpp::schema::Glass::FileInfo; };
template<> struct SCHEMA::predicate<748> { using type = facebook::glean::cpp::schema::Deadcode::GraphNodeByEntity; };
template<> struct SCHEMA::predicate<749> { using type = facebook::glean::cpp::schema::Deadcode::GraphNode; };
template<> struct SCHEMA::predicate<750> { using type = facebook::glean::cpp::schema::Deadcode::GraphInverseEdge; };
template<> struct SCHEMA::predicate<751> { using type = facebook::glean::cpp::schema::Deadcode::GraphEntityByFile; };
template<> struct SCHEMA::predicate<752> { using type = facebook::glean::cpp::schema::Deadcode::GraphEdge; };
template<> struct SCHEMA::predicate<753> { using type = facebook::glean::cpp::schema::Cxx1::UsingDirective; };
template<> struct SCHEMA::predicate<754> { using type = facebook::glean::cpp::schema::Cxx1::UsingDeclaration; };
template<> struct SCHEMA::predicate<755> { using type = facebook::glean::cpp::schema::Cxx1::TypeAliasDeclaration; };
template<> struct SCHEMA::predicate<756> { using type = facebook::glean::cpp::schema::Cxx1::Type; };
template<> struct SCHEMA::predicate<757> { using type = facebook::glean::cpp::schema::Cxx1::TranslationUnitXRefs; };
template<> struct SCHEMA::predicate<758> { using type = facebook::glean::cpp::schema::Cxx1::TranslationUnitTrace; };
template<> struct SCHEMA::predicate<759> { using type = facebook::glean::cpp::schema::Cxx1::TranslationUnitIncludeTree; };
template<> struct SCHEMA::predicate<760> { using type = facebook::glean::cpp::schema::Cxx1::Trace; };
template<> struct SCHEMA::predicate<761> { using type = facebook::glean::cpp::schema::Cxx1::RecordDerived; };
template<> struct SCHEMA::predicate<762> { using type = facebook::glean::cpp::schema::Cxx1::Signature; };
template<> struct SCHEMA::predicate<763> { using type = facebook::glean::cpp::schema::Cxx1::PPDefineLocation; };
template<> struct SCHEMA::predicate<764> { using type = facebook::glean::cpp::schema::Cxx1::ObjcSelector; };
template<> struct SCHEMA::predicate<765> { using type = facebook::glean::cpp::schema::Cxx1::ObjcPropertyImplementation; };
template<> struct SCHEMA::predicate<766> { using type = facebook::glean::cpp::schema::Cxx1::ObjcPropertyIVar; };
template<> struct SCHEMA::predicate<767> { using type = facebook::glean::cpp::schema::Cxx1::ObjcMethodDefinition; };
template<> struct SCHEMA::predicate<768> { using type = facebook::glean::cpp::schema::Cxx1::ObjcMethodDeclarationName; };
template<> struct SCHEMA::predicate<769> { using type = facebook::glean::cpp::schema::Cxx1::ObjcInterfaceToImplementation; };
template<> struct SCHEMA::predicate<770> { using type = facebook::glean::cpp::schema::Cxx1::ObjcImplements; };
template<> struct SCHEMA::predicate<771> { using type = facebook::glean::cpp::schema::Cxx1::ObjcContainerInheritance; };
template<> struct SCHEMA::predicate<772> { using type = facebook::glean::cpp::schema::Cxx1::ObjcContainerDefinition; };
template<> struct SCHEMA::predicate<773> { using type = facebook::glean::cpp::schema::Cxx1::ObjcContainerBase; };
template<> struct SCHEMA::predicate<774> { using type = facebook::glean::cpp::schema::Cxx1::ObjcContainerDeclaration; };
template<> struct SCHEMA::predicate<775> { using type = facebook::glean::cpp::schema::Cxx1::ObjcMethodDeclaration; };
template<> struct SCHEMA::predicate<776> { using type = facebook::glean::cpp::schema::Cxx1::ObjcPropertyDeclaration; };
template<> struct SCHEMA::predicate<777> { using type = facebook::glean::cpp::schema::Cxx1::ObjContainerIdName; };
template<> struct SCHEMA::predicate<778> { using type = facebook::glean::cpp::schema::Cxx1::NamespaceQName; };
template<> struct SCHEMA::predicate<779> { using type = facebook::glean::cpp::schema::Cxx1::NamespaceDefinition; };
template<> struct SCHEMA::predicate<780> { using type = facebook::glean::cpp::schema::Cxx1::NamespaceDeclarationName; };
template<> struct SCHEMA::predicate<781> { using type = facebook::glean::cpp::schema::Cxx1::NamespaceDeclaration; };
template<> struct SCHEMA::predicate<782> { using type = facebook::glean::cpp::schema::Cxx1::NamespaceAliasDeclaration; };
template<> struct SCHEMA::predicate<783> { using type = facebook::glean::cpp::schema::Cxx1::Name; };
template<> struct SCHEMA::predicate<784> { using type = facebook::glean::cpp::schema::Cxx1::MethodOverrides; };
template<> struct SCHEMA::predicate<785> { using type = facebook::glean::cpp::schema::Cxx1::MethodOverridden; };
template<> struct SCHEMA::predicate<786> { using type = facebook::glean::cpp::schema::Cxx1::IncludeTree; };
template<> struct SCHEMA::predicate<787> { using type = facebook::glean::cpp::schema::Cxx1::PPTrace; };
template<> struct SCHEMA::predicate<788> { using type = facebook::glean::cpp::schema::Cxx1::FunctionDefinition; };
template<> struct SCHEMA::predicate<789> { using type = facebook::glean::cpp::schema::Cxx1::FunctionDeclarationNameString; };
template<> struct SCHEMA::predicate<790> { using type = facebook::glean::cpp::schema::Cxx1::FunctionDeclarationName; };
template<> struct SCHEMA::predicate<791> { using type = facebook::glean::cpp::schema::Cxx1::FunctionDeclaration; };
template<> struct SCHEMA::predicate<792> { using type = facebook::glean::cpp::schema::Cxx1::FunctionDeclAttribute; };
template<> struct SCHEMA::predicate<793> { using type = facebook::glean::cpp::schema::Cxx1::FunctionAttribute; };
template<> struct SCHEMA::predicate<794> { using type = facebook::glean::cpp::schema::Cxx1::FileXRefs; };
template<> struct SCHEMA::predicate<795> { using type = facebook::glean::cpp::schema::Cxx1::FilePPUseXRefs; };
template<> struct SCHEMA::predicate<796> { using type = facebook::glean::cpp::schema::Cxx1::FilePPUseTraceXRefs; };
template<> struct SCHEMA::predicate<797> { using type = facebook::glean::cpp::schema::Cxx1::FilePPTraceXRefs; };
template<> struct SCHEMA::predicate<798> { using type = facebook::glean::cpp::schema::Cxx1::VariableDeclaration; };
template<> struct SCHEMA::predicate<799> { using type = facebook::glean::cpp::schema::Cxx1::EnumeratorInEnum; };
template<> struct SCHEMA::predicate<800> { using type = facebook::glean::cpp::schema::Cxx1::Enumerator; };
template<> struct SCHEMA::predicate<801> { using type = facebook::glean::cpp::schema::Cxx1::EnumDefinition; };
template<> struct SCHEMA::predicate<802> { using type = facebook::glean::cpp::schema::Cxx1::EnumDeclaration; };
template<> struct SCHEMA::predicate<803> { using type = facebook::glean::cpp::schema::Cxx1::DefnInRecord; };
template<> struct SCHEMA::predicate<804> { using type = facebook::glean::cpp::schema::Cxx1::DeclarationComment; };
template<> struct SCHEMA::predicate<805> { using type = facebook::glean::cpp::schema::Cxx1::DeclarationInTrace; };
template<> struct SCHEMA::predicate<806> { using type = facebook::glean::cpp::schema::Cxx1::DeclarationLocationName; };
template<> struct SCHEMA::predicate<807> { using type = facebook::glean::cpp::schema::Cxx1::DeclarationLocationNameSpan; };
template<> struct SCHEMA::predicate<808> { using type = facebook::glean::cpp::schema::Cxx1::DeclarationNameSpan; };
template<> struct SCHEMA::predicate<809> { using type = facebook::glean::cpp::schema::Cxx1::DeclarationSources; };
template<> struct SCHEMA::predicate<810> { using type = facebook::glean::cpp::schema::Cxx1::DeclarationSrcRange; };
template<> struct SCHEMA::predicate<811> { using type = facebook::glean::cpp::schema::Cxx1::DeclarationTargets; };
template<> struct SCHEMA::predicate<812> { using type = facebook::glean::cpp::schema::Cxx1::DeclarationToUSR; };
template<> struct SCHEMA::predicate<813> { using type = facebook::glean::cpp::schema::Cxx1::Declarations; };
template<> struct SCHEMA::predicate<814> { using type = facebook::glean::cpp::schema::Cxx1::DefToBaseDecl; };
template<> struct SCHEMA::predicate<815> { using type = facebook::glean::cpp::schema::Cxx1::Same; };
template<> struct SCHEMA::predicate<816> { using type = facebook::glean::cpp::schema::Cxx1::USRToDeclaration; };
template<> struct SCHEMA::predicate<817> { using type = facebook::glean::cpp::schema::Cxx1::FileXRefMap; };
template<> struct SCHEMA::predicate<818> { using type = facebook::glean::cpp::schema::Cxx1::SpellingXRef; };
template<> struct SCHEMA::predicate<819> { using type = facebook::glean::cpp::schema::Cxx1::TargetUses; };
template<> struct SCHEMA::predicate<820> { using type = facebook::glean::cpp::schema::Cxx1::XRefIndirectTarget; };
template<> struct SCHEMA::predicate<821> { using type = facebook::glean::cpp::schema::Cxx1::XRefTargets; };
template<> struct SCHEMA::predicate<822> { using type = facebook::glean::cpp::schema::Search::Cxx::GlobalDeclarationWithName; };
template<> struct SCHEMA::predicate<823> { using type = facebook::glean::cpp::schema::Symbolid::Cxx::LookupNamespaceDeclaration; };
template<> struct SCHEMA::predicate<824> { using type = facebook::glean::cpp::schema::Thrift::FromCpp2; };
template<> struct SCHEMA::predicate<825> { using type = facebook::glean::cpp::schema::Cxx1::DeclToFamily; };
template<> struct SCHEMA::predicate<826> { using type = facebook::glean::cpp::schema::Cxx1::DeclInRecord; };
template<> struct SCHEMA::predicate<827> { using type = facebook::glean::cpp::schema::Cxx1::DeclInObjcContainer; };
template<> struct SCHEMA::predicate<828> { using type = facebook::glean::cpp::schema::Cxx1::DeclFamilyOf; };
template<> struct SCHEMA::predicate<829> { using type = facebook::glean::cpp::schema::Cxx1::DeclFamily; };
template<> struct SCHEMA::predicate<830> { using type = facebook::glean::cpp::schema::Cxx1::DeclByName; };
template<> struct SCHEMA::predicate<831> { using type = facebook::glean::cpp::schema::Cxx1::CxxToThrift; };
template<> struct SCHEMA::predicate<832> { using type = facebook::glean::cpp::schema::Cxx1::Attribute; };
template<> struct SCHEMA::predicate<833> { using type = facebook::glean::cpp::schema::Cxx1::RecordDefinition; };
template<> struct SCHEMA::predicate<834> { using type = facebook::glean::cpp::schema::Csharp::UnityPackageToProject; };
template<> struct SCHEMA::predicate<835> { using type = facebook::glean::cpp::schema::Csharp::UnityPackage; };
template<> struct SCHEMA::predicate<836> { using type = facebook::glean::cpp::schema::Csharp::UnityProjectSource; };
template<> struct SCHEMA::predicate<837> { using type = facebook::glean::cpp::schema::Csharp::TypeParameter; };
template<> struct SCHEMA::predicate<838> { using type = facebook::glean::cpp::schema::Csharp::SourceFileToProject; };
template<> struct SCHEMA::predicate<839> { using type = facebook::glean::cpp::schema::Csharp::SolutionToProject; };
template<> struct SCHEMA::predicate<840> { using type = facebook::glean::cpp::schema::Csharp::Solution; };
template<> struct SCHEMA::predicate<841> { using type = facebook::glean::cpp::schema::Csharp::ProjectToSourceFile; };
template<> struct SCHEMA::predicate<842> { using type = facebook::glean::cpp::schema::Csharp::ProjectToSolution; };
template<> struct SCHEMA::predicate<843> { using type = facebook::glean::cpp::schema::Csharp::Project; };
template<> struct SCHEMA::predicate<844> { using type = facebook::glean::cpp::schema::Csharp::Namespace; };
template<> struct SCHEMA::predicate<845> { using type = facebook::glean::cpp::schema::Csharp::NameLowerCase; };
template<> struct SCHEMA::predicate<846> { using type = facebook::glean::cpp::schema::Csharp::Name; };
template<> struct SCHEMA::predicate<847> { using type = facebook::glean::cpp::schema::Csharp::MSBuildProjectSource; };
template<> struct SCHEMA::predicate<848> { using type = facebook::glean::cpp::schema::Csharp::MemberAccessLocation; };
template<> struct SCHEMA::predicate<849> { using type = facebook::glean::cpp::schema::Csharp::MethodInvocationLocation; };
template<> struct SCHEMA::predicate<850> { using type = facebook::glean::cpp::schema::Csharp::Implements; };
template<> struct SCHEMA::predicate<851> { using type = facebook::glean::cpp::schema::Csharp::FunctionPointerType; };
template<> struct SCHEMA::predicate<852> { using type = facebook::glean::cpp::schema::Csharp::FullName; };
template<> struct SCHEMA::predicate<853> { using type = facebook::glean::cpp::schema::Csharp::Class; };
template<> struct SCHEMA::predicate<854> { using type = facebook::glean::cpp::schema::Csharp::Interface; };
template<> struct SCHEMA::predicate<855> { using type = facebook::glean::cpp::schema::Csharp::Record; };
template<> struct SCHEMA::predicate<856> { using type = facebook::glean::cpp::schema::Csharp::Struct; };
template<> struct SCHEMA::predicate<857> { using type = facebook::glean::cpp::schema::Csharp::ArrayType; };
template<> struct SCHEMA::predicate<858> { using type = facebook::glean::cpp::schema::Csharp::DefinitionLocation; };
template<> struct SCHEMA::predicate<859> { using type = facebook::glean::cpp::schema::Csharp::DefinitionLocationName; };
template<> struct SCHEMA::predicate<860> { using type = facebook::glean::cpp::schema::Csharp::FileDefinitions; };
template<> struct SCHEMA::predicate<861> { using type = facebook::glean::cpp::schema::Csharp::FileEntityXRefs; };
template<> struct SCHEMA::predicate<862> { using type = facebook::glean::cpp::schema::Csharp::SearchByName; };
template<> struct SCHEMA::predicate<863> { using type = facebook::glean::cpp::schema::Csharp::Field; };
template<> struct SCHEMA::predicate<864> { using type = facebook::glean::cpp::schema::Csharp::Local; };
template<> struct SCHEMA::predicate<865> { using type = facebook::glean::cpp::schema::Csharp::Method; };
template<> struct SCHEMA::predicate<866> { using type = facebook::glean::cpp::schema::Csharp::ObjectCreationLocation; };
template<> struct SCHEMA::predicate<867> { using type = facebook::glean::cpp::schema::Csharp::Parameter; };
template<> struct SCHEMA::predicate<868> { using type = facebook::glean::cpp::schema::Csharp::PointerType; };
template<> struct SCHEMA::predicate<869> { using type = facebook::glean::cpp::schema::Csharp::Property; };
template<> struct SCHEMA::predicate<870> { using type = facebook::glean::cpp::schema::Csharp::TypeLocation; };
template<> struct SCHEMA::predicate<871> { using type = facebook::glean::cpp::schema::Contbuild::Owner; };
template<> struct SCHEMA::predicate<872> { using type = facebook::glean::cpp::schema::Contbuild::IndexerName; };
template<> struct SCHEMA::predicate<873> { using type = facebook::glean::cpp::schema::Contbuild::FileToContbuild; };
template<> struct SCHEMA::predicate<874> { using type = facebook::glean::cpp::schema::Contbuild::IndexFailure; };
template<> struct SCHEMA::predicate<875> { using type = facebook::glean::cpp::schema::Contbuild::ContbuildName; };
template<> struct SCHEMA::predicate<876> { using type = facebook::glean::cpp::schema::Contbuild::ContbuildLocator; };
template<> struct SCHEMA::predicate<877> { using type = facebook::glean::cpp::schema::Contbuild::ContbuildFbpkg; };
template<> struct SCHEMA::predicate<878> { using type = facebook::glean::cpp::schema::Configerator::ImportFilesStatement; };
template<> struct SCHEMA::predicate<879> { using type = facebook::glean::cpp::schema::Codexref::SymbolName; };
template<> struct SCHEMA::predicate<880> { using type = facebook::glean::cpp::schema::Codemetrics::CxxRecordReferenceTo; };
template<> struct SCHEMA::predicate<881> { using type = facebook::glean::cpp::schema::Codemetrics::CxxRecordReference; };
template<> struct SCHEMA::predicate<882> { using type = facebook::glean::cpp::schema::Codexref::IncomingXRefs; };
template<> struct SCHEMA::predicate<883> { using type = facebook::glean::cpp::schema::Codexref::OutgoingXRefs; };
template<> struct SCHEMA::predicate<884> { using type = facebook::glean::cpp::schema::Codemarkup::Types::RangeSpanContains; };
template<> struct SCHEMA::predicate<885> { using type = facebook::glean::cpp::schema::Codemarkup::Scip::LsifKindToKind; };
template<> struct SCHEMA::predicate<886> { using type = facebook::glean::cpp::schema::Codemarkup::Python::NonImportPythonDeclarationKind; };
template<> struct SCHEMA::predicate<887> { using type = facebook::glean::cpp::schema::Codemarkup::Python::NonImportPythonDeclarationInfo; };
template<> struct SCHEMA::predicate<888> { using type = facebook::glean::cpp::schema::Codemarkup::Python::ConvertLabel; };
template<> struct SCHEMA::predicate<889> { using type = facebook::glean::cpp::schema::Codemarkup::Pp::PpIncludeXRefLocations; };
template<> struct SCHEMA::predicate<890> { using type = facebook::glean::cpp::schema::Codemarkup::Lsif::LsifKindToKind; };
template<> struct SCHEMA::predicate<891> { using type = facebook::glean::cpp::schema::Codemarkup::Hack::HackEnumInheritedMembers; };
template<> struct SCHEMA::predicate<892> { using type = facebook::glean::cpp::schema::Codemarkup::Hack::FromHackVisibility; };
template<> struct SCHEMA::predicate<893> { using type = facebook::glean::cpp::schema::Codemarkup::Flow::FlowDocumentationSpan; };
template<> struct SCHEMA::predicate<894> { using type = facebook::glean::cpp::schema::Codemarkup::Flow::FlowDeclarationDocumentation; };
template<> struct SCHEMA::predicate<895> { using type = facebook::glean::cpp::schema::Codemarkup::Cxx::FromCxxVisibility; };
template<> struct SCHEMA::predicate<896> { using type = facebook::glean::cpp::schema::Codemarkup::Cxx::CxxFileEntityXMapVariableXRefDeclLocations; };
template<> struct SCHEMA::predicate<897> { using type = facebook::glean::cpp::schema::Codemarkup::Cxx::CxxDeclarationModifiers; };
template<> struct SCHEMA::predicate<898> { using type = facebook::glean::cpp::schema::Codemarkup::Cxx::CxxDeclVisibility; };
template<> struct SCHEMA::predicate<899> { using type = facebook::glean::cpp::schema::Codemarkup::Cxx::CxxDeclKind; };
template<> struct SCHEMA::predicate<900> { using type = facebook::glean::cpp::schema::Codemarkup::Cxx::CxxDeclInfo; };
template<> struct SCHEMA::predicate<901> { using type = facebook::glean::cpp::schema::Codemarkup::Cxx::CxxDataAvailable; };
template<> struct SCHEMA::predicate<902> { using type = facebook::glean::cpp::schema::Codemarkup::IndexedFile; };
template<> struct SCHEMA::predicate<903> { using type = facebook::glean::cpp::schema::Codemarkup::EntityDataAvailable; };
template<> struct SCHEMA::predicate<904> { using type = facebook::glean::cpp::schema::Codemarkup::Scip::EntityInfo; };
template<> struct SCHEMA::predicate<905> { using type = facebook::glean::cpp::schema::Codemarkup::Scip::ScipEntityLocation; };
template<> struct SCHEMA::predicate<906> { using type = facebook::glean::cpp::schema::Codemarkup::Scip::ScipEntityUses; };
template<> struct SCHEMA::predicate<907> { using type = facebook::glean::cpp::schema::Codemarkup::Scip::ScipFileEntityXRefLocations; };
template<> struct SCHEMA::predicate<908> { using type = facebook::glean::cpp::schema::Codemarkup::Scip::ScipResolveLocation; };
template<> struct SCHEMA::predicate<909> { using type = facebook::glean::cpp::schema::Code::Quality::Repository; };
template<> struct SCHEMA::predicate<910> { using type = facebook::glean::cpp::schema::Code::Quality::Producer; };
template<> struct SCHEMA::predicate<911> { using type = facebook::glean::cpp::schema::Code::Quality::Integration; };
template<> struct SCHEMA::predicate<912> { using type = facebook::glean::cpp::schema::Code::Quality::FlagType; };
template<> struct SCHEMA::predicate<913> { using type = facebook::glean::cpp::schema::Code::Quality::FlagName; };
template<> struct SCHEMA::predicate<914> { using type = facebook::glean::cpp::schema::Code::Quality::FlagInfo; };
template<> struct SCHEMA::predicate<915> { using type = facebook::glean::cpp::schema::Code::Quality::Detail; };
template<> struct SCHEMA::predicate<916> { using type = facebook::glean::cpp::schema::Code::Quality::Category; };
template<> struct SCHEMA::predicate<917> { using type = facebook::glean::cpp::schema::Codemarkup::Python::PythonContainsChildEntity; };
template<> struct SCHEMA::predicate<918> { using type = facebook::glean::cpp::schema::Codemarkup::Python::PythonContainsParentEntity; };
template<> struct SCHEMA::predicate<919> { using type = facebook::glean::cpp::schema::Codemarkup::Python::PythonEntityComments; };
template<> struct SCHEMA::predicate<920> { using type = facebook::glean::cpp::schema::Codemarkup::Python::PythonEntityInfo; };
template<> struct SCHEMA::predicate<921> { using type = facebook::glean::cpp::schema::Codemarkup::Python::PythonEntityKind; };
template<> struct SCHEMA::predicate<922> { using type = facebook::glean::cpp::schema::Codemarkup::Python::PythonEntityLocation; };
template<> struct SCHEMA::predicate<923> { using type = facebook::glean::cpp::schema::Codemarkup::Python::PythonEntityModuleName; };
template<> struct SCHEMA::predicate<924> { using type = facebook::glean::cpp::schema::Codemarkup::Python::PythonEntityUses; };
template<> struct SCHEMA::predicate<925> { using type = facebook::glean::cpp::schema::Codemarkup::Python::PythonExtendsChildEntity; };
template<> struct SCHEMA::predicate<926> { using type = facebook::glean::cpp::schema::Codemarkup::Python::PythonExtendsParentEntity; };
template<> struct SCHEMA::predicate<927> { using type = facebook::glean::cpp::schema::Codemarkup::Python::PythonFileEntityXRefLocations; };
template<> struct SCHEMA::predicate<928> { using type = facebook::glean::cpp::schema::Codemarkup::Python::PythonModifiers; };
template<> struct SCHEMA::predicate<929> { using type = facebook::glean::cpp::schema::Codemarkup::Python::PythonResolveLocation; };
template<> struct SCHEMA::predicate<930> { using type = facebook::glean::cpp::schema::Codemarkup::Python::PythonVisibility; };
template<> struct SCHEMA::predicate<931> { using type = facebook::glean::cpp::schema::Codemarkup::Python::PythonAnnotation; };
template<> struct SCHEMA::predicate<932> { using type = facebook::glean::cpp::schema::Codemarkup::Pp::PPEntityLocation; };
template<> struct SCHEMA::predicate<933> { using type = facebook::glean::cpp::schema::Codemarkup::Pp::PpEntityInfo; };
template<> struct SCHEMA::predicate<934> { using type = facebook::glean::cpp::schema::Codemarkup::Pp::PpEntityKind; };
template<> struct SCHEMA::predicate<935> { using type = facebook::glean::cpp::schema::Codemarkup::Pp::PpEntityTraceXRefLocations; };
template<> struct SCHEMA::predicate<936> { using type = facebook::glean::cpp::schema::Codemarkup::Pp::PpEntityUses; };
template<> struct SCHEMA::predicate<937> { using type = facebook::glean::cpp::schema::Codemarkup::Pp::PpFileEntityXRefLocations; };
template<> struct SCHEMA::predicate<938> { using type = facebook::glean::cpp::schema::Codemarkup::Pp::PpResolveLocation; };
template<> struct SCHEMA::predicate<939> { using type = facebook::glean::cpp::schema::Codemarkup::Pp::PpResolveTraceLocation; };
template<> struct SCHEMA::predicate<940> { using type = facebook::glean::cpp::schema::Codemarkup::Lsif::EntityInfo; };
template<> struct SCHEMA::predicate<941> { using type = facebook::glean::cpp::schema::Codemarkup::Lsif::LsifEntityLocation; };
template<> struct SCHEMA::predicate<942> { using type = facebook::glean::cpp::schema::Codemarkup::Lsif::LsifEntityModuleName; };
template<> struct SCHEMA::predicate<943> { using type = facebook::glean::cpp::schema::Codemarkup::Lsif::LsifEntityUses; };
template<> struct SCHEMA::predicate<944> { using type = facebook::glean::cpp::schema::Codemarkup::Lsif::LsifFileEntityXRefLocations; };
template<> struct SCHEMA::predicate<945> { using type = facebook::glean::cpp::schema::Codemarkup::Lsif::LsifResolveLocation; };
template<> struct SCHEMA::predicate<946> { using type = facebook::glean::cpp::schema::Codemarkup::Kotlin::KotlinContainsChildEntity; };
template<> struct SCHEMA::predicate<947> { using type = facebook::glean::cpp::schema::Codemarkup::Kotlin::KotlinContainsParentEntity; };
template<> struct SCHEMA::predicate<948> { using type = facebook::glean::cpp::schema::Codemarkup::Kotlin::KotlinEntityKind; };
template<> struct SCHEMA::predicate<949> { using type = facebook::glean::cpp::schema::Codemarkup::Kotlin::KotlinEntityLocation; };
template<> struct SCHEMA::predicate<950> { using type = facebook::glean::cpp::schema::Codemarkup::Kotlin::KotlinEntityUses; };
template<> struct SCHEMA::predicate<951> { using type = facebook::glean::cpp::schema::Codemarkup::Kotlin::KotlinExtendsParentEntity; };
template<> struct SCHEMA::predicate<952> { using type = facebook::glean::cpp::schema::Codemarkup::Kotlin::KotlinFileEntityXRefLocations; };
template<> struct SCHEMA::predicate<953> { using type = facebook::glean::cpp::schema::Codemarkup::Kotlin::KotlinResolveLocation; };
template<> struct SCHEMA::predicate<954> { using type = facebook::glean::cpp::schema::Codemarkup::Java::JavaContainsChildEntity; };
template<> struct SCHEMA::predicate<955> { using type = facebook::glean::cpp::schema::Codemarkup::Java::JavaContainsParentEntity; };
template<> struct SCHEMA::predicate<956> { using type = facebook::glean::cpp::schema::Codemarkup::Java::JavaEntityDocumentation; };
template<> struct SCHEMA::predicate<957> { using type = facebook::glean::cpp::schema::Codemarkup::Java::JavaEntityKind; };
template<> struct SCHEMA::predicate<958> { using type = facebook::glean::cpp::schema::Codemarkup::Java::JavaEntityLocation; };
template<> struct SCHEMA::predicate<959> { using type = facebook::glean::cpp::schema::Codemarkup::Java::JavaEntityUses; };
template<> struct SCHEMA::predicate<960> { using type = facebook::glean::cpp::schema::Codemarkup::Java::JavaExtendsChildEntity; };
template<> struct SCHEMA::predicate<961> { using type = facebook::glean::cpp::schema::Codemarkup::Java::JavaExtendsParentEntity; };
template<> struct SCHEMA::predicate<962> { using type = facebook::glean::cpp::schema::Codemarkup::Java::JavaModifiers; };
template<> struct SCHEMA::predicate<963> { using type = facebook::glean::cpp::schema::Codemarkup::Java::JavaResolveLocation; };
template<> struct SCHEMA::predicate<964> { using type = facebook::glean::cpp::schema::Codemarkup::Java::JavaVisibility; };
template<> struct SCHEMA::predicate<965> { using type = facebook::glean::cpp::schema::Codemarkup::Java::JavalFileEntityXRefLocations; };
template<> struct SCHEMA::predicate<966> { using type = facebook::glean::cpp::schema::Codemarkup::Java::JavaAnnotation; };
template<> struct SCHEMA::predicate<967> { using type = facebook::glean::cpp::schema::Codemarkup::Haskell::HaskellEntityLocation; };
template<> struct SCHEMA::predicate<968> { using type = facebook::glean::cpp::schema::Codemarkup::Haskell::HaskellEntityUses; };
template<> struct SCHEMA::predicate<969> { using type = facebook::glean::cpp::schema::Codemarkup::Haskell::HaskellFileEntityXRefLocations; };
template<> struct SCHEMA::predicate<970> { using type = facebook::glean::cpp::schema::Codemarkup::Haskell::HaskellResolveLocation; };
template<> struct SCHEMA::predicate<971> { using type = facebook::glean::cpp::schema::Search::Hs::SearchByName; };
template<> struct SCHEMA::predicate<972> { using type = facebook::glean::cpp::schema::Codemarkup::Hack::EntityHasHideFromDocsAttr; };
template<> struct SCHEMA::predicate<973> { using type = facebook::glean::cpp::schema::Codemarkup::Hack::HackContainsChildEntity; };
template<> struct SCHEMA::predicate<974> { using type = facebook::glean::cpp::schema::Codemarkup::Hack::HackContainsParentEntity; };
template<> struct SCHEMA::predicate<975> { using type = facebook::glean::cpp::schema::Codemarkup::Hack::HackEntityDocumentation; };
template<> struct SCHEMA::predicate<976> { using type = facebook::glean::cpp::schema::Codemarkup::Hack::HackEntityInfo; };
template<> struct SCHEMA::predicate<977> { using type = facebook::glean::cpp::schema::Codemarkup::Hack::HackEntityKind; };
template<> struct SCHEMA::predicate<978> { using type = facebook::glean::cpp::schema::Codemarkup::Hack::HackEntityLocation; };
template<> struct SCHEMA::predicate<979> { using type = facebook::glean::cpp::schema::Codemarkup::Hack::HackEntityModuleName; };
template<> struct SCHEMA::predicate<980> { using type = facebook::glean::cpp::schema::Codemarkup::Hack::HackEntitySource; };
template<> struct SCHEMA::predicate<981> { using type = facebook::glean::cpp::schema::Codemarkup::Hack::HackEntityUses; };
template<> struct SCHEMA::predicate<982> { using type = facebook::glean::cpp::schema::Codemarkup::Hack::HackExtendsChildEntity; };
template<> struct SCHEMA::predicate<983> { using type = facebook::glean::cpp::schema::Codemarkup::Hack::HackExtendsParentEntity; };
template<> struct SCHEMA::predicate<984> { using type = facebook::glean::cpp::schema::Codemarkup::Hack::HackExtendsParentEntityConcise; };
template<> struct SCHEMA::predicate<985> { using type = facebook::glean::cpp::schema::Codemarkup::Hack::HackFileEntityXRefLocations; };
template<> struct SCHEMA::predicate<986> { using type = facebook::glean::cpp::schema::Codemarkup::Hack::HackFileEntityXRefSpans; };
template<> struct SCHEMA::predicate<987> { using type = facebook::glean::cpp::schema::Codemarkup::Hack::HackModifiers; };
template<> struct SCHEMA::predicate<988> { using type = facebook::glean::cpp::schema::Codemarkup::Hack::HackRequiredConstraint; };
template<> struct SCHEMA::predicate<989> { using type = facebook::glean::cpp::schema::Codemarkup::Hack::HackResolveLocation; };
template<> struct SCHEMA::predicate<990> { using type = facebook::glean::cpp::schema::Codemarkup::Hack::HackVisibility; };
template<> struct SCHEMA::predicate<991> { using type = facebook::glean::cpp::schema::Codemetrics::HackReferencesFrom; };
template<> struct SCHEMA::predicate<992> { using type = facebook::glean::cpp::schema::Codemetrics::HackReferencesTo; };
template<> struct SCHEMA::predicate<993> { using type = facebook::glean::cpp::schema::Codemarkup::Hack::HackAnnotation; };
template<> struct SCHEMA::predicate<994> { using type = facebook::glean::cpp::schema::Codemarkup::Graphql::GraphQLEntityKind; };
template<> struct SCHEMA::predicate<995> { using type = facebook::glean::cpp::schema::Codemarkup::Graphql::GraphQLEntityLocation; };
template<> struct SCHEMA::predicate<996> { using type = facebook::glean::cpp::schema::Codemarkup::Graphql::GraphQLEntityUses; };
template<> struct SCHEMA::predicate<997> { using type = facebook::glean::cpp::schema::Codemarkup::Graphql::GraphQLFileEntityXRefLocations; };
template<> struct SCHEMA::predicate<998> { using type = facebook::glean::cpp::schema::Codemarkup::Graphql::GraphQLResolveLocation; };
template<> struct SCHEMA::predicate<999> { using type = facebook::glean::cpp::schema::Codemarkup::Flow::FlowContainsChildEntity; };
template<> struct SCHEMA::predicate<1000> { using type = facebook::glean::cpp::schema::Codemarkup::Flow::FlowContainsParentEntity; };
template<> struct SCHEMA::predicate<1001> { using type = facebook::glean::cpp::schema::Codemarkup::Flow::FlowEntityDocumentation; };
template<> struct SCHEMA::predicate<1002> { using type = facebook::glean::cpp::schema::Codemarkup::Flow::FlowEntityKind; };
template<> struct SCHEMA::predicate<1003> { using type = facebook::glean::cpp::schema::Codemarkup::Flow::FlowEntityLocation; };
template<> struct SCHEMA::predicate<1004> { using type = facebook::glean::cpp::schema::Codemarkup::Flow::FlowEntityModuleName; };
template<> struct SCHEMA::predicate<1005> { using type = facebook::glean::cpp::schema::Codemarkup::Flow::FlowEntityUses; };
template<> struct SCHEMA::predicate<1006> { using type = facebook::glean::cpp::schema::Codemarkup::Flow::FlowFileEntityXRefLocations; };
template<> struct SCHEMA::predicate<1007> { using type = facebook::glean::cpp::schema::Codemarkup::Flow::FlowFileImportDeclEntityXRefLocations; };
template<> struct SCHEMA::predicate<1008> { using type = facebook::glean::cpp::schema::Codemarkup::Flow::FlowFileReferenceEntityXRefLocations; };
template<> struct SCHEMA::predicate<1009> { using type = facebook::glean::cpp::schema::Codemarkup::Flow::FlowResolveLocation; };
template<> struct SCHEMA::predicate<1010> { using type = facebook::glean::cpp::schema::Codemarkup::Fbthrift::FbthriftEntityDocumentation; };
template<> struct SCHEMA::predicate<1011> { using type = facebook::glean::cpp::schema::Codemarkup::Fbthrift::ThriftContainsChildEntity; };
template<> struct SCHEMA::predicate<1012> { using type = facebook::glean::cpp::schema::Codemarkup::Fbthrift::ThriftContainsParentEntity; };
template<> struct SCHEMA::predicate<1013> { using type = facebook::glean::cpp::schema::Codemarkup::Fbthrift::ThriftEntityKind; };
template<> struct SCHEMA::predicate<1014> { using type = facebook::glean::cpp::schema::Codemarkup::Fbthrift::ThriftEntityLocation; };
template<> struct SCHEMA::predicate<1015> { using type = facebook::glean::cpp::schema::Codemarkup::Fbthrift::ThriftExtendsChildEntity; };
template<> struct SCHEMA::predicate<1016> { using type = facebook::glean::cpp::schema::Codemarkup::Fbthrift::ThriftExtendsParentEntity; };
template<> struct SCHEMA::predicate<1017> { using type = facebook::glean::cpp::schema::Codemarkup::Fbthrift::ThriftFileEntityXRefLocations; };
template<> struct SCHEMA::predicate<1018> { using type = facebook::glean::cpp::schema::Codemarkup::Fbthrift::ThriftResolveLocation; };
template<> struct SCHEMA::predicate<1019> { using type = facebook::glean::cpp::schema::Codemarkup::Erlang::ErlangEntityDocumentation; };
template<> struct SCHEMA::predicate<1020> { using type = facebook::glean::cpp::schema::Codemarkup::Erlang::ErlangEntityInfo; };
template<> struct SCHEMA::predicate<1021> { using type = facebook::glean::cpp::schema::Codemarkup::Erlang::ErlangEntityKind; };
template<> struct SCHEMA::predicate<1022> { using type = facebook::glean::cpp::schema::Codemarkup::Erlang::ErlangEntityLocation; };
template<> struct SCHEMA::predicate<1023> { using type = facebook::glean::cpp::schema::Codemarkup::Erlang::ErlangEntityUses; };
template<> struct SCHEMA::predicate<1024> { using type = facebook::glean::cpp::schema::Codemarkup::Erlang::ErlangFileEntityXRefLocations; };
template<> struct SCHEMA::predicate<1025> { using type = facebook::glean::cpp::schema::Codemarkup::Erlang::ErlangResolveLocation; };
template<> struct SCHEMA::predicate<1026> { using type = facebook::glean::cpp::schema::Search::Erlang::SearchByFQN; };
template<> struct SCHEMA::predicate<1027> { using type = facebook::glean::cpp::schema::Search::Erlang::SearchByName; };
template<> struct SCHEMA::predicate<1028> { using type = facebook::glean::cpp::schema::Codemarkup::Cxx::CxxContainsChildEntity; };
template<> struct SCHEMA::predicate<1029> { using type = facebook::glean::cpp::schema::Codemarkup::Cxx::CxxContainsParentEntity; };
template<> struct SCHEMA::predicate<1030> { using type = facebook::glean::cpp::schema::Codemarkup::Cxx::CxxDeclToDefXRefTargetLocation; };
template<> struct SCHEMA::predicate<1031> { using type = facebook::glean::cpp::schema::Codemarkup::Cxx::CxxDeclarationContainsChild; };
template<> struct SCHEMA::predicate<1032> { using type = facebook::glean::cpp::schema::Codemarkup::Cxx::CxxDeclarationContainsParent; };
template<> struct SCHEMA::predicate<1033> { using type = facebook::glean::cpp::schema::Codemarkup::Cxx::CxxDeclarationExtendsChild; };
template<> struct SCHEMA::predicate<1034> { using type = facebook::glean::cpp::schema::Codemarkup::Cxx::CxxDeclarationExtendsParent; };
template<> struct SCHEMA::predicate<1035> { using type = facebook::glean::cpp::schema::Codemarkup::Cxx::CxxDeclarationSource; };
template<> struct SCHEMA::predicate<1036> { using type = facebook::glean::cpp::schema::Codemarkup::Cxx::CxxDefToDeclFamilyXRefTargetLocation; };
template<> struct SCHEMA::predicate<1037> { using type = facebook::glean::cpp::schema::Codemarkup::Cxx::CxxEntityDocumentation; };
template<> struct SCHEMA::predicate<1038> { using type = facebook::glean::cpp::schema::Codemarkup::Cxx::CxxEntityInfo; };
template<> struct SCHEMA::predicate<1039> { using type = facebook::glean::cpp::schema::Codemarkup::Cxx::CxxEntityKind; };
template<> struct SCHEMA::predicate<1040> { using type = facebook::glean::cpp::schema::Codemarkup::Cxx::CxxEntityLocation; };
template<> struct SCHEMA::predicate<1041> { using type = facebook::glean::cpp::schema::Codemarkup::Cxx::CxxEntitySource; };
template<> struct SCHEMA::predicate<1042> { using type = facebook::glean::cpp::schema::Codemarkup::Cxx::CxxEntityUSR; };
template<> struct SCHEMA::predicate<1043> { using type = facebook::glean::cpp::schema::Codemarkup::Cxx::CxxEntityUses; };
template<> struct SCHEMA::predicate<1044> { using type = facebook::glean::cpp::schema::Codemarkup::Cxx::CxxExtendsChildEntity; };
template<> struct SCHEMA::predicate<1045> { using type = facebook::glean::cpp::schema::Codemarkup::Cxx::CxxExtendsParentEntity; };
template<> struct SCHEMA::predicate<1046> { using type = facebook::glean::cpp::schema::Codemarkup::Cxx::CxxFileEntitySpellingXRefLocations; };
template<> struct SCHEMA::predicate<1047> { using type = facebook::glean::cpp::schema::Codemarkup::Cxx::CxxFileEntityTraceDeclToDefXRefLocations; };
template<> struct SCHEMA::predicate<1048> { using type = facebook::glean::cpp::schema::Codemarkup::Cxx::CxxFileEntityXMapFixedXRefLocations; };
template<> struct SCHEMA::predicate<1049> { using type = facebook::glean::cpp::schema::Codemarkup::Cxx::CxxFileEntityXMapVariableXRefDeclToDefs; };
template<> struct SCHEMA::predicate<1050> { using type = facebook::glean::cpp::schema::Codemarkup::Cxx::CxxFileEntityXRefLocations; };
template<> struct SCHEMA::predicate<1051> { using type = facebook::glean::cpp::schema::Codemarkup::Cxx::CxxFindDefinitionOfEntity; };
template<> struct SCHEMA::predicate<1052> { using type = facebook::glean::cpp::schema::Codemarkup::Cxx::CxxModifiers; };
template<> struct SCHEMA::predicate<1053> { using type = facebook::glean::cpp::schema::Codemarkup::Cxx::CxxNamespaceDeclarationContainsChild; };
template<> struct SCHEMA::predicate<1054> { using type = facebook::glean::cpp::schema::Codemarkup::Cxx::CxxResolveDeclarationToEntity; };
template<> struct SCHEMA::predicate<1055> { using type = facebook::glean::cpp::schema::Codemarkup::Cxx::CxxResolveLocation; };
template<> struct SCHEMA::predicate<1056> { using type = facebook::glean::cpp::schema::Codemarkup::Cxx::CxxResolveTraceLocation; };
template<> struct SCHEMA::predicate<1057> { using type = facebook::glean::cpp::schema::Codemarkup::Cxx::CxxVisibility; };
template<> struct SCHEMA::predicate<1058> { using type = facebook::glean::cpp::schema::Codemarkup::Cxx::CxxXRefTargetLocation; };
template<> struct SCHEMA::predicate<1059> { using type = facebook::glean::cpp::schema::Codemarkup::Cxx::EntityToXRefTarget; };
template<> struct SCHEMA::predicate<1060> { using type = facebook::glean::cpp::schema::Codemarkup::Cxx::XRefTargetToEntity; };
template<> struct SCHEMA::predicate<1061> { using type = facebook::glean::cpp::schema::Codemetrics::CxxReferencesFrom; };
template<> struct SCHEMA::predicate<1062> { using type = facebook::glean::cpp::schema::Codemetrics::CxxReferencesTo; };
template<> struct SCHEMA::predicate<1063> { using type = facebook::glean::cpp::schema::Search::Cxx::EntityUses; };
template<> struct SCHEMA::predicate<1064> { using type = facebook::glean::cpp::schema::Search::Cxx::SearchBySelector; };
template<> struct SCHEMA::predicate<1065> { using type = facebook::glean::cpp::schema::Symbolid::Cxx::DefinitionOfDecl; };
template<> struct SCHEMA::predicate<1066> { using type = facebook::glean::cpp::schema::Symbolid::Cxx::LookupNamespaceDefinition; };
template<> struct SCHEMA::predicate<1067> { using type = facebook::glean::cpp::schema::Codemarkup::Cxx::CxxDefinitionContainsChild; };
template<> struct SCHEMA::predicate<1068> { using type = facebook::glean::cpp::schema::Codemarkup::Cxx::CxxDefinitionContainsParent; };
template<> struct SCHEMA::predicate<1069> { using type = facebook::glean::cpp::schema::Codemarkup::Cxx::CxxDefinitionExtendsChild; };
template<> struct SCHEMA::predicate<1070> { using type = facebook::glean::cpp::schema::Codemarkup::Cxx::CxxDefinitionExtendsParent; };
template<> struct SCHEMA::predicate<1071> { using type = facebook::glean::cpp::schema::Codemarkup::Cxx::CxxDefinitionModifiers; };
template<> struct SCHEMA::predicate<1072> { using type = facebook::glean::cpp::schema::Codemarkup::Cxx::CxxDefnVisibility; };
template<> struct SCHEMA::predicate<1073> { using type = facebook::glean::cpp::schema::Codemarkup::Cxx::CxxEntityDefinitionBase; };
template<> struct SCHEMA::predicate<1074> { using type = facebook::glean::cpp::schema::Search::Cxx::DeclIsDefn; };
template<> struct SCHEMA::predicate<1075> { using type = facebook::glean::cpp::schema::Code::Cxx::DeclToDef; };
template<> struct SCHEMA::predicate<1076> { using type = facebook::glean::cpp::schema::Codemarkup::Cxx::CxxAnnotation; };
template<> struct SCHEMA::predicate<1077> { using type = facebook::glean::cpp::schema::Codemarkup::Csharp::CSharpEntityKind; };
template<> struct SCHEMA::predicate<1078> { using type = facebook::glean::cpp::schema::Codemarkup::Csharp::CSharpEntityLocation; };
template<> struct SCHEMA::predicate<1079> { using type = facebook::glean::cpp::schema::Codemarkup::Csharp::CSharpEntityUses; };
template<> struct SCHEMA::predicate<1080> { using type = facebook::glean::cpp::schema::Codemarkup::Csharp::CSharpFileEntityXRefLocations; };
template<> struct SCHEMA::predicate<1081> { using type = facebook::glean::cpp::schema::Codemarkup::Csharp::CSharpResolveLocation; };
template<> struct SCHEMA::predicate<1082> { using type = facebook::glean::cpp::schema::Code::Compose::CxxContainerChildSignatures; };
template<> struct SCHEMA::predicate<1083> { using type = facebook::glean::cpp::schema::Codemarkup::Buck::BuckEntityKind; };
template<> struct SCHEMA::predicate<1084> { using type = facebook::glean::cpp::schema::Codemarkup::Buck::BuckEntityLocation; };
template<> struct SCHEMA::predicate<1085> { using type = facebook::glean::cpp::schema::Codemarkup::Buck::BuckEntityUses; };
template<> struct SCHEMA::predicate<1086> { using type = facebook::glean::cpp::schema::Codemarkup::Buck::BuckFileEntityXRefLocations; };
template<> struct SCHEMA::predicate<1087> { using type = facebook::glean::cpp::schema::Codemarkup::Buck::BuckResolveLocation; };
template<> struct SCHEMA::predicate<1088> { using type = facebook::glean::cpp::schema::Search::Buck::SearchByFQN; };
template<> struct SCHEMA::predicate<1089> { using type = facebook::glean::cpp::schema::Search::Buck::SearchDefinition; };
template<> struct SCHEMA::predicate<1090> { using type = facebook::glean::cpp::schema::Search::Buck::SearchFile; };
template<> struct SCHEMA::predicate<1091> { using type = facebook::glean::cpp::schema::Code::EntityLanguageSCIP; };
template<> struct SCHEMA::predicate<1092> { using type = facebook::glean::cpp::schema::Code::EntityLanguageLSIF; };
template<> struct SCHEMA::predicate<1093> { using type = facebook::glean::cpp::schema::Code::EntityLanguage; };
template<> struct SCHEMA::predicate<1094> { using type = facebook::glean::cpp::schema::Codemarkup::Cxx::CxxEntityIdl; };
template<> struct SCHEMA::predicate<1095> { using type = facebook::glean::cpp::schema::Codemarkup::Hack::HackEntityIdl; };
template<> struct SCHEMA::predicate<1096> { using type = facebook::glean::cpp::schema::Code::Compose::CxxSearchContainerKind; };
template<> struct SCHEMA::predicate<1097> { using type = facebook::glean::cpp::schema::Codemarkup::ContainsChildEntity; };
template<> struct SCHEMA::predicate<1098> { using type = facebook::glean::cpp::schema::Codemarkup::ContainsParentEntity; };
template<> struct SCHEMA::predicate<1099> { using type = facebook::glean::cpp::schema::Codemarkup::EntityComments; };
template<> struct SCHEMA::predicate<1100> { using type = facebook::glean::cpp::schema::Codemarkup::EntityIdl; };
template<> struct SCHEMA::predicate<1101> { using type = facebook::glean::cpp::schema::Codemarkup::EntityInfo; };
template<> struct SCHEMA::predicate<1102> { using type = facebook::glean::cpp::schema::Codemarkup::EntityIsDefinition; };
template<> struct SCHEMA::predicate<1103> { using type = facebook::glean::cpp::schema::Codemarkup::EntityKind; };
template<> struct SCHEMA::predicate<1104> { using type = facebook::glean::cpp::schema::Codemarkup::EntityLocation; };
template<> struct SCHEMA::predicate<1105> { using type = facebook::glean::cpp::schema::Codemarkup::EntityModifiers; };
template<> struct SCHEMA::predicate<1106> { using type = facebook::glean::cpp::schema::Codemarkup::EntityModuleName; };
template<> struct SCHEMA::predicate<1107> { using type = facebook::glean::cpp::schema::Codemarkup::EntityReferences; };
template<> struct SCHEMA::predicate<1108> { using type = facebook::glean::cpp::schema::Codemarkup::EntitySource; };
template<> struct SCHEMA::predicate<1109> { using type = facebook::glean::cpp::schema::Codemarkup::EntityUses; };
template<> struct SCHEMA::predicate<1110> { using type = facebook::glean::cpp::schema::Codemarkup::EntityVisibility; };
template<> struct SCHEMA::predicate<1111> { using type = facebook::glean::cpp::schema::Codemarkup::ExtendsChildEntity; };
template<> struct SCHEMA::predicate<1112> { using type = facebook::glean::cpp::schema::Codemarkup::ExtendsParentEntity; };
template<> struct SCHEMA::predicate<1113> { using type = facebook::glean::cpp::schema::Codemarkup::ExtendsParentEntityConcise; };
template<> struct SCHEMA::predicate<1114> { using type = facebook::glean::cpp::schema::Codemarkup::FileEntityDigest; };
template<> struct SCHEMA::predicate<1115> { using type = facebook::glean::cpp::schema::Codemarkup::FileEntityInfos; };
template<> struct SCHEMA::predicate<1116> { using type = facebook::glean::cpp::schema::Codemarkup::FileEntityKinds; };
template<> struct SCHEMA::predicate<1117> { using type = facebook::glean::cpp::schema::Codemarkup::FileEntityLocations; };
template<> struct SCHEMA::predicate<1118> { using type = facebook::glean::cpp::schema::Codemarkup::FileEntityXRefInfos; };
template<> struct SCHEMA::predicate<1119> { using type = facebook::glean::cpp::schema::Codemarkup::FileEntityXRefKinds; };
template<> struct SCHEMA::predicate<1120> { using type = facebook::glean::cpp::schema::Codemarkup::FileEntityXRefLocations; };
template<> struct SCHEMA::predicate<1121> { using type = facebook::glean::cpp::schema::Codemarkup::FileEntityXRefRangeSpans; };
template<> struct SCHEMA::predicate<1122> { using type = facebook::glean::cpp::schema::Codemarkup::FileEntityXRefSpans; };
template<> struct SCHEMA::predicate<1123> { using type = facebook::glean::cpp::schema::Codemarkup::FindEntityDefinition; };
template<> struct SCHEMA::predicate<1124> { using type = facebook::glean::cpp::schema::Codemarkup::SearchRelatedEntities; };
template<> struct SCHEMA::predicate<1125> { using type = facebook::glean::cpp::schema::Codemarkup::ReferencingEntity; };
template<> struct SCHEMA::predicate<1126> { using type = facebook::glean::cpp::schema::Codemarkup::ResolveLocation; };
template<> struct SCHEMA::predicate<1127> { using type = facebook::glean::cpp::schema::Codemarkup::Cxx::CxxFileEntityIdl; };
template<> struct SCHEMA::predicate<1128> { using type = facebook::glean::cpp::schema::Codemarkup::Hack::ConvertCallee; };
template<> struct SCHEMA::predicate<1129> { using type = facebook::glean::cpp::schema::Codemarkup::Hack::ConvertCalleeForFileCall; };
template<> struct SCHEMA::predicate<1130> { using type = facebook::glean::cpp::schema::Codemarkup::Hack::ConvertStaticType; };
template<> struct SCHEMA::predicate<1131> { using type = facebook::glean::cpp::schema::Codemarkup::Search::EntityLocationAndKind; };
template<> struct SCHEMA::predicate<1132> { using type = facebook::glean::cpp::schema::Codemarkup::Search::SearchByName; };
template<> struct SCHEMA::predicate<1133> { using type = facebook::glean::cpp::schema::Codemarkup::Search::SearchByScope; };
template<> struct SCHEMA::predicate<1134> { using type = facebook::glean::cpp::schema::Codemetrics::ReferencesFrom; };
template<> struct SCHEMA::predicate<1135> { using type = facebook::glean::cpp::schema::Codemetrics::ReferencesTo; };
template<> struct SCHEMA::predicate<1136> { using type = facebook::glean::cpp::schema::Deadcode::GraphEntity; };
template<> struct SCHEMA::predicate<1137> { using type = facebook::glean::cpp::schema::Deletthis::FileReverseDeps; };
template<> struct SCHEMA::predicate<1138> { using type = facebook::glean::cpp::schema::Dyn::EntityUsage; };
template<> struct SCHEMA::predicate<1139> { using type = facebook::glean::cpp::schema::Monk::BestPiiFunc; };
template<> struct SCHEMA::predicate<1140> { using type = facebook::glean::cpp::schema::Monk::PiiCallerFunc; };
template<> struct SCHEMA::predicate<1141> { using type = facebook::glean::cpp::schema::Monk::PiiFunc; };
template<> struct SCHEMA::predicate<1142> { using type = facebook::glean::cpp::schema::Search::Code::BuckSearchByLocalNameFact; };
template<> struct SCHEMA::predicate<1143> { using type = facebook::glean::cpp::schema::Search::Code::BuckSearchByLowerCaseName; };
template<> struct SCHEMA::predicate<1144> { using type = facebook::glean::cpp::schema::Search::Code::BuckSearchByName; };
template<> struct SCHEMA::predicate<1145> { using type = facebook::glean::cpp::schema::Search::Code::CSharpSearchByLowerCaseName; };
template<> struct SCHEMA::predicate<1146> { using type = facebook::glean::cpp::schema::Search::Code::CSharpSearchByName; };
template<> struct SCHEMA::predicate<1147> { using type = facebook::glean::cpp::schema::Search::Code::CxxSearchByLowerCaseName; };
template<> struct SCHEMA::predicate<1148> { using type = facebook::glean::cpp::schema::Search::Code::CxxSearchByLowerCaseScope; };
template<> struct SCHEMA::predicate<1149> { using type = facebook::glean::cpp::schema::Search::Code::CxxSearchByName; };
template<> struct SCHEMA::predicate<1150> { using type = facebook::glean::cpp::schema::Search::Code::CxxSearchByScope; };
template<> struct SCHEMA::predicate<1151> { using type = facebook::glean::cpp::schema::Search::Code::ErlangSearchByLowerCaseName; };
template<> struct SCHEMA::predicate<1152> { using type = facebook::glean::cpp::schema::Search::Code::ErlangSearchByName; };
template<> struct SCHEMA::predicate<1153> { using type = facebook::glean::cpp::schema::Search::Code::FbthriftSearchByNameFact; };
template<> struct SCHEMA::predicate<1154> { using type = facebook::glean::cpp::schema::Search::Code::FlowSearchByLowerCaseName; };
template<> struct SCHEMA::predicate<1155> { using type = facebook::glean::cpp::schema::Search::Code::FlowSearchByLowerCaseScope; };
template<> struct SCHEMA::predicate<1156> { using type = facebook::glean::cpp::schema::Search::Code::FlowSearchByName; };
template<> struct SCHEMA::predicate<1157> { using type = facebook::glean::cpp::schema::Search::Code::FlowSearchByNameWithFact; };
template<> struct SCHEMA::predicate<1158> { using type = facebook::glean::cpp::schema::Search::Code::FlowSearchByScope; };
template<> struct SCHEMA::predicate<1159> { using type = facebook::glean::cpp::schema::Search::Code::FlowSearchByScopeWithName; };
template<> struct SCHEMA::predicate<1160> { using type = facebook::glean::cpp::schema::Search::Code::GraphQLSearchByLowerCaseName; };
template<> struct SCHEMA::predicate<1161> { using type = facebook::glean::cpp::schema::Search::Code::GraphQLSearchByName; };
template<> struct SCHEMA::predicate<1162> { using type = facebook::glean::cpp::schema::Search::Code::HackSearchByLowerCaseName; };
template<> struct SCHEMA::predicate<1163> { using type = facebook::glean::cpp::schema::Search::Code::HackSearchByLowerCaseScope; };
template<> struct SCHEMA::predicate<1164> { using type = facebook::glean::cpp::schema::Search::Code::HackSearchByName; };
template<> struct SCHEMA::predicate<1165> { using type = facebook::glean::cpp::schema::Search::Code::HackSearchByNameWithName; };
template<> struct SCHEMA::predicate<1166> { using type = facebook::glean::cpp::schema::Search::Code::HackSearchByScope; };
template<> struct SCHEMA::predicate<1167> { using type = facebook::glean::cpp::schema::Search::Code::HackSearchByScopeWithName; };
template<> struct SCHEMA::predicate<1168> { using type = facebook::glean::cpp::schema::Search::Code::HsSearchByLowerCaseName; };
template<> struct SCHEMA::predicate<1169> { using type = facebook::glean::cpp::schema::Search::Code::HsSearchByName; };
template<> struct SCHEMA::predicate<1170> { using type = facebook::glean::cpp::schema::Search::Code::JavaSearchByLowerCaseName; };
template<> struct SCHEMA::predicate<1171> { using type = facebook::glean::cpp::schema::Search::Code::JavaSearchByLowerCaseScope; };
template<> struct SCHEMA::predicate<1172> { using type = facebook::glean::cpp::schema::Search::Code::JavaSearchByName; };
template<> struct SCHEMA::predicate<1173> { using type = facebook::glean::cpp::schema::Search::Code::JavaSearchByNameWithFact; };
template<> struct SCHEMA::predicate<1174> { using type = facebook::glean::cpp::schema::Search::Code::JavaSearchByScope; };
template<> struct SCHEMA::predicate<1175> { using type = facebook::glean::cpp::schema::Search::Code::JavaSearchByScopeWithName; };
template<> struct SCHEMA::predicate<1176> { using type = facebook::glean::cpp::schema::Search::Code::KotlinSearchByLowerCaseName; };
template<> struct SCHEMA::predicate<1177> { using type = facebook::glean::cpp::schema::Search::Code::KotlinSearchByLowerCaseScope; };
template<> struct SCHEMA::predicate<1178> { using type = facebook::glean::cpp::schema::Search::Code::KotlinSearchByName; };
template<> struct SCHEMA::predicate<1179> { using type = facebook::glean::cpp::schema::Search::Code::KotlinSearchByNameWithFact; };
template<> struct SCHEMA::predicate<1180> { using type = facebook::glean::cpp::schema::Search::Code::KotlinSearchByScope; };
template<> struct SCHEMA::predicate<1181> { using type = facebook::glean::cpp::schema::Search::Code::KotlinSearchByScopeWithName; };
template<> struct SCHEMA::predicate<1182> { using type = facebook::glean::cpp::schema::Search::Code::LsifSearchByLowerCaseName; };
template<> struct SCHEMA::predicate<1183> { using type = facebook::glean::cpp::schema::Search::Code::LsifSearchByName; };
template<> struct SCHEMA::predicate<1184> { using type = facebook::glean::cpp::schema::Search::Code::PpSearchByLowerCaseName; };
template<> struct SCHEMA::predicate<1185> { using type = facebook::glean::cpp::schema::Search::Code::PpSearchByMacroFact; };
template<> struct SCHEMA::predicate<1186> { using type = facebook::glean::cpp::schema::Search::Code::PpSearchByName; };
template<> struct SCHEMA::predicate<1187> { using type = facebook::glean::cpp::schema::Search::Code::PythonSearchByLocalNameFact; };
template<> struct SCHEMA::predicate<1188> { using type = facebook::glean::cpp::schema::Search::Code::PythonSearchByLowerCaseName; };
template<> struct SCHEMA::predicate<1189> { using type = facebook::glean::cpp::schema::Search::Code::PythonSearchByLowerCaseScope; };
template<> struct SCHEMA::predicate<1190> { using type = facebook::glean::cpp::schema::Search::Code::PythonSearchByName; };
template<> struct SCHEMA::predicate<1191> { using type = facebook::glean::cpp::schema::Search::Code::PythonSearchByScope; };
template<> struct SCHEMA::predicate<1192> { using type = facebook::glean::cpp::schema::Search::Code::PythonSearchByScopeWithName; };
template<> struct SCHEMA::predicate<1193> { using type = facebook::glean::cpp::schema::Search::Code::SearchByLowerCaseNameAndLanguage; };
template<> struct SCHEMA::predicate<1194> { using type = facebook::glean::cpp::schema::Search::Code::SearchByLowerCaseScope; };
template<> struct SCHEMA::predicate<1195> { using type = facebook::glean::cpp::schema::Search::Code::SearchByNameAndLanguage; };
template<> struct SCHEMA::predicate<1196> { using type = facebook::glean::cpp::schema::Search::Code::SearchByScope; };
template<> struct SCHEMA::predicate<1197> { using type = facebook::glean::cpp::schema::Search::Code::ThriftSearchByLowerCaseName; };
template<> struct SCHEMA::predicate<1198> { using type = facebook::glean::cpp::schema::Search::Code::ThriftSearchByName; };
template<> struct SCHEMA::predicate<1199> { using type = facebook::glean::cpp::schema::Codemarkup::FileCall; };
template<> struct SCHEMA::predicate<1200> { using type = facebook::glean::cpp::schema::Codemarkup::Hack::ConvertCallArguments; };
template<> struct SCHEMA::predicate<1201> { using type = facebook::glean::cpp::schema::Codemarkup::Hack::ConvertMaybeCallArguments; };
template<> struct SCHEMA::predicate<1202> { using type = facebook::glean::cpp::schema::Codemarkup::Hack::HackFileCall; };
template<> struct SCHEMA::predicate<1203> { using type = facebook::glean::cpp::schema::Codemarkup::Python::ConvertCallArguments; };
template<> struct SCHEMA::predicate<1204> { using type = facebook::glean::cpp::schema::Codemarkup::Python::PythonFileCall; };
template<> struct SCHEMA::predicate<1205> { using type = facebook::glean::cpp::schema::Codemarkup::Hack::ConvertArgument; };
template<> struct SCHEMA::predicate<1206> { using type = facebook::glean::cpp::schema::Codemarkup::Python::ConvertArgument; };
template<> struct SCHEMA::predicate<1207> { using type = facebook::glean::cpp::schema::Codemarkup::EntityToAnnotations; };
template<> struct SCHEMA::predicate<1208> { using type = facebook::glean::cpp::schema::Code::Quality::Issue; };
template<> struct SCHEMA::predicate<1209> { using type = facebook::glean::cpp::schema::Cxx1::FunctionName; };
template<> struct SCHEMA::predicate<1210> { using type = facebook::glean::cpp::schema::Cxx1::RecordDeclaration; };
template<> struct SCHEMA::predicate<1211> { using type = facebook::glean::cpp::schema::Cxx1::DeclarationScope; };
template<> struct SCHEMA::predicate<1212> { using type = facebook::glean::cpp::schema::Cxx1::FunctionQName; };
template<> struct SCHEMA::predicate<1213> { using type = facebook::glean::cpp::schema::Cxx1::QName; };
template<> struct SCHEMA::predicate<1214> { using type = facebook::glean::cpp::schema::Search::Code::CxxSearchByNameAndScopeFact; };
template<> struct SCHEMA::predicate<1215> { using type = facebook::glean::cpp::schema::Search::Cxx::QueryToScopeCase; };
template<> struct SCHEMA::predicate<1216> { using type = facebook::glean::cpp::schema::Search::Cxx::SearchByNameAndScope; };
template<> struct SCHEMA::predicate<1217> { using type = facebook::glean::cpp::schema::Search::Cxx::SearchByScope; };
template<> struct SCHEMA::predicate<1218> { using type = facebook::glean::cpp::schema::Symbolid::Cxx::LookupDeclaration; };
template<> struct SCHEMA::predicate<1219> { using type = facebook::glean::cpp::schema::Symbolid::Cxx::LookupDefinition; };
template<> struct SCHEMA::predicate<1220> { using type = facebook::glean::cpp::schema::Symbolid::Cxx::LookupEnumerator; };
template<> struct SCHEMA::predicate<1221> { using type = facebook::glean::cpp::schema::Symbolid::Cxx::LookupFunctionDeclaration; };
template<> struct SCHEMA::predicate<1222> { using type = facebook::glean::cpp::schema::Symbolid::Cxx::LookupFunctionDefinition; };
template<> struct SCHEMA::predicate<1223> { using type = facebook::glean::cpp::schema::Symbolid::Cxx::LookupFunctionSignatureDeclaration; };
template<> struct SCHEMA::predicate<1224> { using type = facebook::glean::cpp::schema::Symbolid::Cxx::LookupFunctionSignatureDefinition; };
template<> struct SCHEMA::predicate<1225> { using type = facebook::glean::cpp::schema::Symbolid::Cxx::LookupFunctionSignatureQualifierDeclaration; };
template<> struct SCHEMA::predicate<1226> { using type = facebook::glean::cpp::schema::Symbolid::Cxx::LookupFunctionSignatureQualifierDefinition; };
template<> struct SCHEMA::predicate<1227> { using type = facebook::glean::cpp::schema::Fbthrift::FunctionSpecification; };
template<> struct SCHEMA::predicate<1228> { using type = facebook::glean::cpp::schema::Thrift::FunctionSpecification; };
template<> struct SCHEMA::predicate<1229> { using type = facebook::glean::cpp::schema::Buckuses::UsesOfTargetHeader; };
template<> struct SCHEMA::predicate<1230> { using type = facebook::glean::cpp::schema::Buckuses::UsesOfTarget; };
template<> struct SCHEMA::predicate<1231> { using type = facebook::glean::cpp::schema::Buck::Meta::Oncall; };
template<> struct SCHEMA::predicate<1232> { using type = facebook::glean::cpp::schema::Buck::Meta::ModeType; };
template<> struct SCHEMA::predicate<1233> { using type = facebook::glean::cpp::schema::Buck::Meta::TargetModes; };
template<> struct SCHEMA::predicate<1234> { using type = facebook::glean::cpp::schema::Buck::Meta::LocatorOncall; };
template<> struct SCHEMA::predicate<1235> { using type = facebook::glean::cpp::schema::Buck::Meta::FileOncall; };
template<> struct SCHEMA::predicate<1236> { using type = facebook::glean::cpp::schema::Buck::Type; };
template<> struct SCHEMA::predicate<1237> { using type = facebook::glean::cpp::schema::Buck::TranslationUnit; };
template<> struct SCHEMA::predicate<1238> { using type = facebook::glean::cpp::schema::Buck::TargetUses; };
template<> struct SCHEMA::predicate<1239> { using type = facebook::glean::cpp::schema::Buck::TargetSourcesBaseModule; };
template<> struct SCHEMA::predicate<1240> { using type = facebook::glean::cpp::schema::Buck::TargetSources; };
template<> struct SCHEMA::predicate<1241> { using type = facebook::glean::cpp::schema::Buck::TargetOuts; };
template<> struct SCHEMA::predicate<1242> { using type = facebook::glean::cpp::schema::Buck::TargetOut; };
template<> struct SCHEMA::predicate<1243> { using type = facebook::glean::cpp::schema::Buck::TargetMode; };
template<> struct SCHEMA::predicate<1244> { using type = facebook::glean::cpp::schema::Buck::TargetLocation; };
template<> struct SCHEMA::predicate<1245> { using type = facebook::glean::cpp::schema::Buck::TargetLinkWhole; };
template<> struct SCHEMA::predicate<1246> { using type = facebook::glean::cpp::schema::Buck::TargetIndexerName; };
template<> struct SCHEMA::predicate<1247> { using type = facebook::glean::cpp::schema::Buck::TargetIndexer; };
template<> struct SCHEMA::predicate<1248> { using type = facebook::glean::cpp::schema::Buck::TargetHash; };
template<> struct SCHEMA::predicate<1249> { using type = facebook::glean::cpp::schema::Buck::TargetCall; };
template<> struct SCHEMA::predicate<1250> { using type = facebook::glean::cpp::schema::Buck::TargetByType; };
template<> struct SCHEMA::predicate<1251> { using type = facebook::glean::cpp::schema::Buck::TargetAttribute; };
template<> struct SCHEMA::predicate<1252> { using type = facebook::glean::cpp::schema::Buck::Target; };
template<> struct SCHEMA::predicate<1253> { using type = facebook::glean::cpp::schema::Buck::SourceFileLocation; };
template<> struct SCHEMA::predicate<1254> { using type = facebook::glean::cpp::schema::Buck::SearchByLocalName; };
template<> struct SCHEMA::predicate<1255> { using type = facebook::glean::cpp::schema::Buck::RuleKey; };
template<> struct SCHEMA::predicate<1256> { using type = facebook::glean::cpp::schema::Buck::Platform; };
template<> struct SCHEMA::predicate<1257> { using type = facebook::glean::cpp::schema::Buck::Owner; };
template<> struct SCHEMA::predicate<1258> { using type = facebook::glean::cpp::schema::Buck::OutsTarget; };
template<> struct SCHEMA::predicate<1259> { using type = facebook::glean::cpp::schema::Buck::OutputLabel; };
template<> struct SCHEMA::predicate<1260> { using type = facebook::glean::cpp::schema::Buck::OutTarget; };
template<> struct SCHEMA::predicate<1261> { using type = facebook::glean::cpp::schema::Buck::LocatorWithLabel; };
template<> struct SCHEMA::predicate<1262> { using type = facebook::glean::cpp::schema::Buck::LocatorReverseDeps; };
template<> struct SCHEMA::predicate<1263> { using type = facebook::glean::cpp::schema::Buck::LocatorReverseDep; };
template<> struct SCHEMA::predicate<1264> { using type = facebook::glean::cpp::schema::Buck::Locator; };
template<> struct SCHEMA::predicate<1265> { using type = facebook::glean::cpp::schema::Buck::LocalNameLowerCase; };
template<> struct SCHEMA::predicate<1266> { using type = facebook::glean::cpp::schema::Buck::LocalName; };
template<> struct SCHEMA::predicate<1267> { using type = facebook::glean::cpp::schema::Buck::Labels; };
template<> struct SCHEMA::predicate<1268> { using type = facebook::glean::cpp::schema::Buck::Label; };
template<> struct SCHEMA::predicate<1269> { using type = facebook::glean::cpp::schema::Buck::IndexerName; };
template<> struct SCHEMA::predicate<1270> { using type = facebook::glean::cpp::schema::Buck::FileXRefs; };
template<> struct SCHEMA::predicate<1271> { using type = facebook::glean::cpp::schema::Buck::FileToTarget; };
template<> struct SCHEMA::predicate<1272> { using type = facebook::glean::cpp::schema::Buck::FileTarget; };
template<> struct SCHEMA::predicate<1273> { using type = facebook::glean::cpp::schema::Buck::FileResolved; };
template<> struct SCHEMA::predicate<1274> { using type = facebook::glean::cpp::schema::Buck::FileEntity; };
template<> struct SCHEMA::predicate<1275> { using type = facebook::glean::cpp::schema::Buck::FileDefinition; };
template<> struct SCHEMA::predicate<1276> { using type = facebook::glean::cpp::schema::Buck::File; };
template<> struct SCHEMA::predicate<1277> { using type = facebook::glean::cpp::schema::Buck::FailureSources; };
template<> struct SCHEMA::predicate<1278> { using type = facebook::glean::cpp::schema::Buck::IndexFailureX; };
template<> struct SCHEMA::predicate<1279> { using type = facebook::glean::cpp::schema::Buck::DestinationUses; };
template<> struct SCHEMA::predicate<1280> { using type = facebook::glean::cpp::schema::Buck::TargetDependencies; };
template<> struct SCHEMA::predicate<1281> { using type = facebook::glean::cpp::schema::Buck::DefinitionLocation; };
template<> struct SCHEMA::predicate<1282> { using type = facebook::glean::cpp::schema::Buck::Definition; };
template<> struct SCHEMA::predicate<1283> { using type = facebook::glean::cpp::schema::Buck::Consumer; };
template<> struct SCHEMA::predicate<1284> { using type = facebook::glean::cpp::schema::Buck::CallArgument; };
template<> struct SCHEMA::predicate<1285> { using type = facebook::glean::cpp::schema::Buck::AttributeName; };
template<> struct SCHEMA::predicate<1286> { using type = facebook::glean::cpp::schema::Buck::AttributeValue; };
template<> struct SCHEMA::predicate<1287> { using type = facebook::glean::cpp::schema::Buck::ArgumentValue; };


} // namespace schema

} // namespace cpp

} // namespace glean

} // namespace facebook
