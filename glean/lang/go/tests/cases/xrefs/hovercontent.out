[
  "@generated",
  {
    "key": {
      "defn": {
        "key": {
          "file": { "key": "glean/lang/go/tests/cases/xrefs/leaphash.go" },
          "range": {
            "key": {
              "range": {
                "lineBegin": 21,
                "columnBegin": 2,
                "lineEnd": 21,
                "columnEnd": 13
              }
            }
          }
        }
      },
      "hover": {
        "key": {
          "text": {
            "key": "Package sha1 implements the SHA-1 hash algorithm as defined in RFC 3174. \u000a\u000aSHA-1 is cryptographically broken and should not be used for secure applications. \u000a\u000a"
          },
          "language": 56
        }
      }
    }
  },
  {
    "key": {
      "defn": {
        "key": {
          "file": { "key": "glean/lang/go/tests/cases/xrefs/leaphash.go" },
          "range": {
            "key": {
              "range": {
                "lineBegin": 22,
                "columnBegin": 2,
                "lineEnd": 22,
                "columnEnd": 5
              }
            }
          }
        }
      },
      "hover": {
        "key": {
          "text": {
            "key": "Package fmt implements formatted I/O with functions analogous to C's printf and scanf.  The format 'verbs' are derived from C's but are simpler. \u000a\u000a### hdr-PrintingPrinting\u000aThe verbs: \u000a\u000aGeneral: \u000a\u000a```\u000a%v\u0009the value in a default format\u000a\u0009when printing structs, the plus flag (%+v) adds field names\u000a%#v\u0009a Go-syntax representation of the value\u000a%T\u0009a Go-syntax representation of the type of the value\u000a%%\u0009a literal percent sign; consumes no value\u000a\u000a```\u000aBoolean: \u000a\u000a```\u000a%t\u0009the word true or false\u000a\u000a```\u000aInteger: \u000a\u000a```\u000a%b\u0009base 2\u000a%c\u0009the character represented by the corresponding Unicode code point\u000a%d\u0009base 10\u000a%o\u0009base 8\u000a%O\u0009base 8 with 0o prefix\u000a%q\u0009a single-quoted character literal safely escaped with Go syntax.\u000a%x\u0009base 16, with lower-case letters for a-f\u000a%X\u0009base 16, with upper-case letters for A-F\u000a%U\u0009Unicode format: U+1234; same as \"U+%04X\"\u000a\u000a```\u000aFloating-point and complex constituents: \u000a\u000a```\u000a%b\u0009decimalless scientific notation with exponent a power of two,\u000a\u0009in the manner of strconv.FormatFloat with the 'b' format,\u000a\u0009e.g. -123456p-78\u000a%e\u0009scientific notation, e.g. -1.234456e+78\u000a%E\u0009scientific notation, e.g. -1.234456E+78\u000a%f\u0009decimal point but no exponent, e.g. 123.456\u000a%F\u0009synonym for %f\u000a%g\u0009%e for large exponents, %f otherwise. Precision is discussed below.\u000a%G\u0009%E for large exponents, %F otherwise\u000a%x\u0009hexadecimal notation (with decimal power of two exponent), e.g. -0x1.23abcp+20\u000a%X\u0009upper-case hexadecimal notation, e.g. -0X1.23ABCP+20\u000a\u000a```\u000aString and slice of bytes (treated equivalently with these verbs): \u000a\u000a```\u000a%s\u0009the uninterpreted bytes of the string or slice\u000a%q\u0009a double-quoted string safely escaped with Go syntax\u000a%x\u0009base 16, lower-case, two characters per byte\u000a%X\u0009base 16, upper-case, two characters per byte\u000a\u000a```\u000aSlice: \u000a\u000a```\u000a%p\u0009address of 0th element in base 16 notation, with leading 0x\u000a\u000a```\u000aPointer: \u000a\u000a```\u000a%p\u0009base 16 notation, with leading 0x\u000aThe %b, %d, %o, %x and %X verbs also work with pointers,\u000aformatting the value exactly as if it were an integer.\u000a\u000a```\u000aThe default format for %v is: \u000a\u000a```\u000abool:                    %t\u000aint, int8 etc.:          %d\u000auint, uint8 etc.:        %d, %#x if printed with %#v\u000afloat32, complex64, etc: %g\u000astring:                  %s\u000achan:                    %p\u000apointer:                 %p\u000a\u000a```\u000aFor compound objects, the elements are printed using these rules, recursively, laid out like this: \u000a\u000a```\u000astruct:             {field0 field1 ...}\u000aarray, slice:       [elem0 elem1 ...]\u000amaps:               map[key1:value1 key2:value2 ...]\u000apointer to above:   &{}, &[], &map[]\u000a\u000a```\u000aWidth is specified by an optional decimal number immediately preceding the verb. If absent, the width is whatever is necessary to represent the value. Precision is specified after the (optional) width by a period followed by a decimal number. If no period is present, a default precision is used. A period with no following number specifies a precision of zero. Examples: \u000a\u000a```\u000a%f     default width, default precision\u000a%9f    width 9, default precision\u000a%.2f   default width, precision 2\u000a%9.2f  width 9, precision 2\u000a%9.f   width 9, precision 0\u000a\u000a```\u000aWidth and precision are measured in units of Unicode code points, that is, runes. (This differs from C's printf where the units are always measured in bytes.) Either or both of the flags may be replaced with the character '*', causing their values to be obtained from the next operand (preceding the one to format), which must be of type int. \u000a\u000aFor most values, width is the minimum number of runes to output, padding the formatted form with spaces if necessary. \u000a\u000aFor strings, byte slices and byte arrays, however, precision limits the length of the input to be formatted (not the size of the output), truncating if necessary. Normally it is measured in runes, but for these types when formatted with the %x or %X format it is measured in bytes. \u000a\u000aFor floating-point values, width sets the minimum width of the field and precision sets the number of places after the decimal, if appropriate, except that for %g/%G precision sets the maximum number of significant digits (trailing zeros are removed). For example, given 12.345 the format %6.3f prints 12.345 while %.3g prints 12.3. The default precision for %e, %f and %#g is 6; for %g it is the smallest number of digits necessary to identify the value uniquely. \u000a\u000aFor complex numbers, the width and precision apply to the two components independently and the result is parenthesized, so %f applied to 1.2+3.4i produces (1.200000+3.400000i). \u000a\u000aOther flags: \u000a\u000a```\u000a+\u0009always print a sign for numeric values;\u000a\u0009guarantee ASCII-only output for %q (%+q)\u000a-\u0009pad with spaces on the right rather than the left (left-justify the field)\u000a#\u0009alternate format: add leading 0b for binary (%#b), 0 for octal (%#o),\u000a\u00090x or 0X for hex (%#x or %#X); suppress 0x for %p (%#p);\u000a\u0009for %q, print a raw (backquoted) string if strconv.CanBackquote\u000a\u0009returns true;\u000a\u0009always print a decimal point for %e, %E, %f, %F, %g and %G;\u000a\u0009do not remove trailing zeros for %g and %G;\u000a\u0009write e.g. U+0078 'x' if the character is printable for %U (%#U).\u000a' '\u0009(space) leave a space for elided sign in numbers (% d);\u000a\u0009put spaces between bytes printing strings or slices in hex (% x, % X)\u000a0\u0009pad with leading zeros rather than spaces;\u000a\u0009for numbers, this moves the padding after the sign\u000a\u000a```\u000aFlags are ignored by verbs that do not expect them. For example there is no alternate decimal format, so %#d and %d behave identically. \u000a\u000aFor each Printf-like function, there is also a Print function that takes no format and is equivalent to saying %v for every operand.  Another variant Println inserts blanks between operands and appends a newline. \u000a\u000aRegardless of the verb, if an operand is an interface value, the internal concrete value is used, not the interface itself. Thus: \u000a\u000a```\u000avar i interface{} = 23\u000afmt.Printf(\"%v\\n\", i)\u000a\u000a```\u000awill print 23. \u000a\u000aExcept when printed using the verbs %T and %p, special formatting considerations apply for operands that implement certain interfaces. In order of application: \u000a\u000a1. If the operand is a reflect.Value, the operand is replaced by the concrete value that it holds, and printing continues with the next rule. \u000a\u000a2. If an operand implements the Formatter interface, it will be invoked. In this case the interpretation of verbs and flags is controlled by that implementation. \u000a\u000a3. If the %v verb is used with the # flag (%#v) and the operand implements the GoStringer interface, that will be invoked. \u000a\u000aIf the format (which is implicitly %v for Println etc.) is valid for a string (%s %q %v %x %X), the following two rules apply: \u000a\u000a4. If an operand implements the error interface, the Error method will be invoked to convert the object to a string, which will then be formatted as required by the verb (if any). \u000a\u000a5. If an operand implements method String() string, that method will be invoked to convert the object to a string, which will then be formatted as required by the verb (if any). \u000a\u000aFor compound operands such as slices and structs, the format applies to the elements of each operand, recursively, not to the operand as a whole. Thus %q will quote each element of a slice of strings, and %6.2f will control formatting for each element of a floating-point array. \u000a\u000aHowever, when printing a byte slice with a string-like verb (%s %q %x %X), it is treated identically to a string, as a single item. \u000a\u000aTo avoid recursion in cases such as \u000a\u000a```\u000atype X string\u000afunc (x X) String() string { return Sprintf(\"<%s>\", x) }\u000a\u000a```\u000aconvert the value before recurring: \u000a\u000a```\u000afunc (x X) String() string { return Sprintf(\"<%s>\", string(x)) }\u000a\u000a```\u000aInfinite recursion can also be triggered by self-referential data structures, such as a slice that contains itself as an element, if that type has a String method. Such pathologies are rare, however, and the package does not protect against them. \u000a\u000aWhen printing a struct, fmt cannot and therefore does not invoke formatting methods such as Error or String on unexported fields. \u000a\u000a### hdr-Explicit_argument_indexesExplicit argument indexes\u000aIn Printf, Sprintf, and Fprintf, the default behavior is for each formatting verb to format successive arguments passed in the call. However, the notation [n] immediately before the verb indicates that the nth one-indexed argument is to be formatted instead. The same notation before a '*' for a width or precision selects the argument index holding the value. After processing a bracketed expression [n], subsequent verbs will use arguments n+1, n+2, etc. unless otherwise directed. \u000a\u000aFor example, \u000a\u000a```\u000afmt.Sprintf(\"%[2]d %[1]d\\n\", 11, 22)\u000a\u000a```\u000awill yield \"22 11\", while \u000a\u000a```\u000afmt.Sprintf(\"%[3]*.[2]*[1]f\", 12.0, 2, 6)\u000a\u000a```\u000aequivalent to \u000a\u000a```\u000afmt.Sprintf(\"%6.2f\", 12.0)\u000a\u000a```\u000awill yield \" 12.00\". Because an explicit index affects subsequent verbs, this notation can be used to print the same values multiple times by resetting the index for the first argument to be repeated: \u000a\u000a```\u000afmt.Sprintf(\"%d %d %#[1]x %#x\", 16, 17)\u000a\u000a```\u000awill yield \"16 17 0x10 0x11\". \u000a\u000a### hdr-Format_errorsFormat errors\u000aIf an invalid argument is given for a verb, such as providing a string to %d, the generated string will contain a description of the problem, as in these examples: \u000a\u000a```\u000aWrong type or unknown verb: %!verb(type=value)\u000a\u0009Printf(\"%d\", \"hi\"):        %!d(string=hi)\u000aToo many arguments: %!(EXTRA type=value)\u000a\u0009Printf(\"hi\", \"guys\"):      hi%!(EXTRA string=guys)\u000aToo few arguments: %!verb(MISSING)\u000a\u0009Printf(\"hi%d\"):            hi%!d(MISSING)\u000aNon-int for width or precision: %!(BADWIDTH) or %!(BADPREC)\u000a\u0009Printf(\"%*s\", 4.5, \"hi\"):  %!(BADWIDTH)hi\u000a\u0009Printf(\"%.*s\", 4.5, \"hi\"): %!(BADPREC)hi\u000aInvalid or invalid use of argument index: %!(BADINDEX)\u000a\u0009Printf(\"%*[2]d\", 7):       %!d(BADINDEX)\u000a\u0009Printf(\"%.[2]d\", 7):       %!d(BADINDEX)\u000a\u000a```\u000aAll errors begin with the string \"%!\" followed sometimes by a single character (the verb) and end with a parenthesized description. \u000a\u000aIf an Error or String method triggers a panic when called by a print routine, the fmt package reformats the error message from the panic, decorating it with an indication that it came through the fmt package.  For example, if a String method calls panic(\"bad\"), the resulting formatted message will look like \u000a\u000a```\u000a%!s(PANIC=bad)\u000a\u000a```\u000aThe %!s just shows the print verb in use when the failure occurred. If the panic is caused by a nil receiver to an Error or String method, however, the output is the undecorated string, \"<nil>\". \u000a\u000a### hdr-ScanningScanning\u000aAn analogous set of functions scans formatted text to yield values.  Scan, Scanf and Scanln read from os.Stdin; Fscan, Fscanf and Fscanln read from a specified io.Reader; Sscan, Sscanf and Sscanln read from an argument string. \u000a\u000aScan, Fscan, Sscan treat newlines in the input as spaces. \u000a\u000aScanln, Fscanln and Sscanln stop scanning at a newline and require that the items be followed by a newline or EOF. \u000a\u000aScanf, Fscanf, and Sscanf parse the arguments according to a format string, analogous to that of Printf. In the text that follows, 'space' means any Unicode whitespace character except newline. \u000a\u000aIn the format string, a verb introduced by the % character consumes and parses input; these verbs are described in more detail below. A character other than %, space, or newline in the format consumes exactly that input character, which must be present. A newline with zero or more spaces before it in the format string consumes zero or more spaces in the input followed by a single newline or the end of the input. A space following a newline in the format string consumes zero or more spaces in the input. Otherwise, any run of one or more spaces in the format string consumes as many spaces as possible in the input. Unless the run of spaces in the format string appears adjacent to a newline, the run must consume at least one space from the input or find the end of the input. \u000a\u000aThe handling of spaces and newlines differs from that of C's scanf family: in C, newlines are treated as any other space, and it is never an error when a run of spaces in the format string finds no spaces to consume in the input. \u000a\u000aThe verbs behave analogously to those of Printf. For example, %x will scan an integer as a hexadecimal number, and %v will scan the default representation format for the value. The Printf verbs %p and %T and the flags # and + are not implemented. For floating-point and complex values, all valid formatting verbs (%b %e %E %f %F %g %G %x %X and %v) are equivalent and accept both decimal and hexadecimal notation (for example: \"2.3e+7\", \"0x4.5p-8\") and digit-separating underscores (for example: \"3.14159_26535_89793\"). \u000a\u000aInput processed by verbs is implicitly space-delimited: the implementation of every verb except %c starts by discarding leading spaces from the remaining input, and the %s verb (and %v reading into a string) stops consuming input at the first space or newline character. \u000a\u000aThe familiar base-setting prefixes 0b (binary), 0o and 0 (octal), and 0x (hexadecimal) are accepted when scanning integers without a format or with the %v verb, as are digit-separating underscores. \u000a\u000aWidth is interpreted in the input text but there is no syntax for scanning with a precision (no %5.2f, just %5f). If width is provided, it applies after leading spaces are trimmed and specifies the maximum number of runes to read to satisfy the verb. For example, \u000a\u000a```\u000aSscanf(\" 1234567 \", \"%5s%d\", &s, &i)\u000a\u000a```\u000awill set s to \"12345\" and i to 67 while \u000a\u000a```\u000aSscanf(\" 12 34 567 \", \"%5s%d\", &s, &i)\u000a\u000a```\u000awill set s to \"12\" and i to 34. \u000a\u000aIn all the scanning functions, a carriage return followed immediately by a newline is treated as a plain newline (\\r\\n means the same as \\n). \u000a\u000aIn all the scanning functions, if an operand implements method Scan (that is, it implements the Scanner interface) that method will be used to scan the text for that operand.  Also, if the number of arguments scanned is less than the number of arguments provided, an error is returned. \u000a\u000aAll arguments to be scanned must be either pointers to basic types or implementations of the Scanner interface. \u000a\u000aLike Scanf and Fscanf, Sscanf need not consume its entire input. There is no way to recover how much of the input string Sscanf used. \u000a\u000aNote: Fscan etc. can read one character (rune) past the input they return, which means that a loop calling a scan routine may skip some of the input.  This is usually a problem only when there is no space between input values.  If the reader provided to Fscan implements ReadRune, that method will be used to read characters.  If the reader also implements UnreadRune, that method will be used to save the character and successive calls will not lose data.  To attach ReadRune and UnreadRune methods to a reader without that capability, use bufio.NewReader. \u000a\u000a"
          },
          "language": 56
        }
      }
    }
  },
  {
    "key": {
      "defn": {
        "key": {
          "file": { "key": "glean/lang/go/tests/cases/xrefs/leaphash.go" },
          "range": {
            "key": {
              "range": {
                "lineBegin": 23,
                "columnBegin": 2,
                "lineEnd": 23,
                "columnEnd": 9
              }
            }
          }
        }
      },
      "hover": {
        "key": {
          "text": {
            "key": "Package strings implements simple functions to manipulate UTF-8 encoded strings. \u000a\u000aFor information about UTF-8 strings in Go, see [https://blog.golang.org/strings](https://blog.golang.org/strings). \u000a\u000a"
          },
          "language": 56
        }
      }
    }
  },
  {
    "key": {
      "defn": {
        "key": {
          "file": { "key": "glean/lang/go/tests/cases/xrefs/leaphash.go" },
          "range": {
            "key": {
              "range": {
                "lineBegin": 31,
                "columnBegin": 5,
                "lineEnd": 31,
                "columnEnd": 12
              }
            }
          }
        }
      },
      "hover": {
        "key": {
          "text": {
            "key": "Compute returns the sha1 sum of all non whitespace characters in data excluding comments. Since it includes logic for special lines specific to the leap-second.list format its not a general purpose function and should be only used to verify the integrity of an official leap-second.list document. \u000a\u000a"
          },
          "language": 56
        }
      }
    }
  },
  {
    "key": {
      "defn": {
        "key": {
          "file": { "key": "glean/lang/go/tests/cases/xrefs/leaphash.go" },
          "range": {
            "key": {
              "range": {
                "lineBegin": 31,
                "columnBegin": 13,
                "lineEnd": 31,
                "columnEnd": 17
              }
            }
          }
        }
      },
      "hover": {
        "key": { "text": { "key": "var data string" }, "language": 16 }
      }
    }
  },
  {
    "key": {
      "defn": {
        "key": {
          "file": { "key": "glean/lang/go/tests/cases/xrefs/leaphash.go" },
          "range": {
            "key": {
              "range": {
                "lineBegin": 32,
                "columnBegin": 1,
                "lineEnd": 32,
                "columnEnd": 6
              }
            }
          }
        }
      },
      "hover": {
        "key": { "text": { "key": "var lines []string" }, "language": 16 }
      }
    }
  },
  {
    "key": {
      "defn": {
        "key": {
          "file": { "key": "glean/lang/go/tests/cases/xrefs/leaphash.go" },
          "range": {
            "key": {
              "range": {
                "lineBegin": 34,
                "columnBegin": 5,
                "lineEnd": 34,
                "columnEnd": 13
              }
            }
          }
        }
      },
      "hover": {
        "key": { "text": { "key": "var filtered string" }, "language": 16 }
      }
    }
  },
  {
    "key": {
      "defn": {
        "key": {
          "file": { "key": "glean/lang/go/tests/cases/xrefs/leaphash.go" },
          "range": {
            "key": {
              "range": {
                "lineBegin": 35,
                "columnBegin": 1,
                "lineEnd": 35,
                "columnEnd": 13
              }
            }
          }
        }
      },
      "hover": {
        "key": {
          "text": { "key": "var filterBlanks func(r rune) rune" },
          "language": 16
        }
      }
    }
  },
  {
    "key": {
      "defn": {
        "key": {
          "file": { "key": "glean/lang/go/tests/cases/xrefs/leaphash.go" },
          "range": {
            "key": {
              "range": {
                "lineBegin": 35,
                "columnBegin": 22,
                "lineEnd": 35,
                "columnEnd": 23
              }
            }
          }
        }
      },
      "hover": { "key": { "text": { "key": "var r rune" }, "language": 16 } }
    }
  },
  {
    "key": {
      "defn": {
        "key": {
          "file": { "key": "glean/lang/go/tests/cases/xrefs/leaphash.go" },
          "range": {
            "key": {
              "range": {
                "lineBegin": 42,
                "columnBegin": 5,
                "lineEnd": 42,
                "columnEnd": 6
              }
            }
          }
        }
      },
      "hover": { "key": { "text": { "key": "var i int" }, "language": 16 } }
    }
  },
  {
    "key": {
      "defn": {
        "key": {
          "file": { "key": "glean/lang/go/tests/cases/xrefs/leaphash.go" },
          "range": {
            "key": {
              "range": {
                "lineBegin": 51,
                "columnBegin": 3,
                "lineEnd": 51,
                "columnEnd": 7
              }
            }
          }
        }
      },
      "hover": {
        "key": { "text": { "key": "var line string" }, "language": 16 }
      }
    }
  },
  {
    "key": {
      "defn": {
        "key": {
          "file": { "key": "glean/lang/go/tests/cases/xrefs/leaphash.go" },
          "range": {
            "key": {
              "range": {
                "lineBegin": 53,
                "columnBegin": 3,
                "lineEnd": 53,
                "columnEnd": 13
              }
            }
          }
        }
      },
      "hover": {
        "key": { "text": { "key": "var commentPos int" }, "language": 16 }
      }
    }
  },
  {
    "key": {
      "defn": {
        "key": {
          "file": { "key": "glean/lang/go/tests/cases/xrefs/leaphash.go" },
          "range": {
            "key": {
              "range": {
                "lineBegin": 63,
                "columnBegin": 1,
                "lineEnd": 63,
                "columnEnd": 5
              }
            }
          }
        }
      },
      "hover": {
        "key": { "text": { "key": "var hash string" }, "language": 16 }
      }
    }
  },
  {
    "key": {
      "defn": {
        "key": {
          "file": { "key": "glean/lang/go/tests/cases/xrefs/leaphash.go" },
          "range": {
            "key": {
              "range": {
                "lineBegin": 65,
                "columnBegin": 5,
                "lineEnd": 65,
                "columnEnd": 16
              }
            }
          }
        }
      },
      "hover": {
        "key": { "text": { "key": "var groupedHash string" }, "language": 16 }
      }
    }
  },
  {
    "key": {
      "defn": {
        "key": {
          "file": { "key": "glean/lang/go/tests/cases/xrefs/leaphash.go" },
          "range": {
            "key": {
              "range": {
                "lineBegin": 67,
                "columnBegin": 5,
                "lineEnd": 67,
                "columnEnd": 6
              }
            }
          }
        }
      },
      "hover": { "key": { "text": { "key": "var i int" }, "language": 16 } }
    }
  }
]