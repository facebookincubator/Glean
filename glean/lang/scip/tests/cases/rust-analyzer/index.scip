
]
@generated   0.1Cfile:///data/users/wilfred/fbsource/fbcode/hphp/hack/src/utils/rust ªú"rust
relative_path.rslocal 0V	Nrust-analyzer cargo alloc https://github.com/rust-lang/rust/library/alloc fmt/local 0V	Nrust-analyzer cargo alloc https://github.com/rust-lang/rust/library/alloc fmt/\Trust-analyzer cargo core https://github.com/rust-lang/rust/library/core fmt/Display#local 0S	Krust-analyzer cargo std https://github.com/rust-lang/rust/library/std path/XPrust-analyzer cargo std https://github.com/rust-lang/rust/library/std path/Path#local 0S	Krust-analyzer cargo std https://github.com/rust-lang/rust/library/std path/[Srust-analyzer cargo std https://github.com/rust-lang/rust/library/std path/PathBuf#
local 18
0rust-analyzer cargo eq_modulo_pos . EqModuloPos#local 24,rust-analyzer cargo no_pos_hash . NoPosHash#local 34,rust-analyzer cargo ocamlrep . FromOcamlRep#local 36.rust-analyzer cargo ocamlrep . FromOcamlRepIn#local 32*rust-analyzer cargo ocamlrep . ToOcamlRep#	local 4;3rust-analyzer cargo serde-1.0.152 . de/Deserialize#	local 4:2rust-analyzer cargo serde-1.0.152 . ser/Serialize#f^rust-analyzer cargo core https://github.com/rust-lang/rust/library/core builtin/macros/derive!\	Trust-analyzer cargo core https://github.com/rust-lang/rust/library/core clone/Clone!\Trust-analyzer cargo core https://github.com/rust-lang/rust/library/core marker/Copy!aYrust-analyzer cargo core https://github.com/rust-lang/rust/library/core macros/fmt/Debug!WOrust-analyzer cargo core https://github.com/rust-lang/rust/library/core cmp/Eq!a!%Yrust-analyzer cargo core https://github.com/rust-lang/rust/library/core macros/hash/Hash!X'*Prust-analyzer cargo core https://github.com/rust-lang/rust/library/core cmp/Ord!^,5Vrust-analyzer cargo core https://github.com/rust-lang/rust/library/core cmp/PartialEq!_7AWrust-analyzer cargo core https://github.com/rust-lang/rust/library/core cmp/PartialOrd!f^rust-analyzer cargo core https://github.com/rust-lang/rust/library/core builtin/macros/derive!@	8rust-analyzer cargo _serde_derive-1.0.152 . Deserialize!>6rust-analyzer cargo _serde_derive-1.0.152 . Serialize!f^rust-analyzer cargo core https://github.com/rust-lang/rust/library/core builtin/macros/derive!@	8rust-analyzer cargo _eq_modulo_pos_derive . EqModuloPos!<"4rust-analyzer cargo _ocamlrep_derive . FromOcamlRep!>$26rust-analyzer cargo _ocamlrep_derive . FromOcamlRepIn!:4>2rust-analyzer cargo _ocamlrep_derive . ToOcamlRep!<@I4rust-analyzer cargo _no_pos_hash_derive . NoPosHash!local 55	+rust-analyzer cargo relative_path . Prefix#3)rust-analyzer cargo relative_path . Root#2(rust-analyzer cargo relative_path . Hhi#4	*rust-analyzer cargo relative_path . Dummy#2(rust-analyzer cargo relative_path . Tmp#local 66.rust-analyzer cargo arena_trait . TrivialDrop#3"(+rust-analyzer cargo relative_path . Prefix#3+rust-analyzer cargo relative_path . Prefix#>4rust-analyzer cargo relative_path . Prefix#is_hhi().4*rust-analyzer cargo relative_path . (self)local 7_ Wrust-analyzer cargo core https://github.com/rust-lang/rust/library/core macros/matches!2 *rust-analyzer cargo relative_path . (self)3 +rust-analyzer cargo relative_path . Prefix#0 "(rust-analyzer cargo relative_path . Hhi#`$Xrust-analyzer cargo core https://github.com/rust-lang/rust/library/core convert/TryFrom#$local 83$+rust-analyzer cargo relative_path . Prefix#D%	:rust-analyzer cargo relative_path . Prefix#TryFrom#[Error]`%Xrust-analyzer cargo alloc https://github.com/rust-lang/rust/library/alloc string/String#H'>rust-analyzer cargo relative_path . Prefix#TryFrom#try_from().:'0rust-analyzer cargo relative_path . (prefix_raw)'!local 8^'&,Vrust-analyzer cargo core https://github.com/rust-lang/rust/library/core result/Result#3'-1+rust-analyzer cargo relative_path . Prefix#`'39Xrust-analyzer cargo alloc https://github.com/rust-lang/rust/library/alloc string/String#8(0rust-analyzer cargo relative_path . (prefix_raw)Z)Rrust-analyzer cargo core https://github.com/rust-lang/rust/library/core result/Ok#3)+rust-analyzer cargo relative_path . Prefix#1) )rust-analyzer cargo relative_path . Root#Z*Rrust-analyzer cargo core https://github.com/rust-lang/rust/library/core result/Ok#3*+rust-analyzer cargo relative_path . Prefix#0*(rust-analyzer cargo relative_path . Hhi#Z+Rrust-analyzer cargo core https://github.com/rust-lang/rust/library/core result/Ok#3++rust-analyzer cargo relative_path . Prefix#2+!*rust-analyzer cargo relative_path . Dummy#Z,Rrust-analyzer cargo core https://github.com/rust-lang/rust/library/core result/Ok#3,+rust-analyzer cargo relative_path . Prefix#0,(rust-analyzer cargo relative_path . Tmp#[-Srust-analyzer cargo core https://github.com/rust-lang/rust/library/core result/Err#`-Xrust-analyzer cargo alloc https://github.com/rust-lang/rust/library/alloc macros/format!8-9C0rust-analyzer cargo relative_path . (prefix_raw)\2Trust-analyzer cargo core https://github.com/rust-lang/rust/library/core fmt/Display#32+rust-analyzer cargo relative_path . Prefix#C3
9rust-analyzer cargo relative_path . Prefix#Display#fmt().43*rust-analyzer cargo relative_path . (self)13'rust-analyzer cargo relative_path . (f)V3Nrust-analyzer cargo alloc https://github.com/rust-lang/rust/library/alloc fmt/^3(Vrust-analyzer cargo core https://github.com/rust-lang/rust/library/core fmt/Formatter#V314Nrust-analyzer cargo alloc https://github.com/rust-lang/rust/library/alloc fmt/\36<Trust-analyzer cargo core https://github.com/rust-lang/rust/library/core fmt/[Result]26*rust-analyzer cargo relative_path . (self)37+rust-analyzer cargo relative_path . Prefix#17)rust-analyzer cargo relative_path . Root#]7Urust-analyzer cargo core https://github.com/rust-lang/rust/library/core macros/write!/7!"'rust-analyzer cargo relative_path . (f)38+rust-analyzer cargo relative_path . Prefix#08(rust-analyzer cargo relative_path . Hhi#]8Urust-analyzer cargo core https://github.com/rust-lang/rust/library/core macros/write!/8 !'rust-analyzer cargo relative_path . (f)39+rust-analyzer cargo relative_path . Prefix#09(rust-analyzer cargo relative_path . Tmp#]9Urust-analyzer cargo core https://github.com/rust-lang/rust/library/core macros/write!/9 !'rust-analyzer cargo relative_path . (f)3:+rust-analyzer cargo relative_path . Prefix#2:*rust-analyzer cargo relative_path . Dummy#]: Urust-analyzer cargo core https://github.com/rust-lang/rust/library/core macros/write!/:"#'rust-analyzer cargo relative_path . (f)f?^rust-analyzer cargo core https://github.com/rust-lang/rust/library/core builtin/macros/derive!\?	Trust-analyzer cargo core https://github.com/rust-lang/rust/library/core clone/Clone!W?Orust-analyzer cargo core https://github.com/rust-lang/rust/library/core cmp/Eq!a?Yrust-analyzer cargo core https://github.com/rust-lang/rust/library/core macros/hash/Hash!^?#Vrust-analyzer cargo core https://github.com/rust-lang/rust/library/core cmp/PartialEq!f@^rust-analyzer cargo core https://github.com/rust-lang/rust/library/core builtin/macros/derive!@@	8rust-analyzer cargo _eq_modulo_pos_derive . EqModuloPos!<@4rust-analyzer cargo _no_pos_hash_derive . NoPosHash!;A1rust-analyzer cargo relative_path . RelativePath#BB
8rust-analyzer cargo relative_path . RelativePath#prefix.3B+rust-analyzer cargo relative_path . Prefix#@F6rust-analyzer cargo relative_path . RelativePath#path.^F
Vrust-analyzer cargo core https://github.com/rust-lang/rust/library/core option/Option#[FSrust-analyzer cargo std https://github.com/rust-lang/rust/library/std path/PathBuf#9I1rust-analyzer cargo relative_path . RelativePath#BJ8rust-analyzer cargo relative_path . RelativePath#make().6J,rust-analyzer cargo relative_path . (prefix)3J+rust-analyzer cargo relative_path . Prefix#4J $*rust-analyzer cargo relative_path . (path)[J&-Srust-analyzer cargo std https://github.com/rust-lang/rust/library/std path/PathBuf#9J261rust-analyzer cargo relative_path . RelativePath#9K1rust-analyzer cargo relative_path . RelativePath#>M6rust-analyzer cargo relative_path . RelativePath#path.2M*rust-analyzer cargo relative_path . (path)dM#\rust-analyzer cargo std https://github.com/rust-lang/rust/library/std path/Path#as_os_str().jM&.brust-analyzer cargo std https://github.com/rust-lang/rust/library/std os_str/ffi/OsStr#is_empty().\NTrust-analyzer cargo core https://github.com/rust-lang/rust/library/core option/None#\PTrust-analyzer cargo core https://github.com/rust-lang/rust/library/core option/Some#2P*rust-analyzer cargo relative_path . (path)AU7rust-analyzer cargo relative_path . RelativePath#EMPTY.9U1rust-analyzer cargo relative_path . RelativePath#9U 1rust-analyzer cargo relative_path . RelativePath#@V8rust-analyzer cargo relative_path . RelativePath#prefix.3V+rust-analyzer cargo relative_path . Prefix#2V*rust-analyzer cargo relative_path . Dummy#>W6rust-analyzer cargo relative_path . RelativePath#path.\WTrust-analyzer cargo core https://github.com/rust-lang/rust/library/core option/None#FZ<rust-analyzer cargo relative_path . RelativePath#is_empty().4Z*rust-analyzer cargo relative_path . (self)Z"local 72[*rust-analyzer cargo relative_path . (self)9[1rust-analyzer cargo relative_path . RelativePath#?[7rust-analyzer cargo relative_path . RelativePath#EMPTY.K^Arust-analyzer cargo relative_path . RelativePath#has_extension().4^*rust-analyzer cargo relative_path . (self)1^ !'rust-analyzer cargo relative_path . (s)^^(-Vrust-analyzer cargo core https://github.com/rust-lang/rust/library/core convert/AsRef#X^.2Prust-analyzer cargo std https://github.com/rust-lang/rust/library/std path/Path#^8<local 72_*rust-analyzer cargo relative_path . (self)@_8rust-analyzer cargo relative_path . RelativePath#path().d_\rust-analyzer cargo std https://github.com/rust-lang/rust/library/std path/Path#extension().\_#'Trust-analyzer cargo core https://github.com/rust-lang/rust/library/core option/Some#/_()'rust-analyzer cargo relative_path . (s)g_*0_rust-analyzer cargo core https://github.com/rust-lang/rust/library/core convert/AsRef#as_ref().d_3<\rust-analyzer cargo std https://github.com/rust-lang/rust/library/std path/Path#as_os_str().Bb8rust-analyzer cargo relative_path . RelativePath#path().4b*rust-analyzer cargo relative_path . (self)XbPrust-analyzer cargo std https://github.com/rust-lang/rust/library/std path/Path#2c*rust-analyzer cargo relative_path . (self)>c6rust-analyzer cargo relative_path . RelativePath#path.icarust-analyzer cargo core https://github.com/rust-lang/rust/library/core option/Option#as_deref().jc&brust-analyzer cargo core https://github.com/rust-lang/rust/library/core option/Option#unwrap_or().Xc'+Prust-analyzer cargo std https://github.com/rust-lang/rust/library/std path/Path#^c-0Vrust-analyzer cargo std https://github.com/rust-lang/rust/library/std path/Path#new().Ff<rust-analyzer cargo relative_path . RelativePath#path_str().4f*rust-analyzer cargo relative_path . (self)f"local 92g*rust-analyzer cargo relative_path . (self)@g8rust-analyzer cargo relative_path . RelativePath#path().agYrust-analyzer cargo std https://github.com/rust-lang/rust/library/std path/Path#to_str().gg#_rust-analyzer cargo core https://github.com/rust-lang/rust/library/core option/Option#unwrap().Dj:rust-analyzer cargo relative_path . RelativePath#prefix().4j*rust-analyzer cargo relative_path . (self)3j"+rust-analyzer cargo relative_path . Prefix#2k*rust-analyzer cargo relative_path . (self)@k8rust-analyzer cargo relative_path . RelativePath#prefix.Dn:rust-analyzer cargo relative_path . RelativePath#is_hhi().4n*rust-analyzer cargo relative_path . (self)n local 72o*rust-analyzer cargo relative_path . (self)@o8rust-analyzer cargo relative_path . RelativePath#prefix.<o4rust-analyzer cargo relative_path . Prefix#is_hhi().Ir?rust-analyzer cargo relative_path . RelativePath#to_absolute().4r*rust-analyzer cargo relative_path . (self)3r!)rust-analyzer cargo relative_path . (ctx)<r$34rust-analyzer cargo relative_path . RelativePathCtx#[r8?Srust-analyzer cargo std https://github.com/rust-lang/rust/library/std path/PathBuf#1s)rust-analyzer cargo relative_path . (ctx)JsBrust-analyzer cargo relative_path . RelativePathCtx#prefix_path().2s*rust-analyzer cargo relative_path . (self)@s#8rust-analyzer cargo relative_path . RelativePath#prefix._s%)Wrust-analyzer cargo std https://github.com/rust-lang/rust/library/std path/Path#join().2s*.*rust-analyzer cargo relative_path . (self)@s/38rust-analyzer cargo relative_path . RelativePath#path().\wTrust-analyzer cargo core https://github.com/rust-lang/rust/library/core fmt/Display#9w1rust-analyzer cargo relative_path . RelativePath#Ix
?rust-analyzer cargo relative_path . RelativePath#Display#fmt().4x*rust-analyzer cargo relative_path . (self)1x'rust-analyzer cargo relative_path . (f)VxNrust-analyzer cargo alloc https://github.com/rust-lang/rust/library/alloc fmt/^x(Vrust-analyzer cargo core https://github.com/rust-lang/rust/library/core fmt/Formatter#Vx14Nrust-analyzer cargo alloc https://github.com/rust-lang/rust/library/alloc fmt/\x6<Trust-analyzer cargo core https://github.com/rust-lang/rust/library/core fmt/[Result]]yUrust-analyzer cargo core https://github.com/rust-lang/rust/library/core macros/write!/y'rust-analyzer cargo relative_path . (f)2y*rust-analyzer cargo relative_path . (self)@y &8rust-analyzer cargo relative_path . RelativePath#prefix.2y(,*rust-analyzer cargo relative_path . (self)@y-18rust-analyzer cargo relative_path . RelativePath#path().by4;Zrust-analyzer cargo std https://github.com/rust-lang/rust/library/std path/Path#display().}local 0V}
Nrust-analyzer cargo alloc https://github.com/rust-lang/rust/library/alloc fmt/Z}Rrust-analyzer cargo core https://github.com/rust-lang/rust/library/core fmt/Debug#9}%1rust-analyzer cargo relative_path . RelativePath#G~
=rust-analyzer cargo relative_path . RelativePath#Debug#fmt().4~*rust-analyzer cargo relative_path . (self)1~'rust-analyzer cargo relative_path . (f)~local 0V~"Nrust-analyzer cargo alloc https://github.com/rust-lang/rust/library/alloc fmt/^~$-Vrust-analyzer cargo core https://github.com/rust-lang/rust/library/core fmt/Formatter#~69local 0V~;>Nrust-analyzer cargo alloc https://github.com/rust-lang/rust/library/alloc fmt/\~@FTrust-analyzer cargo core https://github.com/rust-lang/rust/library/core fmt/[Result]]Urust-analyzer cargo core https://github.com/rust-lang/rust/library/core macros/write!/'rust-analyzer cargo relative_path . (f)YáPrust-analyzer cargo core https://github.com/rust-lang/rust/library/core cmp/Ord#:á1rust-analyzer cargo relative_path . RelativePath#Fà
;rust-analyzer cargo relative_path . RelativePath#Ord#cmp().5à*rust-analyzer cargo relative_path . (self)6à+rust-analyzer cargo relative_path . (other):à1rust-analyzer cargo relative_path . RelativePath#à#&local 0Uà(+Lrust-analyzer cargo core https://github.com/rust-lang/rust/library/core cmp/^à-5Urust-analyzer cargo core https://github.com/rust-lang/rust/library/core cmp/Ordering#3â*rust-analyzer cargo relative_path . (self)Aâ8rust-analyzer cargo relative_path . RelativePath#prefix._äVrust-analyzer cargo core https://github.com/rust-lang/rust/library/core cmp/Ord#cmp().4ä+rust-analyzer cargo relative_path . (other)Aä8rust-analyzer cargo relative_path . RelativePath#prefix.eã\rust-analyzer cargo core https://github.com/rust-lang/rust/library/core cmp/Ordering#then().3ã*rust-analyzer cargo relative_path . (self)Aã8rust-analyzer cargo relative_path . RelativePath#path().eã'\rust-analyzer cargo std https://github.com/rust-lang/rust/library/std path/Path#as_os_str().jã*-arust-analyzer cargo std https://github.com/rust-lang/rust/library/std os_str/ffi/OsStr#Ord#cmp().4ã.3+rust-analyzer cargo relative_path . (other)Aã488rust-analyzer cargo relative_path . RelativePath#path().eã;D\rust-analyzer cargo std https://github.com/rust-lang/rust/library/std path/Path#as_os_str().`èWrust-analyzer cargo core https://github.com/rust-lang/rust/library/core cmp/PartialOrd#:è 1rust-analyzer cargo relative_path . RelativePath#UêJrust-analyzer cargo relative_path . RelativePath#PartialOrd#partial_cmp().5ê*rust-analyzer cargo relative_path . (self)6ê+rust-analyzer cargo relative_path . (other):ê"&1rust-analyzer cargo relative_path . RelativePath#_ê+1Vrust-analyzer cargo core https://github.com/rust-lang/rust/library/core option/Option#ê25local 0Uê7:Lrust-analyzer cargo core https://github.com/rust-lang/rust/library/core cmp/^ê<DUrust-analyzer cargo core https://github.com/rust-lang/rust/library/core cmp/Ordering#]ëTrust-analyzer cargo core https://github.com/rust-lang/rust/library/core option/Some#3ë*rust-analyzer cargo relative_path . (self)Dë;rust-analyzer cargo relative_path . RelativePath#Ord#cmp().4ë+rust-analyzer cargo relative_path . (other);ó2rust-analyzer cargo serde-1.0.152 . ser/Serialize#:ó1rust-analyzer cargo relative_path . RelativePath#RòGrust-analyzer cargo relative_path . RelativePath#Serialize#serialize().òlocal 10òlocal 4<ò%3rust-analyzer cargo serde-1.0.152 . ser/Serializer#5ò(,*rust-analyzer cargo relative_path . (self);ò.80rust-analyzer cargo relative_path . (serializer)ò:;local 10_ò@FVrust-analyzer cargo core https://github.com/rust-lang/rust/library/core result/Result#òGHlocal 10@òJL7rust-analyzer cargo serde-1.0.152 . ser/Serializer#[Ok]òNOlocal 10CòQV:rust-analyzer cargo serde-1.0.152 . ser/Serializer#[Error]ôlocal 113ô*rust-analyzer cargo relative_path . (self)Aô!8rust-analyzer cargo relative_path . RelativePath#path().bô$*Yrust-analyzer cargo std https://github.com/rust-lang/rust/library/std path/Path#to_str().löcrust-analyzer cargo core https://github.com/rust-lang/rust/library/core option/Option#ok_or_else().ö local 41ö"%(rust-analyzer cargo serde-1.0.152 . ser/7ö',.rust-analyzer cargo serde-1.0.152 . ser/Error#@ö.47rust-analyzer cargo serde-1.0.152 . ser/Error#custom().9õ0rust-analyzer cargo relative_path . (serializer)Lõ Crust-analyzer cargo serde-1.0.152 . ser/Serializer#serialize_str().aõ"(Xrust-analyzer cargo alloc https://github.com/rust-lang/rust/library/alloc macros/format!3õ37*rust-analyzer cargo relative_path . (self)Aõ8>8rust-analyzer cargo relative_path . RelativePath#prefix.õ@Hlocal 11†local 12<†
3rust-analyzer cargo serde-1.0.152 . de/Deserialize#†local 12:†+1rust-analyzer cargo relative_path . RelativePath#V°Krust-analyzer cargo relative_path . RelativePath#Deserialize#deserialize().°local 13=°"2rust-analyzer cargo relative_path . (deserializer)°$%local 13_°*0Vrust-analyzer cargo core https://github.com/rust-lang/rust/library/core result/Result#:°151rust-analyzer cargo relative_path . RelativePath#°78local 13D°:?;rust-analyzer cargo serde-1.0.152 . de/Deserializer#[Error]£	local 13£local 4=£4rust-analyzer cargo serde-1.0.152 . de/Deserializer#£"local 127•,rust-analyzer cargo relative_path . Visitor#ßlocal 14ßlocal 40ß'rust-analyzer cargo serde-1.0.152 . de/8ß$/rust-analyzer cargo serde-1.0.152 . de/Visitor#ß%(local 145ß.5,rust-analyzer cargo relative_path . Visitor#F®;rust-analyzer cargo relative_path . Visitor#Visitor#[Value]:®%1rust-analyzer cargo relative_path . RelativePath#K™@rust-analyzer cargo relative_path . Visitor#Visitor#expecting().5™*rust-analyzer cargo relative_path . (self):™ )/rust-analyzer cargo relative_path . (formatter)™25local 0W™7:Nrust-analyzer cargo alloc https://github.com/rust-lang/rust/library/alloc fmt/_™<EVrust-analyzer cargo core https://github.com/rust-lang/rust/library/core fmt/Formatter#™PSlocal 0W™UXNrust-analyzer cargo alloc https://github.com/rust-lang/rust/library/alloc fmt/]™Z`Trust-analyzer cargo core https://github.com/rust-lang/rust/library/core fmt/[Result]^´Urust-analyzer cargo core https://github.com/rust-lang/rust/library/core macros/write!8´ /rust-analyzer cargo relative_path . (formatter)KÆ@rust-analyzer cargo relative_path . Visitor#Visitor#visit_str().Ælocal 155Æ *rust-analyzer cargo relative_path . (self)6Æ"'+rust-analyzer cargo relative_path . (value)Æ*-local 9_Æ28Vrust-analyzer cargo core https://github.com/rust-lang/rust/library/core result/Result#:Æ9E1rust-analyzer cargo relative_path . RelativePath#ÆGHlocal 15∞local 15∞local 40∞'rust-analyzer cargo serde-1.0.152 . de/6∞#-rust-analyzer cargo serde-1.0.152 . de/Error#≤local 164≤ %+rust-analyzer cargo relative_path . (value)^≤&,Urust-analyzer cargo core https://github.com/rust-lang/rust/library/core str/splitn().≥local 17≥!&local 16q≥'+hrust-analyzer cargo core https://github.com/rust-lang/rust/library/core iter/str/SplitN#Iterator#next().¥local 18¥$local 16q¥%)hrust-analyzer cargo core https://github.com/rust-lang/rust/library/core iter/str/SplitN#Iterator#next().gµ^rust-analyzer cargo core https://github.com/rust-lang/rust/library/core builtin/macros/assert!µlocal 16qµ"hrust-analyzer cargo core https://github.com/rust-lang/rust/library/core iter/str/SplitN#Iterator#next().iµ%,`rust-analyzer cargo core https://github.com/rust-lang/rust/library/core option/Option#is_none().∂local 19∂#-local 17]∑Trust-analyzer cargo core https://github.com/rust-lang/rust/library/core option/Some#4∑$*+rust-analyzer cargo relative_path . Prefix#2∑,0)rust-analyzer cargo relative_path . Root#]∏Trust-analyzer cargo core https://github.com/rust-lang/rust/library/core option/Some#4∏#)+rust-analyzer cargo relative_path . Prefix#1∏+.(rust-analyzer cargo relative_path . Hhi#]πTrust-analyzer cargo core https://github.com/rust-lang/rust/library/core option/Some#4π#)+rust-analyzer cargo relative_path . Prefix#1π+.(rust-analyzer cargo relative_path . Tmp#]∫Trust-analyzer cargo core https://github.com/rust-lang/rust/library/core option/Some#4∫ &+rust-analyzer cargo relative_path . Prefix#3∫(-*rust-analyzer cargo relative_path . Dummy#\º"Srust-analyzer cargo core https://github.com/rust-lang/rust/library/core result/Err#º#$local 15Fº&3=rust-analyzer cargo serde-1.0.152 . de/Error#invalid_value().Ω!local 40Ω#%'rust-analyzer cargo serde-1.0.152 . de/;Ω'12rust-analyzer cargo serde-1.0.152 . de/Unexpected#6Ω38-rust-analyzer cargo serde-1.0.152 . de/Other#aΩ:@Xrust-analyzer cargo alloc https://github.com/rust-lang/rust/library/alloc macros/format!4ø %+rust-analyzer cargo relative_path . (value)3¡!*rust-analyzer cargo relative_path . (self)≈local 20≈!)local 18]∆Trust-analyzer cargo core https://github.com/rust-lang/rust/library/core option/Some#∆!local 21∆&.local 21`∆/7Wrust-analyzer cargo core https://github.com/rust-lang/rust/library/core str/is_empty().]∆=ATrust-analyzer cargo core https://github.com/rust-lang/rust/library/core option/None#]«Trust-analyzer cargo core https://github.com/rust-lang/rust/library/core option/Some#«!local 22]«&*Trust-analyzer cargo core https://github.com/rust-lang/rust/library/core option/Some#\«+2Srust-analyzer cargo std https://github.com/rust-lang/rust/library/std path/PathBuf#h«48_rust-analyzer cargo std https://github.com/rust-lang/rust/library/std path/PathBuf#From#from().«9Alocal 22]»Trust-analyzer cargo core https://github.com/rust-lang/rust/library/core option/None#\…"Srust-analyzer cargo core https://github.com/rust-lang/rust/library/core result/Err#…#$local 15F…&3=rust-analyzer cargo serde-1.0.152 . de/Error#invalid_value(). !local 40 #%'rust-analyzer cargo serde-1.0.152 . de/; '12rust-analyzer cargo serde-1.0.152 . de/Unexpected#6 38-rust-analyzer cargo serde-1.0.152 . de/Other#3Œ!*rust-analyzer cargo relative_path . (self)[“Rrust-analyzer cargo core https://github.com/rust-lang/rust/library/core result/Ok#:“1rust-analyzer cargo relative_path . RelativePath#;÷2rust-analyzer cargo relative_path . (deserializer)O÷$Frust-analyzer cargo serde-1.0.152 . de/Deserializer#deserialize_str().5÷%,,rust-analyzer cargo relative_path . Visitor#3⁄*rust-analyzer cargo ocamlrep . ToOcamlRep#:⁄ 1rust-analyzer cargo relative_path . RelativePath#U€Jrust-analyzer cargo relative_path . RelativePath#ToOcamlRep#to_ocamlrep().€local 23€local 24€"local 32€$-)rust-analyzer cargo ocamlrep . Allocator#€02local 235€37*rust-analyzer cargo relative_path . (self)6€9>+rust-analyzer cargo relative_path . (alloc)€AClocal 23€DElocal 24€JRlocal 34€TY+rust-analyzer cargo ocamlrep . value/Value#€Z\local 23‹local 254‹+rust-analyzer cargo relative_path . (alloc)D‹-;rust-analyzer cargo ocamlrep . Allocator#block_with_size().4›+rust-analyzer cargo relative_path . (alloc)>›5rust-analyzer cargo ocamlrep . Allocator#set_field().›"local 254›',+rust-analyzer cargo relative_path . (alloc)8›-0/rust-analyzer cargo ocamlrep . Allocator#add().3›26*rust-analyzer cargo relative_path . (self)A›7=8rust-analyzer cargo relative_path . RelativePath#prefix.4ﬁ+rust-analyzer cargo relative_path . (alloc)>ﬁ5rust-analyzer cargo ocamlrep . Allocator#set_field().ﬁ"local 254ﬁ',+rust-analyzer cargo relative_path . (alloc)8ﬁ-0/rust-analyzer cargo ocamlrep . Allocator#add().3ﬁ15*rust-analyzer cargo relative_path . (self)Aﬁ6:8rust-analyzer cargo relative_path . RelativePath#path().ﬂlocal 25Cﬂ:rust-analyzer cargo ocamlrep . block/BlockBuilder#build().5„,rust-analyzer cargo ocamlrep . FromOcamlRep#:„"1rust-analyzer cargo relative_path . RelativePath#Y‰Nrust-analyzer cargo relative_path . RelativePath#FromOcamlRep#from_ocamlrep().6‰+rust-analyzer cargo relative_path . (value)‰$local 34‰&++rust-analyzer cargo ocamlrep . value/Value#_‰4:Vrust-analyzer cargo core https://github.com/rust-lang/rust/library/core result/Result#:‰;?1rust-analyzer cargo relative_path . RelativePath#‰AIlocal 38‰KT/rust-analyzer cargo ocamlrep . error/FromError#Âlocal 26Âlocal 3-Â"$rust-analyzer cargo ocamlrep . from/<Â$03rust-analyzer cargo ocamlrep . from/expect_tuple().4Â16+rust-analyzer cargo relative_path . (value)Êlocal 27Êlocal 3-Ê#$rust-analyzer cargo ocamlrep . from/5Ê%*,rust-analyzer cargo ocamlrep . from/field().Ê+0local 26Álocal 28\ÁSrust-analyzer cargo std https://github.com/rust-lang/rust/library/std path/PathBuf#Á$local 3-Á&*$rust-analyzer cargo ocamlrep . from/5Á,1,rust-analyzer cargo ocamlrep . from/field().Á27local 26[Ë
Rrust-analyzer cargo core https://github.com/rust-lang/rust/library/core result/Ok#:Ë1rust-analyzer cargo relative_path . RelativePath#AË8rust-analyzer cargo relative_path . RelativePath#make().Ëlocal 27Ë"local 284Ï	)rust-analyzer cargo relative_path . [Map]Ïlocal 29Ïlocal 0[Ï"Rrust-analyzer cargo std https://github.com/rust-lang/rust/library/std collections/rÏ$,irust-analyzer cargo alloc https://github.com/rust-lang/rust/library/alloc map/btree/collections/BTreeMap#:Ï-91rust-analyzer cargo relative_path . RelativePath#Ï;<local 293Ó(rust-analyzer cargo relative_path . map/Ôlocal 302Ô)rust-analyzer cargo relative_path . [Map]gÚ^rust-analyzer cargo core https://github.com/rust-lang/rust/library/core builtin/macros/derive!bÚ	Yrust-analyzer cargo core https://github.com/rust-lang/rust/library/core macros/fmt/Debug!aÚXrust-analyzer cargo core https://github.com/rust-lang/rust/library/core default/Default!]ÚTrust-analyzer cargo core https://github.com/rust-lang/rust/library/core clone/Clone!gÛ^rust-analyzer cargo core https://github.com/rust-lang/rust/library/core builtin/macros/derive!Û	local 4?Û6rust-analyzer cargo _serde_derive-1.0.152 . Serialize!Û local 4AÛ"-8rust-analyzer cargo _serde_derive-1.0.152 . Deserialize!?Ù4rust-analyzer cargo relative_path . RelativePathCtx#Dı9rust-analyzer cargo relative_path . RelativePathCtx#root.\ıSrust-analyzer cargo std https://github.com/rust-lang/rust/library/std path/PathBuf#Cˆ8rust-analyzer cargo relative_path . RelativePathCtx#hhi.\ˆSrust-analyzer cargo std https://github.com/rust-lang/rust/library/std path/PathBuf#C˜8rust-analyzer cargo relative_path . RelativePathCtx#tmp.\˜Srust-analyzer cargo std https://github.com/rust-lang/rust/library/std path/PathBuf#E¯:rust-analyzer cargo relative_path . RelativePathCtx#dummy.\¯Srust-analyzer cargo std https://github.com/rust-lang/rust/library/std path/PathBuf#=˚4rust-analyzer cargo relative_path . RelativePathCtx#M¸Brust-analyzer cargo relative_path . RelativePathCtx#prefix_path().5¸*rust-analyzer cargo relative_path . (self)7¸$,rust-analyzer cargo relative_path . (prefix)4¸&,+rust-analyzer cargo relative_path . Prefix#Y¸26Prust-analyzer cargo std https://github.com/rust-lang/rust/library/std path/Path#5˝,rust-analyzer cargo relative_path . (prefix)4˛+rust-analyzer cargo relative_path . Prefix#2˛)rust-analyzer cargo relative_path . Root#3˛!*rust-analyzer cargo relative_path . (self)B˛"&9rust-analyzer cargo relative_path . RelativePathCtx#root.4ˇ+rust-analyzer cargo relative_path . Prefix#1ˇ(rust-analyzer cargo relative_path . Hhi#3ˇ *rust-analyzer cargo relative_path . (self)Aˇ!$8rust-analyzer cargo relative_path . RelativePathCtx#hhi.4Ä+rust-analyzer cargo relative_path . Prefix#1Ä(rust-analyzer cargo relative_path . Tmp#3Ä *rust-analyzer cargo relative_path . (self)AÄ!$8rust-analyzer cargo relative_path . RelativePathCtx#tmp.4Å+rust-analyzer cargo relative_path . Prefix#3Å*rust-analyzer cargo relative_path . Dummy#3Å"*rust-analyzer cargo relative_path . (self)CÅ#(:rust-analyzer cargo relative_path . RelativePathCtx#dummy.Ülocal 315á	*rust-analyzer cargo relative_path . tests/älocal 30eå
\rust-analyzer cargo core https://github.com/rust-lang/rust/library/core builtin/macros/test!OçDrust-analyzer cargo relative_path . tests/test_valid_usize_prefix().élocal 32élocal 8bèYrust-analyzer cargo core https://github.com/rust-lang/rust/library/core macros/assert_eq![èRrust-analyzer cargo core https://github.com/rust-lang/rust/library/core result/Ok#4è+rust-analyzer cargo relative_path . Prefix#3è#*rust-analyzer cargo relative_path . Dummy#4è&,+rust-analyzer cargo relative_path . Prefix#Gè.6>rust-analyzer cargo relative_path . Prefix#TryFrom#try_from().è7Clocal 32eí
\rust-analyzer cargo core https://github.com/rust-lang/rust/library/core builtin/macros/test!Qì Frust-analyzer cargo relative_path . tests/test_invalid_usize_prefix().îlocal 33î!local 8bñYrust-analyzer cargo core https://github.com/rust-lang/rust/library/core macros/assert_eq!\óSrust-analyzer cargo core https://github.com/rust-lang/rust/library/core result/Err#oó+4frust-analyzer cargo alloc https://github.com/rust-lang/rust/library/alloc string/ToString#to_string().4ò+rust-analyzer cargo relative_path . Prefix#Gò>rust-analyzer cargo relative_path . Prefix#TryFrom#try_from().ò+local 33ÜF
local 0˙E
```rust
extern crate std
```

---

# The Rust Standard Library

The Rust Standard Library is the foundation of portable Rust software, a
set of minimal and battle-tested shared abstractions for the [broader Rust
ecosystem](https://crates.io). It offers core types, like [`Vec<T>`] and
[`Option<T>`], library-defined [operations on language
primitives](https://doc.rust-lang.org/nightly/std/index.html#primitives), [standard macros](https://doc.rust-lang.org/nightly/std/index.html#macros), [I/O] and
[multithreading], among [many other things](https://doc.rust-lang.org/nightly/std/index.html#what-is-in-the-standard-library-documentation).

`std` is available to all Rust crates by default. Therefore, the
standard library can be accessed in [`use`](https://doc.rust-lang.org/nightly/book/ch07-02-defining-modules-to-control-scope-and-privacy.html) statements through the path
`std`, as in [`use std::env`](https://doc.rust-lang.org/nightly/std/env/index.html).

# How to read this documentation

If you already know the name of what you are looking for, the fastest way to
find it is to use the <a href="#" onclick="window.searchState.focus();">search
bar</a> at the top of the page.

Otherwise, you may want to jump to one of these useful sections:

* [`std::*` modules](https://doc.rust-lang.org/nightly/std/index.html#modules)
* [Primitive types](https://doc.rust-lang.org/nightly/std/index.html#primitives)
* [Standard macros](https://doc.rust-lang.org/nightly/std/index.html#macros)
* [The Rust Prelude]

If this is your first time, the documentation for the standard library is
written to be casually perused. Clicking on interesting things should
generally lead you to interesting places. Still, there are important bits
you don't want to miss, so read on for a tour of the standard library and
its documentation!

Once you are familiar with the contents of the standard library you may
begin to find the verbosity of the prose distracting. At this stage in your
development you may want to press the `[-]` button near the top of the
page to collapse it into a more skimmable view.

While you are looking at that `[-]` button also notice the `source`
link. Rust's API documentation comes with the source code and you are
encouraged to read it. The standard library source is generally high
quality and a peek behind the curtains is often enlightening.

# What is in the standard library documentation?

First of all, The Rust Standard Library is divided into a number of focused
modules, [all listed further down this page](https://doc.rust-lang.org/nightly/std/index.html#modules). These modules are
the bedrock upon which all of Rust is forged, and they have mighty names
like [`std::slice`] and [`std::cmp`]. Modules' documentation typically
includes an overview of the module along with examples, and are a smart
place to start familiarizing yourself with the library.

Second, implicit methods on [primitive types](https://doc.rust-lang.org/nightly/book/ch03-02-data-types.html) are documented here. This can
be a source of confusion for two reasons:

1. While primitives are implemented by the compiler, the standard library
   implements methods directly on the primitive types (and it is the only
   library that does so), which are [documented in the section on
   primitives](https://doc.rust-lang.org/nightly/std/index.html#primitives).
1. The standard library exports many modules *with the same name as
   primitive types*. These define additional items related to the primitive
   type, but not the all-important methods.

So for example there is a [page for the primitive type
`i32`](https://doc.rust-lang.org/nightly/core/primitive.i32.html) that lists all the methods that can be called on
32-bit integers (very useful), and there is a [page for the module
`std::i32`](https://doc.rust-lang.org/nightly/core/i32/index.html) that documents the constant values [`MIN`] and [`MAX`] (rarely
useful).

Note the documentation for the primitives [`str`] and [`[T]`](https://doc.rust-lang.org/nightly/alloc/slice/index.html) (also
called 'slice'). Many method calls on [`String`](https://doc.rust-lang.org/nightly/alloc/string/struct.String.html) and [`Vec<T>`] are actually
calls to methods on [`str`] and [`[T]`](https://doc.rust-lang.org/nightly/alloc/slice/index.html) respectively, via [deref
coercions](https://doc.rust-lang.org/nightly/book/ch15-02-deref.html#implicit-deref-coercions-with-functions-and-methods).

Third, the standard library defines [The Rust Prelude], a small collection
of items - mostly traits - that are imported into every module of every
crate. The traits in the prelude are pervasive, making the prelude
documentation a good entry point to learning about the library.

And finally, the standard library exports a number of standard macros, and
[lists them on this page](https://doc.rust-lang.org/nightly/std/index.html#macros) (technically, not all of the standard
macros are defined by the standard library - some are defined by the
compiler - but they are documented here the same). Like the prelude, the
standard macros are imported by default into all crates.

# Contributing changes to the documentation

Check out the rust contribution guidelines [here](https://rustc-dev-guide.rust-lang.org/contributing.html#writing-documentation).
The source for this documentation can be found on
[GitHub](https://github.com/rust-lang/rust).
To contribute changes, make sure you read the guidelines first, then submit
pull-requests for your suggested changes.

Contributions are appreciated! If you see a part of the docs that can be
improved, submit a PR, or chat with us first on [Discord](https://discord.gg/rust-lang)
\#docs.

# A Tour of The Rust Standard Library

The rest of this crate documentation is dedicated to pointing out notable
features of The Rust Standard Library.

## Containers and collections

The [`option`](https://doc.rust-lang.org/nightly/core/option/index.html) and [`result`](https://doc.rust-lang.org/nightly/core/result/index.html) modules define optional and error-handling
types, [`Option<T>`] and [`Result<T, E>`]. The [`iter`](https://doc.rust-lang.org/nightly/core/iter/index.html) module defines
Rust's iterator trait, [`Iterator`](https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html), which works with the [`for`](https://doc.rust-lang.org/nightly/book/ch03-05-control-flow.html#looping-through-a-collection-with-for) loop to
access collections.

The standard library exposes three common ways to deal with contiguous
regions of memory:

* [`Vec<T>`] - A heap-allocated *vector* that is resizable at runtime.
* [`[T; N]`](https://doc.rust-lang.org/nightly/core/array/index.html) - An inline *array* with a fixed size at compile time.
* [`[T]`](https://doc.rust-lang.org/nightly/alloc/slice/index.html) - A dynamically sized *slice* into any other kind of contiguous
  storage, whether heap-allocated or not.

Slices can only be handled through some kind of *pointer*, and as such come
in many flavors such as:

* `&[T]` - *shared slice*
* `&mut [T]` - *mutable slice*
* [`Box<[T]>`](https://doc.rust-lang.org/nightly/alloc/boxed/index.html) - *owned slice*

[`str`], a UTF-8 string slice, is a primitive type, and the standard library
defines many methods for it. Rust [`str`]s are typically accessed as
immutable references: `&str`. Use the owned [`String`](https://doc.rust-lang.org/nightly/alloc/string/struct.String.html) for building and
mutating strings.

For converting to strings use the [`format`](https://doc.rust-lang.org/nightly/alloc/macros/macro.format.html) macro, and for converting from
strings use the [`FromStr`] trait.

Data may be shared by placing it in a reference-counted box or the [`Rc`]
type, and if further contained in a [`Cell`] or [`RefCell`], may be mutated
as well as shared. Likewise, in a concurrent setting it is common to pair an
atomically-reference-counted box, [`Arc`], with a [`Mutex`] to get the same
effect.

The [`collections`](https://doc.rust-lang.org/nightly/std/collections/index.html) module defines maps, sets, linked lists and other
typical collection types, including the common [`HashMap<K, V>`].

## Platform abstractions and I/O

Besides basic data types, the standard library is largely concerned with
abstracting over differences in common platforms, most notably Windows and
Unix derivatives.

Common types of I/O, including [files], [TCP], and [UDP], are defined in
the [`io`](https://doc.rust-lang.org/nightly/std/io/index.html), [`fs`](https://doc.rust-lang.org/nightly/std/fs/index.html), and [`net`](https://doc.rust-lang.org/nightly/std/net/index.html) modules.

The [`thread`](https://doc.rust-lang.org/nightly/std/thread/index.html) module contains Rust's threading abstractions. [`sync`](https://doc.rust-lang.org/nightly/std/sync/index.html)
contains further primitive shared memory types, including [`atomic`] and
[`mpsc`], which contains the channel types for message passing.Ú∫
Nrust-analyzer cargo alloc https://github.com/rust-lang/rust/library/alloc fmt/û∫
```rust
alloc
```

```rust
mod fmt
```

---

Utilities for formatting and printing `String`s.

This module contains the runtime support for the [`format`](https://doc.rust-lang.org/nightly/alloc/macros/macro.format.html) syntax extension.
This macro is implemented in the compiler to emit calls to this module in
order to format arguments at runtime into strings.

# Usage

The [`format`](https://doc.rust-lang.org/nightly/alloc/macros/macro.format.html) macro is intended to be familiar to those coming from C's
`printf`/`fprintf` functions or Python's `str.format` function.

Some examples of the [`format`](https://doc.rust-lang.org/nightly/alloc/macros/macro.format.html) extension are:

```
format!("Hello");                 // => "Hello"
format!("Hello, {}!", "world");   // => "Hello, world!"
format!("The number is {}", 1);   // => "The number is 1"
format!("{:?}", (3, 4));          // => "(3, 4)"
format!("{value}", value=4);      // => "4"
let people = "Rustaceans";
format!("Hello {people}!");       // => "Hello Rustaceans!"
format!("{} {}", 1, 2);           // => "1 2"
format!("{:04}", 42);             // => "0042" with leading zeros
format!("{:#?}", (100, 200));     // => "(
                                  //       100,
                                  //       200,
                                  //     )"
```

From these, you can see that the first argument is a format string. It is
required by the compiler for this to be a string literal; it cannot be a
variable passed in (in order to perform validity checking). The compiler
will then parse the format string and determine if the list of arguments
provided is suitable to pass to this format string.

To convert a single value to a string, use the [`to_string`] method. This
will use the [`Display`](https://doc.rust-lang.org/nightly/core/fmt/trait.Display.html) formatting trait.

## Positional parameters

Each formatting argument is allowed to specify which value argument it's
referencing, and if omitted it is assumed to be "the next argument". For
example, the format string `{} {} {}` would take three parameters, and they
would be formatted in the same order as they're given. The format string
`{2} {1} {0}`, however, would format arguments in reverse order.

Things can get a little tricky once you start intermingling the two types of
positional specifiers. The "next argument" specifier can be thought of as an
iterator over the argument. Each time a "next argument" specifier is seen,
the iterator advances. This leads to behavior like this:

```
format!("{1} {} {0} {}", 1, 2); // => "2 1 1 2"
```

The internal iterator over the argument has not been advanced by the time
the first `{}` is seen, so it prints the first argument. Then upon reaching
the second `{}`, the iterator has advanced forward to the second argument.
Essentially, parameters that explicitly name their argument do not affect
parameters that do not name an argument in terms of positional specifiers.

A format string is required to use all of its arguments, otherwise it is a
compile-time error. You may refer to the same argument more than once in the
format string.

## Named parameters

Rust itself does not have a Python-like equivalent of named parameters to a
function, but the [`format`](https://doc.rust-lang.org/nightly/alloc/macros/macro.format.html) macro is a syntax extension that allows it to
leverage named parameters. Named parameters are listed at the end of the
argument list and have the syntax:

```text
identifier '=' expression
```

For example, the following [`format`](https://doc.rust-lang.org/nightly/alloc/macros/macro.format.html) expressions all use named arguments:

```
format!("{argument}", argument = "test");   // => "test"
format!("{name} {}", 1, name = 2);          // => "2 1"
format!("{a} {c} {b}", a="a", b='b', c=3);  // => "a 3 b"
```

If a named parameter does not appear in the argument list, `format!` will
reference a variable with that name in the current scope.

```
let argument = 2 + 2;
format!("{argument}");   // => "4"

fn make_string(a: u32, b: &str) -> String {
    format!("{b} {a}")
}
make_string(927, "label"); // => "label 927"
```

It is not valid to put positional parameters (those without names) after
arguments that have names. Like with positional parameters, it is not
valid to provide named parameters that are unused by the format string.

# Formatting Parameters

Each argument being formatted can be transformed by a number of formatting
parameters (corresponding to `format_spec` in [the syntax](https://doc.rust-lang.org/nightly/alloc/fmt/index.html#syntax)). These
parameters affect the string representation of what's being formatted.

## Width

```
// All of these print "Hello x    !"
println!("Hello {:5}!", "x");
println!("Hello {:1$}!", "x", 5);
println!("Hello {1:0$}!", 5, "x");
println!("Hello {:width$}!", "x", width = 5);
let width = 5;
println!("Hello {:width$}!", "x");
```

This is a parameter for the "minimum width" that the format should take up.
If the value's string does not fill up this many characters, then the
padding specified by fill/alignment will be used to take up the required
space (see below).

The value for the width can also be provided as a [`usize`](https://doc.rust-lang.org/nightly/core/primitive.usize.html) in the list of
parameters by adding a postfix `$`, indicating that the second argument is
a [`usize`](https://doc.rust-lang.org/nightly/core/primitive.usize.html) specifying the width.

Referring to an argument with the dollar syntax does not affect the "next
argument" counter, so it's usually a good idea to refer to arguments by
position, or use named arguments.

## Fill/Alignment

```
assert_eq!(format!("Hello {:<5}!", "x"),  "Hello x    !");
assert_eq!(format!("Hello {:-<5}!", "x"), "Hello x----!");
assert_eq!(format!("Hello {:^5}!", "x"),  "Hello   x  !");
assert_eq!(format!("Hello {:>5}!", "x"),  "Hello     x!");
```

The optional fill character and alignment is provided normally in conjunction with the
[`width`](https://doc.rust-lang.org/nightly/alloc/fmt/index.html#width) parameter. It must be defined before `width`, right after the `:`.
This indicates that if the value being formatted is smaller than
`width` some extra characters will be printed around it.
Filling comes in the following variants for different alignments:

* `[fill]<` - the argument is left-aligned in `width` columns
* `[fill]^` - the argument is center-aligned in `width` columns
* `[fill]>` - the argument is right-aligned in `width` columns

The default [fill/alignment](https://doc.rust-lang.org/nightly/alloc/fmt/index.html#fillalignment) for non-numerics is a space and
left-aligned. The
default for numeric formatters is also a space character but with right-alignment. If
the `0` flag (see below) is specified for numerics, then the implicit fill character is
`0`.

Note that alignment might not be implemented by some types. In particular, it
is not generally implemented for the `Debug` trait.  A good way to ensure
padding is applied is to format your input, then pad this resulting string
to obtain your output:

```
println!("Hello {:^15}!", format!("{:?}", Some("hi"))); // => "Hello   Some("hi")   !"
```

## Sign/`#`/`0`

```
assert_eq!(format!("Hello {:+}!", 5), "Hello +5!");
assert_eq!(format!("{:#x}!", 27), "0x1b!");
assert_eq!(format!("Hello {:05}!", 5),  "Hello 00005!");
assert_eq!(format!("Hello {:05}!", -5), "Hello -0005!");
assert_eq!(format!("{:#010x}!", 27), "0x0000001b!");
```

These are all flags altering the behavior of the formatter.

* `+` - This is intended for numeric types and indicates that the sign
  should always be printed. Positive signs are never printed by
  default, and the negative sign is only printed by default for signed values.
  This flag indicates that the correct sign (`+` or `-`) should always be printed.
* `-` - Currently not used
* `#` - This flag indicates that the "alternate" form of printing should
  be used. The alternate forms are:
  * `#?` - pretty-print the [`Debug`](https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html) formatting (adds linebreaks and indentation)
  * `#x` - precedes the argument with a `0x`
  * `#X` - precedes the argument with a `0x`
  * `#b` - precedes the argument with a `0b`
  * `#o` - precedes the argument with a `0o`
* `0` - This is used to indicate for integer formats that the padding to `width` should
  both be done with a `0` character as well as be sign-aware. A format
  like `{:08}` would yield `00000001` for the integer `1`, while the
  same format would yield `-0000001` for the integer `-1`. Notice that
  the negative version has one fewer zero than the positive version.
  Note that padding zeros are always placed after the sign (if any)
  and before the digits. When used together with the `#` flag, a similar
  rule applies: padding zeros are inserted after the prefix but before
  the digits. The prefix is included in the total width.

## Precision

For non-numeric types, this can be considered a "maximum width". If the resulting string is
longer than this width, then it is truncated down to this many characters and that truncated
value is emitted with proper `fill`, `alignment` and `width` if those parameters are set.

For integral types, this is ignored.

For floating-point types, this indicates how many digits after the decimal point should be
printed.

There are three possible ways to specify the desired `precision`:

1. An integer `.N`:
   
   the integer `N` itself is the precision.

1. An integer or name followed by dollar sign `.N$`:
   
   use format *argument* `N` (which must be a `usize`) as the precision.

1. An asterisk `.*`:
   
   `.*` means that this `{...}` is associated with *two* format inputs rather than one:
   
   * If a format string in the fashion of `{:<spec>.*}` is used, then the first input holds
     the `usize` precision, and the second holds the value to print.
   * If a format string in the fashion of `{<arg>:<spec>.*}` is used, then the `<arg>` part
     refers to the value to print, and the `precision` is taken like it was specified with an
     omitted positional parameter (`{}` instead of `{<arg>:}`).

For example, the following calls all print the same thing `Hello x is 0.01000`:

```
// Hello {arg 0 ("x")} is {arg 1 (0.01) with precision specified inline (5)}
println!("Hello {0} is {1:.5}", "x", 0.01);

// Hello {arg 1 ("x")} is {arg 2 (0.01) with precision specified in arg 0 (5)}
println!("Hello {1} is {2:.0$}", 5, "x", 0.01);

// Hello {arg 0 ("x")} is {arg 2 (0.01) with precision specified in arg 1 (5)}
println!("Hello {0} is {2:.1$}", "x", 5, 0.01);

// Hello {next arg -> arg 0 ("x")} is {second of next two args -> arg 2 (0.01) with precision
//                          specified in first of next two args -> arg 1 (5)}
println!("Hello {} is {:.*}",    "x", 5, 0.01);

// Hello {arg 1 ("x")} is {arg 2 (0.01) with precision
//                          specified in next arg -> arg 0 (5)}
println!("Hello {1} is {2:.*}",  5, "x", 0.01);

// Hello {next arg -> arg 0 ("x")} is {arg 2 (0.01) with precision
//                          specified in next arg -> arg 1 (5)}
println!("Hello {} is {2:.*}",   "x", 5, 0.01);

// Hello {next arg -> arg 0 ("x")} is {arg "number" (0.01) with precision specified
//                          in arg "prec" (5)}
println!("Hello {} is {number:.prec$}", "x", prec = 5, number = 0.01);
```

While these:

```
println!("{}, `{name:.*}` has 3 fractional digits", "Hello", 3, name=1234.56);
println!("{}, `{name:.*}` has 3 characters", "Hello", 3, name="1234.56");
println!("{}, `{name:>8.*}` has 3 right-aligned characters", "Hello", 3, name="1234.56");
```

print three significantly different things:

```text
Hello, `1234.560` has 3 fractional digits
Hello, `123` has 3 characters
Hello, `     123` has 3 right-aligned characters
```

## Localization

In some programming languages, the behavior of string formatting functions
depends on the operating system's locale setting. The format functions
provided by Rust's standard library do not have any concept of locale and
will produce the same results on all systems regardless of user
configuration.

For example, the following code will always print `1.5` even if the system
locale uses a decimal separator other than a dot.

```
println!("The value is {}", 1.5);
```

# Escaping

The literal characters `{` and `}` may be included in a string by preceding
them with the same character. For example, the `{` character is escaped with
`{{` and the `}` character is escaped with `}}`.

```
assert_eq!(format!("Hello {{}}"), "Hello {}");
assert_eq!(format!("{{ Hello"), "{ Hello");
```

# Syntax

To summarize, here you can find the full grammar of format strings.
The syntax for the formatting language used is drawn from other languages,
so it should not be too alien. Arguments are formatted with Python-like
syntax, meaning that arguments are surrounded by `{}` instead of the C-like
`%`. The actual grammar for the formatting syntax is:

```text
format_string := text [ maybe_format text ] *
maybe_format := '{' '{' | '}' '}' | format
format := '{' [ argument ] [ ':' format_spec ] [ ws ] * '}'
argument := integer | identifier

format_spec := [[fill]align][sign]['#']['0'][width]['.' precision]type
fill := character
align := '<' | '^' | '>'
sign := '+' | '-'
width := count
precision := count | '*'
type := '' | '?' | 'x?' | 'X?' | identifier
count := parameter | integer
parameter := argument '$'
```

In the above grammar,

* `text` must not contain any `'{'` or `'}'` characters,
* `ws` is any character for which [`char::is_whitespace`](`char::is_whitespace`) returns `true`, has no semantic
  meaning and is completely optional,
* `integer` is a decimal integer that may contain leading zeroes and must fit into an `usize` and
* `identifier` is an `IDENTIFIER_OR_KEYWORD` (not an `IDENTIFIER`) as defined by the [Rust language reference](https://doc.rust-lang.org/reference/identifiers.html).

# Formatting traits

When requesting that an argument be formatted with a particular type, you
are actually requesting that an argument ascribes to a particular trait.
This allows multiple actual types to be formatted via `{:x}` (like [`i8`](https://doc.rust-lang.org/nightly/core/primitive.i8.html) as
well as [`isize`](https://doc.rust-lang.org/nightly/core/primitive.isize.html)). The current mapping of types to traits is:

* *nothing* ‚áí [`Display`](https://doc.rust-lang.org/nightly/core/fmt/trait.Display.html)
* `?` ‚áí [`Debug`](https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html)
* `x?` ‚áí [`Debug`](https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html) with lower-case hexadecimal integers
* `X?` ‚áí [`Debug`](https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html) with upper-case hexadecimal integers
* `o` ‚áí [`Octal`](https://doc.rust-lang.org/nightly/core/fmt/trait.Octal.html)
* `x` ‚áí [`LowerHex`](https://doc.rust-lang.org/nightly/core/fmt/trait.LowerHex.html)
* `X` ‚áí [`UpperHex`](https://doc.rust-lang.org/nightly/core/fmt/trait.UpperHex.html)
* `p` ‚áí [`Pointer`](https://doc.rust-lang.org/nightly/core/fmt/trait.Pointer.html)
* `b` ‚áí [`Binary`](https://doc.rust-lang.org/nightly/core/fmt/trait.Binary.html)
* `e` ‚áí [`LowerExp`](https://doc.rust-lang.org/nightly/core/fmt/trait.LowerExp.html)
* `E` ‚áí [`UpperExp`](https://doc.rust-lang.org/nightly/core/fmt/trait.UpperExp.html)

What this means is that any type of argument which implements the
[`fmt::Binary`](https://doc.rust-lang.org/nightly/core/fmt/trait.Binary.html) trait can then be formatted with `{:b}`. Implementations
are provided for these traits for a number of primitive types by the
standard library as well. If no format is specified (as in `{}` or `{:6}`),
then the format trait used is the [`Display`](https://doc.rust-lang.org/nightly/core/fmt/trait.Display.html) trait.

When implementing a format trait for your own type, you will have to
implement a method of the signature:

```
# #![allow(dead_code)]
# use std::fmt;
# struct Foo; // our custom type
# impl fmt::Display for Foo {
fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
# write!(f, "testing, testing")
# } }
```

Your type will be passed as `self` by-reference, and then the function
should emit output into the Formatter `f` which implements `fmt::Write`. It is up to each
format trait implementation to correctly adhere to the requested formatting parameters.
The values of these parameters can be accessed with methods of the
[`Formatter`](https://doc.rust-lang.org/nightly/core/fmt/struct.Formatter.html) struct. In order to help with this, the [`Formatter`](https://doc.rust-lang.org/nightly/core/fmt/struct.Formatter.html) struct also
provides some helper methods.

Additionally, the return value of this function is [`fmt::Result`] which is a
type alias of <code>
[Result]\<(), [std::fmt::Error]\></code>. Formatting implementations
should ensure that they propagate errors from the [`Formatter`](https://doc.rust-lang.org/nightly/core/fmt/struct.Formatter.html) (e.g., when
calling [`write`](https://doc.rust-lang.org/nightly/core/macros/macro.write.html)). However, they should never return errors spuriously. That
is, a formatting implementation must and may only return an error if the
passed-in [`Formatter`](https://doc.rust-lang.org/nightly/core/fmt/struct.Formatter.html) returns an error. This is because, contrary to what
the function signature might suggest, string formatting is an infallible
operation. This function only returns a result because writing to the
underlying stream might fail and it must provide a way to propagate the fact
that an error has occurred back up the stack.

An example of implementing the formatting traits would look
like:

```
use std::fmt;

#[derive(Debug)]
struct Vector2D {
    x: isize,
    y: isize,
}

impl fmt::Display for Vector2D {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        // The `f` value implements the `Write` trait, which is what the
        // write! macro is expecting. Note that this formatting ignores the
        // various flags provided to format strings.
        write!(f, "({}, {})", self.x, self.y)
    }
}

// Different traits allow different forms of output of a type. The meaning
// of this format is to print the magnitude of a vector.
impl fmt::Binary for Vector2D {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let magnitude = (self.x * self.x + self.y * self.y) as f64;
        let magnitude = magnitude.sqrt();

        // Respect the formatting flags by using the helper method
        // `pad_integral` on the Formatter object. See the method
        // documentation for details, and the function `pad` can be used
        // to pad strings.
        let decimals = f.precision().unwrap_or(3);
        let string = format!("{magnitude:.decimals$}");
        f.pad_integral(true, "", &string)
    }
}

fn main() {
    let myvector = Vector2D { x: 3, y: 4 };

    println!("{myvector}");       // => "(3, 4)"
    println!("{myvector:?}");     // => "Vector2D {x: 3, y:4}"
    println!("{myvector:10.3b}"); // => "     5.000"
}
```

### `fmt::Display` vs `fmt::Debug`

These two formatting traits have distinct purposes:

* [`fmt::Display`](https://doc.rust-lang.org/nightly/core/fmt/trait.Display.html) implementations assert that the type can be faithfully
  represented as a UTF-8 string at all times. It is **not** expected that
  all types implement the [`Display`](https://doc.rust-lang.org/nightly/core/fmt/trait.Display.html) trait.
* [`fmt::Debug`](https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html) implementations should be implemented for **all** public types.
  Output will typically represent the internal state as faithfully as possible.
  The purpose of the [`Debug`](https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html) trait is to facilitate debugging Rust code. In
  most cases, using `#[derive(Debug)]` is sufficient and recommended.

Some examples of the output from both traits:

```
assert_eq!(format!("{} {:?}", 3, 4), "3 4");
assert_eq!(format!("{} {:?}", 'a', 'b'), "a 'b'");
assert_eq!(format!("{} {:?}", "foo\n", "bar\n"), "foo\n \"bar\\n\"");
```

# Related macros

There are a number of related macros in the [`format`](https://doc.rust-lang.org/nightly/alloc/macros/macro.format.html) family. The ones that
are currently implemented are:

```ignore (only-for-syntax-highlight)
format!      // described above
write!       // first argument is either a &mut io::Write or a &mut fmt::Write, the destination
writeln!     // same as write but appends a newline
print!       // the format string is printed to the standard output
println!     // same as print but appends a newline
eprint!      // the format string is printed to the standard error
eprintln!    // same as eprint but appends a newline
format_args! // described below.
```

### `write!`

[`write`](https://doc.rust-lang.org/nightly/core/macros/macro.write.html) and [`writeln`](https://doc.rust-lang.org/nightly/core/macros/macro.writeln.html) are two macros which are used to emit the format string
to a specified stream. This is used to prevent intermediate allocations of
format strings and instead directly write the output. Under the hood, this
function is actually invoking the [`write_fmt`](https://doc.rust-lang.org/nightly/std/io/trait.Write.html#method.write_fmt) function defined on the
[`std::io::Write`](https://doc.rust-lang.org/nightly/std/io/trait.Write.html) and the [`std::fmt::Write`](https://doc.rust-lang.org/nightly/std/fmt/trait.Write.html) trait. Example usage is:

```
# #![allow(unused_must_use)]
use std::io::Write;
let mut w = Vec::new();
write!(&mut w, "Hello {}!", "world");
```

### `print!`

This and [`println!`](https://doc.rust-lang.org/nightly/std/macro.println.html) emit their output to stdout. Similarly to the [`write`](https://doc.rust-lang.org/nightly/core/macros/macro.write.html)
macro, the goal of these macros is to avoid intermediate allocations when
printing output. Example usage is:

```
print!("Hello {}!", "world");
println!("I have a newline {}", "character at the end");
```

### `eprint!`

The [`eprint!`](https://doc.rust-lang.org/nightly/std/macro.eprint.html) and [`eprintln!`](https://doc.rust-lang.org/nightly/std/macro.eprintln.html) macros are identical to
[`print!`](https://doc.rust-lang.org/nightly/std/macro.print.html) and [`println!`](https://doc.rust-lang.org/nightly/std/macro.println.html), respectively, except they emit their
output to stderr.

### `format_args!`

[`format_args!`](https://doc.rust-lang.org/nightly/std/macro.format_args.html) is a curious macro used to safely pass around
an opaque object describing the format string. This object
does not require any heap allocations to create, and it only
references information on the stack. Under the hood, all of
the related macros are implemented in terms of this. First
off, some example usage is:

```
# #![allow(unused_must_use)]
use std::fmt;
use std::io::{self, Write};

let mut some_writer = io::stdout();
write!(&mut some_writer, "{}", format_args!("print with a {}", "macro"));

fn my_fmt_fn(args: fmt::Arguments) {
    write!(&mut io::stdout(), "{args}");
}
my_fmt_fn(format_args!(", or a {} too", "function"));
```

The result of the [`format_args!`](https://doc.rust-lang.org/nightly/std/macro.format_args.html) macro is a value of type [`fmt::Arguments`].
This structure can then be passed to the [`write`] and [`format`] functions
inside this module in order to process the format string.
The goal of this macro is to even further prevent intermediate allocations
when dealing with formatting strings.

For example, a logging library could use the standard formatting syntax, but
it would internally pass around this structure until it has been determined
where output should go to.ì

Trust-analyzer cargo core https://github.com/rust-lang/rust/library/core fmt/Display#∫	
```rust
core::fmt
```

```rust
pub trait Display
```

---

Format trait for an empty format, `{}`.

Implementing this trait for a type will automatically implement the
[`ToString`](https://doc.rust-lang.org/nightly/std/string/trait.ToString.html) trait for the type, allowing the usage
of the [`.to_string()`](https://doc.rust-lang.org/nightly/std/string/trait.ToString.html#tymethod.to_string) method. Prefer implementing
the `Display` trait for a type, rather than [`ToString`](https://doc.rust-lang.org/nightly/std/string/trait.ToString.html).

`Display` is similar to [`Debug`](https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html), but `Display` is for user-facing
output, and so cannot be derived.

For more information on formatters, see [the module-level documentation](https://doc.rust-lang.org/nightly/std/fmt/index.html).

# Examples

Implementing `Display` on a type:

```
use std::fmt;

struct Point {
    x: i32,
    y: i32,
}

impl fmt::Display for Point {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "({}, {})", self.x, self.y)
    }
}

let origin = Point { x: 0, y: 0 };

assert_eq!(format!("The origin is: {origin}"), "The origin is: (0, 0)");
```è
Krust-analyzer cargo std https://github.com/rust-lang/rust/library/std path/ø
```rust
std
```

```rust
mod path
```

---

Cross-platform path manipulation.

This module provides two types, [`PathBuf`](https://doc.rust-lang.org/nightly/std/path/struct.PathBuf.html) and [`Path`](https://doc.rust-lang.org/nightly/std/path/struct.Path.html) (akin to [`String`](https://doc.rust-lang.org/nightly/alloc/string/struct.String.html)
and [`str`](https://doc.rust-lang.org/nightly/core/primitive.str.html)), for working with paths abstractly. These types are thin wrappers
around [`OsString`](https://doc.rust-lang.org/nightly/std/ffi/os_str/struct.OsString.html) and [`OsStr`](https://doc.rust-lang.org/nightly/std/ffi/os_str/struct.OsStr.html) respectively, meaning that they work directly
on strings according to the local platform's path syntax.

Paths can be parsed into [`Component`](https://doc.rust-lang.org/nightly/std/path/enum.Component.html)s by iterating over the structure
returned by the [`components`] method on [`Path`](https://doc.rust-lang.org/nightly/std/path/struct.Path.html). [`Component`](https://doc.rust-lang.org/nightly/std/path/enum.Component.html)s roughly
correspond to the substrings between path separators (`/` or `\`). You can
reconstruct an equivalent path from components with the [`push`] method on
[`PathBuf`](https://doc.rust-lang.org/nightly/std/path/struct.PathBuf.html); note that the paths may differ syntactically by the
normalization described in the documentation for the [`components`] method.

## Case sensitivity

Unless otherwise indicated path methods that do not access the filesystem,
such as [`Path::starts_with`](`Path::starts_with`) and [`Path::ends_with`](`Path::ends_with`), are case sensitive no
matter the platform or filesystem. An exception to this is made for Windows
drive letters.

## Simple usage

Path manipulation includes both parsing components from slices and building
new owned paths.

To parse a path, you can create a [`Path`](https://doc.rust-lang.org/nightly/std/path/struct.Path.html) slice from a [`str`](https://doc.rust-lang.org/nightly/core/primitive.str.html)
slice and start asking questions:

```
use std::path::Path;
use std::ffi::OsStr;

let path = Path::new("/tmp/foo/bar.txt");

let parent = path.parent();
assert_eq!(parent, Some(Path::new("/tmp/foo")));

let file_stem = path.file_stem();
assert_eq!(file_stem, Some(OsStr::new("bar")));

let extension = path.extension();
assert_eq!(extension, Some(OsStr::new("txt")));
```

To build or modify paths, use [`PathBuf`](https://doc.rust-lang.org/nightly/std/path/struct.PathBuf.html):

```
use std::path::PathBuf;

// This way works...
let mut path = PathBuf::from("c:\\");

path.push("windows");
path.push("system32");

path.set_extension("dll");

// ... but push is best used if you don't know everything up
// front. If you do, this way is better:
let path: PathBuf = ["c:\\", "windows", "system32.dll"].iter().collect();
```ê

Prust-analyzer cargo std https://github.com/rust-lang/rust/library/std path/Path#ª	
```rust
std::path
```

```rust
pub struct Path
```

---

A slice of a path (akin to [`str`](https://doc.rust-lang.org/nightly/core/primitive.str.html)).

This type supports a number of operations for inspecting a path, including
breaking the path into its components (separated by `/` on Unix and by either
`/` or `\` on Windows), extracting the file name, determining whether the path
is absolute, and so on.

This is an *unsized* type, meaning that it must always be used behind a
pointer like `&` or [`Box`](https://doc.rust-lang.org/nightly/alloc/boxed/struct.Box.html). For an owned version of this type,
see [`PathBuf`](https://doc.rust-lang.org/nightly/std/path/struct.PathBuf.html).

More details about the overall approach can be found in
the [documentation](https://doc.rust-lang.org/nightly/std/path/index.html).

# Examples

```
use std::path::Path;
use std::ffi::OsStr;

// Note: this example does work on Windows
let path = Path::new("./foo/bar.txt");

let parent = path.parent();
assert_eq!(parent, Some(Path::new("./foo")));

let file_stem = path.file_stem();
assert_eq!(file_stem, Some(OsStr::new("bar")));

let extension = path.extension();
assert_eq!(extension, Some(OsStr::new("txt")));
```˝
Srust-analyzer cargo std https://github.com/rust-lang/rust/library/std path/PathBuf#•
```rust
std::path
```

```rust
pub struct PathBuf
```

---

An owned, mutable path (akin to [`String`](https://doc.rust-lang.org/nightly/alloc/string/struct.String.html)).

This type provides methods like [`push`] and [`set_extension`] that mutate
the path in place. It also implements [`Deref`](https://doc.rust-lang.org/nightly/core/ops/deref/trait.Deref.html) to [`Path`](https://doc.rust-lang.org/nightly/std/path/struct.Path.html), meaning that
all methods on [`Path`](https://doc.rust-lang.org/nightly/std/path/struct.Path.html) slices are available on `PathBuf` values as well.

More details about the overall approach can be found in
the [documentation](https://doc.rust-lang.org/nightly/std/path/index.html).

# Examples

You can use [`push`] to build up a `PathBuf` from
components:

```
use std::path::PathBuf;

let mut path = PathBuf::new();

path.push(r"C:\");
path.push("windows");
path.push("system32");

path.set_extension("dll");
```

However, [`push`] is best used for dynamic situations. This is a better way
to do this when you know all of the components ahead of time:

```
use std::path::PathBuf;

let path: PathBuf = [r"C:\", "windows", "system32.dll"].iter().collect();
```

We can still do better than this! Since these are all strings, we can use
`From::from`:

```
use std::path::PathBuf;

let path = PathBuf::from(r"C:\windows\system32.dll");
```

Which method works best depends on what kind of situation you're in.2
local 1'
```rust
extern crate eq_modulo_pos
```®
0rust-analyzer cargo eq_modulo_pos . EqModuloPos#Û
```rust
eq_modulo_pos
```

```rust
pub trait EqModuloPos
```

---

An implementation of `Eq` which is insensitive to positions
(e.g., `pos::BPos`) and reasons (e.g., `ty::reason::BReason`).

If `PartialOrd` or `Ord` are also implemented for `Self`, their methods must
be consistent with `EqModuloPos`. For any two values for which
`eq_modulo_pos` or `eq_modulo_pos_and_reason` returns `false`, it must be
the case that their ordering cannot be changed by modifying positions or
reasons inside them.0
local 2%
```rust
extern crate no_pos_hash
```Ô
,rust-analyzer cargo no_pos_hash . NoPosHash#æ
```rust
no_pos_hash
```

```rust
pub trait NoPosHash
```

---

A type for which we can produce a position-insensitive hash.

For incremental typechecking, we are often interested in
determining whether a declaration or AST has changed in a way that
requires re-typechecking of dependents. Changes which only affect
the `Pos` fields in a declaration do not require rechecking of
dependents, so we want to distinguish "position-only" changes from
other types of changes.

In OCaml, we do this by reallocating the old and new declarations
(or ASTs) with `Pos.none` in every position field, then performing
a polymorphic hash or comparison. In Rust, we could rewrite
positions and then use the `Hash` trait, but we'd like to avoid
the reallocation/clone (besides, we don't have an endo-visitor for
our by-ref types at this time). By comparing the output of hashing
with `Hash` and `NoPosHash`, we can easily determine when a value
has only changed in positions.ÚT
local 3ÊT
```rust
extern crate ocamlrep
```

---

OcamlRep is a framework for building and interpreting the in-memory
representation of OCaml values. This is useful for converting Rust values to
OCaml values and vice-versa, and for building and storing OCaml values off of
the OCaml runtime's garbage-collected heap.

OcamlRep provides a generic interface abstracting over the allocation of OCaml
values, allowing custom allocators to choose where values are allocated
(including directly onto the OCaml heap).

# Example: build an OCaml value

This crate provides an arena-allocator which manages the memory in which
converted OCaml values are stored. When the arena is dropped, the values are
freed.

```rust
// Import the Allocator trait for access to its `add` method, which builds an
// OCaml-value representation of the argument (using `OcamlRep::to_ocamlrep`)
// and returns that value.
use ocamlrep::{Allocator, Arena, Value};

// The `ocamlrep` crate provides implementations of `OcamlRep` for builtin types
// like `Option`, `String`, integers, and tuples. This allows them to be
// converted to OCaml values using the Allocator trait (which Arena implements).
let tuple = (Some(42), String::from("a"));

// Allocate a chunk of Rust-managed backing storage for our OCaml value.
let arena = Arena::new();

// This value borrows the Arena, to ensure that we cannot continue to use it
// after the Arena has been freed. OcamlRep values do not borrow the Rust values
// they were converted from--the string "a" is copied into the Arena.
let ocamlrep_value: Value<'_> = arena.add(&tuple);

// We must now convert the value to a usize which can be handed over to the
// OCaml runtime. We must take care when doing this to ensure that our OCaml
// program doesn't use the value after the Arena is freed.
let ocaml_value: usize = ocamlrep_value.to_bits();
```

# Example: return an OCaml value to the OCaml runtime

The value `ocaml_value` from the previous example is suitable to be handed to
the OCaml runtime. We might do so with an extern declaration like this:

```ocaml
external get_tuple : unit -> int option * string = "get_tuple"

let use_rust_tuple () =
  match get_tuple () with
  | (Some i, s) -> Printf.printf "%d, %s\n" i s
  | (None, s) -> Printf.printf "None, %s\n" s
```

We could provide this symbol from the Rust side like this:

```rust
#[no_mangle]
pub extern "C" fn get_tuple(_unit: usize) -> usize {
    use ocamlrep::{Allocator, Arena};
    let arena = Box::leak(Box::new(Arena::new()));
    let ocaml_tuple = arena.add(&(Some(42), String::from("a")));
    // This is safe because we leaked the Arena--no matter what we do with this
    // value on the OCaml side, we'll never use-after-free.
    ocaml_tuple.to_bits()
}
```

But this leaks memory. For small amounts of memory, or a short-lived process,
this might be fine. If not, we might choose another strategy...

# Example: lend an OCaml value to the OCaml runtime

Instead, we could register an OCaml callback which uses the value:

```ocaml
let use_tuple (tuple : int option * string) : unit =
  match tuple with
  | (Some i, s) -> Printf.printf "%d, %s\n" i s
  | (None, s) -> Printf.printf "None, %s\n" s

external make_and_use_tuple : unit -> unit = "make_and_use_tuple"

let () =
  Callback.register "use_tuple" use_tuple;
  make_and_use_tuple ()
```

And call into OCaml from Rust (using the `ocaml` crate) to hand over the value:

```rust
#[no_mangle]
pub extern "C" fn make_and_use_tuple(_unit: usize) -> usize {
    use ocamlrep::{Allocator, Arena};
    let arena = Arena::new();
    let tuple_ocamlrep = arena.add(&(Some(42), String::from("a")));

    let use_tuple = ocaml::named_value("use_tuple")
        .expect("use_tuple must be registered using Callback.register");

    // This is safe because we are passing the value to `use_tuple`, which
    // doesn't store the value and returns before we free the Arena.
    let ocaml_tuple: usize = tuple_ocamlrep.to_bits();
    use_tuple
        .call(ocaml::Value::new(ocaml_tuple))
        .expect("use_tuple must be a function");

    // Free the arena and return unit.
    ocaml::core::mlvalues::UNIT
}
```

# Example: pass an OCaml value to the OCaml runtime

The `ocamlrep_ocamlpool` crate provides an `Allocator` which builds values on
the OCaml runtime's garbage-collected heap. We can replace the memory-leaking
implementation from the [second example ("return an OCaml value to the OCaml
runtime")](https://docs.rs/ocamlrep/*/ocamlrep/index.html#example-return-an-ocaml-value-to-the-ocaml-runtime) with one that
allows the OCaml value to be garbage-collected when no longer used:

```rust
#[no_mangle]
pub extern "C" fn get_tuple(_unit: usize) -> usize {
    ocamlrep_ocamlpool::to_ocaml(&(Some(42), String::from("a")))
}
```

The `ocamlrep_ocamlpool` crate provides a convenience macro for this use case:

```rust
use ocamlrep_ocamlpool::ocaml_ffi;

ocaml_ffi! {
    // This expands to code similar to the above definition of get_tuple.
    fn get_tuple() -> (Option<i32>, String) {
        (Some(42), String::from("a"))
    }
}
```

# Example: pass an OCaml value to Rust

An `Allocator` converts Rust values which implement the `OcamlRep` trait into
OCaml values using the method `OcamlRep::to_ocamlrep`. The `OcamlRep` trait also
provides a method `OcamlRep::from_ocamlrep` (and an FFI helper named
`OcamlRep::from_ocaml`) for conversion in the other direction.

If we call into Rust like this:

```ocaml
external use_tuple : int option * string -> unit = "use_tuple"

let () = use_tuple (Some 42, "a")
```

We could convert the tuple to a Rust value like this:

```rust
#[no_mangle]
pub extern "C" fn use_tuple(ocaml_tuple: usize) -> usize {
    // Import the OcamlRep trait to use its associated function `from_ocaml`.
    use ocamlrep::OcamlRep;
    // Safety: `ocaml_tuple` is a valid OCaml value allocated by the OCaml
    // runtime, all objects reachable from that value are also valid OCaml
    // values, and those objects cannot be concurrently modified while
    // `from_ocaml` runs. This is true because that graph of objects is owned by
    // the OCaml runtime, we didn't expose any of their pointers in any other
    // FFI functions, and the OCaml runtime is both single-threaded and
    // currently interrupted by an FFI call into this function.
    let tuple_result = unsafe { <(Option<i32>, String)>::from_ocaml(ocaml_tuple) };
    let tuple = tuple_result
        .expect("Expected a value of type `int option * string`, \
                 but got some other type or invalid UTF-8");
    println!("{:?}", tuple);
    ocaml::core::mlvalues::UNIT
}
```

The `ocaml_ffi!` macro in the `ocamlrep_ocamlpool` crate supports this use case:

```rust
use ocamlrep_ocamlpool::ocaml_ffi;

ocaml_ffi! {
    // This expands to code similar to the above definition of use_tuple.
    fn use_tuple(tuple: (Option<i32>, String)) {
        println!("{:?}", tuple)
    }
}
```

Note that the value returned by `from_ocaml` is owned--it is effectively a
deep clone of the OCaml value. For instance, the OCaml string "a" is copied into
a newly allocated Rust String--the Rust side does not need to worry about the
OCaml value being garbage collected.

Take care when using `from_ocaml`, `from_ocamlrep`, or `ocaml_ffi!` with types
containing `String`s. OCaml strings are not guaranteed to be UTF-8, so
`from_ocaml` may return an `Err` because a string was invalid UTF-8 rather than
because the OCaml code did not pass a value of the expected type (which should
be forbidden by the OCaml compiler, provided that the `external` declaration is
annotated with the correct type). If representing invalid UTF-8 is a
requirement, use `Vec<u8>` instead (an implementation of `OcamlRep` which
converts `Vec<u8>` to an OCaml `string` is provided).

# Example: implementing OcamlRep

Writing a manual implementation of OcamlRep requires one to choose some type
with which their value should be represented in OCaml and write `to_ocamlrep`
and `from_ocamlrep` conversion functions which build and interpret the in-memory
representation of that type.

This crate provides implementations of OcamlRep for several std types, and
chooses these OCaml types to represent them with:

|Rust type|OCaml type|
|---------|----------|
|`()`|`unit`|
|`bool`|`bool`|
|`usize`/`isize`|`int`|
|[`Option`](https://doc.rust-lang.org/beta/std/option/enum.Option.html)|[`option`](https://caml.inria.fr/pub/docs/manual-ocaml/libref/Option.html)|
|[`Result`](https://doc.rust-lang.org/std/result/enum.Result.html)|[`result`](https://caml.inria.fr/pub/docs/manual-ocaml/libref/Result.html)|
|[`Vec`](https://doc.rust-lang.org/std/vec/struct.Vec.html)|[`list`](https://caml.inria.fr/pub/docs/manual-ocaml/libref/List.html)|
|[`String`](https://doc.rust-lang.org/std/string/struct.String.html)|[`string`](https://caml.inria.fr/pub/docs/manual-ocaml/libref/String.html) (when valid UTF-8)|
|[`Vec<u8>`](https://doc.rust-lang.org/std/vec/struct.Vec.html)|[`string`](https://caml.inria.fr/pub/docs/manual-ocaml/libref/String.html)|
|[`PathBuf`](https://doc.rust-lang.org/std/path/struct.PathBuf.html)|[`string`](https://caml.inria.fr/pub/docs/manual-ocaml/libref/String.html)|
|[`BTreeMap`](https://doc.rust-lang.org/std/collections/struct.BTreeMap.html)|[`Map`](https://caml.inria.fr/pub/docs/manual-ocaml/libref/Map.html)|
|[`BTreeSet`](https://doc.rust-lang.org/std/collections/struct.BTreeSet.html)|[`Set`](https://caml.inria.fr/pub/docs/manual-ocaml/libref/Set.html)|

See the [`impls`](https://docs.rs/ocamlrep/*/src/ocamlrep/impls.rs.html) submodule for examples of
conversions for std types, and [Real World
OCaml](https://dev.realworldocaml.org/runtime-memory-layout.html) and the
[Interfacing C with OCaml](https://ocaml.org/manual/intfc.html) section of the
OCaml manual for description of the OCaml representation of values.

Since manually implementing OcamlRep is cumbersome and error-prone, the
`ocamlrep_derive` crate provides a procedural macro for deriving the OcamlRep
trait.

When derived for custom types like this:

```ocaml
use ocamlrep_derive::OcamlRep;

#[derive(OcamlRep)]
struct Foo {
    a: isize,
    b: Vec<bool>,
}

#[derive(OcamlRep)]
enum Fruit {
    Apple,
    Orange(isize),
    Pear { num: isize },
    Kiwi,
}
```

It produces implementations of OcamlRep which construct values belonging to
these roughly-equivalent OCaml types:

```ocaml
type foo = {
  a: int;
  b: bool list;
}

type fruit =
  | Apple
  | Orange of int
  | Pear of { num: int }
  | Kiwi
```

The `oxidize` program at hphp/hack/src/hh_oxidize will take OCaml source files
like the one above and generate Rust source files which define
"roughly-equivalent" types (like the Rust source above). These types will derive
an implementation of `OcamlRep` which will produce OCaml values belonging to the
corresponding type in the OCaml source file.õ
,rust-analyzer cargo ocamlrep . FromOcamlRep#Í
```rust
ocamlrep
```

```rust
pub trait FromOcamlRep
where
    Self: Sized,
```

---

A type which can be reconstructed from an OCaml value.

Types which implement both `ToOcamlRep` and `FromOcamlRep` should provide
compatible implementations thereof. In other words, it is expected that for
any value, `T::from_ocamlrep(value.to_ocamlrep(alloc)) == Ok(value)`.Æ
.rust-analyzer cargo ocamlrep . FromOcamlRepIn#˚
```rust
ocamlrep
```

```rust
pub trait FromOcamlRepIn<'a>
where
    Self: Sized,
```

---

A type which can be reconstructed from an OCaml value.

Types which implement both `ToOcamlRep` and `FromOcamlRepIn` should provide
compatible implementations thereof. In other words, it is expected that for
any value, `T::from_ocamlrep_in(value.to_ocamlrep(alloc), bump) == Ok(value)`.ß
*rust-analyzer cargo ocamlrep . ToOcamlRep#¯
```rust
ocamlrep
```

```rust
pub trait ToOcamlRep
```

---

A data structure that can be converted to an OCaml value.

Types which implement both `ToOcamlRep` and `FromOcamlRep` (or
`FromOcamlRepIn`) should provide compatible implementations thereof.
In other words, it is expected that for any value with type `T`,
`T::from_ocamlrep(value.to_ocamlrep(alloc)) == Ok(value)`.´ 
local 4ü 
```rust
extern crate serde_1.0.152
```

---

# Serde

Serde is a framework for ***ser***ializing and ***de***serializing Rust data
structures efficiently and generically.

The Serde ecosystem consists of data structures that know how to serialize
and deserialize themselves along with data formats that know how to
serialize and deserialize other things. Serde provides the layer by which
these two groups interact with each other, allowing any supported data
structure to be serialized and deserialized using any supported data format.

See the Serde website <https://serde.rs/> for additional documentation and
usage examples.

## Design

Where many other languages rely on runtime reflection for serializing data,
Serde is instead built on Rust's powerful trait system. A data structure
that knows how to serialize and deserialize itself is one that implements
Serde's `Serialize` and `Deserialize` traits (or uses Serde's derive
attribute to automatically generate implementations at compile time). This
avoids any overhead of reflection or runtime type information. In fact in
many situations the interaction between data structure and data format can
be completely optimized away by the Rust compiler, leaving Serde
serialization to perform the same speed as a handwritten serializer for the
specific selection of data structure and data format.

## Data formats

The following is a partial list of data formats that have been implemented
for Serde by the community.

* [JSON](https://github.com/serde-rs/json), the ubiquitous JavaScript Object Notation used by many HTTP APIs.
* [Postcard](https://github.com/jamesmunns/postcard), a no\_std and embedded-systems friendly compact binary format.
* [CBOR](https://github.com/enarx/ciborium), a Concise Binary Object Representation designed for small message
  size without the need for version negotiation.
* [YAML](https://github.com/dtolnay/serde-yaml), a self-proclaimed human-friendly configuration language that ain't
  markup language.
* [MessagePack](https://github.com/3Hren/msgpack-rust), an efficient binary format that resembles a compact JSON.
* [TOML](https://docs.rs/toml), a minimal configuration format used by [Cargo](https://doc.rust-lang.org/cargo/reference/manifest.html).
* [Pickle](https://github.com/birkenfeld/serde-pickle), a format common in the Python world.
* [RON](https://github.com/ron-rs/ron), a Rusty Object Notation.
* [BSON](https://github.com/mongodb/bson-rust), the data storage and network transfer format used by MongoDB.
* [Avro](https://docs.rs/apache-avro), a binary format used within Apache Hadoop, with support for schema
  definition.
* [JSON5](https://github.com/callum-oakley/json5-rs), a superset of JSON including some productions from ES5.
* [URL](https://docs.rs/serde_qs) query strings, in the x-www-form-urlencoded format.
* [Envy](https://github.com/softprops/envy), a way to deserialize environment variables into Rust structs.
  *(deserialization only)*
* [Envy Store](https://github.com/softprops/envy-store), a way to deserialize [AWS Parameter Store](https://docs.aws.amazon.com/systems-manager/latest/userguide/systems-manager-parameter-store.html) parameters into
  Rust structs. *(deserialization only)*
* [S-expressions](https://github.com/rotty/lexpr-rs), the textual representation of code and data used by the
  Lisp language family.
* [D-Bus](https://docs.rs/zvariant)'s binary wire format.
* [FlexBuffers](https://github.com/google/flatbuffers/tree/master/rust/flexbuffers), the schemaless cousin of Google's FlatBuffers zero-copy
  serialization format.
* [Bencode](https://github.com/P3KI/bendy), a simple binary format used in the BitTorrent protocol.
* [Token streams](https://github.com/oxidecomputer/serde_tokenstream), for processing Rust procedural macro input.
  *(deserialization only)*
* [DynamoDB Items](https://docs.rs/serde_dynamo), the format used by [rusoto_dynamodb](https://docs.rs/rusoto_dynamodb) to transfer data to
  and from DynamoDB.
* [Hjson](https://github.com/Canop/deser-hjson), a syntax extension to JSON designed around human reading and
  editing. *(deserialization only)*÷
3rust-analyzer cargo serde-1.0.152 . de/Deserialize#û
```rust
serde_1.0.152::de
```

```rust
pub trait Deserialize<'de>
where
    Self: Sized,
```

---

A **data structure** that can be deserialized from any data format supported
by Serde.

Serde provides `Deserialize` implementations for many Rust primitive and
standard library types. The complete list is [here](https://docs.rs/serde/1.0.152/serde_1.0.152/de/index.html). All of these
can be deserialized using Serde out of the box.

Additionally, Serde provides a procedural macro called `serde_derive` to
automatically generate `Deserialize` implementations for structs and enums
in your program. See the [derive section of the manual](https://serde.rs/derive.html) for how to
use this.

In rare cases it may be necessary to implement `Deserialize` manually for
some type in your program. See the [Implementing
`Deserialize`](https://serde.rs/impl-deserialize.html) section of the manual for more about this.

Third-party crates may provide `Deserialize` implementations for types that
they expose. For example the `linked-hash-map` crate provides a
`LinkedHashMap<K, V>` type that is deserializable by Serde because the crate
provides an implementation of `Deserialize` for it.

# Lifetime

The `'de` lifetime of this trait is the lifetime of data that may be
borrowed by `Self` when deserialized. See the page [Understanding
deserializer lifetimes](https://serde.rs/lifetimes.html) for a more detailed explanation of these lifetimes.»

2rust-analyzer cargo serde-1.0.152 . ser/Serialize#ë

```rust
serde_1.0.152::ser
```

```rust
pub trait Serialize
```

---

A **data structure** that can be serialized into any data format supported
by Serde.

Serde provides `Serialize` implementations for many Rust primitive and
standard library types. The complete list is [here](https://docs.rs/serde/1.0.152/serde_1.0.152/ser/index.html). All of
these can be serialized using Serde out of the box.

Additionally, Serde provides a procedural macro called [`serde_derive`](https://crates.io/crates/serde_derive) to
automatically generate `Serialize` implementations for structs and enums in
your program. See the [derive section of the manual](https://serde.rs/derive.html) for how to use this.

In rare cases it may be necessary to implement `Serialize` manually for some
type in your program. See the [Implementing `Serialize`](https://serde.rs/impl-serialize.html) section of the
manual for more about this.

Third-party crates may provide `Serialize` implementations for types that
they expose. For example the [`linked-hash-map`](https://crates.io/crates/linked-hash-map) crate provides a
[`LinkedHashMap<K, V>`](https://docs.rs/linked-hash-map/*/linked_hash_map/struct.LinkedHashMap.html) type that is serializable by Serde because the crate
provides an implementation of `Serialize` for it.∫
^rust-analyzer cargo core https://github.com/rust-lang/rust/library/core builtin/macros/derive!◊
```rust
core::macros::builtin
```

```rust
macro derive
```

---

Attribute macro used to apply derive macros.

See [the reference](https://doc.rust-lang.org/nightly/reference/attributes/derive.html) for more info.≈
Trust-analyzer cargo core https://github.com/rust-lang/rust/library/core clone/Clone!m
```rust
core::clone
```

```rust
macro Clone
```

---

Derive macro generating an impl of the trait `Clone`.ƒ
Trust-analyzer cargo core https://github.com/rust-lang/rust/library/core marker/Copy!l
```rust
core::marker
```

```rust
macro Copy
```

---

Derive macro generating an impl of the trait `Copy`.–
Yrust-analyzer cargo core https://github.com/rust-lang/rust/library/core macros/fmt/Debug!s
```rust
core::fmt::macros
```

```rust
macro Debug
```

---

Derive macro generating an impl of the trait `Debug`.∏
Orust-analyzer cargo core https://github.com/rust-lang/rust/library/core cmp/Eq!e
```rust
core::cmp
```

```rust
macro Eq
```

---

Derive macro generating an impl of the trait `Eq`.œ
Yrust-analyzer cargo core https://github.com/rust-lang/rust/library/core macros/hash/Hash!r
```rust
core::hash::macros
```

```rust
macro Hash
```

---

Derive macro generating an impl of the trait `Hash`.ª
Prust-analyzer cargo core https://github.com/rust-lang/rust/library/core cmp/Ord!g
```rust
core::cmp
```

```rust
macro Ord
```

---

Derive macro generating an impl of the trait `Ord`.Õ
Vrust-analyzer cargo core https://github.com/rust-lang/rust/library/core cmp/PartialEq!s
```rust
core::cmp
```

```rust
macro PartialEq
```

---

Derive macro generating an impl of the trait `PartialEq`.–
Wrust-analyzer cargo core https://github.com/rust-lang/rust/library/core cmp/PartialOrd!u
```rust
core::cmp
```

```rust
macro PartialOrd
```

---

Derive macro generating an impl of the trait `PartialOrd`.Ç
8rust-analyzer cargo _serde_derive-1.0.152 . Deserialize!F
```rust
_serde_derive_1.0.152
```

```rust
proc_macro Deserialize
```~
6rust-analyzer cargo _serde_derive-1.0.152 . Serialize!D
```rust
_serde_derive_1.0.152
```

```rust
proc_macro Serialize
```Ç
8rust-analyzer cargo _eq_modulo_pos_derive . EqModuloPos!F
```rust
_eq_modulo_pos_derive
```

```rust
proc_macro EqModuloPos
```z
4rust-analyzer cargo _ocamlrep_derive . FromOcamlRep!B
```rust
_ocamlrep_derive
```

```rust
proc_macro FromOcamlRep
```~
6rust-analyzer cargo _ocamlrep_derive . FromOcamlRepIn!D
```rust
_ocamlrep_derive
```

```rust
proc_macro FromOcamlRepIn
```v
2rust-analyzer cargo _ocamlrep_derive . ToOcamlRep!@
```rust
_ocamlrep_derive
```

```rust
proc_macro ToOcamlRep
```z
4rust-analyzer cargo _no_pos_hash_derive . NoPosHash!B
```rust
_no_pos_hash_derive
```

```rust
proc_macro NoPosHash
```f
+rust-analyzer cargo relative_path . Prefix#7
```rust
relative_path
```

```rust
pub enum Prefix
```e
)rust-analyzer cargo relative_path . Root#8
```rust
relative_path::Prefix
```

```rust
Root = 0
```c
(rust-analyzer cargo relative_path . Hhi#7
```rust
relative_path::Prefix
```

```rust
Hhi = 1
```g
*rust-analyzer cargo relative_path . Dummy#9
```rust
relative_path::Prefix
```

```rust
Dummy = 2
```c
(rust-analyzer cargo relative_path . Tmp#7
```rust
relative_path::Prefix
```

```rust
Tmp = 3
```0
local 6%
```rust
extern crate arena_trait
```û
.rust-analyzer cargo arena_trait . TrivialDrop#Î
```rust
arena_trait
```

```rust
pub trait TrivialDrop
```

---

Marker trait for types whose implementation of `Drop` is a no-op.

Used to denote types which can be moved into an arena (which does not drop
its contents) without leaking memory.

Must not be implemented for any type which owns heap memory or otherwise
needs to run cleanup in its `Drop` implementation (e.g., `Box`, `Vec`,
`std::fs::File`, etc.), or any type containing a field with such a
nontrivial `Drop` implementation.É
4rust-analyzer cargo relative_path . Prefix#is_hhi().K
```rust
relative_path::Prefix
```

```rust
pub fn is_hhi(self) -> bool
```G
*rust-analyzer cargo relative_path . (self)
```rust
self: Prefix
```ä
Wrust-analyzer cargo core https://github.com/rust-lang/rust/library/core macros/matches!Æ
```rust
core::macros
```

```rust
macro_rules! matches
```

---

Returns whether the given expression matches any of the given patterns.

Like in a `match` expression, the pattern can be optionally followed by `if`
and a guard expression that has access to names bound by the pattern.

# Examples

```
let foo = 'f';
assert!(matches!(foo, 'A'..='Z' | 'a'..='z'));

let bar = Some(4);
assert!(matches!(bar, Some(x) if x > 2));
```‚
Xrust-analyzer cargo core https://github.com/rust-lang/rust/library/core convert/TryFrom#Ö
```rust
core::convert
```

```rust
pub trait TryFrom<T>
where
    Self: Sized,
```

---

Simple and safe type conversions that may fail in a controlled
way under some circumstances. It is the reciprocal of [`TryInto`](https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html).

This is useful when you are doing a type conversion that may
trivially succeed but may also need special handling.
For example, there is no way to convert an [`i64`](https://doc.rust-lang.org/nightly/core/primitive.i64.html) into an [`i32`](https://doc.rust-lang.org/nightly/core/primitive.i32.html)
using the [`From`](https://doc.rust-lang.org/nightly/core/convert/trait.From.html) trait, because an [`i64`](https://doc.rust-lang.org/nightly/core/primitive.i64.html) may contain a value
that an [`i32`](https://doc.rust-lang.org/nightly/core/primitive.i32.html) cannot represent and so the conversion would lose data.
This might be handled by truncating the [`i64`](https://doc.rust-lang.org/nightly/core/primitive.i64.html) to an [`i32`](https://doc.rust-lang.org/nightly/core/primitive.i32.html) (essentially
giving the [`i64`](https://doc.rust-lang.org/nightly/core/primitive.i64.html)'s value modulo [`i32::MAX`](`i32::MAX`)) or by simply returning
[`i32::MAX`](`i32::MAX`), or by some other method.  The [`From`](https://doc.rust-lang.org/nightly/core/convert/trait.From.html) trait is intended
for perfect conversions, so the `TryFrom` trait informs the
programmer when a type conversion could go bad and lets them
decide how to handle it.

# Generic Implementations

* `TryFrom<T> for U` implies [`TryInto`](https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html)`<U> for T`
* [`try_from`] is reflexive, which means that `TryFrom<T> for T`
  is implemented and cannot fail -- the associated `Error` type for
  calling `T::try_from()` on a value of type `T` is [`Infallible`](https://doc.rust-lang.org/nightly/core/convert/enum.Infallible.html).
  When the [`!`](`!`) type is stabilized [`Infallible`](https://doc.rust-lang.org/nightly/core/convert/enum.Infallible.html) and [`!`](`!`) will be
  equivalent.

`TryFrom<T>` can be implemented as follows:

```
struct GreaterThanZero(i32);

impl TryFrom<i32> for GreaterThanZero {
    type Error = &'static str;

    fn try_from(value: i32) -> Result<Self, Self::Error> {
        if value <= 0 {
            Err("GreaterThanZero only accepts values greater than zero!")
        } else {
            Ok(GreaterThanZero(value))
        }
    }
}
```

# Examples

As described, [`i32`](https://doc.rust-lang.org/nightly/core/primitive.i32.html) implements `TryFrom<`[`i64`](https://doc.rust-lang.org/nightly/core/primitive.i64.html)`>`:

```
let big_number = 1_000_000_000_000i64;
// Silently truncates `big_number`, requires detecting
// and handling the truncation after the fact.
let smaller_number = big_number as i32;
assert_eq!(smaller_number, -727379968);

// Returns an error because `big_number` is too big to
// fit in an `i32`.
let try_smaller_number = i32::try_from(big_number);
assert!(try_smaller_number.is_err());

// Returns `Ok(3)`.
let try_successful_smaller_number = i32::try_from(3);
assert!(try_successful_smaller_number.is_ok());
```µ
:rust-analyzer cargo relative_path . Prefix#TryFrom#[Error]w
```rust
relative_path
```

```rust
type Error = String
```

---

The type returned in the event of a conversion error.Ã=
Xrust-analyzer cargo alloc https://github.com/rust-lang/rust/library/alloc string/String#Ô<
```rust
alloc::string
```

```rust
pub struct String
```

---

A UTF-8‚Äìencoded, growable string.

The `String` type is the most common string type that has ownership over the
contents of the string. It has a close relationship with its borrowed
counterpart, the primitive [`str`].

# Examples

You can create a `String` from [a literal string](https://doc.rust-lang.org/nightly/alloc/str/index.html) with [`String::from`]:

```
let hello = String::from("Hello, world!");
```

You can append a [`char`](https://doc.rust-lang.org/nightly/core/primitive.char.html) to a `String` with the [`push`] method, and
append a [`&str`] with the [`push_str`] method:

```
let mut hello = String::from("Hello, ");

hello.push('w');
hello.push_str("orld!");
```

If you have a vector of UTF-8 bytes, you can create a `String` from it with
the [`from_utf8`] method:

```
// some bytes, in a vector
let sparkle_heart = vec![240, 159, 146, 150];

// We know these bytes are valid, so we'll use `unwrap()`.
let sparkle_heart = String::from_utf8(sparkle_heart).unwrap();

assert_eq!("üíñ", sparkle_heart);
```

# UTF-8

`String`s are always valid UTF-8. If you need a non-UTF-8 string, consider
[`OsString`](https://doc.rust-lang.org/nightly/std/ffi/struct.OsString.html). It is similar, but without the UTF-8 constraint. Because UTF-8
is a variable width encoding, `String`s are typically smaller than an array of
the same `chars`:

```
use std::mem;

// `s` is ASCII which represents each `char` as one byte
let s = "hello";
assert_eq!(s.len(), 5);

// A `char` array with the same contents would be longer because
// every `char` is four bytes
let s = ['h', 'e', 'l', 'l', 'o'];
let size: usize = s.into_iter().map(|c| mem::size_of_val(&c)).sum();
assert_eq!(size, 20);

// However, for non-ASCII strings, the difference will be smaller
// and sometimes they are the same
let s = "üíñüíñüíñüíñüíñ";
assert_eq!(s.len(), 20);

let s = ['üíñ', 'üíñ', 'üíñ', 'üíñ', 'üíñ'];
let size: usize = s.into_iter().map(|c| mem::size_of_val(&c)).sum();
assert_eq!(size, 20);
```

This raises interesting questions as to how `s[i]` should work.
What should `i` be here? Several options include byte indices and
`char` indices but, because of UTF-8 encoding, only byte indices
would provide constant time indexing. Getting the `i`th `char`, for
example, is available using [`chars`]:

```
let s = "hello";
let third_character = s.chars().nth(2);
assert_eq!(third_character, Some('l'));

let s = "üíñüíñüíñüíñüíñ";
let third_character = s.chars().nth(2);
assert_eq!(third_character, Some('üíñ'));
```

Next, what should `s[i]` return? Because indexing returns a reference
to underlying data it could be `&u8`, `&[u8]`, or something else similar.
Since we're only providing one index, `&u8` makes the most sense but that
might not be what the user expects and can be explicitly achieved with
[`as_bytes()`]:

```
// The first byte is 104 - the byte value of `'h'`
let s = "hello";
assert_eq!(s.as_bytes()[0], 104);
// or
assert_eq!(s.as_bytes()[0], b'h');

// The first byte is 240 which isn't obviously useful
let s = "üíñüíñüíñüíñüíñ";
assert_eq!(s.as_bytes()[0], 240);
```

Due to these ambiguities/restrictions, indexing with a `usize` is simply
forbidden:

```compile_fail,E0277
let s = "hello";

// The following will not compile!
println!("The first letter of s is {}", s[0]);
```

It is more clear, however, how `&s[i..j]` should work (that is,
indexing with a range). It should accept byte indices (to be constant-time)
and return a `&str` which is UTF-8 encoded. This is also called "string slicing".
Note this will panic if the byte indices provided are not character
boundaries - see [`is_char_boundary`] for more details. See the implementations
for [`SliceIndex<str>`] for more details on string slicing. For a non-panicking
version of string slicing, see [`get`].

The [`bytes`] and [`chars`] methods return iterators over the bytes and
codepoints of the string, respectively. To iterate over codepoints along
with byte indices, use [`char_indices`].

# Deref

`String` implements <code>
[Deref]\<Target = [str]\></code>, and so inherits all of [`str`]'s
methods. In addition, this means that you can pass a `String` to a
function which takes a [`&str`] by using an ampersand (`&`):

```
fn takes_str(s: &str) { }

let s = String::from("Hello");

takes_str(&s);
```

This will create a [`&str`] from the `String` and pass it in. This
conversion is very inexpensive, and so generally, functions will accept
[`&str`]s as arguments unless they need a `String` for some specific
reason.

In certain cases Rust doesn't have enough information to make this
conversion, known as [`Deref`] coercion. In the following example a string
slice [`&'a str`](https://doc.rust-lang.org/nightly/alloc/str/index.html) implements the trait `TraitExample`, and the function
`example_func` takes anything that implements the trait. In this case Rust
would need to make two implicit conversions, which Rust doesn't have the
means to do. For that reason, the following example will not compile.

```compile_fail,E0277
trait TraitExample {}

impl<'a> TraitExample for &'a str {}

fn example_func<A: TraitExample>(example_arg: A) {}

let example_string = String::from("example_string");
example_func(&example_string);
```

There are two options that would work instead. The first would be to
change the line `example_func(&example_string);` to
`example_func(example_string.as_str());`, using the method [`as_str()`]
to explicitly extract the string slice containing the string. The second
way changes `example_func(&example_string);` to
`example_func(&*example_string);`. In this case we are dereferencing a
`String` to a [`str`], then referencing the [`str`] back to
[`&str`]. The second way is more idiomatic, however both work to do the
conversion explicitly rather than relying on the implicit conversion.

# Representation

A `String` is made up of three components: a pointer to some bytes, a
length, and a capacity. The pointer points to an internal buffer `String`
uses to store its data. The length is the number of bytes currently stored
in the buffer, and the capacity is the size of the buffer in bytes. As such,
the length will always be less than or equal to the capacity.

This buffer is always stored on the heap.

You can look at these with the [`as_ptr`], [`len`], and [`capacity`]
methods:

```
use std::mem;

let story = String::from("Once upon a time...");

// Prevent automatically dropping the String's data
let mut story = mem::ManuallyDrop::new(story);

let ptr = story.as_mut_ptr();
let len = story.len();
let capacity = story.capacity();

// story has nineteen bytes
assert_eq!(19, len);

// We can re-build a String out of ptr, len, and capacity. This is all
// unsafe because we are responsible for making sure the components are
// valid:
let s = unsafe { String::from_raw_parts(ptr, len, capacity) } ;

assert_eq!(String::from("Once upon a time..."), s);
```

If a `String` has enough capacity, adding elements to it will not
re-allocate. For example, consider this program:

```
let mut s = String::new();

println!("{}", s.capacity());

for _ in 0..5 {
    s.push_str("hello");
    println!("{}", s.capacity());
}
```

This will output the following:

```text
0
8
16
16
32
32
```

At first, we have no memory allocated at all, but as we append to the
string, it increases its capacity appropriately. If we instead use the
[`with_capacity`] method to allocate the correct capacity initially:

```
let mut s = String::with_capacity(25);

println!("{}", s.capacity());

for _ in 0..5 {
    s.push_str("hello");
    println!("{}", s.capacity());
}
```

We end up with a different output:

```text
25
25
25
25
25
25
```

Here, there's no need to allocate more memory inside the loop.»
>rust-analyzer cargo relative_path . Prefix#TryFrom#try_from().Ö
```rust
relative_path::Prefix
```

```rust
fn try_from(prefix_raw: usize) -> Result<Self, String>
```

---

Performs the conversion.R
0rust-analyzer cargo relative_path . (prefix_raw)
```rust
prefix_raw: usize
```Œ
Vrust-analyzer cargo core https://github.com/rust-lang/rust/library/core result/Result#Û
```rust
core::result
```

```rust
pub enum Result<T, E>
```

---

`Result` is a type that represents either success ([`Ok`](https://doc.rust-lang.org/nightly/core/result/enum.Result.html)) or failure ([`Err`](https://doc.rust-lang.org/nightly/core/result/enum.Result.html)).

See the [documentation](https://doc.rust-lang.org/nightly/core/result/index.html) for details.f
+rust-analyzer cargo relative_path . Prefix#7
```rust
relative_path
```

```rust
pub enum Prefix
```´
Rrust-analyzer cargo core https://github.com/rust-lang/rust/library/core result/Ok#U
```rust
core::result::Result
```

```rust
Ok(T)
```

---

Contains the success value´
Srust-analyzer cargo core https://github.com/rust-lang/rust/library/core result/Err#T
```rust
core::result::Result
```

```rust
Err(E)
```

---

Contains the error value¬

Xrust-analyzer cargo alloc https://github.com/rust-lang/rust/library/alloc macros/format!Â	
```rust
alloc::macros
```

```rust
macro_rules! format
```

---

Creates a `String` using interpolation of runtime expressions.

The first argument `format!` receives is a format string. This must be a string
literal. The power of the formatting string is in the `{}`s contained.

Additional parameters passed to `format!` replace the `{}`s within the
formatting string in the order given unless named or positional parameters
are used; see [`std::fmt`](https://doc.rust-lang.org/nightly/alloc/std/fmt/index.html) for more information.

A common use for `format!` is concatenation and interpolation of strings.
The same convention is used with [`print!`](https://doc.rust-lang.org/nightly/alloc/std/macro.print.html) and [`write`] macros,
depending on the intended destination of the string.

To convert a single value to a string, use the [`to_string`] method. This
will use the [`Display`] formatting trait.

# Panics

`format!` panics if a formatting trait implementation returns an error.
This indicates an incorrect implementation
since `fmt::Write for String` never returns an error itself.

# Examples

```
format!("test");
format!("hello {}", "world!");
format!("x = {}, y = {y}", 10, y = 30);
let (x, y) = (1, 2);
format!("{x} + {y} = 3");
```»
9rust-analyzer cargo relative_path . Prefix#Display#fmt().ä
```rust
relative_path::Prefix
```

```rust
fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result
```

---

Formats the value using the given formatter.

# Examples

```
use std::fmt;

struct Position {
    longitude: f32,
    latitude: f32,
}

impl fmt::Display for Position {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "({}, {})", self.longitude, self.latitude)
    }
}

assert_eq!("(1.987, 2.983)",
           format!("{}", Position { longitude: 1.987, latitude: 2.983, }));
```H
*rust-analyzer cargo relative_path . (self)
```rust
self: &Prefix
```I
'rust-analyzer cargo relative_path . (f)
```rust
f: &mut Formatter
```„
Vrust-analyzer cargo core https://github.com/rust-lang/rust/library/core fmt/Formatter#à
```rust
core::fmt
```

```rust
pub struct Formatter<'a>
```

---

Configuration for formatting.

A `Formatter` represents various options related to formatting. Users do not
construct `Formatter`s directly; a mutable reference to one is passed to
the `fmt` method of all formatting traits, like [`Debug`](https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html) and [`Display`](https://doc.rust-lang.org/nightly/core/fmt/trait.Display.html).

To interact with a `Formatter`, you'll call various methods to change the
various options related to formatting. For examples, please see the
documentation of the methods defined on `Formatter` below.ﬂ
Trust-analyzer cargo core https://github.com/rust-lang/rust/library/core fmt/[Result]Ü
```rust
core::fmt
```

```rust
pub type Result = result::Result<(), Error>
```

---

The type returned by formatter methods.

# Examples

```
use std::fmt;

#[derive(Debug)]
struct Triangle {
    a: f32,
    b: f32,
    c: f32
}

impl fmt::Display for Triangle {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "({}, {}, {})", self.a, self.b, self.c)
    }
}

let pythagorean_triple = Triangle { a: 3.0, b: 4.0, c: 5.0 };

assert_eq!(format!("{pythagorean_triple}"), "(3, 4, 5)");
```f
+rust-analyzer cargo relative_path . Prefix#7
```rust
relative_path
```

```rust
pub enum Prefix
```ª
Urust-analyzer cargo core https://github.com/rust-lang/rust/library/core macros/write!·
```rust
core::macros
```

```rust
macro_rules! write
```

---

Writes formatted data into a buffer.

This macro accepts a 'writer', a format string, and a list of arguments. Arguments will be
formatted according to the specified format string and the result will be passed to the writer.
The writer may be any value with a `write_fmt` method; generally this comes from an
implementation of either the [`fmt::Write`] or the [`io::Write`](https://doc.rust-lang.org/nightly/core/std/io/trait.Write.html) trait. The macro
returns whatever the `write_fmt` method returns; commonly a [`fmt::Result`], or an
[`io::Result`](https://doc.rust-lang.org/nightly/core/std/io/type.Result.html).

See [`std::fmt`](https://doc.rust-lang.org/nightly/core/std/fmt/index.html) for more information on the format string syntax.

# Examples

```
use std::io::Write;

fn main() -> std::io::Result<()> {
    let mut w = Vec::new();
    write!(&mut w, "test")?;
    write!(&mut w, "formatted {}", "arguments")?;

    assert_eq!(w, b"testformatted arguments");
    Ok(())
}
```

A module can import both `std::fmt::Write` and `std::io::Write` and call `write!` on objects
implementing either, as objects do not typically implement both. However, the module must
avoid conflict between the trait names, such as by importing them as `_` or otherwise renaming
them:

```
use std::fmt::Write as _;
use std::io::Write as _;

fn main() -> Result<(), Box<dyn std::error::Error>> {
    let mut s = String::new();
    let mut v = Vec::new();

    write!(&mut s, "{} {}", "abc", 123)?; // uses fmt::Write::write_fmt
    write!(&mut v, "s = {:?}", s)?; // uses io::Write::write_fmt
    assert_eq!(v, b"s = \"abc 123\"");
    Ok(())
}
```

If you also need the trait names themselves, such as to implement one or both on your types,
import the containing module and then name them with a prefix:

```
# #![allow(unused_imports)]
use std::fmt::{self, Write as _};
use std::io::{self, Write as _};

struct Example;

impl fmt::Write for Example {
    fn write_str(&mut self, _s: &str) -> core::fmt::Result {
         unimplemented!();
    }
}
```

Note: This macro can be used in `no_std` setups as well.
In a `no_std` setup you are responsible for the implementation details of the components.

```no_run
# extern crate core;
use core::fmt::Write;

struct Example;

impl Write for Example {
    fn write_str(&mut self, _s: &str) -> core::fmt::Result {
         unimplemented!();
    }
}

let mut m = Example{};
write!(&mut m, "Hello World").expect("Not written");
```t
1rust-analyzer cargo relative_path . RelativePath#?
```rust
relative_path
```

```rust
pub struct RelativePath
```Ä
8rust-analyzer cargo relative_path . RelativePath#prefix.D
```rust
relative_path::RelativePath
```

```rust
prefix: Prefix
```º
6rust-analyzer cargo relative_path . RelativePath#path.Å
```rust
relative_path::RelativePath
```

```rust
path: Option<PathBuf>
```

---

Representation invariant: the empty path is always encoded as `None`.
This allows us to construct `RelativePath` in `const` contexts
(because `Path::new` is not a `const fn`).ñ
Vrust-analyzer cargo core https://github.com/rust-lang/rust/library/core option/Option#ª
```rust
core::option
```

```rust
pub enum Option<T>
```

---

The `Option` type. See [the module level documentation](https://doc.rust-lang.org/nightly/core/option/index.html) for more.§
8rust-analyzer cargo relative_path . RelativePath#make().h
```rust
relative_path::RelativePath
```

```rust
pub fn make(prefix: Prefix, path: PathBuf) -> Self
```K
,rust-analyzer cargo relative_path . (prefix)
```rust
prefix: Prefix
```H
*rust-analyzer cargo relative_path . (path)
```rust
path: PathBuf
```t
1rust-analyzer cargo relative_path . RelativePath#?
```rust
relative_path
```

```rust
pub struct RelativePath
```¨
\rust-analyzer cargo std https://github.com/rust-lang/rust/library/std path/Path#as_os_str().À
```rust
std::path::Path
```

```rust
pub fn as_os_str(&self) -> &OsStr
```

---

Yields the underlying [`OsStr`](https://doc.rust-lang.org/nightly/std/ffi/os_str/struct.OsStr.html) slice.

# Examples

```
use std::path::Path;

let os_str = Path::new("foo.txt").as_os_str();
assert_eq!(os_str, std::ffi::OsStr::new("foo.txt"));
```Ñ
brust-analyzer cargo std https://github.com/rust-lang/rust/library/std os_str/ffi/OsStr#is_empty().ù
```rust
std::ffi::os_str::OsStr
```

```rust
pub fn is_empty(&self) -> bool
```

---

Checks whether the `OsStr` is empty.

# Examples

```
use std::ffi::OsStr;

let os_str = OsStr::new("");
assert!(os_str.is_empty());

let os_str = OsStr::new("foo");
assert!(!os_str.is_empty());
```õ
Trust-analyzer cargo core https://github.com/rust-lang/rust/library/core option/None#C
```rust
core::option::Option
```

```rust
None
```

---

No value.¨
Trust-analyzer cargo core https://github.com/rust-lang/rust/library/core option/Some#T
```rust
core::option::Option
```

```rust
Some(T)
```

---

Some value of type `T`.∫
7rust-analyzer cargo relative_path . RelativePath#EMPTY.
```rust
relative_path
```

```rust
pub const EMPTY: Self = Self {
        prefix: Prefix::Dummy,
        path: None,
    }
```î
<rust-analyzer cargo relative_path . RelativePath#is_empty().T
```rust
relative_path::RelativePath
```

```rust
pub fn is_empty(&self) -> bool
```N
*rust-analyzer cargo relative_path . (self) 
```rust
self: &RelativePath
```≥
Arust-analyzer cargo relative_path . RelativePath#has_extension().n
```rust
relative_path::RelativePath
```

```rust
pub fn has_extension(&self, s: impl AsRef<Path>) -> bool
```N
*rust-analyzer cargo relative_path . (self) 
```rust
self: &RelativePath
```K
'rust-analyzer cargo relative_path . (s) 
```rust
s: impl AsRef<Path>
```Æ 
Vrust-analyzer cargo core https://github.com/rust-lang/rust/library/core convert/AsRef#”
```rust
core::convert
```

```rust
pub trait AsRef<T>
where
    T: ?Sized,
```

---

Used to do a cheap reference-to-reference conversion.

This trait is similar to [`AsMut`](https://doc.rust-lang.org/nightly/core/convert/trait.AsMut.html) which is used for converting between mutable references.
If you need to do a costly conversion it is better to implement [`From`](https://doc.rust-lang.org/nightly/core/convert/trait.From.html) with type
`&T` or write a custom function.

# Relation to `Borrow`

`AsRef` has the same signature as [`Borrow`], but [`Borrow`] is different in a few aspects:

* Unlike `AsRef`, [`Borrow`] has a blanket impl for any `T`, and can be used to accept either
  a reference or a value. (See also note on `AsRef`'s reflexibility below.)
* [`Borrow`] also requires that [`Hash`](https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html), [`Eq`] and [`Ord`] for a borrowed value are
  equivalent to those of the owned value. For this reason, if you want to
  borrow only a single field of a struct you can implement `AsRef`, but not [`Borrow`].

**Note: This trait must not fail**. If the conversion can fail, use a
dedicated method which returns an [`Option<T>`](https://doc.rust-lang.org/nightly/core/option/enum.Option.html) or a [`Result<T, E>`](https://doc.rust-lang.org/nightly/core/result/enum.Result.html).

# Generic Implementations

`AsRef` auto-dereferences if the inner type is a reference or a mutable reference
(e.g.: `foo.as_ref()` will work the same if `foo` has type `&mut Foo` or `&&mut Foo`).

Note that due to historic reasons, the above currently does not hold generally for all
[dereferenceable types], e.g. `foo.as_ref()` will *not* work the same as
`Box::new(foo).as_ref()`. Instead, many smart pointers provide an `as_ref` implementation which
simply returns a reference to the [pointed-to value] (but do not perform a cheap
reference-to-reference conversion for that value). However, [`AsRef::as_ref`](https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html#tymethod.as_ref) should not be
used for the sole purpose of dereferencing; instead ['`Deref` coercion'](core::ops::Deref#more-on-deref-coercion) can be used:

```
let x = Box::new(5i32);
// Avoid this:
// let y: &i32 = x.as_ref();
// Better just write:
let y: &i32 = &x;
```

Types which implement [`Deref`] should consider implementing `AsRef<T>` as follows:

```
# use core::ops::Deref;
# struct SomeType;
# impl Deref for SomeType {
#     type Target = [u8];
#     fn deref(&self) -> &[u8] {
#         &[]
#     }
# }
impl<T> AsRef<T> for SomeType
where
    T: ?Sized,
    <SomeType as Deref>::Target: AsRef<T>,
{
    fn as_ref(&self) -> &T {
        self.deref().as_ref()
    }
}
```

# Reflexivity

Ideally, `AsRef` would be reflexive, i.e. there would be an `impl<T: ?Sized> AsRef<T> for T`
with [`as_ref`] simply returning its argument unchanged.
Such a blanket implementation is currently *not* provided due to technical restrictions of
Rust's type system (it would be overlapping with another existing blanket implementation for
`&T where T: AsRef<U>` which allows `AsRef` to auto-dereference, see "Generic Implementations"
above).

A trivial implementation of `AsRef<T> for T` must be added explicitly for a particular type `T`
where needed or desired. Note, however, that not all types from `std` contain such an
implementation, and those cannot be added by external code due to orphan rules.

# Examples

By using trait bounds we can accept arguments of different types as long as they can be
converted to the specified type `T`.

For example: By creating a generic function that takes an `AsRef<str>` we express that we
want to accept all references that can be converted to [`&str`] as an argument.
Since both [`String`](https://doc.rust-lang.org/nightly/std/string/struct.String.html) and [`&str`] implement `AsRef<str>` we can accept both as input argument.

```
fn is_hello<T: AsRef<str>>(s: T) {
   assert_eq!("hello", s.as_ref());
}

let s = "hello";
is_hello(s);

let s = "hello".to_string();
is_hello(s);
```ç
8rust-analyzer cargo relative_path . RelativePath#path().Q
```rust
relative_path::RelativePath
```

```rust
pub fn path(&self) -> &Path
```‚
\rust-analyzer cargo std https://github.com/rust-lang/rust/library/std path/Path#extension().Å
```rust
std::path::Path
```

```rust
pub fn extension(&self) -> Option<&OsStr>
```

---

Extracts the extension (without the leading dot) of [`self.file_name`], if possible.

The extension is:

* [`None`](https://doc.rust-lang.org/nightly/core/option/enum.Option.html), if there is no file name;
* [`None`](https://doc.rust-lang.org/nightly/core/option/enum.Option.html), if there is no embedded `.`;
* [`None`](https://doc.rust-lang.org/nightly/core/option/enum.Option.html), if the file name begins with `.` and has no other `.`s within;
* Otherwise, the portion of the file name after the final `.`

# Examples

```
use std::path::Path;

assert_eq!("rs", Path::new("foo.rs").extension().unwrap());
assert_eq!("gz", Path::new("foo.tar.gz").extension().unwrap());
```Ñ
_rust-analyzer cargo core https://github.com/rust-lang/rust/library/core convert/AsRef#as_ref().†
```rust
core::convert::AsRef
```

```rust
pub fn as_ref(&self) -> &T
```

---

Converts this type into a shared reference of the (usually inferred) input type.N
*rust-analyzer cargo relative_path . (self) 
```rust
self: &RelativePath
```•
arust-analyzer cargo core https://github.com/rust-lang/rust/library/core option/Option#as_deref().ø
```rust
core::option::Option
```

```rust
pub const fn as_deref(&self) -> Option<&T::Target>
where
    T: Deref,
```

---

Converts from `Option<T>` (or `&Option<T>`) to `Option<&T::Target>`.

Leaves the original Option in-place, creating a new one with a reference
to the original one, additionally coercing the contents via [`Deref`](https://doc.rust-lang.org/nightly/core/ops/deref/trait.Deref.html).

# Examples

```
let x: Option<String> = Some("hey".to_owned());
assert_eq!(x.as_deref(), Some("hey"));

let x: Option<String> = None;
assert_eq!(x.as_deref(), None);
```Å
brust-analyzer cargo core https://github.com/rust-lang/rust/library/core option/Option#unwrap_or().ö
```rust
core::option::Option
```

```rust
pub const fn unwrap_or(self, default: T) -> T
where
    T: Destruct,
```

---

Returns the contained [`Some`](https://doc.rust-lang.org/nightly/core/option/enum.Option.html) value or a provided default.

Arguments passed to `unwrap_or` are eagerly evaluated; if you are passing
the result of a function call, it is recommended to use [`unwrap_or_else`],
which is lazily evaluated.

# Examples

```
assert_eq!(Some("car").unwrap_or("bike"), "car");
assert_eq!(None.unwrap_or("bike"), "bike");
```÷
Vrust-analyzer cargo std https://github.com/rust-lang/rust/library/std path/Path#new().˚
```rust
std::path::Path
```

```rust
pub fn new<S>(s: &S) -> &Path
where
    S: AsRef<OsStr> + ?Sized,
```

---

Directly wraps a string slice as a `Path` slice.

This is a cost-free conversion.

# Examples

```
use std::path::Path;

Path::new("foo.txt");
```

You can create `Path`s from `String`s, or even other `Path`s:

```
use std::path::Path;

let string = String::from("foo.txt");
let from_string = Path::new(&string);
let from_path = Path::new(&from_string);
assert_eq!(from_string, from_path);
```î
<rust-analyzer cargo relative_path . RelativePath#path_str().T
```rust
relative_path::RelativePath
```

```rust
pub fn path_str(&self) -> &str
```N
*rust-analyzer cargo relative_path . (self) 
```rust
self: &RelativePath
```˝
Yrust-analyzer cargo std https://github.com/rust-lang/rust/library/std path/Path#to_str().ü
```rust
std::path::Path
```

```rust
pub fn to_str(&self) -> Option<&str>
```

---

Yields a [`&str`] slice if the `Path` is valid unicode.

This conversion may entail doing a check for UTF-8 validity.
Note that validation is performed because non-UTF-8 strings are
perfectly valid for some OS.

# Examples

```
use std::path::Path;

let path = Path::new("foo.txt");
assert_eq!(path.to_str(), Some("foo.txt"));
```Í
_rust-analyzer cargo core https://github.com/rust-lang/rust/library/core option/Option#unwrap().Ü
```rust
core::option::Option
```

```rust
pub const fn unwrap(self) -> T
```

---

Returns the contained [`Some`](https://doc.rust-lang.org/nightly/core/option/enum.Option.html) value, consuming the `self` value.

Because this function may panic, its use is generally discouraged.
Instead, prefer to use pattern matching and handle the [`None`](https://doc.rust-lang.org/nightly/core/option/enum.Option.html)
case explicitly, or call [`unwrap_or`], [`unwrap_or_else`], or
[`unwrap_or_default`].

# Panics

Panics if the self value equals [`None`](https://doc.rust-lang.org/nightly/core/option/enum.Option.html).

# Examples

```
let x = Some("air");
assert_eq!(x.unwrap(), "air");
```

```should_panic
let x: Option<&str> = None;
assert_eq!(x.unwrap(), "air"); // fails
```í
:rust-analyzer cargo relative_path . RelativePath#prefix().T
```rust
relative_path::RelativePath
```

```rust
pub fn prefix(&self) -> Prefix
```N
*rust-analyzer cargo relative_path . (self) 
```rust
self: &RelativePath
```ê
:rust-analyzer cargo relative_path . RelativePath#is_hhi().R
```rust
relative_path::RelativePath
```

```rust
pub fn is_hhi(&self) -> bool
```N
*rust-analyzer cargo relative_path . (self) 
```rust
self: &RelativePath
```¥
?rust-analyzer cargo relative_path . RelativePath#to_absolute().q
```rust
relative_path::RelativePath
```

```rust
pub fn to_absolute(&self, ctx: &RelativePathCtx) -> PathBuf
```N
*rust-analyzer cargo relative_path . (self) 
```rust
self: &RelativePath
```O
)rust-analyzer cargo relative_path . (ctx)"
```rust
ctx: &RelativePathCtx
```z
4rust-analyzer cargo relative_path . RelativePathCtx#B
```rust
relative_path
```

```rust
pub struct RelativePathCtx
```±
Brust-analyzer cargo relative_path . RelativePathCtx#prefix_path().k
```rust
relative_path::RelativePathCtx
```

```rust
pub fn prefix_path(&self, prefix: Prefix) -> &Path
```©
Wrust-analyzer cargo std https://github.com/rust-lang/rust/library/std path/Path#join().Õ
```rust
std::path::Path
```

```rust
pub fn join<P>(&self, path: P) -> PathBuf
where
    P: AsRef<Path>,
```

---

Creates an owned [`PathBuf`](https://doc.rust-lang.org/nightly/std/path/struct.PathBuf.html) with `path` adjoined to `self`.

If `path` is absolute, it replaces the current path.

See [`PathBuf::push`](`PathBuf::push`) for more details on what it means to adjoin a path.

# Examples

```
use std::path::{Path, PathBuf};

assert_eq!(Path::new("/etc").join("passwd"), PathBuf::from("/etc/passwd"));
assert_eq!(Path::new("/etc").join("/bin/sh"), PathBuf::from("/bin/sh"));
```‘
?rust-analyzer cargo relative_path . RelativePath#Display#fmt().ê
```rust
relative_path::RelativePath
```

```rust
fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result
```

---

Formats the value using the given formatter.

# Examples

```
use std::fmt;

struct Position {
    longitude: f32,
    latitude: f32,
}

impl fmt::Display for Position {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "({}, {})", self.longitude, self.latitude)
    }
}

assert_eq!("(1.987, 2.983)",
           format!("{}", Position { longitude: 1.987, latitude: 2.983, }));
```N
*rust-analyzer cargo relative_path . (self) 
```rust
self: &RelativePath
```I
'rust-analyzer cargo relative_path . (f)
```rust
f: &mut Formatter
```ß
Zrust-analyzer cargo std https://github.com/rust-lang/rust/library/std path/Path#display().»
```rust
std::path::Path
```

```rust
pub fn display(&self) -> Display<'_>
```

---

Returns an object that implements [`Display`] for safely printing paths
that may contain non-Unicode data. This may perform lossy conversion,
depending on the platform.  If you would like an implementation which
escapes the path please use [`Debug`] instead.

# Examples

```
use std::path::Path;

let path = Path::new("/tmp/foo.rs");

println!("{}", path.display());
```å
Rrust-analyzer cargo core https://github.com/rust-lang/rust/library/core fmt/Debug#µ
```rust
core::fmt
```

```rust
pub trait Debug
```

---

`?` formatting.

`Debug` should format the output in a programmer-facing, debugging context.

Generally speaking, you should just `derive` a `Debug` implementation.

When used with the alternate format specifier `#?`, the output is pretty-printed.

For more information on formatters, see [the module-level documentation](https://doc.rust-lang.org/nightly/std/fmt/index.html).

This trait can be used with `#[derive]` if all fields implement `Debug`. When
`derive`d for structs, it will use the name of the `struct`, then `{`, then a
comma-separated list of each field's name and `Debug` value, then `}`. For
`enum`s, it will use the name of the variant and, if applicable, `(`, then the
`Debug` values of the fields, then `)`.

# Stability

Derived `Debug` formats are not stable, and so may change with future Rust
versions. Additionally, `Debug` implementations of types provided by the
standard library (`std`, `core`, `alloc`, etc.) are not stable, and
may also change with future Rust versions.

# Examples

Deriving an implementation:

```
#[derive(Debug)]
struct Point {
    x: i32,
    y: i32,
}

let origin = Point { x: 0, y: 0 };

assert_eq!(format!("The origin is: {origin:?}"), "The origin is: Point { x: 0, y: 0 }");
```

Manually implementing:

```
use std::fmt;

struct Point {
    x: i32,
    y: i32,
}

impl fmt::Debug for Point {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("Point")
         .field("x", &self.x)
         .field("y", &self.y)
         .finish()
    }
}

let origin = Point { x: 0, y: 0 };

assert_eq!(format!("The origin is: {origin:?}"), "The origin is: Point { x: 0, y: 0 }");
```

There are a number of helper methods on the [`Formatter`](https://doc.rust-lang.org/nightly/core/fmt/struct.Formatter.html) struct to help you with manual
implementations, such as [`debug_struct`].

Types that do not wish to use the standard suite of debug representations
provided by the `Formatter` trait (`debug_struct`, `debug_tuple`,
`debug_list`, `debug_set`, `debug_map`) can do something totally custom by
manually writing an arbitrary representation to the `Formatter`.

```
# use std::fmt;
# struct Point {
#     x: i32,
#     y: i32,
# }
#
impl fmt::Debug for Point {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "Point [{} {}]", self.x, self.y)
    }
}
```

`Debug` implementations using either `derive` or the debug builder API
on [`Formatter`](https://doc.rust-lang.org/nightly/core/fmt/struct.Formatter.html) support pretty-printing using the alternate flag: `{:#?}`.

Pretty-printing with `#?`:

```
#[derive(Debug)]
struct Point {
    x: i32,
    y: i32,
}

let origin = Point { x: 0, y: 0 };

assert_eq!(format!("The origin is: {origin:#?}"),
"The origin is: Point {
    x: 0,
    y: 0,
}");
```‹
=rust-analyzer cargo relative_path . RelativePath#Debug#fmt().ö
```rust
relative_path::RelativePath
```

```rust
fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result
```

---

Formats the value using the given formatter.

# Examples

```
use std::fmt;

struct Position {
    longitude: f32,
    latitude: f32,
}

impl fmt::Debug for Position {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_tuple("")
         .field(&self.longitude)
         .field(&self.latitude)
         .finish()
    }
}

let position = Position { longitude: 1.987, latitude: 2.983 };
assert_eq!(format!("{position:?}"), "(1.987, 2.983)");

assert_eq!(format!("{position:#?}"), "(
    1.987,
    2.983,
)");
```N
*rust-analyzer cargo relative_path . (self) 
```rust
self: &RelativePath
```I
'rust-analyzer cargo relative_path . (f)
```rust
f: &mut Formatter
```∆
Prust-analyzer cargo core https://github.com/rust-lang/rust/library/core cmp/Ord#Ò
```rust
core::cmp
```

```rust
pub trait Ord
where
    Self: Eq + PartialOrd<Self>,
```

---

Trait for types that form a [total order](https://en.wikipedia.org/wiki/Total_order).

Implementations must be consistent with the [`PartialOrd`](https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html) implementation, and ensure
`max`, `min`, and `clamp` are consistent with `cmp`:

* `partial_cmp(a, b) == Some(cmp(a, b))`.
* `max(a, b) == max_by(a, b, cmp)` (ensured by the default implementation).
* `min(a, b) == min_by(a, b, cmp)` (ensured by the default implementation).
* For `a.clamp(min, max)`, see the [method docs](https://doc.rust-lang.org/nightly/core/cmp/trait.Ord.html#method.clamp)
  (ensured by the default implementation).

It's easy to accidentally make `cmp` and `partial_cmp` disagree by
deriving some of the traits and manually implementing others.

## Corollaries

From the above and the requirements of `PartialOrd`, it follows that `<` defines a strict total order.
This means that for all `a`, `b` and `c`:

* exactly one of `a < b`, `a == b` or `a > b` is true; and
* `<` is transitive: `a < b` and `b < c` implies `a < c`. The same must hold for both `==` and `>`.

## Derivable

This trait can be used with `#[derive]`.

When `derive`d on structs, it will produce a
[lexicographic](https://en.wikipedia.org/wiki/Lexicographic_order) ordering
based on the top-to-bottom declaration order of the struct's members.

When `derive`d on enums, variants are ordered by their discriminants.
By default, the discriminant is smallest for variants at the top, and
largest for variants at the bottom. Here's an example:

```
#[derive(PartialEq, Eq, PartialOrd, Ord)]
enum E {
    Top,
    Bottom,
}

assert!(E::Top < E::Bottom);
```

However, manually setting the discriminants can override this default
behavior:

```
#[derive(PartialEq, Eq, PartialOrd, Ord)]
enum E {
    Top = 2,
    Bottom = 1,
}

assert!(E::Bottom < E::Top);
```

## Lexicographical comparison

Lexicographical comparison is an operation with the following properties:

* Two sequences are compared element by element.
* The first mismatching element defines which sequence is lexicographically less or greater than the other.
* If one sequence is a prefix of another, the shorter sequence is lexicographically less than the other.
* If two sequence have equivalent elements and are of the same length, then the sequences are lexicographically equal.
* An empty sequence is lexicographically less than any non-empty sequence.
* Two empty sequences are lexicographically equal.

## How can I implement `Ord`?

`Ord` requires that the type also be [`PartialOrd`](https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html) and [`Eq`](https://doc.rust-lang.org/nightly/core/cmp/trait.Eq.html) (which requires [`PartialEq`](https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html)).

Then you must define an implementation for [`cmp`]. You may find it useful to use
[`cmp`] on your type's fields.

Here's an example where you want to sort people by height only, disregarding `id`
and `name`:

```
use std::cmp::Ordering;

#[derive(Eq)]
struct Person {
    id: u32,
    name: String,
    height: u32,
}

impl Ord for Person {
    fn cmp(&self, other: &Self) -> Ordering {
        self.height.cmp(&other.height)
    }
}

impl PartialOrd for Person {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        Some(self.cmp(other))
    }
}

impl PartialEq for Person {
    fn eq(&self, other: &Self) -> bool {
        self.height == other.height
    }
}
```ì
;rust-analyzer cargo relative_path . RelativePath#Ord#cmp().”
```rust
relative_path::RelativePath
```

```rust
fn cmp(&self, other: &Self) -> std::cmp::Ordering
```

---

This method returns an [`Ordering`](`Ordering`) between `self` and `other`.

By convention, `self.cmp(&other)` returns the ordering matching the expression
`self <operator> other` if true.

# Examples

```
use std::cmp::Ordering;

assert_eq!(5.cmp(&10), Ordering::Less);
assert_eq!(10.cmp(&5), Ordering::Greater);
assert_eq!(5.cmp(&5), Ordering::Equal);
```N
*rust-analyzer cargo relative_path . (self) 
```rust
self: &RelativePath
```P
+rust-analyzer cargo relative_path . (other)!
```rust
other: &RelativePath
```t
1rust-analyzer cargo relative_path . RelativePath#?
```rust
relative_path
```

```rust
pub struct RelativePath
```≠
Lrust-analyzer cargo core https://github.com/rust-lang/rust/library/core cmp/‹
```rust
core
```

```rust
mod cmp
```

---

Utilities for comparing and ordering values.

This module contains various tools for comparing and ordering values. In
summary:

* [`Eq`](https://doc.rust-lang.org/nightly/core/cmp/trait.Eq.html) and [`PartialEq`](https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html) are traits that allow you to define total and
  partial equality between values, respectively. Implementing them overloads
  the `==` and `!=` operators.
* [`Ord`](https://doc.rust-lang.org/nightly/core/cmp/trait.Ord.html) and [`PartialOrd`](https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html) are traits that allow you to define total and
  partial orderings between values, respectively. Implementing them overloads
  the `<`, `<=`, `>`, and `>=` operators.
* [`Ordering`](https://doc.rust-lang.org/nightly/core/cmp/enum.Ordering.html) is an enum returned by the main functions of [`Ord`](https://doc.rust-lang.org/nightly/core/cmp/trait.Ord.html) and
  [`PartialOrd`](https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html), and describes an ordering.
* [`Reverse`](https://doc.rust-lang.org/nightly/core/cmp/struct.Reverse.html) is a struct that allows you to easily reverse an ordering.
* [`max`] and [`min`] are functions that build off of [`Ord`](https://doc.rust-lang.org/nightly/core/cmp/trait.Ord.html) and allow you
  to find the maximum or minimum of two values.

For more details, see the respective documentation of each item in the list.Ω
Urust-analyzer cargo core https://github.com/rust-lang/rust/library/core cmp/Ordering#„
```rust
core::cmp
```

```rust
pub enum Ordering
```

---

An `Ordering` is the result of a comparison between two values.

# Examples

```
use std::cmp::Ordering;

let result = 1.cmp(&2);
assert_eq!(Ordering::Less, result);

let result = 1.cmp(&1);
assert_eq!(Ordering::Equal, result);

let result = 2.cmp(&1);
assert_eq!(Ordering::Greater, result);
```Œ
Vrust-analyzer cargo core https://github.com/rust-lang/rust/library/core cmp/Ord#cmp().Û
```rust
core::cmp::Ord
```

```rust
pub fn cmp(&self, other: &Self) -> Ordering
```

---

This method returns an [`Ordering`](https://doc.rust-lang.org/nightly/core/cmp/enum.Ordering.html) between `self` and `other`.

By convention, `self.cmp(&other)` returns the ordering matching the expression
`self <operator> other` if true.

# Examples

```
use std::cmp::Ordering;

assert_eq!(5.cmp(&10), Ordering::Less);
assert_eq!(10.cmp(&5), Ordering::Greater);
assert_eq!(5.cmp(&5), Ordering::Equal);
```‰
\rust-analyzer cargo core https://github.com/rust-lang/rust/library/core cmp/Ordering#then().É
```rust
core::cmp::Ordering
```

```rust
pub const fn then(self, other: Ordering) -> Ordering
```

---

Chains two orderings.

Returns `self` when it's not `Equal`. Otherwise returns `other`.

# Examples

```
use std::cmp::Ordering;

let result = Ordering::Equal.then(Ordering::Less);
assert_eq!(result, Ordering::Less);

let result = Ordering::Less.then(Ordering::Equal);
assert_eq!(result, Ordering::Less);

let result = Ordering::Less.then(Ordering::Greater);
assert_eq!(result, Ordering::Less);

let result = Ordering::Equal.then(Ordering::Equal);
assert_eq!(result, Ordering::Equal);

let x: (i64, i64, i64) = (1, 2, 7);
let y: (i64, i64, i64) = (1, 5, 3);
let result = x.0.cmp(&y.0).then(x.1.cmp(&y.1)).then(x.2.cmp(&y.2));

assert_eq!(result, Ordering::Less);
```±
arust-analyzer cargo std https://github.com/rust-lang/rust/library/std os_str/ffi/OsStr#Ord#cmp().À
```rust
std::ffi::os_str::OsStr
```

```rust
fn cmp(&self, other: &OsStr) -> cmp::Ordering
```

---

This method returns an [`Ordering`](`Ordering`) between `self` and `other`.

By convention, `self.cmp(&other)` returns the ordering matching the expression
`self <operator> other` if true.

# Examples

```
use std::cmp::Ordering;

assert_eq!(5.cmp(&10), Ordering::Less);
assert_eq!(10.cmp(&5), Ordering::Greater);
assert_eq!(5.cmp(&5), Ordering::Equal);
```≈$
Wrust-analyzer cargo core https://github.com/rust-lang/rust/library/core cmp/PartialOrd#È#
```rust
core::cmp
```

```rust
pub trait PartialOrd<Rhs = Self>
where
    Self: PartialEq<Rhs>,
    Rhs: ?Sized,
```

---

Trait for types that form a [partial order](https://en.wikipedia.org/wiki/Partial_order).

The `lt`, `le`, `gt`, and `ge` methods of this trait can be called using
the `<`, `<=`, `>`, and `>=` operators, respectively.

The methods of this trait must be consistent with each other and with those of [`PartialEq`](https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html).
The following conditions must hold:

1. `a == b` if and only if `partial_cmp(a, b) == Some(Equal)`.
1. `a < b` if and only if `partial_cmp(a, b) == Some(Less)`
1. `a > b` if and only if `partial_cmp(a, b) == Some(Greater)`
1. `a <= b` if and only if `a < b || a == b`
1. `a >= b` if and only if `a > b || a == b`
1. `a != b` if and only if `!(a == b)`.

Conditions 2‚Äì5 above are ensured by the default implementation.
Condition 6 is already ensured by [`PartialEq`](https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html).

If [`Ord`](https://doc.rust-lang.org/nightly/core/cmp/trait.Ord.html) is also implemented for `Self` and `Rhs`, it must also be consistent with
`partial_cmp` (see the documentation of that trait for the exact requirements). It's
easy to accidentally make them disagree by deriving some of the traits and manually
implementing others.

The comparison must satisfy, for all `a`, `b` and `c`:

* transitivity: `a < b` and `b < c` implies `a < c`. The same must hold for both `==` and `>`.
* duality: `a < b` if and only if `b > a`.

Note that these requirements mean that the trait itself must be implemented symmetrically and
transitively: if `T: PartialOrd<U>` and `U: PartialOrd<V>` then `U: PartialOrd<T>` and `T: PartialOrd<V>`.

## Corollaries

The following corollaries follow from the above requirements:

* irreflexivity of `<` and `>`: `!(a < a)`, `!(a > a)`
* transitivity of `>`: if `a > b` and `b > c` then `a > c`
* duality of `partial_cmp`: `partial_cmp(a, b) == partial_cmp(b, a).map(Ordering::reverse)`

## Derivable

This trait can be used with `#[derive]`.

When `derive`d on structs, it will produce a
[lexicographic](https://en.wikipedia.org/wiki/Lexicographic_order) ordering
based on the top-to-bottom declaration order of the struct's members.

When `derive`d on enums, variants are ordered by their discriminants.
By default, the discriminant is smallest for variants at the top, and
largest for variants at the bottom. Here's an example:

```
#[derive(PartialEq, PartialOrd)]
enum E {
    Top,
    Bottom,
}

assert!(E::Top < E::Bottom);
```

However, manually setting the discriminants can override this default
behavior:

```
#[derive(PartialEq, PartialOrd)]
enum E {
    Top = 2,
    Bottom = 1,
}

assert!(E::Bottom < E::Top);
```

## How can I implement `PartialOrd`?

`PartialOrd` only requires implementation of the [`partial_cmp`] method, with the others
generated from default implementations.

However it remains possible to implement the others separately for types which do not have a
total order. For example, for floating point numbers, `NaN < 0 == false` and `NaN >= 0 == false` (cf. IEEE 754-2008 section 5.11).

`PartialOrd` requires your type to be [`PartialEq`](https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html).

If your type is [`Ord`](https://doc.rust-lang.org/nightly/core/cmp/trait.Ord.html), you can implement [`partial_cmp`] by using [`cmp`]:

```
use std::cmp::Ordering;

#[derive(Eq)]
struct Person {
    id: u32,
    name: String,
    height: u32,
}

impl PartialOrd for Person {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        Some(self.cmp(other))
    }
}

impl Ord for Person {
    fn cmp(&self, other: &Self) -> Ordering {
        self.height.cmp(&other.height)
    }
}

impl PartialEq for Person {
    fn eq(&self, other: &Self) -> bool {
        self.height == other.height
    }
}
```

You may also find it useful to use [`partial_cmp`] on your type's fields. Here
is an example of `Person` types who have a floating-point `height` field that
is the only field to be used for sorting:

```
use std::cmp::Ordering;

struct Person {
    id: u32,
    name: String,
    height: f64,
}

impl PartialOrd for Person {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        self.height.partial_cmp(&other.height)
    }
}

impl PartialEq for Person {
    fn eq(&self, other: &Self) -> bool {
        self.height == other.height
    }
}
```

# Examples

```
let x: u32 = 0;
let y: u32 = 1;

assert_eq!(x < y, true);
assert_eq!(x.lt(&y), true);
```ß
Jrust-analyzer cargo relative_path . RelativePath#PartialOrd#partial_cmp().ÿ
```rust
relative_path::RelativePath
```

```rust
fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering>
```

---

This method returns an ordering between `self` and `other` values if one exists.

# Examples

```
use std::cmp::Ordering;

let result = 1.0.partial_cmp(&2.0);
assert_eq!(result, Some(Ordering::Less));

let result = 1.0.partial_cmp(&1.0);
assert_eq!(result, Some(Ordering::Equal));

let result = 2.0.partial_cmp(&1.0);
assert_eq!(result, Some(Ordering::Greater));
```

When comparison is impossible:

```
let result = f64::NAN.partial_cmp(&1.0);
assert_eq!(result, None);
```N
*rust-analyzer cargo relative_path . (self) 
```rust
self: &RelativePath
```P
+rust-analyzer cargo relative_path . (other)!
```rust
other: &RelativePath
```t
1rust-analyzer cargo relative_path . RelativePath#?
```rust
relative_path
```

```rust
pub struct RelativePath
```˜
Grust-analyzer cargo relative_path . RelativePath#Serialize#serialize().´
```rust
relative_path::RelativePath
```

```rust
fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
where
    S: serde::Serializer,
```

---

Serialize this value into the given Serde serializer.

See the [Implementing `Serialize`](https://serde.rs/impl-serialize.html) section of the manual for more
information about how to implement this method.

```edition2018
use serde::ser::{Serialize, SerializeStruct, Serializer};

struct Person {
    name: String,
    age: u8,
    phones: Vec<String>,
}

// This is what #[derive(Serialize)] would generate.
impl Serialize for Person {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("Person", 3)?;
        s.serialize_field("name", &self.name)?;
        s.serialize_field("age", &self.age)?;
        s.serialize_field("phones", &self.phones)?;
        s.end()
    }
}
```&
local 10
```rust
S: Serializer
```≠
3rust-analyzer cargo serde-1.0.152 . ser/Serializer#ı
```rust
serde_1.0.152::ser
```

```rust
pub trait Serializer
where
    Self: Sized,
```

---

A **data format** that can serialize any data structure supported by Serde.

The role of this trait is to define the serialization half of the [Serde
data model](https://serde.rs/data-model.html), which is a way to categorize every Rust data structure into one
of 29 possible types. Each method of the `Serializer` trait corresponds to
one of the types of the data model.

Implementations of `Serialize` map themselves into this data model by
invoking exactly one of the `Serializer` methods.

The types that make up the Serde data model are:

* **14 primitive types**
  * bool
  * i8, i16, i32, i64, i128
  * u8, u16, u32, u64, u128
  * f32, f64
  * char
* **string**
  * UTF-8 bytes with a length and no null terminator.
  * When serializing, all strings are handled equally. When deserializing,
    there are three flavors of strings: transient, owned, and borrowed.
* **byte array** - \[u8\]
  * Similar to strings, during deserialization byte arrays can be
    transient, owned, or borrowed.
* **option**
  * Either none or some value.
* **unit**
  * The type of `()` in Rust. It represents an anonymous value containing
    no data.
* **unit_struct**
  * For example `struct Unit` or `PhantomData<T>`. It represents a named
    value containing no data.
* **unit_variant**
  * For example the `E::A` and `E::B` in `enum E { A, B }`.
* **newtype_struct**
  * For example `struct Millimeters(u8)`.
* **newtype_variant**
  * For example the `E::N` in `enum E { N(u8) }`.
* **seq**
  * A variably sized heterogeneous sequence of values, for example
    `Vec<T>` or `HashSet<T>`. When serializing, the length may or may not
    be known before iterating through all the data. When deserializing,
    the length is determined by looking at the serialized data.
* **tuple**
  * A statically sized heterogeneous sequence of values for which the
    length will be known at deserialization time without looking at the
    serialized data, for example `(u8,)` or `(String, u64, Vec<T>)` or
    `[u64; 10]`.
* **tuple_struct**
  * A named tuple, for example `struct Rgb(u8, u8, u8)`.
* **tuple_variant**
  * For example the `E::T` in `enum E { T(u8, u8) }`.
* **map**
  * A heterogeneous key-value pairing, for example `BTreeMap<K, V>`.
* **struct**
  * A heterogeneous key-value pairing in which the keys are strings and
    will be known at deserialization time without looking at the
    serialized data, for example `struct S { r: u8, g: u8, b: u8 }`.
* **struct_variant**
  * For example the `E::S` in `enum E { S { r: u8, g: u8, b: u8 } }`.

Many Serde serializers produce text or binary data as output, for example
JSON or Postcard. This is not a requirement of the `Serializer` trait, and
there are serializers that do not produce text or binary output. One example
is the `serde_json::value::Serializer` (distinct from the main `serde_json`
serializer) that produces a `serde_json::Value` data structure in memory as
output.

# Example implementation

The [example data format](https://serde.rs/data-format.html) presented on the website contains example code for
a basic JSON `Serializer`.N
*rust-analyzer cargo relative_path . (self) 
```rust
self: &RelativePath
```N
0rust-analyzer cargo relative_path . (serializer)
```rust
serializer: S
```ò
7rust-analyzer cargo serde-1.0.152 . ser/Serializer#[Ok]‹
```rust
serde_1.0.152::ser
```

```rust
pub type Ok
```

---

The output type produced by this `Serializer` during successful
serialization. Most serializers that produce text or binary output
should set `Ok = ()` and serialize into an [`io::Write`](https://doc.rust-lang.org/std/io/trait.Write.html) or buffer
contained within the `Serializer` instance. Serializers that build
in-memory data structures may be simplified by using `Ok` to propagate
the data structure around.√
:rust-analyzer cargo serde-1.0.152 . ser/Serializer#[Error]Ñ
```rust
serde_1.0.152::ser
```

```rust
pub type Error: Error
```

---

The error type when some error occurs during serialization.+
local 11
```rust
let path_str: &str
```é
crust-analyzer cargo core https://github.com/rust-lang/rust/library/core option/Option#ok_or_else().¶
```rust
core::option::Option
```

```rust
pub const fn ok_or_else<E, F>(self, err: F) -> Result<T, E>
where
    F: FnOnce() -> E + Destruct,
```

---

Transforms the `Option<T>` into a [`Result<T, E>`](https://doc.rust-lang.org/nightly/core/result/enum.Result.html), mapping [`Some(v)`] to
[`Ok(v)`] and [`None`](https://doc.rust-lang.org/nightly/core/option/enum.Option.html) to [`Err(err())`].

# Examples

```
let x = Some("foo");
assert_eq!(x.ok_or_else(|| 0), Ok("foo"));

let x: Option<&str> = None;
assert_eq!(x.ok_or_else(|| 0), Err(0));
```À
(rust-analyzer cargo serde-1.0.152 . ser/û
```rust
serde_1.0.152
```

```rust
mod ser
```

---

Generic data structure serialization framework.

The two most important traits in this module are [`Serialize`](https://docs.rs/serde/1.0.152/serde_1.0.152/trait.Serialize.html) and
[`Serializer`](https://docs.rs/serde/1.0.152/serde_1.0.152/trait.Serializer.html).

* **A type that implements `Serialize` is a data structure** that can be
  serialized to any data format supported by Serde, and conversely
* **A type that implements `Serializer` is a data format** that can
  serialize any data structure supported by Serde.

# The Serialize trait

Serde provides [`Serialize`](https://docs.rs/serde/1.0.152/serde_1.0.152/trait.Serialize.html) implementations for many Rust primitive and
standard library types. The complete list is below. All of these can be
serialized using Serde out of the box.

Additionally, Serde provides a procedural macro called [`serde_derive`](https://crates.io/crates/serde_derive) to
automatically generate [`Serialize`](https://docs.rs/serde/1.0.152/serde_1.0.152/trait.Serialize.html) implementations for structs and enums
in your program. See the [derive section of the manual](https://serde.rs/derive.html) for how to use this.

In rare cases it may be necessary to implement [`Serialize`](https://docs.rs/serde/1.0.152/serde_1.0.152/trait.Serialize.html) manually for
some type in your program. See the [Implementing `Serialize`](https://serde.rs/impl-serialize.html) section of the
manual for more about this.

Third-party crates may provide [`Serialize`](https://docs.rs/serde/1.0.152/serde_1.0.152/trait.Serialize.html) implementations for types that
they expose. For example the [`linked-hash-map`](https://crates.io/crates/linked-hash-map) crate provides a
[`LinkedHashMap<K, V>`](https://docs.rs/linked-hash-map/*/linked_hash_map/struct.LinkedHashMap.html) type that is serializable by Serde because the crate
provides an implementation of [`Serialize`](https://docs.rs/serde/1.0.152/serde_1.0.152/trait.Serialize.html) for it.

# The Serializer trait

[`Serializer`](https://docs.rs/serde/1.0.152/serde_1.0.152/trait.Serializer.html) implementations are provided by third-party crates, for
example [`serde_json`](https://github.com/serde-rs/json), [`serde_yaml`](https://github.com/dtolnay/serde-yaml) and [`postcard`](https://github.com/jamesmunns/postcard).

A partial list of well-maintained formats is given on the [Serde
website](https://serde.rs/#data-formats).

# Implementations of Serialize provided by Serde

* **Primitive types**:
  * bool
  * i8, i16, i32, i64, i128, isize
  * u8, u16, u32, u64, u128, usize
  * f32, f64
  * char
  * str
  * &T and &mut T
* **Compound types**:
  * \[T\]
  * \[T; 0\] through \[T; 32\]
  * tuples up to size 16
* **Common standard library types**:
  * String
  * Option\<T\>
  * Result\<T, E\>
  * PhantomData\<T\>
* **Wrapper types**:
  * Box\<T\>
  * Cow\<'a, T\>
  * Cell\<T\>
  * RefCell\<T\>
  * Mutex\<T\>
  * RwLock\<T\>
  * Rc\<T\>‚ÄÉ*(if* features = ["rc"]("rc") *is enabled)*
  * Arc\<T\>‚ÄÉ*(if* features = ["rc"]("rc") *is enabled)*
* **Collection types**:
  * BTreeMap\<K, V\>
  * BTreeSet\<T\>
  * BinaryHeap\<T\>
  * HashMap\<K, V, H\>
  * HashSet\<T, H\>
  * LinkedList\<T\>
  * VecDeque\<T\>
  * Vec\<T\>
* **FFI types**:
  * CStr
  * CString
  * OsStr
  * OsString
* **Miscellaneous standard library types**:
  * Duration
  * SystemTime
  * Path
  * PathBuf
  * Range\<T\>
  * RangeInclusive\<T\>
  * Bound\<T\>
  * num::NonZero\*
  * `!` *(unstable)*
* **Net types**:
  * IpAddr
  * Ipv4Addr
  * Ipv6Addr
  * SocketAddr
  * SocketAddrV4
  * SocketAddrV6ÿ
.rust-analyzer cargo serde-1.0.152 . ser/Error#•
```rust
serde_1.0.152::ser
```

```rust
pub trait Error
where
    Self: Sized + StdError,
```

---

Trait used by `Serialize` implementations to generically construct
errors belonging to the `Serializer` against which they are
currently running.

# Example implementation

The [example data format](https://serde.rs/data-format.html) presented on the website shows an error
type appropriate for a basic JSON data format.†
7rust-analyzer cargo serde-1.0.152 . ser/Error#custom().‰
```rust
serde_1.0.152::ser::Error
```

```rust
pub fn custom<T>(msg: T) -> Self
where
    T: Display,
```

---

Used when a [`Serialize`](https://docs.rs/serde/1.0.152/serde_1.0.152/trait.Serialize.html) implementation encounters any error
while serializing a type.

The message should not be capitalized and should not end with a
period.

For example, a filesystem [`Path`](https://doc.rust-lang.org/std/path/struct.Path.html) may refuse to serialize
itself if it contains invalid UTF-8 data.

```edition2018
# struct Path;
#
# impl Path {
#     fn to_str(&self) -> Option<&str> {
#         unimplemented!()
#     }
# }
#
use serde::ser::{self, Serialize, Serializer};

impl Serialize for Path {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        match self.to_str() {
            Some(s) => serializer.serialize_str(s),
            None => Err(ser::Error::custom("path contains invalid UTF-8 characters")),
        }
    }
}
```Â
Crust-analyzer cargo serde-1.0.152 . ser/Serializer#serialize_str().ù
```rust
serde_1.0.152::ser::Serializer
```

```rust
pub fn serialize_str(self, v: &str) -> Result<Self::Ok, Self::Error>
```

---

Serialize a `&str`.

```edition2018
# use serde::Serializer;
#
# serde::__private_serialize!();
#
impl Serialize for str {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_str(self)
    }
}
```
local 12
```rust
'de
```∆
Krust-analyzer cargo relative_path . RelativePath#Deserialize#deserialize().ˆ
```rust
relative_path::RelativePath
```

```rust
fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
where
    D: serde::Deserializer<'de>,
```

---

Deserialize this value from the given Serde deserializer.

See the [Implementing `Deserialize`](https://serde.rs/impl-deserialize.html) section of the
manual for more information about how to implement this method.(
local 13
```rust
D: Deserializer
```R
2rust-analyzer cargo relative_path . (deserializer)
```rust
deserializer: D
```t
1rust-analyzer cargo relative_path . RelativePath#?
```rust
relative_path
```

```rust
pub struct RelativePath
```ÿ
;rust-analyzer cargo serde-1.0.152 . de/Deserializer#[Error]ò
```rust
serde_1.0.152::de
```

```rust
pub type Error: Error
```

---

The error type that can be returned if some error occurs during
deserialization.◊$
4rust-analyzer cargo serde-1.0.152 . de/Deserializer#û$
```rust
serde_1.0.152::de
```

```rust
pub trait Deserializer<'de>
where
    Self: Sized,
```

---

A **data format** that can deserialize any data structure supported by
Serde.

The role of this trait is to define the deserialization half of the [Serde
data model](https://serde.rs/data-model.html), which is a way to categorize every Rust data type into one of
29 possible types. Each method of the `Deserializer` trait corresponds to one
of the types of the data model.

Implementations of `Deserialize` map themselves into this data model by
passing to the `Deserializer` a `Visitor` implementation that can receive
these various types.

The types that make up the Serde data model are:

* **14 primitive types**
  * bool
  * i8, i16, i32, i64, i128
  * u8, u16, u32, u64, u128
  * f32, f64
  * char
* **string**
  * UTF-8 bytes with a length and no null terminator.
  * When serializing, all strings are handled equally. When deserializing,
    there are three flavors of strings: transient, owned, and borrowed.
* **byte array** - \[u8\]
  * Similar to strings, during deserialization byte arrays can be
    transient, owned, or borrowed.
* **option**
  * Either none or some value.
* **unit**
  * The type of `()` in Rust. It represents an anonymous value containing
    no data.
* **unit_struct**
  * For example `struct Unit` or `PhantomData<T>`. It represents a named
    value containing no data.
* **unit_variant**
  * For example the `E::A` and `E::B` in `enum E { A, B }`.
* **newtype_struct**
  * For example `struct Millimeters(u8)`.
* **newtype_variant**
  * For example the `E::N` in `enum E { N(u8) }`.
* **seq**
  * A variably sized heterogeneous sequence of values, for example `Vec<T>`
    or `HashSet<T>`. When serializing, the length may or may not be known
    before iterating through all the data. When deserializing, the length
    is determined by looking at the serialized data.
* **tuple**
  * A statically sized heterogeneous sequence of values for which the
    length will be known at deserialization time without looking at the
    serialized data, for example `(u8,)` or `(String, u64, Vec<T>)` or
    `[u64; 10]`.
* **tuple_struct**
  * A named tuple, for example `struct Rgb(u8, u8, u8)`.
* **tuple_variant**
  * For example the `E::T` in `enum E { T(u8, u8) }`.
* **map**
  * A heterogeneous key-value pairing, for example `BTreeMap<K, V>`.
* **struct**
  * A heterogeneous key-value pairing in which the keys are strings and
    will be known at deserialization time without looking at the serialized
    data, for example `struct S { r: u8, g: u8, b: u8 }`.
* **struct_variant**
  * For example the `E::S` in `enum E { S { r: u8, g: u8, b: u8 } }`.

The `Deserializer` trait supports two entry point styles which enables
different kinds of deserialization.

1. The `deserialize_any` method. Self-describing data formats like JSON are
   able to look at the serialized data and tell what it represents. For
   example the JSON deserializer may see an opening curly brace (`{`) and
   know that it is seeing a map. If the data format supports
   `Deserializer::deserialize_any`, it will drive the Visitor using whatever
   type it sees in the input. JSON uses this approach when deserializing
   `serde_json::Value` which is an enum that can represent any JSON
   document. Without knowing what is in a JSON document, we can deserialize
   it to `serde_json::Value` by going through
   `Deserializer::deserialize_any`.

1. The various `deserialize_*` methods. Non-self-describing formats like
   Postcard need to be told what is in the input in order to deserialize it.
   The `deserialize_*` methods are hints to the deserializer for how to
   interpret the next piece of input. Non-self-describing formats are not
   able to deserialize something like `serde_json::Value` which relies on
   `Deserializer::deserialize_any`.

When implementing `Deserialize`, you should avoid relying on
`Deserializer::deserialize_any` unless you need to be told by the
Deserializer what type is in the input. Know that relying on
`Deserializer::deserialize_any` means your data type will be able to
deserialize from self-describing formats only, ruling out Postcard and many
others.

# Lifetime

The `'de` lifetime of this trait is the lifetime of data that may be
borrowed from the input when deserializing. See the page [Understanding
deserializer lifetimes](https://serde.rs/lifetimes.html) for a more detailed explanation of these lifetimes.

# Example implementation

The [example data format](https://serde.rs/data-format.html) presented on the website contains example code for
a basic JSON `Deserializer`.f
,rust-analyzer cargo relative_path . Visitor#6
```rust
relative_path
```

```rust
struct Visitor
```
local 14
```rust
'de
```—
'rust-analyzer cargo serde-1.0.152 . de/•
```rust
serde_1.0.152
```

```rust
mod de
```

---

Generic data structure deserialization framework.

The two most important traits in this module are [`Deserialize`](https://docs.rs/serde/1.0.152/serde_1.0.152/trait.Deserialize.html) and
[`Deserializer`](https://docs.rs/serde/1.0.152/serde_1.0.152/trait.Deserializer.html).

* **A type that implements `Deserialize` is a data structure** that can be
  deserialized from any data format supported by Serde, and conversely
* **A type that implements `Deserializer` is a data format** that can
  deserialize any data structure supported by Serde.

# The Deserialize trait

Serde provides [`Deserialize`](https://docs.rs/serde/1.0.152/serde_1.0.152/trait.Deserialize.html) implementations for many Rust primitive and
standard library types. The complete list is below. All of these can be
deserialized using Serde out of the box.

Additionally, Serde provides a procedural macro called [`serde_derive`](https://crates.io/crates/serde_derive) to
automatically generate [`Deserialize`](https://docs.rs/serde/1.0.152/serde_1.0.152/trait.Deserialize.html) implementations for structs and enums
in your program. See the [derive section of the manual](https://serde.rs/derive.html) for how to use this.

In rare cases it may be necessary to implement [`Deserialize`](https://docs.rs/serde/1.0.152/serde_1.0.152/trait.Deserialize.html) manually for
some type in your program. See the [Implementing `Deserialize`](https://serde.rs/impl-deserialize.html) section of
the manual for more about this.

Third-party crates may provide [`Deserialize`](https://docs.rs/serde/1.0.152/serde_1.0.152/trait.Deserialize.html) implementations for types
that they expose. For example the [`linked-hash-map`](https://crates.io/crates/linked-hash-map) crate provides a
[`LinkedHashMap<K, V>`](https://docs.rs/linked-hash-map/*/linked_hash_map/struct.LinkedHashMap.html) type that is deserializable by Serde because the
crate provides an implementation of [`Deserialize`](https://docs.rs/serde/1.0.152/serde_1.0.152/trait.Deserialize.html) for it.

# The Deserializer trait

[`Deserializer`](https://docs.rs/serde/1.0.152/serde_1.0.152/trait.Deserializer.html) implementations are provided by third-party crates, for
example [`serde_json`](https://github.com/serde-rs/json), [`serde_yaml`](https://github.com/dtolnay/serde-yaml) and [`postcard`](https://github.com/jamesmunns/postcard).

A partial list of well-maintained formats is given on the [Serde
website](https://serde.rs/#data-formats).

# Implementations of Deserialize provided by Serde

This is a slightly different set of types than what is supported for
serialization. Some types can be serialized by Serde but not deserialized.
One example is `OsStr`.

* **Primitive types**:
  * bool
  * i8, i16, i32, i64, i128, isize
  * u8, u16, u32, u64, u128, usize
  * f32, f64
  * char
* **Compound types**:
  * \[T; 0\] through \[T; 32\]
  * tuples up to size 16
* **Common standard library types**:
  * String
  * Option\<T\>
  * Result\<T, E\>
  * PhantomData\<T\>
* **Wrapper types**:
  * Box\<T\>
  * Box\<\[T\]\>
  * Box\<str\>
  * Cow\<'a, T\>
  * Cell\<T\>
  * RefCell\<T\>
  * Mutex\<T\>
  * RwLock\<T\>
  * Rc\<T\>‚ÄÉ*(if* features = ["rc"]("rc") *is enabled)*
  * Arc\<T\>‚ÄÉ*(if* features = ["rc"]("rc") *is enabled)*
* **Collection types**:
  * BTreeMap\<K, V\>
  * BTreeSet\<T\>
  * BinaryHeap\<T\>
  * HashMap\<K, V, H\>
  * HashSet\<T, H\>
  * LinkedList\<T\>
  * VecDeque\<T\>
  * Vec\<T\>
* **Zero-copy types**:
  * &str
  * &\[u8\]
* **FFI types**:
  * CString
  * Box\<CStr\>
  * OsString
* **Miscellaneous standard library types**:
  * Duration
  * SystemTime
  * Path
  * PathBuf
  * Range\<T\>
  * RangeInclusive\<T\>
  * Bound\<T\>
  * num::NonZero\*
  * `!` *(unstable)*
* **Net types**:
  * IpAddr
  * Ipv4Addr
  * Ipv6Addr
  * SocketAddr
  * SocketAddrV4
  * SocketAddrV6ª	
/rust-analyzer cargo serde-1.0.152 . de/Visitor#á	
```rust
serde_1.0.152::de
```

```rust
pub trait Visitor<'de>
where
    Self: Sized,
```

---

This trait represents a visitor that walks through a deserializer.

# Lifetime

The `'de` lifetime of this trait is the requirement for lifetime of data
that may be borrowed by `Self::Value`. See the page [Understanding
deserializer lifetimes](https://serde.rs/lifetimes.html) for a more detailed explanation of these lifetimes.

# Example

```edition2018
# use std::fmt;
#
# use serde::de::{self, Unexpected, Visitor};
#
/// A visitor that deserializes a long string - a string containing at least
/// some minimum number of bytes.
struct LongString {
    min: usize,
}

impl<'de> Visitor<'de> for LongString {
    type Value = String;

    fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        write!(formatter, "a string containing at least {} bytes", self.min)
    }

    fn visit_str<E>(self, s: &str) -> Result<Self::Value, E>
    where
        E: de::Error,
    {
        if s.len() >= self.min {
            Ok(s.to_owned())
        } else {
            Err(de::Error::invalid_value(Unexpected::Str(s), &self))
        }
    }
}
```µ
;rust-analyzer cargo relative_path . Visitor#Visitor#[Value]v
```rust
relative_path
```

```rust
pub(super) type Value = RelativePath
```

---

The value produced by this visitor.ß
@rust-analyzer cargo relative_path . Visitor#Visitor#expecting().‚
```rust
relative_path::Visitor
```

```rust
fn expecting(&self, formatter: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result
```

---

Format a message stating what data this Visitor expects to receive.

This is used in error messages. The message should complete the sentence
"This Visitor expects to receive ...", for example the message could be
"an integer between 0 and 64". The message should not be capitalized and
should not end with a period.

```edition2018
# use std::fmt;
#
# struct S {
#     max: usize,
# }
#
# impl<'de> serde::de::Visitor<'de> for S {
#     type Value = ();
#
fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
    write!(formatter, "an integer between 0 and {}", self.max)
}
# }
```I
*rust-analyzer cargo relative_path . (self)
```rust
self: &Visitor
```Y
/rust-analyzer cargo relative_path . (formatter)&
```rust
formatter: &mut Formatter
```ê
@rust-analyzer cargo relative_path . Visitor#Visitor#visit_str().À
```rust
relative_path::Visitor
```

```rust
fn visit_str<E>(self, value: &str) -> Result<RelativePath, E>
where
    E: serde::de::Error,
```

---

The input contains a string. The lifetime of the string is ephemeral and
it may be destroyed after this method returns.

This method allows the `Deserializer` to avoid a copy by retaining
ownership of any buffered data. `Deserialize` implementations that do
not benefit from taking ownership of `String` data should indicate that
to the deserializer by using `Deserializer::deserialize_str` rather than
`Deserializer::deserialize_string`.

It is never correct to implement `visit_string` without implementing
`visit_str`. Implement neither, both, or just `visit_str`.!
local 15
```rust
E: Error
```H
*rust-analyzer cargo relative_path . (self)
```rust
self: Visitor
```G
+rust-analyzer cargo relative_path . (value)
```rust
value: &str
```‰
-rust-analyzer cargo serde-1.0.152 . de/Error#≤
```rust
serde_1.0.152::de
```

```rust
pub trait Error
where
    Self: Sized + StdError,
```

---

The `Error` trait allows `Deserialize` implementations to create descriptive
error messages belonging to the `Deserializer` against which they are
currently running.

Every `Deserializer` declares an `Error` type that encompasses both
general-purpose deserialization errors as well as errors specific to the
particular deserialization format. For example the `Error` type of
`serde_json` can represent errors like an invalid JSON escape sequence or an
unterminated string literal, in addition to the error cases that are part of
this trait.

Most deserializers should only need to provide the `Error::custom` method
and inherit the default behavior for the other methods.

# Example implementation

The [example data format](https://serde.rs/data-format.html) presented on the website shows an error
type appropriate for a basic JSON data format.4
local 16(
```rust
let mut split: SplitN<char>
```›

Urust-analyzer cargo core https://github.com/rust-lang/rust/library/core str/splitn().É

```rust
core::str
```

```rust
pub fn splitn<'a, P>(&'a self, n: usize, pat: P) -> SplitN<'a, P>
where
    P: Pattern<'a>,
```

---

An iterator over substrings of the given string slice, separated by a
pattern, restricted to returning at most `n` items.

If `n` substrings are returned, the last substring (the `n`th substring)
will contain the remainder of the string.

The [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a
function or closure that determines if a character matches.

# Iterator behavior

The returned iterator will not be double ended, because it is
not efficient to support.

If the pattern allows a reverse search, the [`rsplitn`] method can be
used.

# Examples

Simple patterns:

```
let v: Vec<&str> = "Mary had a little lambda".splitn(3, ' ').collect();
assert_eq!(v, ["Mary", "had", "a little lambda"]);

let v: Vec<&str> = "lionXXtigerXleopard".splitn(3, "X").collect();
assert_eq!(v, ["lion", "", "tigerXleopard"]);

let v: Vec<&str> = "abcXdef".splitn(1, 'X').collect();
assert_eq!(v, ["abcXdef"]);

let v: Vec<&str> = "".splitn(1, 'X').collect();
assert_eq!(v, [""]);
```

A more complex pattern, using a closure:

```
let v: Vec<&str> = "abc1defXghi".splitn(2, |c| c == '1' || c == 'X').collect();
assert_eq!(v, ["abc", "defXghi"]);
```5
local 17)
```rust
let prefix_str: Option<&str>
``` 
hrust-analyzer cargo core https://github.com/rust-lang/rust/library/core iter/str/SplitN#Iterator#next().›
```rust
core::str::iter::SplitN
```

```rust
fn next(&mut self) -> Option<&'a str>
```

---

Advances the iterator and returns the next value.

Returns [`None`](https://doc.rust-lang.org/nightly/core/option/enum.Option.html) when iteration is finished. Individual iterator
implementations may choose to resume iteration, and so calling `next()`
again may or may not eventually start returning [`Some(Item)`] again at some
point.

# Examples

Basic usage:

```
let a = [1, 2, 3];

let mut iter = a.iter();

// A call to next() returns the next value...
assert_eq!(Some(&1), iter.next());
assert_eq!(Some(&2), iter.next());
assert_eq!(Some(&3), iter.next());

// ... and then None once it's over.
assert_eq!(None, iter.next());

// More calls may or may not return `None`. Here, they always will.
assert_eq!(None, iter.next());
assert_eq!(None, iter.next());
```3
local 18'
```rust
let path_str: Option<&str>
```ƒ
^rust-analyzer cargo core https://github.com/rust-lang/rust/library/core builtin/macros/assert!·
```rust
core::macros::builtin
```

```rust
macro_rules! assert
```

---

Asserts that a boolean expression is `true` at runtime.

This will invoke the [`panic`](https://doc.rust-lang.org/nightly/core/macros/macro.panic.html) macro if the provided expression cannot be
evaluated to `true` at runtime.

# Uses

Assertions are always checked in both debug and release builds, and cannot
be disabled. See [`debug_assert`](https://doc.rust-lang.org/nightly/core/macros/macro.debug_assert.html) for assertions that are not enabled in
release builds by default.

Unsafe code may rely on `assert!` to enforce run-time invariants that, if
violated could lead to unsafety.

Other use-cases of `assert!` include testing and enforcing run-time
invariants in safe code (whose violation cannot result in unsafety).

# Custom Messages

This macro has a second form, where a custom panic message can
be provided with or without arguments for formatting. See [`std::fmt`](https://doc.rust-lang.org/nightly/core/macros/std/fmt/index.html)
for syntax for this form. Expressions used as format arguments will only
be evaluated if the assertion fails.

# Examples

```
// the panic message for these assertions is the stringified value of the
// expression given.
assert!(true);

fn some_computation() -> bool { true } // a very simple function

assert!(some_computation());

// assert with a custom message
let x = true;
assert!(x, "x wasn't true!");

let a = 3; let b = 27;
assert!(a + b == 30, "a = {}, b = {}", a, b);
```Ω
`rust-analyzer cargo core https://github.com/rust-lang/rust/library/core option/Option#is_none().ÿ
```rust
core::option::Option
```

```rust
pub const fn is_none(&self) -> bool
```

---

Returns `true` if the option is a [`None`](https://doc.rust-lang.org/nightly/core/option/enum.Option.html) value.

# Examples

```
let x: Option<u32> = Some(2);
assert_eq!(x.is_none(), false);

let x: Option<u32> = None;
assert_eq!(x.is_none(), true);
```+
local 19
```rust
let prefix: Prefix
```
=rust-analyzer cargo serde-1.0.152 . de/Error#invalid_value().Æ
```rust
serde_1.0.152::de::Error
```

```rust
pub fn invalid_value(unexp: Unexpected, exp: &Expected) -> Self
```

---

Raised when a `Deserialize` receives a value of the right type but that
is wrong for some other reason.

The `unexp` argument provides information about what value was received.
This is the value that was present in the input file or other source
data of the Deserializer.

The `exp` argument provides information about what value was being
expected. This is the type that is written in the program.

For example if we try to deserialize a String out of some binary data
that is not valid UTF-8, the unexpected value is the bytes and the
expected value is a string.∫
2rust-analyzer cargo serde-1.0.152 . de/Unexpected#É
```rust
serde_1.0.152::de
```

```rust
pub enum Unexpected<'a>
```

---

`Unexpected` represents an unexpected invocation of any one of the `Visitor`
trait methods.

This is used as an argument to the `invalid_type`, `invalid_value`, and
`invalid_length` methods of the `Error` trait to build error messages.

```edition2018
# use std::fmt;
#
# use serde::de::{self, Unexpected, Visitor};
#
# struct Example;
#
# impl<'de> Visitor<'de> for Example {
#     type Value = ();
#
#     fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
#         write!(formatter, "definitely not a boolean")
#     }
#
fn visit_bool<E>(self, v: bool) -> Result<Self::Value, E>
where
    E: de::Error,
{
    Err(de::Error::invalid_type(Unexpected::Bool(v), &self))
}
# }
```÷
-rust-analyzer cargo serde-1.0.152 . de/Other#§
```rust
serde_1.0.152::de::Unexpected
```

```rust
Other(&'a str)
```

---

A message stating what uncategorized thing the input contained that was
not expected.

The message should be a noun or noun phrase, not capitalized and without
a period. An example message is "unoriginal superhero".2
local 20&
```rust
let path: Option<PathBuf>
```'
local 21
```rust
path_str: &str
```”
Wrust-analyzer cargo core https://github.com/rust-lang/rust/library/core str/is_empty().˜
```rust
core::str
```

```rust
pub const fn is_empty(&self) -> bool
```

---

Returns `true` if `self` has a length of zero bytes.

# Examples

Basic usage:

```
let s = "";
assert!(s.is_empty());

let s = "not empty";
assert!(!s.is_empty());
```'
local 22
```rust
path_str: &str
```⁄
_rust-analyzer cargo std https://github.com/rust-lang/rust/library/std path/PathBuf#From#from().ˆ
```rust
std::path::PathBuf
```

```rust
fn from(s: &T) -> PathBuf
```

---

Converts a borrowed [`OsStr`](https://doc.rust-lang.org/nightly/std/ffi/os_str/struct.OsStr.html) to a [`PathBuf`](https://doc.rust-lang.org/nightly/std/path/struct.PathBuf.html).

Allocates a [`PathBuf`](https://doc.rust-lang.org/nightly/std/path/struct.PathBuf.html) and copies the data into it.õ
Frust-analyzer cargo serde-1.0.152 . de/Deserializer#deserialize_str().–
```rust
serde_1.0.152::de::Deserializer
```

```rust
pub fn deserialize_str<V>(self, visitor: V) -> Result<V::Value, Self::Error>
where
    V: Visitor<'de>,
```

---

Hint that the `Deserialize` type is expecting a string value and does
not benefit from taking ownership of buffered data owned by the
`Deserializer`.

If the `Visitor` would benefit from taking ownership of `String` data,
indicate this to the `Deserializer` by using `deserialize_string`
instead.¯
Jrust-analyzer cargo relative_path . RelativePath#ToOcamlRep#to_ocamlrep().©
```rust
relative_path::RelativePath
```

```rust
fn to_ocamlrep<'a, A>(&'a self, alloc: &'a A) -> ocamlrep::Value<'a>
where
    A: ocamlrep::Allocator,
```

---

Allocate an OCaml representation of `self` using the given Allocator.

Implementors of this method must not mutate or drop any values after
passing them to `Allocator::add` (or invoking `to_ocamlrep` on them),
else `Allocator::memoized` may return incorrect results (this can
generally only be done using internal-mutability types like `RefCell`,
`Mutex`, or atomics, or by using `unsafe`).
local 23
```rust
'a
```%
local 24
```rust
A: Allocator
```”
)rust-analyzer cargo ocamlrep . Allocator#•
```rust
ocamlrep
```

```rust
pub trait Allocator
where
    Self: Sized,
```

---

An interface for allocating OCaml values in some allocator-defined memory region.N
*rust-analyzer cargo relative_path . (self) 
```rust
self: &RelativePath
```E
+rust-analyzer cargo relative_path . (alloc)
```rust
alloc: &A
```„
+rust-analyzer cargo ocamlrep . value/Value#≥
```rust
ocamlrep::value
```

```rust
pub struct Value<'a>
```

---

A value, as represented by OCaml. Valid, immutable, and immovable for
lifetime `'a`.

Either a tagged integer value or a pointer to a [`Block`](https://docs.rs/ocamlrep/*/ocamlrep/value/struct.Block.html)
containing fields or binary data.4
local 25(
```rust
let mut block: BlockBuilder
```´
;rust-analyzer cargo ocamlrep . Allocator#block_with_size().l
```rust
ocamlrep::Allocator
```

```rust
pub fn block_with_size(&self, size: usize) -> BlockBuilder<'_>
```Ì
5rust-analyzer cargo ocamlrep . Allocator#set_field().≥
```rust
ocamlrep::Allocator
```

```rust
pub fn set_field<'a>(&self, block: &mut BlockBuilder<'a>, index: usize, value: Value<'a>)
```

---

Write the given value to the `index`th field of `block`.

# Panics

Panics if `index` is out of bounds for `block` (i.e., greater than or
equal to the block's size).§
/rust-analyzer cargo ocamlrep . Allocator#add().
```rust
ocamlrep::Allocator
```

```rust
pub fn add<'a, T>(&'a self, value: &'a T) -> Value<'a>
where
    T: ToOcamlRep + ?Sized,
```

---

Convert the given data structure to an OCaml value. Structural sharing
(via references or `Rc`) will not be preserved unless `add` is invoked
within an outer invocation of `add_root`.

To preserve structural sharing without using `add_root` (and the
overhead of maintaining a cache that comes with it), consider using
`ocamlrep::rc::RcOc` instead of `Rc`.ï
:rust-analyzer cargo ocamlrep . block/BlockBuilder#build().W
```rust
ocamlrep::block::BlockBuilder
```

```rust
pub fn build(self) -> Value<'a>
```©
Nrust-analyzer cargo relative_path . RelativePath#FromOcamlRep#from_ocamlrep().÷
```rust
relative_path::RelativePath
```

```rust
fn from_ocamlrep(value: ocamlrep::Value<'_>) -> Result<Self, ocamlrep::FromError>
```

---

Convert the given ocamlrep Value to a value of type `Self`, if possible.H
+rust-analyzer cargo relative_path . (value)
```rust
value: Value
```t
1rust-analyzer cargo relative_path . RelativePath#?
```rust
relative_path
```

```rust
pub struct RelativePath
```Ñ
/rust-analyzer cargo ocamlrep . error/FromError#–
```rust
ocamlrep::error
```

```rust
pub enum FromError
```

---

Returned by
[`OcamlRep::from_ocamlrep`](https://docs.rs/ocamlrep/*/ocamlrep/error/trait.OcamlRep.html#tymethod.from_ocamlrep) when
the given [`Value`](https://docs.rs/ocamlrep/*/ocamlrep/error/struct.Value.html) cannot be converted to a Rust value
of the expected type.)
local 26
```rust
let block: Block
```∏
$rust-analyzer cargo ocamlrep . from/è
```rust
ocamlrep
```

```rust
mod from
```

---

Helpers for implementing `FromOcamlRep::from_ocamlrep` or
`FromOcamlRepIn::from_ocamlrep_in`.∂
3rust-analyzer cargo ocamlrep . from/expect_tuple().
```rust
ocamlrep::from
```

```rust
pub fn expect_tuple<'a>(value: Value<'a>, size: usize) -> Result<Block<'a>, FromError>
```+
local 27
```rust
let prefix: Prefix
```º
,rust-analyzer cargo ocamlrep . from/field().ã
```rust
ocamlrep::from
```

```rust
pub fn field<T>(block: Block<'_>, field: usize) -> Result<T, FromError>
where
    T: FromOcamlRep,
```*
local 28
```rust
let path: PathBuf
```í
)rust-analyzer cargo relative_path . [Map]e
```rust
relative_path
```

```rust
pub type Map<T> = std::collections::BTreeMap<RelativePath, T>
```
local 29
```rust
T
```Ÿç
Rrust-analyzer cargo std https://github.com/rust-lang/rust/library/std collections/Åç
```rust
std
```

```rust
mod collections
```

---

Collection types.

Rust's standard collection library provides efficient implementations of the
most common general purpose programming data structures. By using the
standard implementations, it should be possible for two libraries to
communicate without significant data conversion.

To get this out of the way: you should probably just use [`Vec`](https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html) or [`HashMap`](https://doc.rust-lang.org/nightly/std/collections/hash/map/struct.HashMap.html).
These two collections cover most use cases for generic data storage and
processing. They are exceptionally good at doing what they do. All the other
collections in the standard library have specific use cases where they are
the optimal choice, but these cases are borderline *niche* in comparison.
Even when `Vec` and `HashMap` are technically suboptimal, they're probably a
good enough choice to get started.

Rust's collections can be grouped into four major categories:

* Sequences: [`Vec`](https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html), [`VecDeque`](https://doc.rust-lang.org/nightly/alloc/collections/vec_deque/struct.VecDeque.html), [`LinkedList`](https://doc.rust-lang.org/nightly/alloc/collections/linked_list/struct.LinkedList.html)
* Maps: [`HashMap`](https://doc.rust-lang.org/nightly/std/collections/hash/map/struct.HashMap.html), [`BTreeMap`](https://doc.rust-lang.org/nightly/alloc/collections/btree/map/struct.BTreeMap.html)
* Sets: [`HashSet`](https://doc.rust-lang.org/nightly/std/collections/hash/set/struct.HashSet.html), [`BTreeSet`](https://doc.rust-lang.org/nightly/alloc/collections/btree/set/struct.BTreeSet.html)
* Misc: [`BinaryHeap`](https://doc.rust-lang.org/nightly/alloc/collections/binary_heap/struct.BinaryHeap.html)

# When Should You Use Which Collection?

These are fairly high-level and quick break-downs of when each collection
should be considered. Detailed discussions of strengths and weaknesses of
individual collections can be found on their own documentation pages.

### Use a `Vec` when:

* You want to collect items up to be processed or sent elsewhere later, and
  don't care about any properties of the actual values being stored.
* You want a sequence of elements in a particular order, and will only be
  appending to (or near) the end.
* You want a stack.
* You want a resizable array.
* You want a heap-allocated array.

### Use a `VecDeque` when:

* You want a [`Vec`](https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html) that supports efficient insertion at both ends of the
  sequence.
* You want a queue.
* You want a double-ended queue (deque).

### Use a `LinkedList` when:

* You want a [`Vec`](https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html) or [`VecDeque`](https://doc.rust-lang.org/nightly/alloc/collections/vec_deque/struct.VecDeque.html) of unknown size, and can't tolerate
  amortization.
* You want to efficiently split and append lists.
* You are *absolutely* certain you *really*, *truly*, want a doubly linked
  list.

### Use a `HashMap` when:

* You want to associate arbitrary keys with an arbitrary value.
* You want a cache.
* You want a map, with no extra functionality.

### Use a `BTreeMap` when:

* You want a map sorted by its keys.
* You want to be able to get a range of entries on-demand.
* You're interested in what the smallest or largest key-value pair is.
* You want to find the largest or smallest key that is smaller or larger
  than something.

### Use the `Set` variant of any of these `Map`s when:

* You just want to remember which keys you've seen.
* There is no meaningful value to associate with your keys.
* You just want a set.

### Use a `BinaryHeap` when:

* You want to store a bunch of elements, but only ever want to process the
  "biggest" or "most important" one at any given time.
* You want a priority queue.

# Performance

Choosing the right collection for the job requires an understanding of what
each collection is good at. Here we briefly summarize the performance of
different collections for certain important operations. For further details,
see each type's documentation, and note that the names of actual methods may
differ from the tables below on certain collections.

Throughout the documentation, we will follow a few conventions. For all
operations, the collection's size is denoted by n. If another collection is
involved in the operation, it contains m elements. Operations which have an
*amortized* cost are suffixed with a `*`. Operations with an *expected*
cost are suffixed with a `~`.

All amortized costs are for the potential need to resize when capacity is
exhausted. If a resize occurs it will take *O*(*n*) time. Our collections never
automatically shrink, so removal operations aren't amortized. Over a
sufficiently large series of operations, the average cost per operation will
deterministically equal the given cost.

Only [`HashMap`](https://doc.rust-lang.org/nightly/std/collections/hash/map/struct.HashMap.html) has expected costs, due to the probabilistic nature of hashing.
It is theoretically possible, though very unlikely, for [`HashMap`](https://doc.rust-lang.org/nightly/std/collections/hash/map/struct.HashMap.html) to
experience worse performance.

## Sequences

||get(i)|insert(i)|remove(i)|append|split_off(i)|
|--|------|---------|---------|------|------------|
|[`Vec`](https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html)|*O*(1)|*O*(*n*-*i*)\*|*O*(*n*-*i*)|*O*(*m*)\*|*O*(*n*-*i*)|
|[`VecDeque`](https://doc.rust-lang.org/nightly/alloc/collections/vec_deque/struct.VecDeque.html)|*O*(1)|*O*(min(*i*, *n*-*i*))\*|*O*(min(*i*, *n*-*i*))|*O*(*m*)\*|*O*(min(*i*, *n*-*i*))|
|[`LinkedList`](https://doc.rust-lang.org/nightly/alloc/collections/linked_list/struct.LinkedList.html)|*O*(min(*i*, *n*-*i*))|*O*(min(*i*, *n*-*i*))|*O*(min(*i*, *n*-*i*))|*O*(1)|*O*(min(*i*, *n*-*i*))|

Note that where ties occur, [`Vec`](https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html) is generally going to be faster than [`VecDeque`](https://doc.rust-lang.org/nightly/alloc/collections/vec_deque/struct.VecDeque.html), and
[`VecDeque`](https://doc.rust-lang.org/nightly/alloc/collections/vec_deque/struct.VecDeque.html) is generally going to be faster than [`LinkedList`](https://doc.rust-lang.org/nightly/alloc/collections/linked_list/struct.LinkedList.html).

## Maps

For Sets, all operations have the cost of the equivalent Map operation.

||get|insert|remove|range|append|
|--|---|------|------|-----|------|
|[`HashMap`](https://doc.rust-lang.org/nightly/std/collections/hash/map/struct.HashMap.html)|*O*(1)~|*O*(1)~\*|*O*(1)~|N/A|N/A|
|[`BTreeMap`](https://doc.rust-lang.org/nightly/alloc/collections/btree/map/struct.BTreeMap.html)|*O*(log(*n*))|*O*(log(*n*))|*O*(log(*n*))|*O*(log(*n*))|*O*(*n*+*m*)|

# Correct and Efficient Usage of Collections

Of course, knowing which collection is the right one for the job doesn't
instantly permit you to use it correctly. Here are some quick tips for
efficient and correct usage of the standard collections in general. If
you're interested in how to use a specific collection in particular, consult
its documentation for detailed discussion and code examples.

## Capacity Management

Many collections provide several constructors and methods that refer to
"capacity". These collections are generally built on top of an array.
Optimally, this array would be exactly the right size to fit only the
elements stored in the collection, but for the collection to do this would
be very inefficient. If the backing array was exactly the right size at all
times, then every time an element is inserted, the collection would have to
grow the array to fit it. Due to the way memory is allocated and managed on
most computers, this would almost surely require allocating an entirely new
array and copying every single element from the old one into the new one.
Hopefully you can see that this wouldn't be very efficient to do on every
operation.

Most collections therefore use an *amortized* allocation strategy. They
generally let themselves have a fair amount of unoccupied space so that they
only have to grow on occasion. When they do grow, they allocate a
substantially larger array to move the elements into so that it will take a
while for another grow to be required. While this strategy is great in
general, it would be even better if the collection *never* had to resize its
backing array. Unfortunately, the collection itself doesn't have enough
information to do this itself. Therefore, it is up to us programmers to give
it hints.

Any `with_capacity` constructor will instruct the collection to allocate
enough space for the specified number of elements. Ideally this will be for
exactly that many elements, but some implementation details may prevent
this. See collection-specific documentation for details. In general, use
`with_capacity` when you know exactly how many elements will be inserted, or
at least have a reasonable upper-bound on that number.

When anticipating a large influx of elements, the `reserve` family of
methods can be used to hint to the collection how much room it should make
for the coming items. As with `with_capacity`, the precise behavior of
these methods will be specific to the collection of interest.

For optimal performance, collections will generally avoid shrinking
themselves. If you believe that a collection will not soon contain any more
elements, or just really need the memory, the `shrink_to_fit` method prompts
the collection to shrink the backing array to the minimum size capable of
holding its elements.

Finally, if ever you're interested in what the actual capacity of the
collection is, most collections provide a `capacity` method to query this
information on demand. This can be useful for debugging purposes, or for
use with the `reserve` methods.

## Iterators

Iterators are a powerful and robust mechanism used throughout Rust's
standard libraries. Iterators provide a sequence of values in a generic,
safe, efficient and convenient way. The contents of an iterator are usually
*lazily* evaluated, so that only the values that are actually needed are
ever actually produced, and no allocation need be done to temporarily store
them. Iterators are primarily consumed using a `for` loop, although many
functions also take iterators where a collection or sequence of values is
desired.

All of the standard collections provide several iterators for performing
bulk manipulation of their contents. The three primary iterators almost
every collection should provide are `iter`, `iter_mut`, and `into_iter`.
Some of these are not provided on collections where it would be unsound or
unreasonable to provide them.

`iter` provides an iterator of immutable references to all the contents of a
collection in the most "natural" order. For sequence collections like [`Vec`](https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html),
this means the items will be yielded in increasing order of index starting
at 0. For ordered collections like [`BTreeMap`](https://doc.rust-lang.org/nightly/alloc/collections/btree/map/struct.BTreeMap.html), this means that the items
will be yielded in sorted order. For unordered collections like [`HashMap`](https://doc.rust-lang.org/nightly/std/collections/hash/map/struct.HashMap.html),
the items will be yielded in whatever order the internal representation made
most convenient. This is great for reading through all the contents of the
collection.

```
let vec = vec![1, 2, 3, 4];
for x in vec.iter() {
   println!("vec contained {x:?}");
}
```

`iter_mut` provides an iterator of *mutable* references in the same order as
`iter`. This is great for mutating all the contents of the collection.

```
let mut vec = vec![1, 2, 3, 4];
for x in vec.iter_mut() {
   *x += 1;
}
```

`into_iter` transforms the actual collection into an iterator over its
contents by-value. This is great when the collection itself is no longer
needed, and the values are needed elsewhere. Using `extend` with `into_iter`
is the main way that contents of one collection are moved into another.
`extend` automatically calls `into_iter`, and takes any <code>T: [IntoIterator]</code>.
Calling `collect` on an iterator itself is also a great way to convert one
collection into another. Both of these methods should internally use the
capacity management tools discussed in the previous section to do this as
efficiently as possible.

```
let mut vec1 = vec![1, 2, 3, 4];
let vec2 = vec![10, 20, 30, 40];
vec1.extend(vec2);
```

```
use std::collections::VecDeque;

let vec = [1, 2, 3, 4];
let buf: VecDeque<_> = vec.into_iter().collect();
```

Iterators also provide a series of *adapter* methods for performing common
threads to sequences. Among the adapters are functional favorites like `map`,
`fold`, `skip` and `take`. Of particular interest to collections is the
`rev` adapter, which reverses any iterator that supports this operation. Most
collections provide reversible iterators as the way to iterate over them in
reverse order.

```
let vec = vec![1, 2, 3, 4];
for x in vec.iter().rev() {
   println!("vec contained {x:?}");
}
```

Several other collection methods also return iterators to yield a sequence
of results but avoid allocating an entire collection to store the result in.
This provides maximum flexibility as `collect` or `extend` can be called to
"pipe" the sequence into any collection if desired. Otherwise, the sequence
can be looped over with a `for` loop. The iterator can also be discarded
after partial use, preventing the computation of the unused items.

## Entries

The `entry` API is intended to provide an efficient mechanism for
manipulating the contents of a map conditionally on the presence of a key or
not. The primary motivating use case for this is to provide efficient
accumulator maps. For instance, if one wishes to maintain a count of the
number of times each key has been seen, they will have to perform some
conditional logic on whether this is the first time the key has been seen or
not. Normally, this would require a `find` followed by an `insert`,
effectively duplicating the search effort on each insertion.

When a user calls `map.entry(key)`, the map will search for the key and
then yield a variant of the `Entry` enum.

If a `Vacant(entry)` is yielded, then the key *was not* found. In this case
the only valid operation is to `insert` a value into the entry. When this is
done, the vacant entry is consumed and converted into a mutable reference to
the value that was inserted. This allows for further manipulation of the
value beyond the lifetime of the search itself. This is useful if complex
logic needs to be performed on the value regardless of whether the value was
just inserted.

If an `Occupied(entry)` is yielded, then the key *was* found. In this case,
the user has several options: they can `get`, `insert` or `remove` the
value of the occupied entry. Additionally, they can convert the occupied
entry into a mutable reference to its value, providing symmetry to the
vacant `insert` case.

### Examples

Here are the two primary ways in which `entry` is used. First, a simple
example where the logic performed on the values is trivial.

#### Counting the number of times each character in a string occurs

```
use std::collections::btree_map::BTreeMap;

let mut count = BTreeMap::new();
let message = "she sells sea shells by the sea shore";

for c in message.chars() {
    *count.entry(c).or_insert(0) += 1;
}

assert_eq!(count.get(&'s'), Some(&8));

println!("Number of occurrences of each character");
for (char, count) in &count {
    println!("{char}: {count}");
}
```

When the logic to be performed on the value is more complex, we may simply
use the `entry` API to ensure that the value is initialized and perform the
logic afterwards.

#### Tracking the inebriation of customers at a bar

```
use std::collections::btree_map::BTreeMap;

// A client of the bar. They have a blood alcohol level.
struct Person { blood_alcohol: f32 }

// All the orders made to the bar, by client ID.
let orders = vec![1, 2, 1, 2, 3, 4, 1, 2, 2, 3, 4, 1, 1, 1];

// Our clients.
let mut blood_alcohol = BTreeMap::new();

for id in orders {
    // If this is the first time we've seen this customer, initialize them
    // with no blood alcohol. Otherwise, just retrieve them.
    let person = blood_alcohol.entry(id).or_insert(Person { blood_alcohol: 0.0 });

    // Reduce their blood alcohol level. It takes time to order and drink a beer!
    person.blood_alcohol *= 0.9;

    // Check if they're sober enough to have another beer.
    if person.blood_alcohol > 0.3 {
        // Too drunk... for now.
        println!("Sorry {id}, I have to cut you off");
    } else {
        // Have another!
        person.blood_alcohol += 0.1;
    }
}
```

# Insert and complex keys

If we have a more complex key, calls to `insert` will
not update the value of the key. For example:

```
use std::cmp::Ordering;
use std::collections::BTreeMap;
use std::hash::{Hash, Hasher};

#[derive(Debug)]
struct Foo {
    a: u32,
    b: &'static str,
}

// we will compare `Foo`s by their `a` value only.
impl PartialEq for Foo {
    fn eq(&self, other: &Self) -> bool { self.a == other.a }
}

impl Eq for Foo {}

// we will hash `Foo`s by their `a` value only.
impl Hash for Foo {
    fn hash<H: Hasher>(&self, h: &mut H) { self.a.hash(h); }
}

impl PartialOrd for Foo {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> { self.a.partial_cmp(&other.a) }
}

impl Ord for Foo {
    fn cmp(&self, other: &Self) -> Ordering { self.a.cmp(&other.a) }
}

let mut map = BTreeMap::new();
map.insert(Foo { a: 1, b: "baz" }, 99);

// We already have a Foo with an a of 1, so this will be updating the value.
map.insert(Foo { a: 1, b: "xyz" }, 100);

// The value has been updated...
assert_eq!(map.values().next().unwrap(), &100);

// ...but the key hasn't changed. b is still "baz", not "xyz".
assert_eq!(map.keys().next().unwrap().b, "baz");
```¨,
irust-analyzer cargo alloc https://github.com/rust-lang/rust/library/alloc map/btree/collections/BTreeMap#æ+
```rust
alloc::collections::btree::map
```

```rust
pub struct BTreeMap<K, V, A = Global>
where
    A: Allocator + Clone,
```

---

An ordered map based on a [B-Tree](https://en.wikipedia.org/wiki/B-tree).

B-Trees represent a fundamental compromise between cache-efficiency and actually minimizing
the amount of work performed in a search. In theory, a binary search tree (BST) is the optimal
choice for a sorted map, as a perfectly balanced BST performs the theoretical minimum amount of
comparisons necessary to find an element (log<sub>2</sub>n). However, in practice the way this
is done is *very* inefficient for modern computer architectures. In particular, every element
is stored in its own individually heap-allocated node. This means that every single insertion
triggers a heap-allocation, and every single comparison should be a cache-miss. Since these
are both notably expensive things to do in practice, we are forced to, at the very least,
reconsider the BST strategy.

A B-Tree instead makes each node contain B-1 to 2B-1 elements in a contiguous array. By doing
this, we reduce the number of allocations by a factor of B, and improve cache efficiency in
searches. However, this does mean that searches will have to do *more* comparisons on average.
The precise number of comparisons depends on the node search strategy used. For optimal cache
efficiency, one could search the nodes linearly. For optimal comparisons, one could search
the node using binary search. As a compromise, one could also perform a linear search
that initially only checks every i<sup>th</sup> element for some choice of i.

Currently, our implementation simply performs naive linear search. This provides excellent
performance on *small* nodes of elements which are cheap to compare. However in the future we
would like to further explore choosing the optimal search strategy based on the choice of B,
and possibly other factors. Using linear search, searching for a random element is expected
to take B * log(n) comparisons, which is generally worse than a BST. In practice,
however, performance is excellent.

It is a logic error for a key to be modified in such a way that the key's ordering relative to
any other key, as determined by the [`Ord`](https://doc.rust-lang.org/nightly/core/cmp/trait.Ord.html) trait, changes while it is in the map. This is
normally only possible through [`Cell`], [`RefCell`], global state, I/O, or unsafe code.
The behavior resulting from such a logic error is not specified, but will be encapsulated to the
`BTreeMap` that observed the logic error and not result in undefined behavior. This could
include panics, incorrect results, aborts, memory leaks, and non-termination.

Iterators obtained from functions such as [`BTreeMap::iter`](`BTreeMap::iter`), [`BTreeMap::values`](`BTreeMap::values`), or
[`BTreeMap::keys`](`BTreeMap::keys`) produce their items in order by key, and take worst-case logarithmic and
amortized constant time per item returned.

# Examples

```
use std::collections::BTreeMap;

// type inference lets us omit an explicit type signature (which
// would be `BTreeMap<&str, &str>` in this example).
let mut movie_reviews = BTreeMap::new();

// review some movies.
movie_reviews.insert("Office Space",       "Deals with real issues in the workplace.");
movie_reviews.insert("Pulp Fiction",       "Masterpiece.");
movie_reviews.insert("The Godfather",      "Very enjoyable.");
movie_reviews.insert("The Blues Brothers", "Eye lyked it a lot.");

// check for a specific one.
if !movie_reviews.contains_key("Les Mis√©rables") {
    println!("We've got {} reviews, but Les Mis√©rables ain't one.",
             movie_reviews.len());
}

// oops, this review has a lot of spelling mistakes, let's delete it.
movie_reviews.remove("The Blues Brothers");

// look up the values associated with some keys.
let to_find = ["Up!", "Office Space"];
for movie in &to_find {
    match movie_reviews.get(movie) {
       Some(review) => println!("{movie}: {review}"),
       None => println!("{movie} is unreviewed.")
    }
}

// Look up the value for a key (will panic if the key is not found).
println!("Movie review: {}", movie_reviews["Office Space"]);

// iterate over everything.
for (movie, review) in &movie_reviews {
    println!("{movie}: \"{review}\"");
}
```

A `BTreeMap` with a known list of items can be initialized from an array:

```
use std::collections::BTreeMap;

let solar_distance = BTreeMap::from([
    ("Mercury", 0.4),
    ("Venus", 0.7),
    ("Earth", 1.0),
    ("Mars", 1.5),
]);
```

`BTreeMap` implements an [`Entry API`], which allows for complex
methods of getting, setting, updating and removing keys and their values:

```
use std::collections::BTreeMap;

// type inference lets us omit an explicit type signature (which
// would be `BTreeMap<&str, u8>` in this example).
let mut player_stats = BTreeMap::new();

fn random_stat_buff() -> u8 {
    // could actually return some random value here - let's just return
    // some fixed value for now
    42
}

// insert a key only if it doesn't already exist
player_stats.entry("health").or_insert(100);

// insert a key using a function that provides a new value only if it
// doesn't already exist
player_stats.entry("defence").or_insert_with(random_stat_buff);

// update a key, guarding against the key possibly not being set
let stat = player_stats.entry("attack").or_insert(100);
*stat += random_stat_buff();

// modify an entry before an insert with in-place mutation
player_stats.entry("mana").and_modify(|mana| *mana += 200).or_insert(100);
```[
(rust-analyzer cargo relative_path . map//
```rust
relative_path
```

```rust
mod map
```3
local 30'
```rust
extern crate relative_path
```œ
Xrust-analyzer cargo core https://github.com/rust-lang/rust/library/core default/Default!s
```rust
core::default
```

```rust
macro Default
```

---

Derive macro generating an impl of the trait `Default`.á
9rust-analyzer cargo relative_path . RelativePathCtx#root.J
```rust
relative_path::RelativePathCtx
```

```rust
pub root: PathBuf
```Ö
8rust-analyzer cargo relative_path . RelativePathCtx#hhi.I
```rust
relative_path::RelativePathCtx
```

```rust
pub hhi: PathBuf
```Ö
8rust-analyzer cargo relative_path . RelativePathCtx#tmp.I
```rust
relative_path::RelativePathCtx
```

```rust
pub tmp: PathBuf
```â
:rust-analyzer cargo relative_path . RelativePathCtx#dummy.K
```rust
relative_path::RelativePathCtx
```

```rust
pub dummy: PathBuf
```Q
*rust-analyzer cargo relative_path . (self)#
```rust
self: &RelativePathCtx
```K
,rust-analyzer cargo relative_path . (prefix)
```rust
prefix: Prefix
```_
*rust-analyzer cargo relative_path . tests/1
```rust
relative_path
```

```rust
mod tests
```‡
\rust-analyzer cargo core https://github.com/rust-lang/rust/library/core builtin/macros/test!ˇ
```rust
core::macros::builtin
```

```rust
macro test
```

---

Attribute macro applied to a function to turn it into a unit test.

See [the reference](https://doc.rust-lang.org/nightly/reference/attributes/testing.html#the-test-attribute) for more info.ì
Drust-analyzer cargo relative_path . tests/test_valid_usize_prefix().K
```rust
relative_path::tests
```

```rust
fn test_valid_usize_prefix()
```0
local 32$
```rust
let valid_prefix: usize
```∫
Yrust-analyzer cargo core https://github.com/rust-lang/rust/library/core macros/assert_eq!‹
```rust
core::macros
```

```rust
macro_rules! assert_eq
```

---

Asserts that two expressions are equal to each other (using [`PartialEq`](https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html)).

On panic, this macro will print the values of the expressions with their
debug representations.

Like [`assert`](https://doc.rust-lang.org/nightly/core/macros/builtin/macro.assert.html), this macro has a second form, where a custom
panic message can be provided.

# Examples

```
let a = 3;
let b = 1 + 2;
assert_eq!(a, b);

assert_eq!(a, b, "we are testing addition with {} and {}", a, b);
```ó
Frust-analyzer cargo relative_path . tests/test_invalid_usize_prefix().M
```rust
relative_path::tests
```

```rust
fn test_invalid_usize_prefix()
```2
local 33&
```rust
let invalid_prefix: usize
```Ã
frust-analyzer cargo alloc https://github.com/rust-lang/rust/library/alloc string/ToString#to_string().·
```rust
alloc::string
```

```rust
fn to_string(&self) -> String
```

---

Converts the given value to a `String`.

# Examples

Basic usage:

```
let i = 5;
let five = String::from("5");

assert_eq!(five, i.to_string());
```