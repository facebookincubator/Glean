[
  "@generated",
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000a#[allow]\u000a```\u000a\u000a---\u000a\u000aValid forms are:\u000a\u000a* \\#\\[allow(lint1, lint2, ..., /\\*opt\\*/ reason = \"...\")\\]"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000a#[inline]\u000a```\u000a\u000a---\u000a\u000aValid forms are:\u000a\u000a* \\#\\[inline\\]\u000a* \\#\\[inline(always|never)\\]"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000a'a\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000a'b\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000a'c\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000a'e\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000a'foo\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000a's\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000aL: Add<R>\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000aN: Copy + Mul<N> + Add<N> + Default\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000aO\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000aO: PartialOrd<O> + Zero\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000aP: PartialEq<P>\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000aR\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000aR: Read\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000aT\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000aT: AddAssign<T>\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000aT: Neg\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000aT: Ord\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000aT: PartialEq<T>\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000aW: Write\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000a_p: &i32\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000a_xs: &str\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000aa: T\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000aa: Vec<char>\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000aa: u32\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000aa: u64\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000aa: usize\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000aacc: u64\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000aalloc\u000a```\u000a\u000a```rust\u000amod str\u000a```\u000a\u000a---\u000a\u000aUnicode string slices.\u000a\u000a*[See also the `str` primitive type](https://doc.rust-lang.org/nightly/std/primitive.str.html).*\u000a\u000aThe `&str` type is one of the two main string types, the other being `String`.\u000aUnlike its `String` counterpart, its contents are borrowed.\u000a\u000a# Basic Usage\u000a\u000aA basic string declaration of `&str` type:\u000a\u000a```rust\u000alet hello_world = \"Hello, World!\";\u000a```\u000a\u000aHere we have declared a string literal, also known as a string slice.\u000aString literals have a static lifetime, which means the string `hello_world`\u000ais guaranteed to be valid for the duration of the entire program.\u000aWe can explicitly specify `hello_world`'s lifetime as well:\u000a\u000a```rust\u000alet hello_world: &'static str = \"Hello, world!\";\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000aalloc::borrow::ToOwned\u000a```\u000a\u000a```rust\u000apub fn to_owned(&self) -> Self::Owned\u000a```\u000a\u000a---\u000a\u000aCreates owned data from borrowed data, usually by cloning.\u000a\u000a# Examples\u000a\u000aBasic usage:\u000a\u000a```rust\u000alet s: &str = \"a\";\u000alet ss: String = s.to_owned();\u000a\u000alet v: &[i32] = &[1, 2];\u000alet vv: Vec<i32> = v.to_owned();\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000aalloc::boxed\u000a```\u000a\u000a```rust\u000apub struct Box<T>\u000awhere\u000a    T: ?Sized,\u000a```\u000a\u000a---\u000a\u000aA pointer type for heap allocation.\u000a\u000aSee the [module-level documentation](https://doc.rust-lang.org/nightly/std/boxed/index.html) for more."
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000aalloc::boxed::Box\u000a```\u000a\u000a```rust\u000apub fn new(x: T) -> Box<T>\u000a```\u000a\u000a---\u000a\u000aAllocates memory on the heap and then places `x` into it.\u000a\u000aThis doesn't actually allocate if `T` is zero-sized.\u000a\u000a# Examples\u000a\u000a```rust\u000alet five = Box::new(5);\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000aalloc::macros\u000a```\u000a\u000a```rust\u000amacro_rules! format\u000a```\u000a\u000a---\u000a\u000aCreates a `String` using interpolation of runtime expressions.\u000a\u000aThe first argument `format!` receives is a format string. This must be a string\u000aliteral. The power of the formatting string is in the `{}`s contained.\u000a\u000aAdditional parameters passed to `format!` replace the `{}`s within the\u000aformatting string in the order given unless named or positional parameters\u000aare used; see [`std::fmt`](https://doc.rust-lang.org/nightly/core/fmt/index.html) for more information.\u000a\u000aA common use for `format!` is concatenation and interpolation of strings.\u000aThe same convention is used with [`print!`] and [`write`] macros,\u000adepending on the intended destination of the string.\u000a\u000aTo convert a single value to a string, use the [`to_string`] method. This\u000awill use the [`Display`] formatting trait.\u000a\u000a# Panics\u000a\u000a`format!` panics if a formatting trait implementation returns an error.\u000aThis indicates an incorrect implementation\u000asince `fmt::Write for String` never returns an error itself.\u000a\u000a# Examples\u000a\u000a```rust\u000aformat!(\"test\");\u000aformat!(\"hello {}\", \"world!\");\u000aformat!(\"x = {}, y = {y}\", 10, y = 30);\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000aalloc::macros\u000a```\u000a\u000a```rust\u000amacro_rules! vec\u000a```\u000a\u000a---\u000a\u000aCreates a [`Vec`] containing the arguments.\u000a\u000a`vec!` allows `Vec`s to be defined with the same syntax as array expressions.\u000aThere are two forms of this macro:\u000a\u000a* Create a [`Vec`] containing a given list of elements:\u000a\u000a```rust\u000alet v = vec![1, 2, 3];\u000aassert_eq!(v[0], 1);\u000aassert_eq!(v[1], 2);\u000aassert_eq!(v[2], 3);\u000a```\u000a\u000a* Create a [`Vec`] from a given element and size:\u000a\u000a```rust\u000alet v = vec![1; 3];\u000aassert_eq!(v, [1, 1, 1]);\u000a```\u000a\u000aNote that unlike array expressions this syntax supports all elements\u000awhich implement [`Clone`](https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html) and the number of elements doesn't have to be\u000aa constant.\u000a\u000aThis will use `clone` to duplicate an expression, so one should be careful\u000ausing this with types having a nonstandard `Clone` implementation. For\u000aexample, `vec![Rc::new(1); 5]` will create a vector of five references\u000ato the same boxed integer value, not five references pointing to independently\u000aboxed integers."
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000aalloc::slice\u000a```\u000a\u000a```rust\u000apub fn concat<Item>(&self) -> Concat<Self = Self, Item>::Output\u000awhere\u000a    Item: ?Sized,\u000a    Self: Concat<Item>,\u000a```\u000a\u000a---\u000a\u000aFlattens a slice of `T` into a single value `Self::Output`.\u000a\u000a# Examples\u000a\u000a```rust\u000aassert_eq!([\"hello\", \"world\"].concat(), \"helloworld\");\u000aassert_eq!([[1, 2], [3, 4]].concat(), [1, 2, 3, 4]);\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000aalloc::slice\u000a```\u000a\u000a```rust\u000apub fn join<Separator>(&self, sep: Separator) -> Join<Self = Self, Separator>::Output\u000awhere\u000a    Self: Join<Separator>,\u000a```\u000a\u000a---\u000a\u000aFlattens a slice of `T` into a single value `Self::Output`, placing a\u000agiven separator between each.\u000a\u000a# Examples\u000a\u000a```rust\u000aassert_eq!([\"hello\", \"world\"].join(\" \"), \"hello world\");\u000aassert_eq!([[1, 2], [3, 4]].join(&0), [1, 2, 0, 3, 4]);\u000aassert_eq!([[1, 2], [3, 4]].join(&[0, 0][..]), [1, 2, 0, 0, 3, 4]);\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000aalloc::slice\u000a```\u000a\u000a```rust\u000apub fn sort(&mut self)\u000awhere\u000a    T: Ord,\u000a```\u000a\u000a---\u000a\u000aSorts the slice.\u000a\u000aThis sort is stable (i.e., does not reorder equal elements) and `O(n * log(n))` worst-case.\u000a\u000aWhen applicable, unstable sorting is preferred because it is generally faster than stable\u000asorting and it doesn't allocate auxiliary memory.\u000aSee [`sort_unstable`](#method.sort_unstable).\u000a\u000a# Current implementation\u000a\u000aThe current algorithm is an adaptive, iterative merge sort inspired by\u000a[timsort](https://en.wikipedia.org/wiki/Timsort).\u000aIt is designed to be very fast in cases where the slice is nearly sorted, or consists of\u000atwo or more sorted sequences concatenated one after another.\u000a\u000aAlso, it allocates temporary storage half the size of `self`, but for short slices a\u000anon-allocating insertion sort is used instead.\u000a\u000a# Examples\u000a\u000a```rust\u000alet mut v = [-5, 4, 1, -3, 2];\u000a\u000av.sort();\u000aassert!(v == [-5, -3, 1, 2, 4]);\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000aalloc::slice\u000a```\u000a\u000a```rust\u000apub fn sort_by_key<K, F>(&mut self, f: F)\u000awhere\u000a    F: FnMut(&T) -> K,\u000a    K: Ord,\u000a```\u000a\u000a---\u000a\u000aSorts the slice with a key extraction function.\u000a\u000aThis sort is stable (i.e., does not reorder equal elements) and `O(m * n * log(n))`\u000aworst-case, where the key function is `O(m)`.\u000a\u000aFor expensive key functions (e.g. functions that are not simple property accesses or\u000abasic operations), [`sort_by_cached_key`](#method.sort_by_cached_key) is likely to be\u000asignificantly faster, as it does not recompute element keys.\u000a\u000aWhen applicable, unstable sorting is preferred because it is generally faster than stable\u000asorting and it doesn't allocate auxiliary memory.\u000aSee [`sort_unstable_by_key`](#method.sort_unstable_by_key).\u000a\u000a# Current implementation\u000a\u000aThe current algorithm is an adaptive, iterative merge sort inspired by\u000a[timsort](https://en.wikipedia.org/wiki/Timsort).\u000aIt is designed to be very fast in cases where the slice is nearly sorted, or consists of\u000atwo or more sorted sequences concatenated one after another.\u000a\u000aAlso, it allocates temporary storage half the size of `self`, but for short slices a\u000anon-allocating insertion sort is used instead.\u000a\u000a# Examples\u000a\u000a```rust\u000alet mut v = [-5i32, 4, 1, -3, 2];\u000a\u000av.sort_by_key(|k| k.abs());\u000aassert!(v == [1, 2, -3, 4, -5]);\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000aalloc::slice\u000a```\u000a\u000a```rust\u000apub fn to_vec(&self) -> Vec<T>\u000awhere\u000a    T: Clone,\u000a```\u000a\u000a---\u000a\u000aCopies `self` into a new `Vec`.\u000a\u000a# Examples\u000a\u000a```rust\u000alet s = [10, 40, 30];\u000alet x = s.to_vec();\u000a// Here, `s` and `x` can be modified independently.\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000aalloc::string\u000a```\u000a\u000a```rust\u000apub struct String\u000a```\u000a\u000a---\u000a\u000aA UTF-8 encoded, growable string.\u000a\u000aThe `String` type is the most common string type that has ownership over the\u000acontents of the string. It has a close relationship with its borrowed\u000acounterpart, the primitive [`str`].\u000a\u000a# Examples\u000a\u000aYou can create a `String` from [a literal string](https://doc.rust-lang.org/nightly/alloc/str/index.html) with [`String::from`]:\u000a\u000a```rust\u000alet hello = String::from(\"Hello, world!\");\u000a```\u000a\u000aYou can append a [`char`](`char`) to a `String` with the [`push`] method, and\u000aappend a [`&str`] with the [`push_str`] method:\u000a\u000a```rust\u000alet mut hello = String::from(\"Hello, \");\u000a\u000ahello.push('w');\u000ahello.push_str(\"orld!\");\u000a```\u000a\u000aIf you have a vector of UTF-8 bytes, you can create a `String` from it with\u000athe [`from_utf8`] method:\u000a\u000a```rust\u000a// some bytes, in a vector\u000alet sparkle_heart = vec![240, 159, 146, 150];\u000a\u000a// We know these bytes are valid, so we'll use `unwrap()`.\u000alet sparkle_heart = String::from_utf8(sparkle_heart).unwrap();\u000a\u000aassert_eq!(\"ðŸ’–\", sparkle_heart);\u000a```\u000a\u000a# UTF-8\u000a\u000a`String`s are always valid UTF-8. This has a few implications, the first of\u000awhich is that if you need a non-UTF-8 string, consider [`OsString`]. It is\u000asimilar, but without the UTF-8 constraint. The second implication is that\u000ayou cannot index into a `String`:\u000a\u000a```rust\u000alet s = \"hello\";\u000a\u000aprintln!(\"The first letter of s is {}\", s[0]); // ERROR!!!\u000a```\u000a\u000aIndexing is intended to be a constant-time operation, but UTF-8 encoding\u000adoes not allow us to do this. Furthermore, it's not clear what sort of\u000athing the index should return: a byte, a codepoint, or a grapheme cluster.\u000aThe [`bytes`] and [`chars`] methods return iterators over the first\u000atwo, respectively.\u000a\u000a# Deref\u000a\u000a`String`s implement [`Deref`]`<Target=str>`, and so inherit all of [`str`]'s\u000amethods. In addition, this means that you can pass a `String` to a\u000afunction which takes a [`&str`] by using an ampersand (`&`):\u000a\u000a```rust\u000afn takes_str(s: &str) { }\u000a\u000alet s = String::from(\"Hello\");\u000a\u000atakes_str(&s);\u000a```\u000a\u000aThis will create a [`&str`] from the `String` and pass it in. This\u000aconversion is very inexpensive, and so generally, functions will accept\u000a[`&str`]s as arguments unless they need a `String` for some specific\u000areason.\u000a\u000aIn certain cases Rust doesn't have enough information to make this\u000aconversion, known as [`Deref`] coercion. In the following example a string\u000aslice [`&'a str`](https://doc.rust-lang.org/nightly/alloc/str/index.html) implements the trait `TraitExample`, and the function\u000a`example_func` takes anything that implements the trait. In this case Rust\u000awould need to make two implicit conversions, which Rust doesn't have the\u000ameans to do. For that reason, the following example will not compile.\u000a\u000a```rust\u000atrait TraitExample {}\u000a\u000aimpl<'a> TraitExample for &'a str {}\u000a\u000afn example_func<A: TraitExample>(example_arg: A) {}\u000a\u000alet example_string = String::from(\"example_string\");\u000aexample_func(&example_string);\u000a```\u000a\u000aThere are two options that would work instead. The first would be to\u000achange the line `example_func(&example_string);` to\u000a`example_func(example_string.as_str());`, using the method [`as_str()`]\u000ato explicitly extract the string slice containing the string. The second\u000away changes `example_func(&example_string);` to\u000a`example_func(&*example_string);`. In this case we are dereferencing a\u000a`String` to a [`str`](https://doc.rust-lang.org/nightly/alloc/str/index.html), then referencing the [`str`](https://doc.rust-lang.org/nightly/alloc/str/index.html) back to\u000a[`&str`]. The second way is more idiomatic, however both work to do the\u000aconversion explicitly rather than relying on the implicit conversion.\u000a\u000a# Representation\u000a\u000aA `String` is made up of three components: a pointer to some bytes, a\u000alength, and a capacity. The pointer points to an internal buffer `String`\u000auses to store its data. The length is the number of bytes currently stored\u000ain the buffer, and the capacity is the size of the buffer in bytes. As such,\u000athe length will always be less than or equal to the capacity.\u000a\u000aThis buffer is always stored on the heap.\u000a\u000aYou can look at these with the [`as_ptr`], [`len`], and [`capacity`]\u000amethods:\u000a\u000a```rust\u000ause std::mem;\u000a\u000alet story = String::from(\"Once upon a time...\");\u000a\u000a// Prevent automatically dropping the String's data\u000alet mut story = mem::ManuallyDrop::new(story);\u000a\u000alet ptr = story.as_mut_ptr();\u000alet len = story.len();\u000alet capacity = story.capacity();\u000a\u000a// story has nineteen bytes\u000aassert_eq!(19, len);\u000a\u000a// We can re-build a String out of ptr, len, and capacity. This is all\u000a// unsafe because we are responsible for making sure the components are\u000a// valid:\u000alet s = unsafe { String::from_raw_parts(ptr, len, capacity) } ;\u000a\u000aassert_eq!(String::from(\"Once upon a time...\"), s);\u000a```\u000a\u000aIf a `String` has enough capacity, adding elements to it will not\u000are-allocate. For example, consider this program:\u000a\u000a```rust\u000alet mut s = String::new();\u000a\u000aprintln!(\"{}\", s.capacity());\u000a\u000afor _ in 0..5 {\u000a    s.push_str(\"hello\");\u000a    println!(\"{}\", s.capacity());\u000a}\u000a```\u000a\u000aThis will output the following:\u000a\u000a```text\u000a0\u000a5\u000a10\u000a20\u000a20\u000a40\u000a```\u000a\u000aAt first, we have no memory allocated at all, but as we append to the\u000astring, it increases its capacity appropriately. If we instead use the\u000a[`with_capacity`] method to allocate the correct capacity initially:\u000a\u000a```rust\u000alet mut s = String::with_capacity(25);\u000a\u000aprintln!(\"{}\", s.capacity());\u000a\u000afor _ in 0..5 {\u000a    s.push_str(\"hello\");\u000a    println!(\"{}\", s.capacity());\u000a}\u000a```\u000a\u000aWe end up with a different output:\u000a\u000a```text\u000a25\u000a25\u000a25\u000a25\u000a25\u000a25\u000a```\u000a\u000aHere, there's no need to allocate more memory inside the loop."
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000aalloc::string::String\u000a```\u000a\u000a```rust\u000apub const fn new() -> String\u000a```\u000a\u000a---\u000a\u000aCreates a new empty `String`.\u000a\u000aGiven that the `String` is empty, this will not allocate any initial\u000abuffer. While that means that this initial operation is very\u000ainexpensive, it may cause excessive allocation later when you add\u000adata. If you have an idea of how much data the `String` will hold,\u000aconsider the [`with_capacity`] method to prevent excessive\u000are-allocation.\u000a\u000a# Examples\u000a\u000aBasic usage:\u000a\u000a```rust\u000alet s = String::new();\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000aalloc::string::String\u000a```\u000a\u000a```rust\u000apub fn from_utf8(vec: Vec<u8>) -> Result<String, FromUtf8Error>\u000a```\u000a\u000a---\u000a\u000aConverts a vector of bytes to a `String`.\u000a\u000aA string ([`String`](https://doc.rust-lang.org/nightly/alloc/string/struct.String.html)) is made of bytes ([`u8`](`u8`)), and a vector of bytes\u000a([`Vec<u8>`]) is made of bytes, so this function converts between the\u000atwo. Not all byte slices are valid `String`s, however: `String`\u000arequires that it is valid UTF-8. `from_utf8()` checks to ensure that\u000athe bytes are valid UTF-8, and then does the conversion.\u000a\u000aIf you are sure that the byte slice is valid UTF-8, and you don't want\u000ato incur the overhead of the validity check, there is an unsafe version\u000aof this function, [`from_utf8_unchecked`], which has the same behavior\u000abut skips the check.\u000a\u000aThis method will take care to not copy the vector, for efficiency's\u000asake.\u000a\u000aIf you need a [`&str`] instead of a `String`, consider\u000a[`str::from_utf8`](https://doc.rust-lang.org/nightly/core/str/converts/fn.from_utf8.html).\u000a\u000aThe inverse of this method is [`into_bytes`].\u000a\u000a# Errors\u000a\u000aReturns [`Err`](https://doc.rust-lang.org/nightly/core/result/enum.Result.html) if the slice is not UTF-8 with a description as to why the\u000aprovided bytes are not UTF-8. The vector you moved in is also included.\u000a\u000a# Examples\u000a\u000aBasic usage:\u000a\u000a```rust\u000a// some bytes, in a vector\u000alet sparkle_heart = vec![240, 159, 146, 150];\u000a\u000a// We know these bytes are valid, so we'll use `unwrap()`.\u000alet sparkle_heart = String::from_utf8(sparkle_heart).unwrap();\u000a\u000aassert_eq!(\"ðŸ’–\", sparkle_heart);\u000a```\u000a\u000aIncorrect bytes:\u000a\u000a```rust\u000a// some invalid bytes, in a vector\u000alet sparkle_heart = vec![0, 159, 146, 150];\u000a\u000aassert!(String::from_utf8(sparkle_heart).is_err());\u000a```\u000a\u000aSee the docs for [`FromUtf8Error`](https://doc.rust-lang.org/nightly/alloc/string/struct.FromUtf8Error.html) for more details on what you can do\u000awith this error."
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000aalloc::string::String\u000a```\u000a\u000a```rust\u000apub fn push(&mut self, ch: char)\u000a```\u000a\u000a---\u000a\u000aAppends the given [`char`](`char`) to the end of this `String`.\u000a\u000a# Examples\u000a\u000aBasic usage:\u000a\u000a```rust\u000alet mut s = String::from(\"abc\");\u000a\u000as.push('1');\u000as.push('2');\u000as.push('3');\u000a\u000aassert_eq!(\"abc123\", s);\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000aalloc::string::ToString\u000a```\u000a\u000a```rust\u000apub fn to_string(&self) -> String\u000a```\u000a\u000a---\u000a\u000aConverts the given value to a `String`.\u000a\u000a# Examples\u000a\u000aBasic usage:\u000a\u000a```rust\u000alet i = 5;\u000alet five = String::from(\"5\");\u000a\u000aassert_eq!(five, i.to_string());\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000aalloc::vec\u000a```\u000a\u000a```rust\u000apub struct Vec<T>\u000a```\u000a\u000a---\u000a\u000aA contiguous growable array type, written `Vec<T>` but pronounced 'vector'.\u000a\u000a# Examples\u000a\u000a```rust\u000alet mut vec = Vec::new();\u000avec.push(1);\u000avec.push(2);\u000a\u000aassert_eq!(vec.len(), 2);\u000aassert_eq!(vec[0], 1);\u000a\u000aassert_eq!(vec.pop(), Some(2));\u000aassert_eq!(vec.len(), 1);\u000a\u000avec[0] = 7;\u000aassert_eq!(vec[0], 7);\u000a\u000avec.extend([1, 2, 3].iter().copied());\u000a\u000afor x in &vec {\u000a    println!(\"{}\", x);\u000a}\u000aassert_eq!(vec, [7, 1, 2, 3]);\u000a```\u000a\u000aThe [`vec`](https://doc.rust-lang.org/nightly/alloc/macros/macro.vec.html) macro is provided to make initialization more convenient:\u000a\u000a```rust\u000alet mut vec = vec![1, 2, 3];\u000avec.push(4);\u000aassert_eq!(vec, [1, 2, 3, 4]);\u000a```\u000a\u000aIt can also initialize each element of a `Vec<T>` with a given value.\u000aThis may be more efficient than performing allocation and initialization\u000ain separate steps, especially when initializing a vector of zeros:\u000a\u000a```rust\u000alet vec = vec![0; 5];\u000aassert_eq!(vec, [0, 0, 0, 0, 0]);\u000a\u000a// The following is equivalent, but potentially slower:\u000alet mut vec = Vec::with_capacity(5);\u000avec.resize(5, 0);\u000aassert_eq!(vec, [0, 0, 0, 0, 0]);\u000a```\u000a\u000aFor more information, see\u000a[Capacity and Reallocation](https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html#capacity-and-reallocation).\u000a\u000aUse a `Vec<T>` as an efficient stack:\u000a\u000a```rust\u000alet mut stack = Vec::new();\u000a\u000astack.push(1);\u000astack.push(2);\u000astack.push(3);\u000a\u000awhile let Some(top) = stack.pop() {\u000a    // Prints 3, 2, 1\u000a    println!(\"{}\", top);\u000a}\u000a```\u000a\u000a# Indexing\u000a\u000aThe `Vec` type allows to access values by index, because it implements the\u000a[`Index`](https://doc.rust-lang.org/nightly/core/ops/index/trait.Index.html) trait. An example will be more explicit:\u000a\u000a```rust\u000alet v = vec![0, 2, 4, 6];\u000aprintln!(\"{}\", v[1]); // it will display '2'\u000a```\u000a\u000aHowever be careful: if you try to access an index which isn't in the `Vec`,\u000ayour software will panic! You cannot do this:\u000a\u000a```rust\u000alet v = vec![0, 2, 4, 6];\u000aprintln!(\"{}\", v[6]); // it will panic!\u000a```\u000a\u000aUse [`get`] and [`get_mut`] if you want to check whether the index is in\u000athe `Vec`.\u000a\u000a# Slicing\u000a\u000aA `Vec` can be mutable. Slices, on the other hand, are read-only objects.\u000aTo get a [slice], use [`&`]. Example:\u000a\u000a```rust\u000afn read_slice(slice: &[usize]) {\u000a    // ...\u000a}\u000a\u000alet v = vec![0, 1];\u000aread_slice(&v);\u000a\u000a// ... and that's all!\u000a// you can also do it like this:\u000alet u: &[usize] = &v;\u000a// or like this:\u000alet u: &[_] = &v;\u000a```\u000a\u000aIn Rust, it's more common to pass slices as arguments rather than vectors\u000awhen you just want to provide read access. The same goes for [`String`] and\u000a[`&str`].\u000a\u000a# Capacity and reallocation\u000a\u000aThe capacity of a vector is the amount of space allocated for any future\u000aelements that will be added onto the vector. This is not to be confused with\u000athe *length* of a vector, which specifies the number of actual elements\u000awithin the vector. If a vector's length exceeds its capacity, its capacity\u000awill automatically be increased, but its elements will have to be\u000areallocated.\u000a\u000aFor example, a vector with capacity 10 and length 0 would be an empty vector\u000awith space for 10 more elements. Pushing 10 or fewer elements onto the\u000avector will not change its capacity or cause reallocation to occur. However,\u000aif the vector's length is increased to 11, it will have to reallocate, which\u000acan be slow. For this reason, it is recommended to use [`Vec::with_capacity`](`Vec::with_capacity`)\u000awhenever possible to specify how big the vector is expected to get.\u000a\u000a# Guarantees\u000a\u000aDue to its incredibly fundamental nature, `Vec` makes a lot of guarantees\u000aabout its design. This ensures that it's as low-overhead as possible in\u000athe general case, and can be correctly manipulated in primitive ways\u000aby unsafe code. Note that these guarantees refer to an unqualified `Vec<T>`.\u000aIf additional type parameters are added (e.g., to support custom allocators),\u000aoverriding their defaults may change the behavior.\u000a\u000aMost fundamentally, `Vec` is and always will be a (pointer, capacity, length)\u000atriplet. No more, no less. The order of these fields is completely\u000aunspecified, and you should use the appropriate methods to modify these.\u000aThe pointer will never be null, so this type is null-pointer-optimized.\u000a\u000aHowever, the pointer may not actually point to allocated memory. In particular,\u000aif you construct a `Vec` with capacity 0 via [`Vec::new`](`Vec::new`), [`vec![]`](https://doc.rust-lang.org/nightly/alloc/macros/macro.vec.html),\u000a[`Vec::with_capacity(0)`](`Vec::with_capacity`), or by calling [`shrink_to_fit`]\u000aon an empty Vec, it will not allocate memory. Similarly, if you store zero-sized\u000atypes inside a `Vec`, it will not allocate space for them. *Note that in this case\u000athe `Vec` may not report a [`capacity`] of 0*. `Vec` will allocate if and only\u000aif [`mem::size_of::<T>`]`() * capacity() > 0`. In general, `Vec`'s allocation\u000adetails are very subtle â€” if you intend to allocate memory using a `Vec`\u000aand use it for something else (either to pass to unsafe code, or to build your\u000aown memory-backed collection), be sure to deallocate this memory by using\u000a`from_raw_parts` to recover the `Vec` and then dropping it.\u000a\u000aIf a `Vec` *has* allocated memory, then the memory it points to is on the heap\u000a(as defined by the allocator Rust is configured to use by default), and its\u000apointer points to [`len`] initialized, contiguous elements in order (what\u000ayou would see if you coerced it to a slice), followed by [`capacity`]`-`[`len`] logically uninitialized, contiguous elements.\u000a\u000a`Vec` will never perform a \"small optimization\" where elements are actually\u000astored on the stack for two reasons:\u000a\u000a* It would make it more difficult for unsafe code to correctly manipulate\u000a  a `Vec`. The contents of a `Vec` wouldn't have a stable address if it were\u000a  only moved, and it would be more difficult to determine if a `Vec` had\u000a  actually allocated memory.\u000a\u000a* It would penalize the general case, incurring an additional branch\u000a  on every access.\u000a\u000a`Vec` will never automatically shrink itself, even if completely empty. This\u000aensures no unnecessary allocations or deallocations occur. Emptying a `Vec`\u000aand then filling it back up to the same [`len`] should incur no calls to\u000athe allocator. If you wish to free up unused memory, use\u000a[`shrink_to_fit`].\u000a\u000a[`push`] and [`insert`] will never (re)allocate if the reported capacity is\u000asufficient. [`push`] and [`insert`] *will* (re)allocate if\u000a[`len`]`==`[`capacity`]. That is, the reported capacity is completely\u000aaccurate, and can be relied on. It can even be used to manually free the memory\u000aallocated by a `Vec` if desired. Bulk insertion methods *may* reallocate, even\u000awhen not necessary.\u000a\u000a`Vec` does not guarantee any particular growth strategy when reallocating\u000awhen full, nor when [`reserve`] is called. The current strategy is basic\u000aand it may prove desirable to use a non-constant growth factor. Whatever\u000astrategy is used will of course guarantee `O(1)` amortized [`push`].\u000a\u000a`vec![x; n]`, `vec![a, b, c, d]`, and\u000a[`Vec::with_capacity(n)`](`Vec::with_capacity`), will all produce a `Vec`\u000awith exactly the requested capacity. If [`len`]`==`[`capacity`],\u000a(as is the case for the [`vec`](https://doc.rust-lang.org/nightly/alloc/macros/macro.vec.html) macro), then a `Vec<T>` can be converted to\u000aand from a [`Box<[T]>`](https://doc.rust-lang.org/nightly/alloc/boxed/struct.Box.html) without reallocating or moving the elements.\u000a\u000a`Vec` will not specifically overwrite any data that is removed from it,\u000abut also won't specifically preserve it. Its uninitialized memory is\u000ascratch space that it may use however it wants. It will generally just do\u000awhatever is most efficient or otherwise easy to implement. Do not rely on\u000aremoved data to be erased for security purposes. Even if you drop a `Vec`, its\u000abuffer may simply be reused by another `Vec`. Even if you zero a `Vec`'s memory\u000afirst, that may not actually happen because the optimizer does not consider\u000athis a side-effect that must be preserved. There is one case which we will\u000anot break, however: using `unsafe` code to write to the excess capacity,\u000aand then increasing the length to match, is always valid.\u000a\u000a`Vec` does not currently guarantee the order in which elements are dropped.\u000aThe order has changed in the past and may change again."
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000aalloc::vec::Vec\u000a```\u000a\u000a```rust\u000apub const fn new() -> Vec<T>\u000a```\u000a\u000a---\u000a\u000aConstructs a new, empty `Vec<T>`.\u000a\u000aThe vector will not allocate until elements are pushed onto it.\u000a\u000a# Examples\u000a\u000a```rust\u000alet mut vec: Vec<i32> = Vec::new();\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000aalloc::vec::Vec\u000a```\u000a\u000a```rust\u000apub fn is_empty(&self) -> bool\u000a```\u000a\u000a---\u000a\u000aReturns `true` if the vector contains no elements.\u000a\u000a# Examples\u000a\u000a```rust\u000alet mut v = Vec::new();\u000aassert!(v.is_empty());\u000a\u000av.push(1);\u000aassert!(!v.is_empty());\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000aalloc::vec::Vec\u000a```\u000a\u000a```rust\u000apub fn len(&self) -> usize\u000a```\u000a\u000a---\u000a\u000aReturns the number of elements in the vector, also referred to\u000aas its 'length'.\u000a\u000a# Examples\u000a\u000a```rust\u000alet a = vec![1, 2, 3];\u000aassert_eq!(a.len(), 3);\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000aalloc::vec::Vec\u000a```\u000a\u000a```rust\u000apub fn pop(&mut self) -> Option<T>\u000a```\u000a\u000a---\u000a\u000aRemoves the last element from a vector and returns it, or [`None`](https://doc.rust-lang.org/nightly/core/option/enum.Option.html) if it\u000ais empty.\u000a\u000a# Examples\u000a\u000a```rust\u000alet mut vec = vec![1, 2, 3];\u000aassert_eq!(vec.pop(), Some(3));\u000aassert_eq!(vec, [1, 2]);\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000aalloc::vec::Vec\u000a```\u000a\u000a```rust\u000apub fn push(&mut self, value: T)\u000a```\u000a\u000a---\u000a\u000aAppends an element to the back of a collection.\u000a\u000a# Panics\u000a\u000aPanics if the new capacity exceeds `isize::MAX` bytes.\u000a\u000a# Examples\u000a\u000a```rust\u000alet mut vec = vec![1, 2];\u000avec.push(3);\u000aassert_eq!(vec, [1, 2, 3]);\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000aalloc::vec::Vec\u000a```\u000a\u000a```rust\u000apub fn retain<F>(&mut self, f: F)\u000awhere\u000a    F: FnMut(&T) -> bool,\u000a```\u000a\u000a---\u000a\u000aRetains only the elements specified by the predicate.\u000a\u000aIn other words, remove all elements `e` such that `f(&e)` returns `false`.\u000aThis method operates in place, visiting each element exactly once in the\u000aoriginal order, and preserves the order of the retained elements.\u000a\u000a# Examples\u000a\u000a```rust\u000alet mut vec = vec![1, 2, 3, 4];\u000avec.retain(|&x| x % 2 == 0);\u000aassert_eq!(vec, [2, 4]);\u000a```\u000a\u000aThe exact order may be useful for tracking external state, like an index.\u000a\u000a```rust\u000alet mut vec = vec![1, 2, 3, 4, 5];\u000alet keep = [false, true, true, false, true];\u000alet mut i = 0;\u000avec.retain(|_| (keep[i], i += 1).0);\u000aassert_eq!(vec, [2, 3, 5]);\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000aalloc::vec::Vec\u000a```\u000a\u000a```rust\u000apub fn swap_remove(&mut self, index: usize) -> T\u000a```\u000a\u000a---\u000a\u000aRemoves an element from the vector and returns it.\u000a\u000aThe removed element is replaced by the last element of the vector.\u000a\u000aThis does not preserve ordering, but is O(1).\u000a\u000a# Panics\u000a\u000aPanics if `index` is out of bounds.\u000a\u000a# Examples\u000a\u000a```rust\u000alet mut v = vec![\"foo\", \"bar\", \"baz\", \"qux\"];\u000a\u000aassert_eq!(v.swap_remove(1), \"bar\");\u000aassert_eq!(v, [\"foo\", \"qux\", \"baz\"]);\u000a\u000aassert_eq!(v.swap_remove(0), \"foo\");\u000aassert_eq!(v, [\"baz\", \"qux\"]);\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000aalloc::vec::Vec\u000a```\u000a\u000a```rust\u000apub fn with_capacity(capacity: usize) -> Vec<T>\u000a```\u000a\u000a---\u000a\u000aConstructs a new, empty `Vec<T>` with the specified capacity.\u000a\u000aThe vector will be able to hold exactly `capacity` elements without\u000areallocating. If `capacity` is 0, the vector will not allocate.\u000a\u000aIt is important to note that although the returned vector has the\u000a*capacity* specified, the vector will have a zero *length*. For an\u000aexplanation of the difference between length and capacity, see\u000a*[Capacity and reallocation]*.\u000a\u000a# Examples\u000a\u000a```rust\u000alet mut vec = Vec::with_capacity(10);\u000a\u000a// The vector contains no items, even though it has capacity for more\u000aassert_eq!(vec.len(), 0);\u000aassert_eq!(vec.capacity(), 10);\u000a\u000a// These are all done without reallocating...\u000afor i in 0..10 {\u000a    vec.push(i);\u000a}\u000aassert_eq!(vec.len(), 10);\u000aassert_eq!(vec.capacity(), 10);\u000a\u000a// ...but this may make the vector reallocate\u000avec.push(11);\u000aassert_eq!(vec.len(), 11);\u000aassert!(vec.capacity() >= 11);\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000aarg: String\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000ab: T\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000ab: bool\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000ab: i32\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000ab: u32\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000ab: usize\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics\u000a```\u000a\u000a```rust\u000aconst A_LIM: usize = 10000 (0x2710)\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics\u000a```\u000a\u000a```rust\u000aconst UY: i32 = 10 (0xA)\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics\u000a```\u000a\u000a```rust\u000aenum ETy<T>\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics\u000a```\u000a\u000a```rust\u000aenum Message\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics\u000a```\u000a\u000a```rust\u000afn array_stuff()\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics\u000a```\u000a\u000a```rust\u000afn array_stuff_2() -> Box<[bool]>\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics\u000a```\u000a\u000a```rust\u000afn build_vector() -> Vec<i16>\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics\u000a```\u000a\u000a```rust\u000afn extend_m(vec: &mut Vec<f64>, slice: &[f64])\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics\u000a```\u000a\u000a```rust\u000afn extend_pure(vec: &[f64], slice: &[f64]) -> Vec<f64>\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics\u000a```\u000a\u000a```rust\u000afn f(_: Vec<i32>)\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics\u000a```\u000a\u000a```rust\u000afn f(p: &'static i32)\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics\u000a```\u000a\u000a```rust\u000afn f0()\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics\u000a```\u000a\u000a```rust\u000afn f1() -> usize\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics\u000a```\u000a\u000a```rust\u000afn f1_go(n: u64, acc: u64) -> u64\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics\u000a```\u000a\u000a```rust\u000afn f2<'a>() -> &'a [u64]\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics\u000a```\u000a\u000a```rust\u000afn first_third(point: &[i32; 3]) -> [i32; 2]\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics\u000a```\u000a\u000a```rust\u000afn fix() -> !\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics\u000a```\u000a\u000a```rust\u000afn foo(n: u64) -> u64\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics\u000a```\u000a\u000a```rust\u000afn g(_: Vec<i32>)\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics\u000a```\u000a\u000a```rust\u000afn g<'a>(_p: &'a i32)\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics\u000a```\u000a\u000a```rust\u000afn gcd(n: u64, m: u64) -> u64\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics\u000a```\u000a\u000a```rust\u000afn h(_p: &'static i32)\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics\u000a```\u000a\u000a```rust\u000afn main()\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics\u000a```\u000a\u000a```rust\u000afn smallest<'a>(v: &'a [i32]) -> &'a i32\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics\u000a```\u000a\u000a```rust\u000afn str_games(t: &str) -> String\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics\u000a```\u000a\u000a```rust\u000afn str_stuff()\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics\u000a```\u000a\u000a```rust\u000afn sum_r_xy<'a, 'b, 'c>(r: &'a i32, s: S<'b, 'c>) -> i32\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics\u000a```\u000a\u000a```rust\u000afn test_gcd()\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics\u000a```\u000a\u000a```rust\u000afn vec_reverse_functional(s: Vec<&str>) -> Vec<&str>\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics\u000a```\u000a\u000a```rust\u000afn vec_stuff() -> (Vec<i32>, Vec<i32>)\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics\u000a```\u000a\u000a```rust\u000amod bintree\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics\u000a```\u000a\u000a```rust\u000amod bounds\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics\u000a```\u000a\u000a```rust\u000amod break\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics\u000a```\u000a\u000a```rust\u000amod closures\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics\u000a```\u000a\u000a```rust\u000amod collect\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics\u000a```\u000a\u000a```rust\u000amod collect1\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics\u000a```\u000a\u000a```rust\u000amod enum\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics\u000a```\u000a\u000a```rust\u000amod enum2\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics\u000a```\u000a\u000a```rust\u000amod expr\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics\u000a```\u000a\u000a```rust\u000amod expr2\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics\u000a```\u000a\u000a```rust\u000amod foo\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics\u000a```\u000a\u000a```rust\u000amod generics\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics\u000a```\u000a\u000a```rust\u000amod impl\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics\u000a```\u000a\u000a```rust\u000amod impl2\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics\u000a```\u000a\u000a```rust\u000amod io\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics\u000a```\u000a\u000a```rust\u000amod json\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics\u000a```\u000a\u000a```rust\u000amod lib\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics\u000a```\u000a\u000a```rust\u000amod mod2\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics\u000a```\u000a\u000a```rust\u000amod modules\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics\u000a```\u000a\u000a```rust\u000amod mutable\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics\u000a```\u000a\u000a```rust\u000amod operators\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics\u000a```\u000a\u000a```rust\u000amod ownership\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics\u000a```\u000a\u000a```rust\u000amod panic\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics\u000a```\u000a\u000a```rust\u000amod pattern\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics\u000a```\u000a\u000a```rust\u000amod result\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics\u000a```\u000a\u000a```rust\u000amod sharing\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics\u000a```\u000a\u000a```rust\u000amod struct\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics\u000a```\u000a\u000a```rust\u000amod trait\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics\u000a```\u000a\u000a```rust\u000amod types\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics\u000a```\u000a\u000a```rust\u000apub fn sum_f1(n: u64) -> u64\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics\u000a```\u000a\u000a```rust\u000apub fn sum_f2(n: u64) -> u64\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics\u000a```\u000a\u000a```rust\u000apub fn sum_f3(n: u64) -> u64\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics\u000a```\u000a\u000a```rust\u000astatic WORTH_POINTING_AT: i32 = 1000\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics\u000a```\u000a\u000a```rust\u000astatic mut STASH: &i32 = &128\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics\u000a```\u000a\u000a```rust\u000astruct A\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics\u000a```\u000a\u000a```rust\u000astruct B\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics\u000a```\u000a\u000a```rust\u000astruct Color\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics\u000a```\u000a\u000a```rust\u000astruct P\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics\u000a```\u000a\u000a```rust\u000astruct Person\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics\u000a```\u000a\u000a```rust\u000astruct S<'a, 'b>\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics\u000a```\u000a\u000a```rust\u000astruct S<'a>\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics\u000a```\u000a\u000a```rust\u000astruct T\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics\u000a```\u000a\u000a```rust\u000astruct T<'a>\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics\u000a```\u000a\u000a```rust\u000astruct U<'a, 'b>\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics\u000a```\u000a\u000a```rust\u000atype T = Tree<'a, u64>\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::A\u000a```\u000a\u000a```rust\u000a_bechdel_pass: bool\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::A\u000a```\u000a\u000a```rust\u000af: T\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::A\u000a```\u000a\u000a```rust\u000aname: &str\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::A\u000a```\u000a\u000a```rust\u000asz: u32\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::B\u000a```\u000a\u000a```rust\u000a_a: u64\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::B\u000a```\u000a\u000a```rust\u000af: T\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::B\u000a```\u000a\u000a```rust\u000aname: String\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::B\u000a```\u000a\u000a```rust\u000asz: u32\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::C\u000a```\u000a\u000a```rust\u000a_count: u32\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::C\u000a```\u000a\u000a```rust\u000af: T\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::C\u000a```\u000a\u000a```rust\u000asz: u32\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::ETy\u000a```\u000a\u000a```rust\u000aA { f: T, sz: u32 }\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::ETy\u000a```\u000a\u000a```rust\u000aB { f: T, sz: u32, _a: u64 }\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::ETy\u000a```\u000a\u000a```rust\u000aC { f: T, sz: u32, _count: u32 }\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::Message\u000a```\u000a\u000a```rust\u000aChangeColor(i32, i32, i32)\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::Message\u000a```\u000a\u000a```rust\u000aMove { x: i32, y: i32 }\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::Message\u000a```\u000a\u000a```rust\u000aQuit\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::Message\u000a```\u000a\u000a```rust\u000aWrite(String)\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::Move\u000a```\u000a\u000a```rust\u000ax: i32\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::Move\u000a```\u000a\u000a```rust\u000ay: i32\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::P\u000a```\u000a\u000a```rust\u000ax: i32\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::P\u000a```\u000a\u000a```rust\u000ay: i32\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::Person\u000a```\u000a\u000a```rust\u000abirth: i32\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::Person\u000a```\u000a\u000a```rust\u000aname: String\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::S\u000a```\u000a\u000a```rust\u000ar: &i32\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::S\u000a```\u000a\u000a```rust\u000ax: &i32\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::S\u000a```\u000a\u000a```rust\u000ay: &i32\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::T\u000a```\u000a\u000a```rust\u000aels: Vec<String>\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::T\u000a```\u000a\u000a```rust\u000afn findl_by_prefix(&self, prefix: &str) -> Option<&String>\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::T\u000a```\u000a\u000a```rust\u000as: S\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::U\u000a```\u000a\u000a```rust\u000ax: &i32\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::U\u000a```\u000a\u000a```rust\u000ay: &i32\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::bintree\u000a```\u000a\u000a```rust\u000aenum Tree<'a, T>\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::bintree\u000a```\u000a\u000a```rust\u000afn count<T>(t: &Tree<T>) -> usize\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::bintree\u000a```\u000a\u000a```rust\u000afn into_iter(self) -> Self::IntoIter\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::bintree\u000a```\u000a\u000a```rust\u000afn make_node<'a, T>(left: &'a Tree<'a, T>, e: T, right: &'a Tree<'a, T>) -> Tree<'a, T>\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::bintree\u000a```\u000a\u000a```rust\u000apub fn main()\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::bintree\u000a```\u000a\u000a```rust\u000astruct Node<'a, T>\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::bintree\u000a```\u000a\u000a```rust\u000astruct TreeIter<'a, T>\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::bintree\u000a```\u000a\u000a```rust\u000atype IntoIter = TreeIter<'a, T>\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::bintree\u000a```\u000a\u000a```rust\u000atype Item = &'a T\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::bintree::Node\u000a```\u000a\u000a```rust\u000ae: T\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::bintree::Node\u000a```\u000a\u000a```rust\u000aleft: &Tree<T>\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::bintree::Node\u000a```\u000a\u000a```rust\u000aright: &Tree<T>\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::bintree::Tree\u000a```\u000a\u000a```rust\u000aEmpty\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::bintree::Tree\u000a```\u000a\u000a```rust\u000aNonEmpty(Node<'a, T>)\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::bintree::Tree\u000a```\u000a\u000a```rust\u000afn iter(&self) -> TreeIter<T>\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::bintree::TreeIter\u000a```\u000a\u000a```rust\u000afn next(&mut self) -> Option<&'a T>\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::bintree::TreeIter\u000a```\u000a\u000a```rust\u000afn push_left_edge(&mut self, tree: &'a Tree<T>)\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::bintree::TreeIter\u000a```\u000a\u000a```rust\u000aunvisited: Vec<&Node<T>>\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::bounds\u000a```\u000a\u000a```rust\u000afn dot<N>(v1: &[N], v2: &[N]) -> N\u000awhere\u000a    N: Copy + Mul<Output = N> + Add<Output = N> + Default,\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::bounds\u000a```\u000a\u000a```rust\u000apub fn main()\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::break\u000a```\u000a\u000a```rust\u000apub fn break_main()\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::closures\u000a```\u000a\u000a```rust\u000afn sort_s_pure(c: &[S]) -> Vec<S>\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::closures\u000a```\u000a\u000a```rust\u000afn start_sorting_thread(cs: Vec<S>, x: i64) -> thread::JoinHandle<Vec<S>>\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::closures\u000a```\u000a\u000a```rust\u000apub fn main()\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::closures\u000a```\u000a\u000a```rust\u000astruct S\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::closures::S\u000a```\u000a\u000a```rust\u000aa: String\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::closures::S\u000a```\u000a\u000a```rust\u000ab: i64\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::closures::S\u000a```\u000a\u000a```rust\u000ac: String\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::collect\u000a```\u000a\u000a```rust\u000afn ref_1()\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::collect\u000a```\u000a\u000a```rust\u000afn ref_2()\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::collect\u000a```\u000a\u000a```rust\u000afn ref_3(b: bool)\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::collect\u000a```\u000a\u000a```rust\u000afn ref_4()\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::collect\u000a```\u000a\u000a```rust\u000afn show(t: &Table)\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::collect\u000a```\u000a\u000a```rust\u000afn sort_works(t: &mut Table)\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::collect\u000a```\u000a\u000a```rust\u000apub fn main()\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::collect\u000a```\u000a\u000a```rust\u000atype Table = HashMap<String, Vec<String>>\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::collect1\u000a```\u000a\u000a```rust\u000apub fn main()\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::enum\u000a```\u000a\u000a```rust\u000aenum A\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::enum\u000a```\u000a\u000a```rust\u000aenum O\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::enum\u000a```\u000a\u000a```rust\u000aenum Tree<T>\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::enum\u000a```\u000a\u000a```rust\u000afn empty<T>() -> Tree<T>\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::enum\u000a```\u000a\u000a```rust\u000afn single<T>(e: T) -> Tree<T>\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::enum\u000a```\u000a\u000a```rust\u000apub fn main()\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::enum\u000a```\u000a\u000a```rust\u000astruct Node<T>\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::enum2\u000a```\u000a\u000a```rust\u000aenum Tree<T>\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::enum2\u000a```\u000a\u000a```rust\u000afn add<T>(t: Tree<T>, v: T) -> Tree<T>\u000awhere\u000a    T: Ord,\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::enum2\u000a```\u000a\u000a```rust\u000afn empty<T>() -> Tree<T>\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::enum2\u000a```\u000a\u000a```rust\u000afn single<T>(e: T) -> Tree<T>\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::enum2\u000a```\u000a\u000a```rust\u000apub fn main()\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::enum2\u000a```\u000a\u000a```rust\u000astruct Node<T>\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::enum2::Node\u000a```\u000a\u000a```rust\u000aelement: T\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::enum2::Node\u000a```\u000a\u000a```rust\u000aleft: Tree<T>\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::enum2::Node\u000a```\u000a\u000a```rust\u000aright: Tree<T>\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::enum2::Tree\u000a```\u000a\u000a```rust\u000aEmpty\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::enum2::Tree\u000a```\u000a\u000a```rust\u000aFull(Box<Node<T>>)\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::enum2::Tree\u000a```\u000a\u000a```rust\u000afn add_mut(&mut self, v: T)\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::enum::A\u000a```\u000a\u000a```rust\u000aF(Option<String>)\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::enum::A\u000a```\u000a\u000a```rust\u000aG { left: u32, right: u32 }\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::enum::A\u000a```\u000a\u000a```rust\u000aX\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::enum::A\u000a```\u000a\u000a```rust\u000aZ\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::enum::G\u000a```\u000a\u000a```rust\u000aleft: u32\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::enum::G\u000a```\u000a\u000a```rust\u000aright: u32\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::enum::Node\u000a```\u000a\u000a```rust\u000aelement: T\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::enum::Node\u000a```\u000a\u000a```rust\u000aleft: Tree<T>\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::enum::Node\u000a```\u000a\u000a```rust\u000aright: Tree<T>\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::enum::O\u000a```\u000a\u000a```rust\u000aEQ_\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::enum::O\u000a```\u000a\u000a```rust\u000aGT_\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::enum::O\u000a```\u000a\u000a```rust\u000aLT_\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::enum::O\u000a```\u000a\u000a```rust\u000afn compare_(n: i32, m: i32) -> O\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::enum::O\u000a```\u000a\u000a```rust\u000afn i32_to_maybe_o(n: i32) -> Option<O>\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::enum::Tree\u000a```\u000a\u000a```rust\u000aEmpty\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::enum::Tree\u000a```\u000a\u000a```rust\u000aFull(Box<Node<T>>)\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::expr\u000a```\u000a\u000a```rust\u000aconst FOO: u64 = 3735928559 (0xDEADBEEF)\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::expr\u000a```\u000a\u000a```rust\u000afn undefined() -> !\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::expr\u000a```\u000a\u000a```rust\u000apub fn main()\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::expr2\u000a```\u000a\u000a```rust\u000apub fn main()\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::foo\u000a```\u000a\u000a```rust\u000afn main()\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::foo\u000a```\u000a\u000a```rust\u000afn new_secret_foo(deep_foo: u64) -> Foo\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::foo\u000a```\u000a\u000a```rust\u000apub fn new_foo(deep_foo: u64) -> Foo\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::foo\u000a```\u000a\u000a```rust\u000apub struct Foo\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::foo::Foo\u000a```\u000a\u000a```rust\u000adeep_foo: u64\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::generics\u000a```\u000a\u000a```rust\u000afn min<T>(a: T, b: T) -> T\u000awhere\u000a    T: Ord,\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::generics\u000a```\u000a\u000a```rust\u000apub fn elem<P>(vec: &[P], x: P) -> bool\u000awhere\u000a    P: PartialEq,\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::generics\u000a```\u000a\u000a```rust\u000apub fn ex1()\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::generics\u000a```\u000a\u000a```rust\u000apub fn main()\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::impl\u000a```\u000a\u000a```rust\u000apub fn main()\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::impl\u000a```\u000a\u000a```rust\u000apub struct Q\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::impl2\u000a```\u000a\u000a```rust\u000afn find_e<'s>(slice: &'s [i32]) -> E\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::impl2\u000a```\u000a\u000a```rust\u000apub fn is_empty_q<T>(q: &Q<T>) -> bool\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::impl2\u000a```\u000a\u000a```rust\u000apub fn main()\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::impl2\u000a```\u000a\u000a```rust\u000apub fn new_q<T>() -> Q<T>\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::impl2\u000a```\u000a\u000a```rust\u000apub fn push_q<T>(q: &mut Q<T>, t: T)\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::impl2\u000a```\u000a\u000a```rust\u000apub struct Q<T>\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::impl2\u000a```\u000a\u000a```rust\u000astruct E<'e>\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::impl2\u000a```\u000a\u000a```rust\u000astruct P<T>\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::impl2::E\u000a```\u000a\u000a```rust\u000abiggest: &i32\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::impl2::E\u000a```\u000a\u000a```rust\u000asmallest: &i32\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::impl2::P\u000a```\u000a\u000a```rust\u000ax: T\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::impl2::P\u000a```\u000a\u000a```rust\u000ay: T\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::impl2::Q\u000a```\u000a\u000a```rust\u000aleft: Vec<T>\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::impl2::Q\u000a```\u000a\u000a```rust\u000apub fn is_empty(&self) -> bool\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::impl2::Q\u000a```\u000a\u000a```rust\u000apub fn new() -> Self\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::impl2::Q\u000a```\u000a\u000a```rust\u000apub fn push(&mut self, t: T)\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::impl2::Q\u000a```\u000a\u000a```rust\u000aright: Vec<T>\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::impl::Q\u000a```\u000a\u000a```rust\u000anew: Vec<char>\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::impl::Q\u000a```\u000a\u000a```rust\u000aold: Vec<char>\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::impl::Q\u000a```\u000a\u000a```rust\u000apub fn is_empty(&self) -> bool\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::impl::Q\u000a```\u000a\u000a```rust\u000apub fn pop(&mut self) -> Option<char>\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::impl::Q\u000a```\u000a\u000a```rust\u000apub fn push(&mut self, c: char)\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::impl::Q\u000a```\u000a\u000a```rust\u000apub fn split(self) -> (Vec<char>, Vec<char>)\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::io\u000a```\u000a\u000a```rust\u000aconst DEFAULT_BUF_SIZE: usize = 8192 (0x2000)\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::io\u000a```\u000a\u000a```rust\u000apub fn copy<R, W>(reader: &mut R, writer: &mut W) -> io::Result<u64>\u000awhere\u000a    R: ?Sized,\u000a    W: ?Sized,\u000a    R: Read,\u000a    W: Write,\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::io\u000a```\u000a\u000a```rust\u000apub fn main()\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::json\u000a```\u000a\u000a```rust\u000aconst COMMA: &str = &r#\",\"#\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::json\u000a```\u000a\u000a```rust\u000aconst DOUBLE_QUOTE: &str = &r#\"\"\"#\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::json\u000a```\u000a\u000a```rust\u000aconst LEFT_BRACE: &str = &r#\"{\"#\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::json\u000a```\u000a\u000a```rust\u000aconst LEFT_BRACKET: &str = &r#\"[\"#\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::json\u000a```\u000a\u000a```rust\u000aconst RIGHT_BRACE: &str = &r#\"}\"#\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::json\u000a```\u000a\u000a```rust\u000aconst RIGHT_BRACKET: &str = &r#\"]\"#\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::json\u000a```\u000a\u000a```rust\u000afn braces(d: R<()>) -> R<()>\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::json\u000a```\u000a\u000a```rust\u000afn brackets(d: R<()>) -> R<()>\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::json\u000a```\u000a\u000a```rust\u000afn double_quotes(d: R<()>) -> R<()>\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::json\u000a```\u000a\u000a```rust\u000afn pp_array(vs: &[JSValue]) -> R<()>\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::json\u000a```\u000a\u000a```rust\u000afn pp_bool<'a>(v: bool) -> R<'a, ()>\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::json\u000a```\u000a\u000a```rust\u000afn pp_char<'a>(c: char) -> R<'a, ()>\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::json\u000a```\u000a\u000a```rust\u000afn pp_field(_: &(JSLabel, JSValue)) -> R<()>\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::json\u000a```\u000a\u000a```rust\u000afn pp_null<'a>() -> R<'a, ()>\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::json\u000a```\u000a\u000a```rust\u000afn pp_number<'a>(x: Rational64) -> R<'a, ()>\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::json\u000a```\u000a\u000a```rust\u000afn pp_object(vs: &[(JSLabel, JSValue)]) -> R<()>\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::json\u000a```\u000a\u000a```rust\u000afn pp_string(s: &str) -> R<()>\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::json\u000a```\u000a\u000a```rust\u000afn pp_value(v: &JSValue) -> R<()>\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::json\u000a```\u000a\u000a```rust\u000apub enum JSValue\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::json\u000a```\u000a\u000a```rust\u000apub fn main()\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::json\u000a```\u000a\u000a```rust\u000apub struct JSLabel\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::json::JSValue\u000a```\u000a\u000a```rust\u000aJSArray(Vec<JSValue>)\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::json::JSValue\u000a```\u000a\u000a```rust\u000aJSBool(bool)\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::json::JSValue\u000a```\u000a\u000a```rust\u000aJSNull\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::json::JSValue\u000a```\u000a\u000a```rust\u000aJSObject(Vec<(JSLabel, JSValue)>)\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::json::JSValue\u000a```\u000a\u000a```rust\u000aJSRational(Rational64)\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::json::JSValue\u000a```\u000a\u000a```rust\u000aJSString(String)\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::json::JSValue\u000a```\u000a\u000a```rust\u000apub fn to_doc(&self) -> R<()>\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::json::JSValue\u000a```\u000a\u000a```rust\u000apub fn to_pretty(&self, width: usize) -> String\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::lib\u000a```\u000a\u000a```rust\u000apub fn sum_f1(n: u64) -> u64\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::lib\u000a```\u000a\u000a```rust\u000apub fn sum_f2(n: u64) -> u64\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::lib\u000a```\u000a\u000a```rust\u000apub fn sum_f3(n: u64) -> u64\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::mod2\u000a```\u000a\u000a```rust\u000amod m\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::mod2\u000a```\u000a\u000a```rust\u000apub fn main()\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::mod2::m\u000a```\u000a\u000a```rust\u000apub enum E<T>\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::mod2::m\u000a```\u000a\u000a```rust\u000apub enum Tree<'a, T>\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::mod2::m\u000a```\u000a\u000a```rust\u000apub fn mk_e_v() -> E<u64>\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::mod2::m\u000a```\u000a\u000a```rust\u000apub fn mk_one_node<'a, T>(v: T) -> Tree<'a, T>\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::mod2::m\u000a```\u000a\u000a```rust\u000apub static EMPTY_TREE: Tree<u64> = Tree::Empty\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::mod2::m\u000a```\u000a\u000a```rust\u000apub struct U<T>\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::mod2::m\u000a```\u000a\u000a```rust\u000apub struct V<T>\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::mod2::m::E\u000a```\u000a\u000a```rust\u000aEV(V<T>)\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::mod2::m::E\u000a```\u000a\u000a```rust\u000a_EU(U<T>)\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::mod2::m::Node\u000a```\u000a\u000a```rust\u000apub left: &Tree<T>\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::mod2::m::Node\u000a```\u000a\u000a```rust\u000apub right: &Tree<T>\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::mod2::m::Node\u000a```\u000a\u000a```rust\u000apub value: T\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::mod2::m::Tree\u000a```\u000a\u000a```rust\u000aEmpty\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::mod2::m::Tree\u000a```\u000a\u000a```rust\u000aNode { left: &'a Tree<'a, T>, right: &'a Tree<'a, T>, value: T }\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::mod2::m::U\u000a```\u000a\u000a```rust\u000au: T\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::mod2::m::V\u000a```\u000a\u000a```rust\u000av: T\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::modules\u000a```\u000a\u000a```rust\u000amod m\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::modules\u000a```\u000a\u000a```rust\u000apub fn main()\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::modules\u000a```\u000a\u000a```rust\u000apub struct A\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::modules::A\u000a```\u000a\u000a```rust\u000aa: u64\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::modules::m\u000a```\u000a\u000a```rust\u000apub fn new_a(a: u64) -> A\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::mutable\u000a```\u000a\u000a```rust\u000afn mk_spider() -> Result<Spider, std::io::Error>\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::mutable\u000a```\u000a\u000a```rust\u000apub fn main()\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::mutable\u000a```\u000a\u000a```rust\u000apub struct Spider\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::mutable::Spider\u000a```\u000a\u000a```rust\u000aerr_count: RefCell<u32>\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::mutable::Spider\u000a```\u000a\u000a```rust\u000alegs: [File; 8]\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::mutable::Spider\u000a```\u000a\u000a```rust\u000aspecies: String\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::mutable::Spider\u000a```\u000a\u000a```rust\u000aweb: bool\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::operators\u000a```\u000a\u000a```rust\u000apub fn main()\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::operators\u000a```\u000a\u000a```rust\u000astruct Complex<T>\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::operators\u000a```\u000a\u000a```rust\u000atype Output = Complex<O>\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::operators\u000a```\u000a\u000a```rust\u000atype Output = Complex<T>\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::operators::Complex\u000a```\u000a\u000a```rust\u000afn add(self, rhs: Complex<R>) -> Self::Output\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::operators::Complex\u000a```\u000a\u000a```rust\u000afn add_assign(&mut self, rhs: Complex<T>)\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::operators::Complex\u000a```\u000a\u000a```rust\u000afn eq(&self, other: &Complex<T>) -> bool\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::operators::Complex\u000a```\u000a\u000a```rust\u000afn neg(self) -> Self::Output\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::operators::Complex\u000a```\u000a\u000a```rust\u000aim: T\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::operators::Complex\u000a```\u000a\u000a```rust\u000are: T\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::ownership\u000a```\u000a\u000a```rust\u000afn boxing() -> String\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::ownership\u000a```\u000a\u000a```rust\u000afn move_thing() -> (Vec<String>, Vec<String>)\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::ownership\u000a```\u000a\u000a```rust\u000afn move_thing1() -> String\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::ownership\u000a```\u000a\u000a```rust\u000afn move_thing2() -> String\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::ownership\u000a```\u000a\u000a```rust\u000afn move_thing3()\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::ownership\u000a```\u000a\u000a```rust\u000afn move_thing4()\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::ownership\u000a```\u000a\u000a```rust\u000afn move_thing5() -> (Option<String>, Vec<Person>)\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::ownership\u000a```\u000a\u000a```rust\u000afn print_padovan()\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::ownership\u000a```\u000a\u000a```rust\u000apub fn main()\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::ownership\u000a```\u000a\u000a```rust\u000astruct Person\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::ownership::Person\u000a```\u000a\u000a```rust\u000abirth: i32\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::ownership::Person\u000a```\u000a\u000a```rust\u000aname: Option<String>\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::panic\u000a```\u000a\u000a```rust\u000afn fix() -> !\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::panic\u000a```\u000a\u000a```rust\u000afn pirate_share(total: u64, crew_size: usize) -> u64\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::panic\u000a```\u000a\u000a```rust\u000apub fn main()\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::pattern\u000a```\u000a\u000a```rust\u000apub fn main()\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::result\u000a```\u000a\u000a```rust\u000afn find(f: &dyn Fn(u8) -> bool, p: &[u8]) -> Option<u8>\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::result\u000a```\u000a\u000a```rust\u000afn find_index(k: &dyn Fn(u8) -> bool, p: &[u8]) -> Option<usize>\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::result\u000a```\u000a\u000a```rust\u000afn get_weather() -> MyBoolResult\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::result\u000a```\u000a\u000a```rust\u000afn get_weather2() -> Result<bool, MyError>\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::result\u000a```\u000a\u000a```rust\u000afn wrapping() -> Result<(), io::Error>\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::result\u000a```\u000a\u000a```rust\u000apub fn main()\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::result\u000a```\u000a\u000a```rust\u000apub struct MyError\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::result\u000a```\u000a\u000a```rust\u000atype MyBoolResult = MyResult<bool>\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::result\u000a```\u000a\u000a```rust\u000atype MyResult = Result<T, io::Error>\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::result::MyError\u000a```\u000a\u000a```rust\u000apub problem: String\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::sharing\u000a```\u000a\u000a```rust\u000apub fn main()\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::struct\u000a```\u000a\u000a```rust\u000afn mk_gsm(w: usize, h: usize) -> GSM\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::struct\u000a```\u000a\u000a```rust\u000afn mk_p(a: usize, b: usize, c: usize) -> P\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::struct\u000a```\u000a\u000a```rust\u000apub fn main()\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::struct\u000a```\u000a\u000a```rust\u000astruct GSM\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::struct\u000a```\u000a\u000a```rust\u000astruct P\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::struct\u000a```\u000a\u000a```rust\u000astruct T\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::struct\u000a```\u000a\u000a```rust\u000astruct U\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::struct::GSM\u000a```\u000a\u000a```rust\u000apixels: Vec<u8>\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::struct::GSM\u000a```\u000a\u000a```rust\u000asize: (usize, usize)\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::struct::P\u000a```\u000a\u000a```rust\u000a1: usize\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::trait\u000a```\u000a\u000a```rust\u000afn is_good(&self) -> bool\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::trait\u000a```\u000a\u000a```rust\u000apub fn main()\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::trait\u000a```\u000a\u000a```rust\u000atrait V\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::trait::V\u000a```\u000a\u000a```rust\u000afn is_good(&self) -> bool\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::types\u000a```\u000a\u000a```rust\u000aconst BIT1: u32 = 8\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::types\u000a```\u000a\u000a```rust\u000aconst BIT2: u32 = 2\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::types\u000a```\u000a\u000a```rust\u000aconst BITS: [u32; 2] = [BIT1, BIT2]\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::types\u000a```\u000a\u000a```rust\u000aconst BITS_N_STRINGS: BitsNStrings<'static> = BitsNStrings {\u000a    mybits: BITS,\u000a    mystring: STRING,\u000a}\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::types\u000a```\u000a\u000a```rust\u000aconst E_EXP_ONE: Expr = Expr::CONST(1)\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::types\u000a```\u000a\u000a```rust\u000aconst E_EXP_TWO: Expr = Expr::CONST(2)\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::types\u000a```\u000a\u000a```rust\u000aconst E_EXP_VAR_X: Expr = Expr::VAR('x')\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::types\u000a```\u000a\u000a```rust\u000aconst STRING: &str = \"bitstring\"\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::types\u000a```\u000a\u000a```rust\u000aconst S_1: &str = \"test 1 2 3\"\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::types\u000a```\u000a\u000a```rust\u000aconst S_2: &str = \"there \\nonce was\"\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::types\u000a```\u000a\u000a```rust\u000aconst S_3: &str = \"this\\n                  is a string\\n                  in complete free form.\\n         \"\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::types\u000a```\u000a\u000a```rust\u000aconst S_4: [u8; 3] = [b'A', b'B', b'C']\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::types\u000a```\u000a\u000a```rust\u000aconst V_ARR_0: [u8; 4] = [0x00,0xe0,0x4c,0x68]\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::types\u000a```\u000a\u000a```rust\u000aconst V_CHAR: char = '\\u{0}'\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::types\u000a```\u000a\u000a```rust\u000aconst V_F32: f32 = 0\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::types\u000a```\u000a\u000a```rust\u000aconst V_F64: f64 = 0\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::types\u000a```\u000a\u000a```rust\u000aconst V_FALSE: bool = false\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::types\u000a```\u000a\u000a```rust\u000aconst V_FN_TY_0: fn() -> u32 = mk_u32_zero\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::types\u000a```\u000a\u000a```rust\u000aconst V_FN_TY_1: fn() -> u32 = || 1\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::types\u000a```\u000a\u000a```rust\u000aconst V_FN_TY_2: fn(u32, u32) -> u32 = |a,b| a*b\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::types\u000a```\u000a\u000a```rust\u000aconst V_I16: i16 = -5\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::types\u000a```\u000a\u000a```rust\u000aconst V_I32: i32 = 16 (0x10)\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::types\u000a```\u000a\u000a```rust\u000aconst V_I64: i64 = 20922789888000000 (0x4A552AA2FC0000)\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::types\u000a```\u000a\u000a```rust\u000aconst V_I8: i8 = 0\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::types\u000a```\u000a\u000a```rust\u000aconst V_ISIZE: isize = 137 (0x89)\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::types\u000a```\u000a\u000a```rust\u000aconst V_REF: &i32 = &V_I32\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::types\u000a```\u000a\u000a```rust\u000aconst V_STRUCT: TyStruct = TyStruct { x: 32., y: 64. }\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::types\u000a```\u000a\u000a```rust\u000aconst V_TRUE: bool = true\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::types\u000a```\u000a\u000a```rust\u000aconst V_TUPLE: (char, u8, i32) = ('x', 42, 256)\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::types\u000a```\u000a\u000a```rust\u000aconst V_TUP_STRUCT: TyTupStruct = TyTupStruct(42, 'f')\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::types\u000a```\u000a\u000a```rust\u000aconst V_U128_1: u128 = 59750332941227774781 (0x33D33D33D3D33D33D)\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::types\u000a```\u000a\u000a```rust\u000aconst V_U16: u16 = 5\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::types\u000a```\u000a\u000a```rust\u000aconst V_U32: u32 = 0\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::types\u000a```\u000a\u000a```rust\u000aconst V_U64: u64 = 0\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::types\u000a```\u000a\u000a```rust\u000aconst V_U64_0: u64 = 18446744073709551615 (0xFFFFFFFFFFFFFFFF)\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::types\u000a```\u000a\u000a```rust\u000aconst V_U8: u8 = 0\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::types\u000a```\u000a\u000a```rust\u000aconst V_UNIT: () = ()\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::types\u000a```\u000a\u000a```rust\u000aconst V_USIZE: usize = 4294966272 (0xFFFFFC00)\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::types\u000a```\u000a\u000a```rust\u000aconst V_Z: Z = Z\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::types\u000a```\u000a\u000a```rust\u000aenum Expr\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::types\u000a```\u000a\u000a```rust\u000aenum X\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::types\u000a```\u000a\u000a```rust\u000aenum Y\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::types\u000a```\u000a\u000a```rust\u000afn mk_3slice(vs: &[u8]) -> &[u8]\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::types\u000a```\u000a\u000a```rust\u000afn mk_exp_eval(e1: Expr, e2: Expr) -> Expr\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::types\u000a```\u000a\u000a```rust\u000afn mk_exp_lam(sym: char, e: Expr) -> Expr\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::types\u000a```\u000a\u000a```rust\u000afn mk_exp_op(op: char, e1: Expr, e2: Expr) -> Expr\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::types\u000a```\u000a\u000a```rust\u000afn mk_suffix(x: char, s: &str) -> String\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::types\u000a```\u000a\u000a```rust\u000afn mk_u32_zero() -> u32\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::types\u000a```\u000a\u000a```rust\u000afn mk_vec(vs: &[u8]) -> Vec<u8>\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::types\u000a```\u000a\u000a```rust\u000afn x() -> Y\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::types\u000a```\u000a\u000a```rust\u000apub fn main()\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::types\u000a```\u000a\u000a```rust\u000astruct BitsNStrings<'a>\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::types\u000a```\u000a\u000a```rust\u000astruct TyStruct\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::types\u000a```\u000a\u000a```rust\u000astruct TyTupStruct\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::types\u000a```\u000a\u000a```rust\u000astruct Z\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::types::BitsNStrings\u000a```\u000a\u000a```rust\u000amybits: [u32; 2]\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::types::BitsNStrings\u000a```\u000a\u000a```rust\u000amystring: &str\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::types::Expr\u000a```\u000a\u000a```rust\u000aCONST(u32)\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::types::Expr\u000a```\u000a\u000a```rust\u000aEVAL(Box<Expr>, Box<Expr>)\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::types::Expr\u000a```\u000a\u000a```rust\u000aLAM(char, Box<Expr>)\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::types::Expr\u000a```\u000a\u000a```rust\u000aPRIM(char, Box<Expr>, Box<Expr>)\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::types::Expr\u000a```\u000a\u000a```rust\u000aVAR(char)\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::types::TyStruct\u000a```\u000a\u000a```rust\u000ax: f32\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::types::TyStruct\u000a```\u000a\u000a```rust\u000ay: f32\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::types::Y\u000a```\u000a\u000a```rust\u000aX\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abasics::types::Y\u000a```\u000a\u000a```rust\u000aZ\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000abool\u000a```\u000a\u000a---\u000a\u000aThe boolean type.\u000a\u000aThe `bool` represents a value, which could only be either `true` or `false`. If you cast\u000aa `bool` into an integer, `true` will be 1 and `false` will be 0.\u000a\u000a# Basic usage\u000a\u000a`bool` implements various traits, such as [`BitAnd`], [`BitOr`], [`Not`], etc.,\u000awhich allow us to perform boolean operations using `&`, `|` and `!`.\u000a\u000a`if` always demands a `bool` value. [`assert!`](`assert!`), which is an important macro in testing,\u000achecks whether an expression returns `true` and panics if it isn't.\u000a\u000a```rust\u000alet bool_val = true & false | false;\u000aassert!(!bool_val);\u000a```\u000a\u000a# Examples\u000a\u000aA trivial example of the usage of `bool`,\u000a\u000a```rust\u000alet praise_the_borrow_checker = true;\u000a\u000a// using the `if` conditional\u000aif praise_the_borrow_checker {\u000a    println!(\"oh, yeah!\");\u000a} else {\u000a    println!(\"what?!!\");\u000a}\u000a\u000a// ... or, a match pattern\u000amatch praise_the_borrow_checker {\u000a    true => println!(\"keep praising!\"),\u000a    false => println!(\"you should praise!\"),\u000a}\u000a```\u000a\u000aAlso, since `bool` implements the [`Copy`](`Copy`) trait, we don't\u000ahave to worry about the move semantics (just like the integer and float primitives).\u000a\u000aNow an example of `bool` cast to integer type:\u000a\u000a```rust\u000aassert_eq!(true as i32, 1);\u000aassert_eq!(false as i32, 0);\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000ac: &S\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000ac: &[S]\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000ac: char\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000ac: usize\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000achar\u000a```\u000a\u000a---\u000a\u000aA character type.\u000a\u000aThe `char` type represents a single character. More specifically, since\u000a'character' isn't a well-defined concept in Unicode, `char` is a '[Unicode\u000ascalar value]', which is similar to, but not the same as, a '[Unicode code\u000apoint]'.\u000a\u000aThis documentation describes a number of methods and trait implementations on the\u000a`char` type. For technical reasons, there is additional, separate\u000adocumentation in [the `std::char` module](char/index.html) as well.\u000a\u000a# Representation\u000a\u000a`char` is always four bytes in size. This is a different representation than\u000aa given character would have as part of a [`String`]. For example:\u000a\u000a```rust\u000alet v = vec!['h', 'e', 'l', 'l', 'o'];\u000a\u000a// five elements times four bytes for each element\u000aassert_eq!(20, v.len() * std::mem::size_of::<char>());\u000a\u000alet s = String::from(\"hello\");\u000a\u000a// five elements times one byte per element\u000aassert_eq!(5, s.len() * std::mem::size_of::<u8>());\u000a```\u000a\u000aAs always, remember that a human intuition for 'character' may not map to\u000aUnicode's definitions. For example, despite looking similar, the 'Ã©'\u000acharacter is one Unicode code point while 'eÌ' is two Unicode code points:\u000a\u000a```rust\u000alet mut chars = \"Ã©\".chars();\u000a// U+00e9: 'latin small letter e with acute'\u000aassert_eq!(Some('\\u{00e9}'), chars.next());\u000aassert_eq!(None, chars.next());\u000a\u000alet mut chars = \"eÌ\".chars();\u000a// U+0065: 'latin small letter e'\u000aassert_eq!(Some('\\u{0065}'), chars.next());\u000a// U+0301: 'combining acute accent'\u000aassert_eq!(Some('\\u{0301}'), chars.next());\u000aassert_eq!(None, chars.next());\u000a```\u000a\u000aThis means that the contents of the first string above *will* fit into a\u000a`char` while the contents of the second string *will not*. Trying to create\u000aa `char` literal with the contents of the second string gives an error:\u000a\u000a```text\u000aerror: character literal may only contain one codepoint: 'eÌ'\u000alet c = 'eÌ';\u000a        ^^^\u000a```\u000a\u000aAnother implication of the 4-byte fixed size of a `char` is that\u000aper-`char` processing can end up using a lot more memory:\u000a\u000a```rust\u000alet s = String::from(\"love: â¤ï¸\");\u000alet v: Vec<char> = s.chars().collect();\u000a\u000aassert_eq!(12, std::mem::size_of_val(&s[..]));\u000aassert_eq!(32, std::mem::size_of_val(&v[..]));\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000acore\u000a```\u000a\u000a```rust\u000amod cell\u000a```\u000a\u000a---\u000a\u000aShareable mutable containers.\u000a\u000aRust memory safety is based on this rule: Given an object `T`, it is only possible to\u000ahave one of the following:\u000a\u000a* Having several immutable references (`&T`) to the object (also known as **aliasing**).\u000a* Having one mutable reference (`&mut T`) to the object (also known as **mutability**).\u000a\u000aThis is enforced by the Rust compiler. However, there are situations where this rule is not\u000aflexible enough. Sometimes it is required to have multiple references to an object and yet\u000amutate it.\u000a\u000aShareable mutable containers exist to permit mutability in a controlled manner, even in the\u000apresence of aliasing. Both `Cell<T>` and `RefCell<T>` allow doing this in a single-threaded\u000away. However, neither `Cell<T>` nor `RefCell<T>` are thread safe (they do not implement\u000a`Sync`). If you need to do aliasing and mutation between multiple threads it is possible to\u000ause [`Mutex`](https://doc.rust-lang.org/nightly/std/sync/struct.Mutex.html),\u000a[`RwLock`](https://doc.rust-lang.org/nightly/std/sync/struct.RwLock.html) or\u000a[`atomic`](https://doc.rust-lang.org/nightly/core/sync/atomic/index.html) types.\u000a\u000aValues of the `Cell<T>` and `RefCell<T>` types may be mutated through shared references (i.e.\u000athe common `&T` type), whereas most Rust types can only be mutated through unique (`&mut T`)\u000areferences. We say that `Cell<T>` and `RefCell<T>` provide 'interior mutability', in contrast\u000awith typical Rust types that exhibit 'inherited mutability'.\u000a\u000aCell types come in two flavors: `Cell<T>` and `RefCell<T>`. `Cell<T>` implements interior\u000amutability by moving values in and out of the `Cell<T>`. To use references instead of values,\u000aone must use the `RefCell<T>` type, acquiring a write lock before mutating. `Cell<T>` provides\u000amethods to retrieve and change the current interior value:\u000a\u000a* For types that implement `Copy`, the `get` method retrieves the current interior value.\u000a* For types that implement `Default`, the `take` method replaces the current interior value\u000a  with `Default::default()` and returns the replaced value.\u000a* For all types, the `replace` method replaces the current interior value and returns the\u000a  replaced value and the `into_inner` method consumes the `Cell<T>` and returns the interior\u000a  value. Additionally, the `set` method replaces the interior value, dropping the replaced\u000a  value.\u000a\u000a`RefCell<T>` uses Rust's lifetimes to implement 'dynamic borrowing', a process whereby one can\u000aclaim temporary, exclusive, mutable access to the inner value. Borrows for `RefCell<T>`s are\u000atracked 'at runtime', unlike Rust's native reference types which are entirely tracked\u000astatically, at compile time. Because `RefCell<T>` borrows are dynamic it is possible to attempt\u000ato borrow a value that is already mutably borrowed; when this happens it results in thread\u000apanic.\u000a\u000a# When to choose interior mutability\u000a\u000aThe more common inherited mutability, where one must have unique access to mutate a value, is\u000aone of the key language elements that enables Rust to reason strongly about pointer aliasing,\u000astatically preventing crash bugs. Because of that, inherited mutability is preferred, and\u000ainterior mutability is something of a last resort. Since cell types enable mutation where it\u000awould otherwise be disallowed though, there are occasions when interior mutability might be\u000aappropriate, or even *must* be used, e.g.\u000a\u000a* Introducing mutability 'inside' of something immutable\u000a* Implementation details of logically-immutable methods.\u000a* Mutating implementations of `Clone`.\u000a\u000a## Introducing mutability 'inside' of something immutable\u000a\u000aMany shared smart pointer types, including `Rc<T>` and `Arc<T>`, provide containers that can be\u000acloned and shared between multiple parties. Because the contained values may be\u000amultiply-aliased, they can only be borrowed with `&`, not `&mut`. Without cells it would be\u000aimpossible to mutate data inside of these smart pointers at all.\u000a\u000aIt's very common then to put a `RefCell<T>` inside shared pointer types to reintroduce\u000amutability:\u000a\u000a```rust\u000ause std::cell::{RefCell, RefMut};\u000ause std::collections::HashMap;\u000ause std::rc::Rc;\u000a\u000afn main() {\u000a    let shared_map: Rc<RefCell<_>> = Rc::new(RefCell::new(HashMap::new()));\u000a    // Create a new block to limit the scope of the dynamic borrow\u000a    {\u000a        let mut map: RefMut<_> = shared_map.borrow_mut();\u000a        map.insert(\"africa\", 92388);\u000a        map.insert(\"kyoto\", 11837);\u000a        map.insert(\"piccadilly\", 11826);\u000a        map.insert(\"marbles\", 38);\u000a    }\u000a\u000a    // Note that if we had not let the previous borrow of the cache fall out\u000a    // of scope then the subsequent borrow would cause a dynamic thread panic.\u000a    // This is the major hazard of using `RefCell`.\u000a    let total: i32 = shared_map.borrow().values().sum();\u000a    println!(\"{}\", total);\u000a}\u000a```\u000a\u000aNote that this example uses `Rc<T>` and not `Arc<T>`. `RefCell<T>`s are for single-threaded\u000ascenarios. Consider using `RwLock<T>` or `Mutex<T>` if you need shared mutability in a\u000amulti-threaded situation.\u000a\u000a## Implementation details of logically-immutable methods\u000a\u000aOccasionally it may be desirable not to expose in an API that there is mutation happening\u000a\"under the hood\". This may be because logically the operation is immutable, but e.g., caching\u000aforces the implementation to perform mutation; or because you must employ mutation to implement\u000aa trait method that was originally defined to take `&self`.\u000a\u000a```rust\u000ause std::cell::RefCell;\u000a\u000astruct Graph {\u000a    edges: Vec<(i32, i32)>,\u000a    span_tree_cache: RefCell<Option<Vec<(i32, i32)>>>\u000a}\u000a\u000aimpl Graph {\u000a    fn minimum_spanning_tree(&self) -> Vec<(i32, i32)> {\u000a        self.span_tree_cache.borrow_mut()\u000a            .get_or_insert_with(|| self.calc_span_tree())\u000a            .clone()\u000a    }\u000a\u000a    fn calc_span_tree(&self) -> Vec<(i32, i32)> {\u000a        // Expensive computation goes here\u000a        vec![]\u000a    }\u000a}\u000a```\u000a\u000a## Mutating implementations of `Clone`\u000a\u000aThis is simply a special - but common - case of the previous: hiding mutability for operations\u000athat appear to be immutable. The `clone` method is expected to not change the source value, and\u000ais declared to take `&self`, not `&mut self`. Therefore, any mutation that happens in the\u000a`clone` method must use cell types. For example, `Rc<T>` maintains its reference counts within a\u000a`Cell<T>`.\u000a\u000a```rust\u000ause std::cell::Cell;\u000ause std::ptr::NonNull;\u000ause std::process::abort;\u000ause std::marker::PhantomData;\u000a\u000astruct Rc<T: ?Sized> {\u000a    ptr: NonNull<RcBox<T>>,\u000a    phantom: PhantomData<RcBox<T>>,\u000a}\u000a\u000astruct RcBox<T: ?Sized> {\u000a    strong: Cell<usize>,\u000a    refcount: Cell<usize>,\u000a    value: T,\u000a}\u000a\u000aimpl<T: ?Sized> Clone for Rc<T> {\u000a    fn clone(&self) -> Rc<T> {\u000a        self.inc_strong();\u000a        Rc {\u000a            ptr: self.ptr,\u000a            phantom: PhantomData,\u000a        }\u000a    }\u000a}\u000a\u000atrait RcBoxPtr<T: ?Sized> {\u000a\u000a    fn inner(&self) -> &RcBox<T>;\u000a\u000a    fn strong(&self) -> usize {\u000a        self.inner().strong.get()\u000a    }\u000a\u000a    fn inc_strong(&self) {\u000a        self.inner()\u000a            .strong\u000a            .set(self.strong()\u000a                     .checked_add(1)\u000a                     .unwrap_or_else(|| abort() ));\u000a    }\u000a}\u000a\u000aimpl<T: ?Sized> RcBoxPtr<T> for Rc<T> {\u000a   fn inner(&self) -> &RcBox<T> {\u000a       unsafe {\u000a           self.ptr.as_ref()\u000a       }\u000a   }\u000a}\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000acore\u000a```\u000a\u000a```rust\u000amod char\u000a```\u000a\u000a---\u000a\u000aA character type.\u000a\u000aThe `char` type represents a single character. More specifically, since\u000a'character' isn't a well-defined concept in Unicode, `char` is a '[Unicode\u000ascalar value]', which is similar to, but not the same as, a '[Unicode code\u000apoint]'.\u000a\u000aThis module exists for technical reasons, the primary documentation for\u000a`char` is directly on [the `char` primitive type](https://doc.rust-lang.org/nightly/std/primitive.char.html)\u000aitself.\u000a\u000aThis module is the home of the iterator implementations for the iterators\u000aimplemented on `char`, as well as some useful constants and conversion\u000afunctions that convert various types to `char`."
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000acore\u000a```\u000a\u000a```rust\u000amod cmp\u000a```\u000a\u000a---\u000a\u000aFunctionality for ordering and comparison.\u000a\u000aThis module contains various tools for ordering and comparing values. In\u000asummary:\u000a\u000a* [`Eq`](https://doc.rust-lang.org/nightly/core/cmp/trait.Eq.html) and [`PartialEq`](https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html) are traits that allow you to define total and\u000a  partial equality between values, respectively. Implementing them overloads\u000a  the `==` and `!=` operators.\u000a* [`Ord`](https://doc.rust-lang.org/nightly/core/cmp/trait.Ord.html) and [`PartialOrd`](https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html) are traits that allow you to define total and\u000a  partial orderings between values, respectively. Implementing them overloads\u000a  the `<`, `<=`, `>`, and `>=` operators.\u000a* [`Ordering`](https://doc.rust-lang.org/nightly/core/cmp/enum.Ordering.html) is an enum returned by the main functions of [`Ord`](https://doc.rust-lang.org/nightly/core/cmp/trait.Ord.html) and\u000a  [`PartialOrd`](https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html), and describes an ordering.\u000a* [`Reverse`](https://doc.rust-lang.org/nightly/core/cmp/struct.Reverse.html) is a struct that allows you to easily reverse an ordering.\u000a* [`max`] and [`min`] are functions that build off of [`Ord`](https://doc.rust-lang.org/nightly/core/cmp/trait.Ord.html) and allow you\u000a  to find the maximum or minimum of two values.\u000a\u000aFor more details, see the respective documentation of each item in the list."
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000acore\u000a```\u000a\u000a```rust\u000amod mem\u000a```\u000a\u000a---\u000a\u000aBasic functions for dealing with memory.\u000a\u000aThis module contains functions for querying the size and alignment of\u000atypes, initializing and manipulating memory."
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000acore\u000a```\u000a\u000a```rust\u000amod ops\u000a```\u000a\u000a---\u000a\u000aOverloadable operators.\u000a\u000aImplementing these traits allows you to overload certain operators.\u000a\u000aSome of these traits are imported by the prelude, so they are available in\u000aevery Rust program. Only operators backed by traits can be overloaded. For\u000aexample, the addition operator (`+`) can be overloaded through the [`Add`](https://doc.rust-lang.org/nightly/core/ops/arith/trait.Add.html)\u000atrait, but since the assignment operator (`=`) has no backing trait, there\u000ais no way of overloading its semantics. Additionally, this module does not\u000aprovide any mechanism to create new operators. If traitless overloading or\u000acustom operators are required, you should look toward macros or compiler\u000aplugins to extend Rust's syntax.\u000a\u000aImplementations of operator traits should be unsurprising in their\u000arespective contexts, keeping in mind their usual meanings and\u000a[operator precedence]. For example, when implementing [`Mul`](https://doc.rust-lang.org/nightly/core/ops/arith/trait.Mul.html), the operation\u000ashould have some resemblance to multiplication (and share expected\u000aproperties like associativity).\u000a\u000aNote that the `&&` and `||` operators short-circuit, i.e., they only\u000aevaluate their second operand if it contributes to the result. Since this\u000abehavior is not enforceable by traits, `&&` and `||` are not supported as\u000aoverloadable operators.\u000a\u000aMany of the operators take their operands by value. In non-generic\u000acontexts involving built-in types, this is usually not a problem.\u000aHowever, using these operators in generic code, requires some\u000aattention if values have to be reused as opposed to letting the operators\u000aconsume them. One option is to occasionally use [`clone`].\u000aAnother option is to rely on the types involved providing additional\u000aoperator implementations for references. For example, for a user-defined\u000atype `T` which is supposed to support addition, it is probably a good\u000aidea to have both `T` and `&T` implement the traits [`Add<T>`](https://doc.rust-lang.org/nightly/core/ops/arith/trait.Add.html) and\u000a[`Add<&T>`](https://doc.rust-lang.org/nightly/core/ops/arith/trait.Add.html) so that generic code can be written without unnecessary\u000acloning.\u000a\u000a# Examples\u000a\u000aThis example creates a `Point` struct that implements [`Add`](https://doc.rust-lang.org/nightly/core/ops/arith/trait.Add.html) and [`Sub`](https://doc.rust-lang.org/nightly/core/ops/arith/trait.Sub.html),\u000aand then demonstrates adding and subtracting two `Point`s.\u000a\u000a```rust\u000ause std::ops::{Add, Sub};\u000a\u000a#[derive(Debug, Copy, Clone, PartialEq)]\u000astruct Point {\u000a    x: i32,\u000a    y: i32,\u000a}\u000a\u000aimpl Add for Point {\u000a    type Output = Self;\u000a\u000a    fn add(self, other: Self) -> Self {\u000a        Self {x: self.x + other.x, y: self.y + other.y}\u000a    }\u000a}\u000a\u000aimpl Sub for Point {\u000a    type Output = Self;\u000a\u000a    fn sub(self, other: Self) -> Self {\u000a        Self {x: self.x - other.x, y: self.y - other.y}\u000a    }\u000a}\u000a\u000aassert_eq!(Point {x: 3, y: 3}, Point {x: 1, y: 0} + Point {x: 2, y: 3});\u000aassert_eq!(Point {x: -1, y: -3}, Point {x: 1, y: 0} - Point {x: 2, y: 3});\u000a```\u000a\u000aSee the documentation for each trait for an example implementation.\u000a\u000aThe [`Fn`](https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html), [`FnMut`](https://doc.rust-lang.org/nightly/core/ops/function/trait.FnMut.html), and [`FnOnce`](https://doc.rust-lang.org/nightly/core/ops/function/trait.FnOnce.html) traits are implemented by types that can be\u000ainvoked like functions. Note that [`Fn`](https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html) takes `&self`, [`FnMut`](https://doc.rust-lang.org/nightly/core/ops/function/trait.FnMut.html) takes `&mut self` and [`FnOnce`](https://doc.rust-lang.org/nightly/core/ops/function/trait.FnOnce.html) takes `self`. These correspond to the three kinds of\u000amethods that can be invoked on an instance: call-by-reference,\u000acall-by-mutable-reference, and call-by-value. The most common use of these\u000atraits is to act as bounds to higher-level functions that take functions or\u000aclosures as arguments.\u000a\u000aTaking a [`Fn`](https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html) as a parameter:\u000a\u000a```rust\u000afn call_with_one<F>(func: F) -> usize\u000a    where F: Fn(usize) -> usize\u000a{\u000a    func(1)\u000a}\u000a\u000alet double = |x| x * 2;\u000aassert_eq!(call_with_one(double), 2);\u000a```\u000a\u000aTaking a [`FnMut`](https://doc.rust-lang.org/nightly/core/ops/function/trait.FnMut.html) as a parameter:\u000a\u000a```rust\u000afn do_twice<F>(mut func: F)\u000a    where F: FnMut()\u000a{\u000a    func();\u000a    func();\u000a}\u000a\u000alet mut x: usize = 1;\u000a{\u000a    let add_two_to_x = || x += 2;\u000a    do_twice(add_two_to_x);\u000a}\u000a\u000aassert_eq!(x, 5);\u000a```\u000a\u000aTaking a [`FnOnce`](https://doc.rust-lang.org/nightly/core/ops/function/trait.FnOnce.html) as a parameter:\u000a\u000a```rust\u000afn consume_with_relish<F>(func: F)\u000a    where F: FnOnce() -> String\u000a{\u000a    // `func` consumes its captured variables, so it cannot be run more\u000a    // than once\u000a    println!(\"Consumed: {}\", func());\u000a\u000a    println!(\"Delicious!\");\u000a\u000a    // Attempting to invoke `func()` again will throw a `use of moved\u000a    // value` error for `func`\u000a}\u000a\u000alet x = String::from(\"x\");\u000alet consume_and_return_x = move || x;\u000aconsume_with_relish(consume_and_return_x);\u000a\u000a// `consume_and_return_x` can no longer be invoked at this point\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000acore\u000a```\u000a\u000a```rust\u000amod u64\u000a```\u000a\u000a---\u000a\u000aThe 64-bit unsigned integer type.\u000a\u000a*[See also the `u64` primitive type](https://doc.rust-lang.org/nightly/std/primitive.u64.html).*\u000a\u000aAlthough using these constants wonâ€™t cause compilation warnings,\u000anew code should use the associated constants directly on the primitive type."
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000acore::cell\u000a```\u000a\u000a```rust\u000apub struct RefCell<T>\u000awhere\u000a    T: ?Sized,\u000a```\u000a\u000a---\u000a\u000aA mutable memory location with dynamically checked borrow rules\u000a\u000aSee the [module-level documentation](https://doc.rust-lang.org/nightly/core/cell/index.html) for more."
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000acore::cell::RefCell\u000a```\u000a\u000a```rust\u000apub const fn new(value: T) -> RefCell<T>\u000a```\u000a\u000a---\u000a\u000aCreates a new `RefCell` containing `value`.\u000a\u000a# Examples\u000a\u000a```rust\u000ause std::cell::RefCell;\u000a\u000alet c = RefCell::new(5);\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000acore::char::convert\u000a```\u000a\u000a```rust\u000apub fn from_u32(i: u32) -> Option<char>\u000a```\u000a\u000a---\u000a\u000aConverts a `u32` to a `char`.\u000a\u000aNote that all [`char`](`char`)s are valid [`u32`](`u32`)s, and can be cast to one with\u000a`as`:\u000a\u000a```rust\u000alet c = 'ðŸ’¯';\u000alet i = c as u32;\u000a\u000aassert_eq!(128175, i);\u000a```\u000a\u000aHowever, the reverse is not true: not all valid [`u32`](`u32`)s are valid\u000a[`char`](`char`)s. `from_u32()` will return `None` if the input is not a valid value\u000afor a [`char`](`char`).\u000a\u000aFor an unsafe version of this function which ignores these checks, see\u000a[`from_u32_unchecked`](https://doc.rust-lang.org/nightly/core/char/convert/fn.from_u32_unchecked.html).\u000a\u000a# Examples\u000a\u000aBasic usage:\u000a\u000a```rust\u000ause std::char;\u000a\u000alet c = char::from_u32(0x2764);\u000a\u000aassert_eq!(Some('â¤'), c);\u000a```\u000a\u000aReturning `None` when the input is not a valid [`char`](`char`):\u000a\u000a```rust\u000ause std::char;\u000a\u000alet c = char::from_u32(0x110000);\u000a\u000aassert_eq!(None, c);\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000acore::char::methods\u000a```\u000a\u000a```rust\u000apub fn escape_unicode(self) -> EscapeUnicode\u000a```\u000a\u000a---\u000a\u000aReturns an iterator that yields the hexadecimal Unicode escape of a\u000acharacter as `char`s.\u000a\u000aThis will escape characters with the Rust syntax of the form\u000a`\\u{NNNNNN}` where `NNNNNN` is a hexadecimal representation.\u000a\u000a# Examples\u000a\u000aAs an iterator:\u000a\u000a```rust\u000afor c in 'â¤'.escape_unicode() {\u000a    print!(\"{}\", c);\u000a}\u000aprintln!();\u000a```\u000a\u000aUsing `println!` directly:\u000a\u000a```rust\u000aprintln!(\"{}\", 'â¤'.escape_unicode());\u000a```\u000a\u000aBoth are equivalent to:\u000a\u000a```rust\u000aprintln!(\"\\\\u{{2764}}\");\u000a```\u000a\u000aUsing `to_string`:\u000a\u000a```rust\u000aassert_eq!('â¤'.escape_unicode().to_string(), \"\\\\u{2764}\");\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000acore::char::methods\u000a```\u000a\u000a```rust\u000apub fn is_control(self) -> bool\u000a```\u000a\u000a---\u000a\u000aReturns `true` if this `char` has the general category for control codes.\u000a\u000aControl codes (code points with the general category of `Cc`) are described in Chapter 4\u000a(Character Properties) of the [Unicode Standard] and specified in the [Unicode Character\u000aDatabase](https://www.unicode.org/reports/tr44/) [`UnicodeData.txt`].\u000a\u000a# Examples\u000a\u000aBasic usage:\u000a\u000a```rust\u000a// U+009C, STRING TERMINATOR\u000aassert!('\u009c'.is_control());\u000aassert!(!'q'.is_control());\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000acore::clone::Clone\u000a```\u000a\u000a```rust\u000apub fn clone(&self) -> Self\u000a```\u000a\u000a---\u000a\u000aReturns a copy of the value.\u000a\u000a# Examples\u000a\u000a```rust\u000alet hello = \"Hello\"; // &str implements Clone\u000a\u000aassert_eq!(\"Hello\", hello.clone());\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000acore::cmp\u000a```\u000a\u000a```rust\u000apub enum Ordering\u000a```\u000a\u000a---\u000a\u000aAn `Ordering` is the result of a comparison between two values.\u000a\u000a# Examples\u000a\u000a```rust\u000ause std::cmp::Ordering;\u000a\u000alet result = 1.cmp(&2);\u000aassert_eq!(Ordering::Less, result);\u000a\u000alet result = 1.cmp(&1);\u000aassert_eq!(Ordering::Equal, result);\u000a\u000alet result = 2.cmp(&1);\u000aassert_eq!(Ordering::Greater, result);\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000acore::cmp\u000a```\u000a\u000a```rust\u000apub trait Ord\u000awhere\u000a    Self: Eq + PartialOrd<Self>,\u000a```\u000a\u000a---\u000a\u000aTrait for types that form a [total order](https://en.wikipedia.org/wiki/Total_order).\u000a\u000aAn order is a total order if it is (for all `a`, `b` and `c`):\u000a\u000a* total and asymmetric: exactly one of `a < b`, `a == b` or `a > b` is true; and\u000a* transitive, `a < b` and `b < c` implies `a < c`. The same must hold for both `==` and `>`.\u000a\u000a## Derivable\u000a\u000aThis trait can be used with `#[derive]`. When `derive`d on structs, it will produce a\u000alexicographic ordering based on the top-to-bottom declaration order of the struct's members.\u000aWhen `derive`d on enums, variants are ordered by their top-to-bottom discriminant order.\u000a\u000a## How can I implement `Ord`?\u000a\u000a`Ord` requires that the type also be [`PartialOrd`](https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html) and [`Eq`](https://doc.rust-lang.org/nightly/core/cmp/trait.Eq.html) (which requires [`PartialEq`](https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html)).\u000a\u000aThen you must define an implementation for [`cmp`]. You may find it useful to use\u000a[`cmp`] on your type's fields.\u000a\u000aImplementations of [`PartialEq`](https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html), [`PartialOrd`](https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html), and `Ord` *must*\u000aagree with each other. That is, `a.cmp(b) == Ordering::Equal` if\u000aand only if `a == b` and `Some(a.cmp(b)) == a.partial_cmp(b)` for\u000aall `a` and `b`. It's easy to accidentally make them disagree by\u000aderiving some of the traits and manually implementing others.\u000a\u000aHere's an example where you want to sort people by height only, disregarding `id`\u000aand `name`:\u000a\u000a```rust\u000ause std::cmp::Ordering;\u000a\u000a#[derive(Eq)]\u000astruct Person {\u000a    id: u32,\u000a    name: String,\u000a    height: u32,\u000a}\u000a\u000aimpl Ord for Person {\u000a    fn cmp(&self, other: &Self) -> Ordering {\u000a        self.height.cmp(&other.height)\u000a    }\u000a}\u000a\u000aimpl PartialOrd for Person {\u000a    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\u000a        Some(self.cmp(other))\u000a    }\u000a}\u000a\u000aimpl PartialEq for Person {\u000a    fn eq(&self, other: &Self) -> bool {\u000a        self.height == other.height\u000a    }\u000a}\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000acore::cmp\u000a```\u000a\u000a```rust\u000apub trait PartialEq<Rhs = Self>\u000awhere\u000a    Rhs: ?Sized,\u000a```\u000a\u000a---\u000a\u000aTrait for equality comparisons which are [partial equivalence\u000arelations](https://en.wikipedia.org/wiki/Partial_equivalence_relation).\u000a\u000aThis trait allows for partial equality, for types that do not have a full\u000aequivalence relation. For example, in floating point numbers `NaN != NaN`,\u000aso floating point types implement `PartialEq` but not [`Eq`](https://doc.rust-lang.org/nightly/core/cmp/trait.Eq.html).\u000a\u000aFormally, the equality must be (for all `a`, `b` and `c`):\u000a\u000a* symmetric: `a == b` implies `b == a`; and\u000a* transitive: `a == b` and `b == c` implies `a == c`.\u000a\u000aNote that these requirements mean that the trait itself must be implemented\u000asymmetrically and transitively: if `T: PartialEq<U>` and `U: PartialEq<V>`\u000athen `U: PartialEq<T>` and `T: PartialEq<V>`.\u000a\u000a## Derivable\u000a\u000aThis trait can be used with `#[derive]`. When `derive`d on structs, two\u000ainstances are equal if all fields are equal, and not equal if any fields\u000aare not equal. When `derive`d on enums, each variant is equal to itself\u000aand not equal to the other variants.\u000a\u000a## How can I implement `PartialEq`?\u000a\u000a`PartialEq` only requires the [`eq`] method to be implemented; [`ne`] is defined\u000ain terms of it by default. Any manual implementation of [`ne`] *must* respect\u000athe rule that [`eq`] is a strict inverse of [`ne`]; that is, `!(a == b)` if and\u000aonly if `a != b`.\u000a\u000aImplementations of `PartialEq`, [`PartialOrd`](https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html), and [`Ord`](https://doc.rust-lang.org/nightly/core/cmp/trait.Ord.html) *must* agree with\u000aeach other. It's easy to accidentally make them disagree by deriving some\u000aof the traits and manually implementing others.\u000a\u000aAn example implementation for a domain in which two books are considered\u000athe same book if their ISBN matches, even if the formats differ:\u000a\u000a```rust\u000aenum BookFormat {\u000a    Paperback,\u000a    Hardback,\u000a    Ebook,\u000a}\u000a\u000astruct Book {\u000a    isbn: i32,\u000a    format: BookFormat,\u000a}\u000a\u000aimpl PartialEq for Book {\u000a    fn eq(&self, other: &Self) -> bool {\u000a        self.isbn == other.isbn\u000a    }\u000a}\u000a\u000alet b1 = Book { isbn: 3, format: BookFormat::Paperback };\u000alet b2 = Book { isbn: 3, format: BookFormat::Ebook };\u000alet b3 = Book { isbn: 10, format: BookFormat::Paperback };\u000a\u000aassert!(b1 == b2);\u000aassert!(b1 != b3);\u000a```\u000a\u000a## How can I compare two different types?\u000a\u000aThe type you can compare with is controlled by `PartialEq`'s type parameter.\u000aFor example, let's tweak our previous code a bit:\u000a\u000a```rust\u000a// The derive implements <BookFormat> == <BookFormat> comparisons\u000a#[derive(PartialEq)]\u000aenum BookFormat {\u000a    Paperback,\u000a    Hardback,\u000a    Ebook,\u000a}\u000a\u000astruct Book {\u000a    isbn: i32,\u000a    format: BookFormat,\u000a}\u000a\u000a// Implement <Book> == <BookFormat> comparisons\u000aimpl PartialEq<BookFormat> for Book {\u000a    fn eq(&self, other: &BookFormat) -> bool {\u000a        self.format == *other\u000a    }\u000a}\u000a\u000a// Implement <BookFormat> == <Book> comparisons\u000aimpl PartialEq<Book> for BookFormat {\u000a    fn eq(&self, other: &Book) -> bool {\u000a        *self == other.format\u000a    }\u000a}\u000a\u000alet b1 = Book { isbn: 3, format: BookFormat::Paperback };\u000a\u000aassert!(b1 == BookFormat::Paperback);\u000aassert!(BookFormat::Ebook != b1);\u000a```\u000a\u000aBy changing `impl PartialEq for Book` to `impl PartialEq<BookFormat> for Book`,\u000awe allow `BookFormat`s to be compared with `Book`s.\u000a\u000aA comparison like the one above, which ignores some fields of the struct,\u000acan be dangerous. It can easily lead to an unintended violation of the\u000arequirements for a partial equivalence relation. For example, if we kept\u000athe above implementation of `PartialEq<Book>` for `BookFormat` and added an\u000aimplementation of `PartialEq<Book>` for `Book` (either via a `#[derive]` or\u000avia the manual implementation from the first example) then the result would\u000aviolate transitivity:\u000a\u000a```rust\u000a#[derive(PartialEq)]\u000aenum BookFormat {\u000a    Paperback,\u000a    Hardback,\u000a    Ebook,\u000a}\u000a\u000a#[derive(PartialEq)]\u000astruct Book {\u000a    isbn: i32,\u000a    format: BookFormat,\u000a}\u000a\u000aimpl PartialEq<BookFormat> for Book {\u000a    fn eq(&self, other: &BookFormat) -> bool {\u000a        self.format == *other\u000a    }\u000a}\u000a\u000aimpl PartialEq<Book> for BookFormat {\u000a    fn eq(&self, other: &Book) -> bool {\u000a        *self == other.format\u000a    }\u000a}\u000a\u000afn main() {\u000a    let b1 = Book { isbn: 1, format: BookFormat::Paperback };\u000a    let b2 = Book { isbn: 2, format: BookFormat::Paperback };\u000a\u000a    assert!(b1 == BookFormat::Paperback);\u000a    assert!(BookFormat::Paperback == b2);\u000a\u000a    // The following should hold by transitivity but doesn't.\u000a    assert!(b1 == b2); // <-- PANICS\u000a}\u000a```\u000a\u000a# Examples\u000a\u000a```rust\u000alet x: u32 = 0;\u000alet y: u32 = 1;\u000a\u000aassert_eq!(x == y, false);\u000aassert_eq!(x.eq(&y), false);\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000acore::cmp\u000a```\u000a\u000a```rust\u000apub trait PartialOrd<Rhs = Self>\u000awhere\u000a    Self: PartialEq<Rhs>,\u000a    Rhs: ?Sized,\u000a```\u000a\u000a---\u000a\u000aTrait for values that can be compared for a sort-order.\u000a\u000aThe comparison must satisfy, for all `a`, `b` and `c`:\u000a\u000a* asymmetry: if `a < b` then `!(a > b)`, as well as `a > b` implying `!(a < b)`; and\u000a* transitivity: `a < b` and `b < c` implies `a < c`. The same must hold for both `==` and `>`.\u000a\u000aNote that these requirements mean that the trait itself must be implemented symmetrically and\u000atransitively: if `T: PartialOrd<U>` and `U: PartialOrd<V>` then `U: PartialOrd<T>` and `T: PartialOrd<V>`.\u000a\u000a## Derivable\u000a\u000aThis trait can be used with `#[derive]`. When `derive`d on structs, it will produce a\u000alexicographic ordering based on the top-to-bottom declaration order of the struct's members.\u000aWhen `derive`d on enums, variants are ordered by their top-to-bottom discriminant order.\u000a\u000a## How can I implement `PartialOrd`?\u000a\u000a`PartialOrd` only requires implementation of the [`partial_cmp`] method, with the others\u000agenerated from default implementations.\u000a\u000aHowever it remains possible to implement the others separately for types which do not have a\u000atotal order. For example, for floating point numbers, `NaN < 0 == false` and `NaN >= 0 == false` (cf. IEEE 754-2008 section 5.11).\u000a\u000a`PartialOrd` requires your type to be [`PartialEq`](https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html).\u000a\u000aImplementations of [`PartialEq`](https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html), `PartialOrd`, and [`Ord`](https://doc.rust-lang.org/nightly/core/cmp/trait.Ord.html) *must* agree with each other. It's\u000aeasy to accidentally make them disagree by deriving some of the traits and manually\u000aimplementing others.\u000a\u000aIf your type is [`Ord`](https://doc.rust-lang.org/nightly/core/cmp/trait.Ord.html), you can implement [`partial_cmp`] by using [`cmp`]:\u000a\u000a```rust\u000ause std::cmp::Ordering;\u000a\u000a#[derive(Eq)]\u000astruct Person {\u000a    id: u32,\u000a    name: String,\u000a    height: u32,\u000a}\u000a\u000aimpl PartialOrd for Person {\u000a    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\u000a        Some(self.cmp(other))\u000a    }\u000a}\u000a\u000aimpl Ord for Person {\u000a    fn cmp(&self, other: &Self) -> Ordering {\u000a        self.height.cmp(&other.height)\u000a    }\u000a}\u000a\u000aimpl PartialEq for Person {\u000a    fn eq(&self, other: &Self) -> bool {\u000a        self.height == other.height\u000a    }\u000a}\u000a```\u000a\u000aYou may also find it useful to use [`partial_cmp`] on your type's fields. Here\u000ais an example of `Person` types who have a floating-point `height` field that\u000ais the only field to be used for sorting:\u000a\u000a```rust\u000ause std::cmp::Ordering;\u000a\u000astruct Person {\u000a    id: u32,\u000a    name: String,\u000a    height: f64,\u000a}\u000a\u000aimpl PartialOrd for Person {\u000a    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\u000a        self.height.partial_cmp(&other.height)\u000a    }\u000a}\u000a\u000aimpl PartialEq for Person {\u000a    fn eq(&self, other: &Self) -> bool {\u000a        self.height == other.height\u000a    }\u000a}\u000a```\u000a\u000a# Examples\u000a\u000a```rust\u000alet x : u32 = 0;\u000alet y : u32 = 1;\u000a\u000aassert_eq!(x < y, true);\u000aassert_eq!(x.lt(&y), true);\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000acore::cmp::Ord\u000a```\u000a\u000a```rust\u000apub fn cmp(&self, other: &Self) -> Ordering\u000a```\u000a\u000a---\u000a\u000aThis method returns an [`Ordering`](https://doc.rust-lang.org/nightly/core/cmp/enum.Ordering.html) between `self` and `other`.\u000a\u000aBy convention, `self.cmp(&other)` returns the ordering matching the expression\u000a`self <operator> other` if true.\u000a\u000a# Examples\u000a\u000a```rust\u000ause std::cmp::Ordering;\u000a\u000aassert_eq!(5.cmp(&10), Ordering::Less);\u000aassert_eq!(10.cmp(&5), Ordering::Greater);\u000aassert_eq!(5.cmp(&5), Ordering::Equal);\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000acore::cmp::Ordering\u000a```\u000a\u000a```rust\u000aEqual\u000a```\u000a\u000a---\u000a\u000aAn ordering where a compared value is equal to another."
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000acore::cmp::Ordering\u000a```\u000a\u000a```rust\u000aGreater\u000a```\u000a\u000a---\u000a\u000aAn ordering where a compared value is greater than another."
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000acore::cmp::Ordering\u000a```\u000a\u000a```rust\u000aLess\u000a```\u000a\u000a---\u000a\u000aAn ordering where a compared value is less than another."
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000acore::default\u000a```\u000a\u000a```rust\u000apub trait Default\u000awhere\u000a    Self: Sized,\u000a```\u000a\u000a---\u000a\u000aA trait for giving a type a useful default value.\u000a\u000aSometimes, you want to fall back to some kind of default value, and\u000adon't particularly care what it is. This comes up often with `struct`s\u000athat define a set of options:\u000a\u000a```rust\u000astruct SomeOptions {\u000a    foo: i32,\u000a    bar: f32,\u000a}\u000a```\u000a\u000aHow can we define some default values? You can use `Default`:\u000a\u000a```rust\u000a#[derive(Default)]\u000astruct SomeOptions {\u000a    foo: i32,\u000a    bar: f32,\u000a}\u000a\u000afn main() {\u000a    let options: SomeOptions = Default::default();\u000a}\u000a```\u000a\u000aNow, you get all of the default values. Rust implements `Default` for various primitives types.\u000a\u000aIf you want to override a particular option, but still retain the other defaults:\u000a\u000a```rust\u000afn main() {\u000a    let options = SomeOptions { foo: 42, ..Default::default() };\u000a}\u000a```\u000a\u000a## Derivable\u000a\u000aThis trait can be used with `#[derive]` if all of the type's fields implement\u000a`Default`. When `derive`d, it will use the default value for each field's type.\u000a\u000a## How can I implement `Default`?\u000a\u000aProvide an implementation for the `default()` method that returns the value of\u000ayour type that should be the default:\u000a\u000a```rust\u000aenum Kind {\u000a    A,\u000a    B,\u000a    C,\u000a}\u000a\u000aimpl Default for Kind {\u000a    fn default() -> Self { Kind::A }\u000a}\u000a```\u000a\u000a# Examples\u000a\u000a```rust\u000a#[derive(Default)]\u000astruct SomeOptions {\u000a    foo: i32,\u000a    bar: f32,\u000a}\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000acore::default::Default\u000a```\u000a\u000a```rust\u000apub fn default() -> Self\u000a```\u000a\u000a---\u000a\u000aReturns the \"default value\" for a type.\u000a\u000aDefault values are often some kind of initial value, identity value, or anything else that\u000amay make sense as a default.\u000a\u000a# Examples\u000a\u000aUsing built-in default values:\u000a\u000a```rust\u000alet i: i8 = Default::default();\u000alet (x, y): (Option<String>, f64) = Default::default();\u000alet (a, b, (c, d)): (i32, u32, (bool, bool)) = Default::default();\u000a```\u000a\u000aMaking your own:\u000a\u000a```rust\u000aenum Kind {\u000a    A,\u000a    B,\u000a    C,\u000a}\u000a\u000aimpl Default for Kind {\u000a    fn default() -> Self { Kind::A }\u000a}\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000acore::f64\u000a```\u000a\u000a```rust\u000amod consts\u000a```\u000a\u000a---\u000a\u000aBasic mathematical constants."
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000acore::f64::consts\u000a```\u000a\u000a```rust\u000apub const PI: f64 = 0\u000a```\u000a\u000a---\u000a\u000aArchimedes' constant (Ï€)"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000acore::intrinsics\u000a```\u000a\u000a```rust\u000apub unsafe fn transmute<T, U>(e: T) -> U\u000a```\u000a\u000a---\u000a\u000aReinterprets the bits of a value of one type as another type.\u000a\u000aBoth types must have the same size. Neither the original, nor the result,\u000amay be an [invalid value](https://doc.rust-lang.org/nightly/nomicon/what-unsafe-does.html).\u000a\u000a`transmute` is semantically equivalent to a bitwise move of one type\u000ainto another. It copies the bits from the source value into the\u000adestination value, then forgets the original. It's equivalent to C's\u000a`memcpy` under the hood, just like `transmute_copy`.\u000a\u000a`transmute` is **incredibly** unsafe. There are a vast number of ways to\u000acause [undefined behavior](https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html) with this function. `transmute` should be\u000athe absolute last resort.\u000a\u000aThe [nomicon](https://doc.rust-lang.org/nightly/nomicon/transmutes.html) has additional\u000adocumentation.\u000a\u000a# Examples\u000a\u000aThere are a few things that `transmute` is really useful for.\u000a\u000aTurning a pointer into a function pointer. This is *not* portable to\u000amachines where function pointers and data pointers have different sizes.\u000a\u000a```rust\u000afn foo() -> i32 {\u000a    0\u000a}\u000alet pointer = foo as *const ();\u000alet function = unsafe {\u000a    std::mem::transmute::<*const (), fn() -> i32>(pointer)\u000a};\u000aassert_eq!(function(), 0);\u000a```\u000a\u000aExtending a lifetime, or shortening an invariant lifetime. This is\u000aadvanced, very unsafe Rust!\u000a\u000a```rust\u000astruct R<'a>(&'a i32);\u000aunsafe fn extend_lifetime<'b>(r: R<'b>) -> R<'static> {\u000a    std::mem::transmute::<R<'b>, R<'static>>(r)\u000a}\u000a\u000aunsafe fn shorten_invariant_lifetime<'b, 'c>(r: &'b mut R<'static>)\u000a                                             -> &'b mut R<'c> {\u000a    std::mem::transmute::<&'b mut R<'static>, &'b mut R<'c>>(r)\u000a}\u000a```\u000a\u000a# Alternatives\u000a\u000aDon't despair: many uses of `transmute` can be achieved through other means.\u000aBelow are common applications of `transmute` which can be replaced with safer\u000aconstructs.\u000a\u000aTurning raw bytes(`&[u8]`) to `u32`, `f64`, etc.:\u000a\u000a```rust\u000alet raw_bytes = [0x78, 0x56, 0x34, 0x12];\u000a\u000alet num = unsafe {\u000a    std::mem::transmute::<[u8; 4], u32>(raw_bytes)\u000a};\u000a\u000a// use `u32::from_ne_bytes` instead\u000alet num = u32::from_ne_bytes(raw_bytes);\u000a// or use `u32::from_le_bytes` or `u32::from_be_bytes` to specify the endianness\u000alet num = u32::from_le_bytes(raw_bytes);\u000aassert_eq!(num, 0x12345678);\u000alet num = u32::from_be_bytes(raw_bytes);\u000aassert_eq!(num, 0x78563412);\u000a```\u000a\u000aTurning a pointer into a `usize`:\u000a\u000a```rust\u000alet ptr = &0;\u000alet ptr_num_transmute = unsafe {\u000a    std::mem::transmute::<&i32, usize>(ptr)\u000a};\u000a\u000a// Use an `as` cast instead\u000alet ptr_num_cast = ptr as *const i32 as usize;\u000a```\u000a\u000aTurning a `*mut T` into an `&mut T`:\u000a\u000a```rust\u000alet ptr: *mut i32 = &mut 0;\u000alet ref_transmuted = unsafe {\u000a    std::mem::transmute::<*mut i32, &mut i32>(ptr)\u000a};\u000a\u000a// Use a reborrow instead\u000alet ref_casted = unsafe { &mut *ptr };\u000a```\u000a\u000aTurning an `&mut T` into an `&mut U`:\u000a\u000a```rust\u000alet ptr = &mut 0;\u000alet val_transmuted = unsafe {\u000a    std::mem::transmute::<&mut i32, &mut u32>(ptr)\u000a};\u000a\u000a// Now, put together `as` and reborrowing - note the chaining of `as`\u000a// `as` is not transitive\u000alet val_casts = unsafe { &mut *(ptr as *mut i32 as *mut u32) };\u000a```\u000a\u000aTurning an `&str` into an `&[u8]`:\u000a\u000a```rust\u000a// this is not a good way to do this.\u000alet slice = unsafe { std::mem::transmute::<&str, &[u8]>(\"Rust\") };\u000aassert_eq!(slice, &[82, 117, 115, 116]);\u000a\u000a// You could use `str::as_bytes`\u000alet slice = \"Rust\".as_bytes();\u000aassert_eq!(slice, &[82, 117, 115, 116]);\u000a\u000a// Or, just use a byte string, if you have control over the string\u000a// literal\u000aassert_eq!(b\"Rust\", &[82, 117, 115, 116]);\u000a```\u000a\u000aTurning a `Vec<&T>` into a `Vec<Option<&T>>`:\u000a\u000a```rust\u000alet store = [0, 1, 2, 3];\u000alet v_orig = store.iter().collect::<Vec<&i32>>();\u000a\u000a// clone the vector as we will reuse them later\u000alet v_clone = v_orig.clone();\u000a\u000a// Using transmute: this relies on the unspecified data layout of `Vec`, which is a\u000a// bad idea and could cause Undefined Behavior.\u000a// However, it is no-copy.\u000alet v_transmuted = unsafe {\u000a    std::mem::transmute::<Vec<&i32>, Vec<Option<&i32>>>(v_clone)\u000a};\u000a\u000alet v_clone = v_orig.clone();\u000a\u000a// This is the suggested, safe way.\u000a// It does copy the entire vector, though, into a new array.\u000alet v_collected = v_clone.into_iter()\u000a                         .map(Some)\u000a                         .collect::<Vec<Option<&i32>>>();\u000a\u000alet v_clone = v_orig.clone();\u000a\u000a// The no-copy, unsafe way, still using transmute, but not relying on the data layout.\u000a// Like the first approach, this reuses the `Vec` internals.\u000a// Therefore, the new inner type must have the\u000a// exact same size, *and the same alignment*, as the old type.\u000a// The same caveats exist for this method as transmute, for\u000a// the original inner type (`&i32`) to the converted inner type\u000a// (`Option<&i32>`), so read the nomicon pages linked above and also\u000a// consult the [`from_raw_parts`] documentation.\u000alet v_from_raw = unsafe {\u000a    // Ensure the original vector is not dropped.\u000a    let mut v_clone = std::mem::ManuallyDrop::new(v_clone);\u000a    Vec::from_raw_parts(v_clone.as_mut_ptr() as *mut Option<&i32>,\u000a                        v_clone.len(),\u000a                        v_clone.capacity())\u000a};\u000a```\u000a\u000aImplementing `split_at_mut`:\u000a\u000a```rust\u000ause std::{slice, mem};\u000a\u000a// There are multiple ways to do this, and there are multiple problems\u000a// with the following (transmute) way.\u000afn split_at_mut_transmute<T>(slice: &mut [T], mid: usize)\u000a                             -> (&mut [T], &mut [T]) {\u000a    let len = slice.len();\u000a    assert!(mid <= len);\u000a    unsafe {\u000a        let slice2 = mem::transmute::<&mut [T], &mut [T]>(slice);\u000a        // first: transmute is not type safe; all it checks is that T and\u000a        // U are of the same size. Second, right here, you have two\u000a        // mutable references pointing to the same memory.\u000a        (&mut slice[0..mid], &mut slice2[mid..len])\u000a    }\u000a}\u000a\u000a// This gets rid of the type safety problems; `&mut *` will *only* give\u000a// you an `&mut T` from an `&mut T` or `*mut T`.\u000afn split_at_mut_casts<T>(slice: &mut [T], mid: usize)\u000a                         -> (&mut [T], &mut [T]) {\u000a    let len = slice.len();\u000a    assert!(mid <= len);\u000a    unsafe {\u000a        let slice2 = &mut *(slice as *mut [T]);\u000a        // however, you still have two mutable references pointing to\u000a        // the same memory.\u000a        (&mut slice[0..mid], &mut slice2[mid..len])\u000a    }\u000a}\u000a\u000a// This is how the standard library does it. This is the best method, if\u000a// you need to do something like this\u000afn split_at_stdlib<T>(slice: &mut [T], mid: usize)\u000a                      -> (&mut [T], &mut [T]) {\u000a    let len = slice.len();\u000a    assert!(mid <= len);\u000a    unsafe {\u000a        let ptr = slice.as_mut_ptr();\u000a        // This now has three mutable references pointing at the same\u000a        // memory. `slice`, the rvalue ret.0, and the rvalue ret.1.\u000a        // `slice` is never used after `let ptr = ...`, and so one can\u000a        // treat it as \"dead\", and therefore, you only have two real\u000a        // mutable slices.\u000a        (slice::from_raw_parts_mut(ptr, mid),\u000a         slice::from_raw_parts_mut(ptr.add(mid), len - mid))\u000a    }\u000a}\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000acore::iter::traits::collect\u000a```\u000a\u000a```rust\u000apub trait IntoIterator\u000a```\u000a\u000a---\u000a\u000aConversion into an [`Iterator`](https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html).\u000a\u000aBy implementing `IntoIterator` for a type, you define how it will be\u000aconverted to an iterator. This is common for types which describe a\u000acollection of some kind.\u000a\u000aOne benefit of implementing `IntoIterator` is that your type will [work\u000awith Rust's `for` loop syntax](https://doc.rust-lang.org/nightly/core/iter/traits/collect/index.html#for-loops-and-intoiterator).\u000a\u000aSee also: [`FromIterator`](https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.FromIterator.html).\u000a\u000a# Examples\u000a\u000aBasic usage:\u000a\u000a```rust\u000alet v = vec![1, 2, 3];\u000alet mut iter = v.into_iter();\u000a\u000aassert_eq!(Some(1), iter.next());\u000aassert_eq!(Some(2), iter.next());\u000aassert_eq!(Some(3), iter.next());\u000aassert_eq!(None, iter.next());\u000a```\u000a\u000aImplementing `IntoIterator` for your type:\u000a\u000a```rust\u000a// A sample collection, that's just a wrapper over Vec<T>\u000a#[derive(Debug)]\u000astruct MyCollection(Vec<i32>);\u000a\u000a// Let's give it some methods so we can create one and add things\u000a// to it.\u000aimpl MyCollection {\u000a    fn new() -> MyCollection {\u000a        MyCollection(Vec::new())\u000a    }\u000a\u000a    fn add(&mut self, elem: i32) {\u000a        self.0.push(elem);\u000a    }\u000a}\u000a\u000a// and we'll implement IntoIterator\u000aimpl IntoIterator for MyCollection {\u000a    type Item = i32;\u000a    type IntoIter = std::vec::IntoIter<Self::Item>;\u000a\u000a    fn into_iter(self) -> Self::IntoIter {\u000a        self.0.into_iter()\u000a    }\u000a}\u000a\u000a// Now we can make a new collection...\u000alet mut c = MyCollection::new();\u000a\u000a// ... add some stuff to it ...\u000ac.add(0);\u000ac.add(1);\u000ac.add(2);\u000a\u000a// ... and then turn it into an Iterator:\u000afor (i, n) in c.into_iter().enumerate() {\u000a    assert_eq!(i as i32, n);\u000a}\u000a```\u000a\u000aIt is common to use `IntoIterator` as a trait bound. This allows\u000athe input collection type to change, so long as it is still an\u000aiterator. Additional bounds can be specified by restricting on\u000a`Item`:\u000a\u000a```rust\u000afn collect_as_strings<T>(collection: T) -> Vec<String>\u000awhere\u000a    T: IntoIterator,\u000a    T::Item: std::fmt::Debug,\u000a{\u000a    collection\u000a        .into_iter()\u000a        .map(|item| format!(\"{:?}\", item))\u000a        .collect()\u000a}\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000acore::iter::traits::collect\u000a```\u000a\u000a```rust\u000apub type IntoIter: Iterator<Item = Self::Item>\u000a```\u000a\u000a---\u000a\u000aWhich kind of iterator are we turning this into?"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000acore::iter::traits::iterator\u000a```\u000a\u000a```rust\u000apub trait Iterator\u000a```\u000a\u000a---\u000a\u000aAn interface for dealing with iterators.\u000a\u000aThis is the main iterator trait. For more about the concept of iterators\u000agenerally, please see the [module-level documentation]. In particular, you\u000amay want to know how to [implement `Iterator`](crate::iter#implementing-iterator)."
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000acore::iter::traits::iterator::Iterator\u000a```\u000a\u000a```rust\u000apub fn collect<B>(self) -> B\u000awhere\u000a    B: FromIterator<Self::Item>,\u000a    Self: Sized,\u000a```\u000a\u000a---\u000a\u000aTransforms an iterator into a collection.\u000a\u000a`collect()` can take anything iterable, and turn it into a relevant\u000acollection. This is one of the more powerful methods in the standard\u000alibrary, used in a variety of contexts.\u000a\u000aThe most basic pattern in which `collect()` is used is to turn one\u000acollection into another. You take a collection, call [`iter`] on it,\u000ado a bunch of transformations, and then `collect()` at the end.\u000a\u000a`collect()` can also create instances of types that are not typical\u000acollections. For example, a [`String`] can be built from [`char`]s,\u000aand an iterator of [`Result<T, E>`](https://doc.rust-lang.org/nightly/core/result/enum.Result.html) items can be collected\u000ainto `Result<Collection<T>, E>`. See the examples below for more.\u000a\u000aBecause `collect()` is so general, it can cause problems with type\u000ainference. As such, `collect()` is one of the few times you'll see\u000athe syntax affectionately known as the 'turbofish': `::<>`. This\u000ahelps the inference algorithm understand specifically which collection\u000ayou're trying to collect into.\u000a\u000a# Examples\u000a\u000aBasic usage:\u000a\u000a```rust\u000alet a = [1, 2, 3];\u000a\u000alet doubled: Vec<i32> = a.iter()\u000a                         .map(|&x| x * 2)\u000a                         .collect();\u000a\u000aassert_eq!(vec![2, 4, 6], doubled);\u000a```\u000a\u000aNote that we needed the `: Vec<i32>` on the left-hand side. This is because\u000awe could collect into, for example, a [`VecDeque<T>`] instead:\u000a\u000a```rust\u000ause std::collections::VecDeque;\u000a\u000alet a = [1, 2, 3];\u000a\u000alet doubled: VecDeque<i32> = a.iter().map(|&x| x * 2).collect();\u000a\u000aassert_eq!(2, doubled[0]);\u000aassert_eq!(4, doubled[1]);\u000aassert_eq!(6, doubled[2]);\u000a```\u000a\u000aUsing the 'turbofish' instead of annotating `doubled`:\u000a\u000a```rust\u000alet a = [1, 2, 3];\u000a\u000alet doubled = a.iter().map(|x| x * 2).collect::<Vec<i32>>();\u000a\u000aassert_eq!(vec![2, 4, 6], doubled);\u000a```\u000a\u000aBecause `collect()` only cares about what you're collecting into, you can\u000astill use a partial type hint, `_`, with the turbofish:\u000a\u000a```rust\u000alet a = [1, 2, 3];\u000a\u000alet doubled = a.iter().map(|x| x * 2).collect::<Vec<_>>();\u000a\u000aassert_eq!(vec![2, 4, 6], doubled);\u000a```\u000a\u000aUsing `collect()` to make a [`String`]:\u000a\u000a```rust\u000alet chars = ['g', 'd', 'k', 'k', 'n'];\u000a\u000alet hello: String = chars.iter()\u000a    .map(|&x| x as u8)\u000a    .map(|x| (x + 1) as char)\u000a    .collect();\u000a\u000aassert_eq!(\"hello\", hello);\u000a```\u000a\u000aIf you have a list of [`Result<T, E>`](https://doc.rust-lang.org/nightly/core/result/enum.Result.html)s, you can use `collect()` to\u000asee if any of them failed:\u000a\u000a```rust\u000alet results = [Ok(1), Err(\"nope\"), Ok(3), Err(\"bad\")];\u000a\u000alet result: Result<Vec<_>, &str> = results.iter().cloned().collect();\u000a\u000a// gives us the first error\u000aassert_eq!(Err(\"nope\"), result);\u000a\u000alet results = [Ok(1), Ok(3)];\u000a\u000alet result: Result<Vec<_>, &str> = results.iter().cloned().collect();\u000a\u000a// gives us the list of answers\u000aassert_eq!(Ok(vec![1, 3]), result);\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000acore::iter::traits::iterator::Iterator\u000a```\u000a\u000a```rust\u000apub fn enumerate(self) -> Enumerate<Self>\u000awhere\u000a    Self: Sized,\u000a```\u000a\u000a---\u000a\u000aCreates an iterator which gives the current iteration count as well as\u000athe next value.\u000a\u000aThe iterator returned yields pairs `(i, val)`, where `i` is the\u000acurrent index of iteration and `val` is the value returned by the\u000aiterator.\u000a\u000a`enumerate()` keeps its count as a [`usize`]. If you want to count by a\u000adifferent sized integer, the [`zip`] function provides similar\u000afunctionality.\u000a\u000a# Overflow Behavior\u000a\u000aThe method does no guarding against overflows, so enumerating more than\u000a[`usize::MAX`] elements either produces the wrong result or panics. If\u000adebug assertions are enabled, a panic is guaranteed.\u000a\u000a# Panics\u000a\u000aThe returned iterator might panic if the to-be-returned index would\u000aoverflow a [`usize`].\u000a\u000a# Examples\u000a\u000a```rust\u000alet a = ['a', 'b', 'c'];\u000a\u000alet mut iter = a.iter().enumerate();\u000a\u000aassert_eq!(iter.next(), Some((0, &'a')));\u000aassert_eq!(iter.next(), Some((1, &'b')));\u000aassert_eq!(iter.next(), Some((2, &'c')));\u000aassert_eq!(iter.next(), None);\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000acore::iter::traits::iterator::Iterator\u000a```\u000a\u000a```rust\u000apub fn map<B, F>(self, f: F) -> Map<Self, F>\u000awhere\u000a    Self: Sized,\u000a    F: FnMut(Self::Item) -> B,\u000a```\u000a\u000a---\u000a\u000aTakes a closure and creates an iterator which calls that closure on each\u000aelement.\u000a\u000a`map()` transforms one iterator into another, by means of its argument:\u000asomething that implements [`FnMut`]. It produces a new iterator which\u000acalls this closure on each element of the original iterator.\u000a\u000aIf you are good at thinking in types, you can think of `map()` like this:\u000aIf you have an iterator that gives you elements of some type `A`, and\u000ayou want an iterator of some other type `B`, you can use `map()`,\u000apassing a closure that takes an `A` and returns a `B`.\u000a\u000a`map()` is conceptually similar to a [`for`] loop. However, as `map()` is\u000alazy, it is best used when you're already working with other iterators.\u000aIf you're doing some sort of looping for a side effect, it's considered\u000amore idiomatic to use [`for`] than `map()`.\u000a\u000a# Examples\u000a\u000aBasic usage:\u000a\u000a```rust\u000alet a = [1, 2, 3];\u000a\u000alet mut iter = a.iter().map(|x| 2 * x);\u000a\u000aassert_eq!(iter.next(), Some(2));\u000aassert_eq!(iter.next(), Some(4));\u000aassert_eq!(iter.next(), Some(6));\u000aassert_eq!(iter.next(), None);\u000a```\u000a\u000aIf you're doing some sort of side effect, prefer [`for`] to `map()`:\u000a\u000a```rust\u000a// don't do this:\u000a(0..5).map(|x| println!(\"{}\", x));\u000a\u000a// it won't even execute, as it is lazy. Rust will warn you about this.\u000a\u000a// Instead, use for:\u000afor x in 0..5 {\u000a    println!(\"{}\", x);\u000a}\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000acore::iter::traits::iterator::Iterator\u000a```\u000a\u000a```rust\u000apub fn product<P>(self) -> P\u000awhere\u000a    Self: Sized,\u000a    P: Product<Self::Item>,\u000a```\u000a\u000a---\u000a\u000aIterates over the entire iterator, multiplying all the elements\u000a\u000aAn empty iterator returns the one value of the type.\u000a\u000a# Panics\u000a\u000aWhen calling `product()` and a primitive integer type is being returned,\u000amethod will panic if the computation overflows and debug assertions are\u000aenabled.\u000a\u000a# Examples\u000a\u000a```rust\u000afn factorial(n: u32) -> u32 {\u000a    (1..=n).product()\u000a}\u000aassert_eq!(factorial(0), 1);\u000aassert_eq!(factorial(1), 1);\u000aassert_eq!(factorial(5), 120);\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000acore::iter::traits::iterator::Iterator\u000a```\u000a\u000a```rust\u000apub fn rev(self) -> Rev<Self>\u000awhere\u000a    Self: Sized + DoubleEndedIterator,\u000a```\u000a\u000a---\u000a\u000aReverses an iterator's direction.\u000a\u000aUsually, iterators iterate from left to right. After using `rev()`,\u000aan iterator will instead iterate from right to left.\u000a\u000aThis is only possible if the iterator has an end, so `rev()` only\u000aworks on [`DoubleEndedIterator`](https://doc.rust-lang.org/nightly/core/iter/traits/double_ended/trait.DoubleEndedIterator.html)s.\u000a\u000a# Examples\u000a\u000a```rust\u000alet a = [1, 2, 3];\u000a\u000alet mut iter = a.iter().rev();\u000a\u000aassert_eq!(iter.next(), Some(&3));\u000aassert_eq!(iter.next(), Some(&2));\u000aassert_eq!(iter.next(), Some(&1));\u000a\u000aassert_eq!(iter.next(), None);\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000acore::iter::traits::iterator::Iterator\u000a```\u000a\u000a```rust\u000apub fn skip(self, n: usize) -> Skip<Self>\u000awhere\u000a    Self: Sized,\u000a```\u000a\u000a---\u000a\u000aCreates an iterator that skips the first `n` elements.\u000a\u000aAfter they have been consumed, the rest of the elements are yielded.\u000aRather than overriding this method directly, instead override the `nth` method.\u000a\u000a# Examples\u000a\u000aBasic usage:\u000a\u000a```rust\u000alet a = [1, 2, 3];\u000a\u000alet mut iter = a.iter().skip(2);\u000a\u000aassert_eq!(iter.next(), Some(&3));\u000aassert_eq!(iter.next(), None);\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000acore::macros\u000a```\u000a\u000a```rust\u000amacro_rules! assert_eq\u000a```\u000a\u000a---\u000a\u000aAsserts that two expressions are equal to each other (using [`PartialEq`](https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html)).\u000a\u000aOn panic, this macro will print the values of the expressions with their\u000adebug representations.\u000a\u000aLike [`assert`](https://doc.rust-lang.org/nightly/core/macros/builtin/macro.assert.html), this macro has a second form, where a custom\u000apanic message can be provided.\u000a\u000a# Examples\u000a\u000a```rust\u000alet a = 3;\u000alet b = 1 + 2;\u000aassert_eq!(a, b);\u000a\u000aassert_eq!(a, b, \"we are testing addition with {} and {}\", a, b);\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000acore::macros\u000a```\u000a\u000a```rust\u000amacro_rules! assert_ne\u000a```\u000a\u000a---\u000a\u000aAsserts that two expressions are not equal to each other (using [`PartialEq`](https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html)).\u000a\u000aOn panic, this macro will print the values of the expressions with their\u000adebug representations.\u000a\u000aLike [`assert`](https://doc.rust-lang.org/nightly/core/macros/builtin/macro.assert.html), this macro has a second form, where a custom\u000apanic message can be provided.\u000a\u000a# Examples\u000a\u000a```rust\u000alet a = 3;\u000alet b = 2;\u000aassert_ne!(a, b);\u000a\u000aassert_ne!(a, b, \"we are testing that the values are not equal\");\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000acore::macros::builtin\u000a```\u000a\u000a```rust\u000amacro test\u000a```\u000a\u000a---\u000a\u000aAttribute macro applied to a function to turn it into a unit test."
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000acore::macros::builtin\u000a```\u000a\u000a```rust\u000amacro_rules! assert\u000a```\u000a\u000a---\u000a\u000aAsserts that a boolean expression is `true` at runtime.\u000a\u000aThis will invoke the [`panic`](https://doc.rust-lang.org/nightly/core/macros/macro.panic.html) macro if the provided expression cannot be\u000aevaluated to `true` at runtime.\u000a\u000a# Uses\u000a\u000aAssertions are always checked in both debug and release builds, and cannot\u000abe disabled. See [`debug_assert`](https://doc.rust-lang.org/nightly/core/macros/macro.debug_assert.html) for assertions that are not enabled in\u000arelease builds by default.\u000a\u000aUnsafe code may rely on `assert!` to enforce run-time invariants that, if\u000aviolated could lead to unsafety.\u000a\u000aOther use-cases of `assert!` include testing and enforcing run-time\u000ainvariants in safe code (whose violation cannot result in unsafety).\u000a\u000a# Custom Messages\u000a\u000aThis macro has a second form, where a custom panic message can\u000abe provided with or without arguments for formatting. See [`std::fmt`]\u000afor syntax for this form.\u000a\u000a# Examples\u000a\u000a```rust\u000a// the panic message for these assertions is the stringified value of the\u000a// expression given.\u000aassert!(true);\u000a\u000afn some_computation() -> bool { true } // a very simple function\u000a\u000aassert!(some_computation());\u000a\u000a// assert with a custom message\u000alet x = true;\u000aassert!(x, \"x wasn't true!\");\u000a\u000alet a = 3; let b = 27;\u000aassert!(a + b == 30, \"a = {}, b = {}\", a, b);\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000acore::marker\u000a```\u000a\u000a```rust\u000apub trait Copy\u000awhere\u000a    Self: Clone,\u000a```\u000a\u000a---\u000a\u000aTypes whose values can be duplicated simply by copying bits.\u000a\u000aBy default, variable bindings have 'move semantics.' In other\u000awords:\u000a\u000a```rust\u000a#[derive(Debug)]\u000astruct Foo;\u000a\u000alet x = Foo;\u000a\u000alet y = x;\u000a\u000a// `x` has moved into `y`, and so cannot be used\u000a\u000a// println!(\"{:?}\", x); // error: use of moved value\u000a```\u000a\u000aHowever, if a type implements `Copy`, it instead has 'copy semantics':\u000a\u000a```rust\u000a// We can derive a `Copy` implementation. `Clone` is also required, as it's\u000a// a supertrait of `Copy`.\u000a#[derive(Debug, Copy, Clone)]\u000astruct Foo;\u000a\u000alet x = Foo;\u000a\u000alet y = x;\u000a\u000a// `y` is a copy of `x`\u000a\u000aprintln!(\"{:?}\", x); // A-OK!\u000a```\u000a\u000aIt's important to note that in these two examples, the only difference is whether you\u000aare allowed to access `x` after the assignment. Under the hood, both a copy and a move\u000acan result in bits being copied in memory, although this is sometimes optimized away.\u000a\u000a## How can I implement `Copy`?\u000a\u000aThere are two ways to implement `Copy` on your type. The simplest is to use `derive`:\u000a\u000a```rust\u000a#[derive(Copy, Clone)]\u000astruct MyStruct;\u000a```\u000a\u000aYou can also implement `Copy` and `Clone` manually:\u000a\u000a```rust\u000astruct MyStruct;\u000a\u000aimpl Copy for MyStruct { }\u000a\u000aimpl Clone for MyStruct {\u000a    fn clone(&self) -> MyStruct {\u000a        *self\u000a    }\u000a}\u000a```\u000a\u000aThere is a small difference between the two: the `derive` strategy will also place a `Copy`\u000abound on type parameters, which isn't always desired.\u000a\u000a## What's the difference between `Copy` and `Clone`?\u000a\u000aCopies happen implicitly, for example as part of an assignment `y = x`. The behavior of\u000a`Copy` is not overloadable; it is always a simple bit-wise copy.\u000a\u000aCloning is an explicit action, `x.clone()`. The implementation of [`Clone`](https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html) can\u000aprovide any type-specific behavior necessary to duplicate values safely. For example,\u000athe implementation of [`Clone`](https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html) for [`String`] needs to copy the pointed-to string\u000abuffer in the heap. A simple bitwise copy of [`String`] values would merely copy the\u000apointer, leading to a double free down the line. For this reason, [`String`] is [`Clone`](https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html)\u000abut not `Copy`.\u000a\u000a[`Clone`](https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html) is a supertrait of `Copy`, so everything which is `Copy` must also implement\u000a[`Clone`](https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html). If a type is `Copy` then its [`Clone`](https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html) implementation only needs to return `*self`\u000a(see the example above).\u000a\u000a## When can my type be `Copy`?\u000a\u000aA type can implement `Copy` if all of its components implement `Copy`. For example, this\u000astruct can be `Copy`:\u000a\u000a```rust\u000a#[derive(Copy, Clone)]\u000astruct Point {\u000a   x: i32,\u000a   y: i32,\u000a}\u000a```\u000a\u000aA struct can be `Copy`, and [`i32`](`i32`) is `Copy`, therefore `Point` is eligible to be `Copy`.\u000aBy contrast, consider\u000a\u000a```rust\u000astruct PointList {\u000a    points: Vec<Point>,\u000a}\u000a```\u000a\u000aThe struct `PointList` cannot implement `Copy`, because [`Vec<T>`] is not `Copy`. If we\u000aattempt to derive a `Copy` implementation, we'll get an error:\u000a\u000a```text\u000athe trait `Copy` may not be implemented for this type; field `points` does not implement `Copy`\u000a```\u000a\u000aShared references (`&T`) are also `Copy`, so a type can be `Copy`, even when it holds\u000ashared references of types `T` that are *not* `Copy`. Consider the following struct,\u000awhich can implement `Copy`, because it only holds a *shared reference* to our non-`Copy`\u000atype `PointList` from above:\u000a\u000a```rust\u000a#[derive(Copy, Clone)]\u000astruct PointListWrapper<'a> {\u000a    point_list_ref: &'a PointList,\u000a}\u000a```\u000a\u000a## When *can't* my type be `Copy`?\u000a\u000aSome types can't be copied safely. For example, copying `&mut T` would create an aliased\u000amutable reference. Copying [`String`] would duplicate responsibility for managing the\u000a[`String`]'s buffer, leading to a double free.\u000a\u000aGeneralizing the latter case, any type implementing [`Drop`](https://doc.rust-lang.org/nightly/core/ops/drop/trait.Drop.html) can't be `Copy`, because it's\u000amanaging some resource besides its own [`size_of::<T>`] bytes.\u000a\u000aIf you try to implement `Copy` on a struct or enum containing non-`Copy` data, you will get\u000athe error [E0204].\u000a\u000a## When *should* my type be `Copy`?\u000a\u000aGenerally speaking, if your type *can* implement `Copy`, it should. Keep in mind, though,\u000athat implementing `Copy` is part of the public API of your type. If the type might become\u000anon-`Copy` in the future, it could be prudent to omit the `Copy` implementation now, to\u000aavoid a breaking API change.\u000a\u000a## Additional implementors\u000a\u000aIn addition to the [implementors listed below](https://doc.rust-lang.org/nightly/core/marker/trait.Copy.html#implementors),\u000athe following types also implement `Copy`:\u000a\u000a* Function item types (i.e., the distinct types defined for each function)\u000a* Function pointer types (e.g., `fn() -> i32`)\u000a* Array types, for all sizes, if the item type also implements `Copy` (e.g., `[i32; 123456]`)\u000a* Tuple types, if each component also implements `Copy` (e.g., `()`, `(i32, bool)`)\u000a* Closure types, if they capture no value from the environment\u000a  or if all such captured values implement `Copy` themselves.\u000a  Note that variables captured by shared reference always implement `Copy`\u000a  (even if the referent doesn't),\u000a  while variables captured by mutable reference never implement `Copy`."
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000acore::marker\u000a```\u000a\u000a```rust\u000apub trait Sized\u000a```\u000a\u000a---\u000a\u000aTypes with a constant size known at compile time.\u000a\u000aAll type parameters have an implicit bound of `Sized`. The special syntax\u000a`?Sized` can be used to remove this bound if it's not appropriate.\u000a\u000a```rust\u000astruct Foo<T>(T);\u000astruct Bar<T: ?Sized>(T);\u000a\u000a// struct FooUse(Foo<[i32]>); // error: Sized is not implemented for [i32]\u000astruct BarUse(Bar<[i32]>); // OK\u000a```\u000a\u000aThe one exception is the implicit `Self` type of a trait. A trait does not\u000ahave an implicit `Sized` bound as this is incompatible with [trait object]s\u000awhere, by definition, the trait needs to work with all possible implementors,\u000aand thus could be any size.\u000a\u000aAlthough Rust will let you bind `Sized` to a trait, you won't\u000abe able to use it to form a trait object later:\u000a\u000a```rust\u000atrait Foo { }\u000atrait Bar: Sized { }\u000a\u000astruct Impl;\u000aimpl Foo for Impl { }\u000aimpl Bar for Impl { }\u000a\u000alet x: &dyn Foo = &Impl;    // OK\u000a// let y: &dyn Bar = &Impl; // error: the trait `Bar` cannot\u000a                            // be made into an object\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000acore::mem\u000a```\u000a\u000a```rust\u000apub const fn size_of<T>() -> usize\u000a```\u000a\u000a---\u000a\u000aReturns the size of a type in bytes.\u000a\u000aMore specifically, this is the offset in bytes between successive elements\u000ain an array with that item type including alignment padding. Thus, for any\u000atype `T` and length `n`, `[T; n]` has a size of `n * size_of::<T>()`.\u000a\u000aIn general, the size of a type is not stable across compilations, but\u000aspecific types such as primitives are.\u000a\u000aThe following table gives the size for primitives.\u000a\u000a|Type|size_of::\\<Type>()|\u000a|----|-----------------|\u000a|()|0|\u000a|bool|1|\u000a|u8|1|\u000a|u16|2|\u000a|u32|4|\u000a|u64|8|\u000a|u128|16|\u000a|i8|1|\u000a|i16|2|\u000a|i32|4|\u000a|i64|8|\u000a|i128|16|\u000a|f32|4|\u000a|f64|8|\u000a|char|4|\u000a\u000aFurthermore, `usize` and `isize` have the same size.\u000a\u000aThe types `*const T`, `&T`, `Box<T>`, `Option<&T>`, and `Option<Box<T>>` all have\u000athe same size. If `T` is Sized, all of those types have the same size as `usize`.\u000a\u000aThe mutability of a pointer does not change its size. As such, `&T` and `&mut T`\u000ahave the same size. Likewise for `*const T` and `*mut T`.\u000a\u000a# Size of `#[repr(C)]` items\u000a\u000aThe `C` representation for items has a defined layout. With this layout,\u000athe size of items is also stable as long as all fields have a stable size.\u000a\u000a## Size of Structs\u000a\u000aFor `structs`, the size is determined by the following algorithm.\u000a\u000aFor each field in the struct ordered by declaration order:\u000a\u000a1. Add the size of the field.\u000a1. Round up the current size to the nearest multiple of the next field's [alignment].\u000a\u000aFinally, round the size of the struct to the nearest multiple of its [alignment].\u000aThe alignment of the struct is usually the largest alignment of all its\u000afields; this can be changed with the use of `repr(align(N))`.\u000a\u000aUnlike `C`, zero sized structs are not rounded up to one byte in size.\u000a\u000a## Size of Enums\u000a\u000aEnums that carry no data other than the discriminant have the same size as C enums\u000aon the platform they are compiled for.\u000a\u000a## Size of Unions\u000a\u000aThe size of a union is the size of its largest field.\u000a\u000aUnlike `C`, zero sized unions are not rounded up to one byte in size.\u000a\u000a# Examples\u000a\u000a```rust\u000ause std::mem;\u000a\u000a// Some primitives\u000aassert_eq!(4, mem::size_of::<i32>());\u000aassert_eq!(8, mem::size_of::<f64>());\u000aassert_eq!(0, mem::size_of::<()>());\u000a\u000a// Some arrays\u000aassert_eq!(8, mem::size_of::<[i32; 2]>());\u000aassert_eq!(12, mem::size_of::<[i32; 3]>());\u000aassert_eq!(0, mem::size_of::<[i32; 0]>());\u000a\u000a\u000a// Pointer size equality\u000aassert_eq!(mem::size_of::<&i32>(), mem::size_of::<*const i32>());\u000aassert_eq!(mem::size_of::<&i32>(), mem::size_of::<Box<i32>>());\u000aassert_eq!(mem::size_of::<&i32>(), mem::size_of::<Option<&i32>>());\u000aassert_eq!(mem::size_of::<Box<i32>>(), mem::size_of::<Option<Box<i32>>>());\u000a```\u000a\u000aUsing `#[repr(C)]`.\u000a\u000a```rust\u000ause std::mem;\u000a\u000a#[repr(C)]\u000astruct FieldStruct {\u000a    first: u8,\u000a    second: u16,\u000a    third: u8\u000a}\u000a\u000a// The size of the first field is 1, so add 1 to the size. Size is 1.\u000a// The alignment of the second field is 2, so add 1 to the size for padding. Size is 2.\u000a// The size of the second field is 2, so add 2 to the size. Size is 4.\u000a// The alignment of the third field is 1, so add 0 to the size for padding. Size is 4.\u000a// The size of the third field is 1, so add 1 to the size. Size is 5.\u000a// Finally, the alignment of the struct is 2 (because the largest alignment amongst its\u000a// fields is 2), so add 1 to the size for padding. Size is 6.\u000aassert_eq!(6, mem::size_of::<FieldStruct>());\u000a\u000a#[repr(C)]\u000astruct TupleStruct(u8, u16, u8);\u000a\u000a// Tuple structs follow the same rules.\u000aassert_eq!(6, mem::size_of::<TupleStruct>());\u000a\u000a// Note that reordering the fields can lower the size. We can remove both padding bytes\u000a// by putting `third` before `second`.\u000a#[repr(C)]\u000astruct FieldStructOptimized {\u000a    first: u8,\u000a    third: u8,\u000a    second: u16\u000a}\u000a\u000aassert_eq!(4, mem::size_of::<FieldStructOptimized>());\u000a\u000a// Union size is the size of the largest field.\u000a#[repr(C)]\u000aunion ExampleUnion {\u000a    smaller: u8,\u000a    larger: u16\u000a}\u000a\u000aassert_eq!(2, mem::size_of::<ExampleUnion>());\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000acore::mem\u000a```\u000a\u000a```rust\u000apub fn replace<T>(dest: &mut T, src: T) -> T\u000a```\u000a\u000a---\u000a\u000aMoves `src` into the referenced `dest`, returning the previous `dest` value.\u000a\u000aNeither value is dropped.\u000a\u000a* If you want to replace the values of two variables, see [`swap`](https://doc.rust-lang.org/nightly/core/mem/fn.swap.html).\u000a* If you want to replace with a default value, see [`take`](https://doc.rust-lang.org/nightly/core/mem/fn.take.html).\u000a\u000a# Examples\u000a\u000aA simple example:\u000a\u000a```rust\u000ause std::mem;\u000a\u000alet mut v: Vec<i32> = vec![1, 2];\u000a\u000alet old_v = mem::replace(&mut v, vec![3, 4, 5]);\u000aassert_eq!(vec![1, 2], old_v);\u000aassert_eq!(vec![3, 4, 5], v);\u000a```\u000a\u000a`replace` allows consumption of a struct field by replacing it with another value.\u000aWithout `replace` you can run into issues like these:\u000a\u000a```rust\u000astruct Buffer<T> { buf: Vec<T> }\u000a\u000aimpl<T> Buffer<T> {\u000a    fn replace_index(&mut self, i: usize, v: T) -> T {\u000a        // error: cannot move out of dereference of `&mut`-pointer\u000a        let t = self.buf[i];\u000a        self.buf[i] = v;\u000a        t\u000a    }\u000a}\u000a```\u000a\u000aNote that `T` does not necessarily implement [`Clone`](https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html), so we can't even clone `self.buf[i]` to\u000aavoid the move. But `replace` can be used to disassociate the original value at that index from\u000a`self`, allowing it to be returned:\u000a\u000a```rust\u000ause std::mem;\u000a\u000aimpl<T> Buffer<T> {\u000a    fn replace_index(&mut self, i: usize, v: T) -> T {\u000a        mem::replace(&mut self.buf[i], v)\u000a    }\u000a}\u000a\u000alet mut buffer = Buffer { buf: vec![0, 1] };\u000aassert_eq!(buffer.buf[0], 0);\u000a\u000aassert_eq!(buffer.replace_index(0, 2), 0);\u000aassert_eq!(buffer.buf[0], 2);\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000acore::mem\u000a```\u000a\u000a```rust\u000apub fn swap<T>(x: &mut T, y: &mut T)\u000a```\u000a\u000a---\u000a\u000aSwaps the values at two mutable locations, without deinitializing either one.\u000a\u000a* If you want to swap with a default or dummy value, see [`take`](https://doc.rust-lang.org/nightly/core/mem/fn.take.html).\u000a* If you want to swap with a passed value, returning the old value, see [`replace`](https://doc.rust-lang.org/nightly/core/mem/fn.replace.html).\u000a\u000a# Examples\u000a\u000a```rust\u000ause std::mem;\u000a\u000alet mut x = 5;\u000alet mut y = 42;\u000a\u000amem::swap(&mut x, &mut y);\u000a\u000aassert_eq!(42, x);\u000aassert_eq!(5, y);\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000acore::mem::maybe_uninit\u000a```\u000a\u000a```rust\u000apub union MaybeUninit<T>\u000a```\u000a\u000a---\u000a\u000aA wrapper type to construct uninitialized instances of `T`.\u000a\u000a# Initialization invariant\u000a\u000aThe compiler, in general, assumes that a variable is properly initialized\u000aaccording to the requirements of the variable's type. For example, a variable of\u000areference type must be aligned and non-NULL. This is an invariant that must\u000a*always* be upheld, even in unsafe code. As a consequence, zero-initializing a\u000avariable of reference type causes instantaneous [undefined behavior](https://doc.rust-lang.org/nightly/core/reference/behavior-considered-undefined.html),\u000ano matter whether that reference ever gets used to access memory:\u000a\u000a```rust\u000ause std::mem::{self, MaybeUninit};\u000a\u000alet x: &i32 = unsafe { mem::zeroed() }; // undefined behavior! âš ï¸\u000a// The equivalent code with `MaybeUninit<&i32>`:\u000alet x: &i32 = unsafe { MaybeUninit::zeroed().assume_init() }; // undefined behavior! âš ï¸\u000a```\u000a\u000aThis is exploited by the compiler for various optimizations, such as eliding\u000arun-time checks and optimizing `enum` layout.\u000a\u000aSimilarly, entirely uninitialized memory may have any content, while a `bool` must\u000aalways be `true` or `false`. Hence, creating an uninitialized `bool` is undefined behavior:\u000a\u000a```rust\u000ause std::mem::{self, MaybeUninit};\u000a\u000alet b: bool = unsafe { mem::uninitialized() }; // undefined behavior! âš ï¸\u000a// The equivalent code with `MaybeUninit<bool>`:\u000alet b: bool = unsafe { MaybeUninit::uninit().assume_init() }; // undefined behavior! âš ï¸\u000a```\u000a\u000aMoreover, uninitialized memory is special in that the compiler knows that\u000ait does not have a fixed value. This makes it undefined behavior to have\u000auninitialized data in a variable even if that variable has an integer type,\u000awhich otherwise can hold any *fixed* bit pattern:\u000a\u000a```rust\u000ause std::mem::{self, MaybeUninit};\u000a\u000alet x: i32 = unsafe { mem::uninitialized() }; // undefined behavior! âš ï¸\u000a// The equivalent code with `MaybeUninit<i32>`:\u000alet x: i32 = unsafe { MaybeUninit::uninit().assume_init() }; // undefined behavior! âš ï¸\u000a```\u000a\u000a(Notice that the rules around uninitialized integers are not finalized yet, but\u000auntil they are, it is advisable to avoid them.)\u000a\u000aOn top of that, remember that most types have additional invariants beyond merely\u000abeing considered initialized at the type level. For example, a `1`-initialized [`Vec<T>`]\u000ais considered initialized (under the current implementation; this does not constitute\u000aa stable guarantee) because the only requirement the compiler knows about it\u000ais that the data pointer must be non-null. Creating such a `Vec<T>` does not cause\u000a*immediate* undefined behavior, but will cause undefined behavior with most\u000asafe operations (including dropping it).\u000a\u000a# Examples\u000a\u000a`MaybeUninit<T>` serves to enable unsafe code to deal with uninitialized data.\u000aIt is a signal to the compiler indicating that the data here might *not*\u000abe initialized:\u000a\u000a```rust\u000ause std::mem::MaybeUninit;\u000a\u000a// Create an explicitly uninitialized reference. The compiler knows that data inside\u000a// a `MaybeUninit<T>` may be invalid, and hence this is not UB:\u000alet mut x = MaybeUninit::<&i32>::uninit();\u000a// Set it to a valid value.\u000aunsafe { x.as_mut_ptr().write(&0); }\u000a// Extract the initialized data -- this is only allowed *after* properly\u000a// initializing `x`!\u000alet x = unsafe { x.assume_init() };\u000a```\u000a\u000aThe compiler then knows to not make any incorrect assumptions or optimizations on this code.\u000a\u000aYou can think of `MaybeUninit<T>` as being a bit like `Option<T>` but without\u000aany of the run-time tracking and without any of the safety checks.\u000a\u000a## out-pointers\u000a\u000aYou can use `MaybeUninit<T>` to implement \"out-pointers\": instead of returning data\u000afrom a function, pass it a pointer to some (uninitialized) memory to put the\u000aresult into. This can be useful when it is important for the caller to control\u000ahow the memory the result is stored in gets allocated, and you want to avoid\u000aunnecessary moves.\u000a\u000a```rust\u000ause std::mem::MaybeUninit;\u000a\u000aunsafe fn make_vec(out: *mut Vec<i32>) {\u000a    // `write` does not drop the old contents, which is important.\u000a    out.write(vec![1, 2, 3]);\u000a}\u000a\u000alet mut v = MaybeUninit::uninit();\u000aunsafe { make_vec(v.as_mut_ptr()); }\u000a// Now we know `v` is initialized! This also makes sure the vector gets\u000a// properly dropped.\u000alet v = unsafe { v.assume_init() };\u000aassert_eq!(&v, &[1, 2, 3]);\u000a```\u000a\u000a## Initializing an array element-by-element\u000a\u000a`MaybeUninit<T>` can be used to initialize a large array element-by-element:\u000a\u000a```rust\u000ause std::mem::{self, MaybeUninit};\u000a\u000alet data = {\u000a    // Create an uninitialized array of `MaybeUninit`. The `assume_init` is\u000a    // safe because the type we are claiming to have initialized here is a\u000a    // bunch of `MaybeUninit`s, which do not require initialization.\u000a    let mut data: [MaybeUninit<Vec<u32>>; 1000] = unsafe {\u000a        MaybeUninit::uninit().assume_init()\u000a    };\u000a\u000a    // Dropping a `MaybeUninit` does nothing. Thus using raw pointer\u000a    // assignment instead of `ptr::write` does not cause the old\u000a    // uninitialized value to be dropped. Also if there is a panic during\u000a    // this loop, we have a memory leak, but there is no memory safety\u000a    // issue.\u000a    for elem in &mut data[..] {\u000a        *elem = MaybeUninit::new(vec![42]);\u000a    }\u000a\u000a    // Everything is initialized. Transmute the array to the\u000a    // initialized type.\u000a    unsafe { mem::transmute::<_, [Vec<u32>; 1000]>(data) }\u000a};\u000a\u000aassert_eq!(&data[0], &[42]);\u000a```\u000a\u000aYou can also work with partially initialized arrays, which could\u000abe found in low-level datastructures.\u000a\u000a```rust\u000ause std::mem::MaybeUninit;\u000ause std::ptr;\u000a\u000a// Create an uninitialized array of `MaybeUninit`. The `assume_init` is\u000a// safe because the type we are claiming to have initialized here is a\u000a// bunch of `MaybeUninit`s, which do not require initialization.\u000alet mut data: [MaybeUninit<String>; 1000] = unsafe { MaybeUninit::uninit().assume_init() };\u000a// Count the number of elements we have assigned.\u000alet mut data_len: usize = 0;\u000a\u000afor elem in &mut data[0..500] {\u000a    *elem = MaybeUninit::new(String::from(\"hello\"));\u000a    data_len += 1;\u000a}\u000a\u000a// For each item in the array, drop if we allocated it.\u000afor elem in &mut data[0..data_len] {\u000a    unsafe { ptr::drop_in_place(elem.as_mut_ptr()); }\u000a}\u000a```\u000a\u000a## Initializing a struct field-by-field\u000a\u000aThere is currently no supported way to create a raw pointer or reference\u000ato a field of a struct inside `MaybeUninit<Struct>`. That means it is not possible\u000ato create a struct by calling `MaybeUninit::uninit::<Struct>()` and then writing\u000ato its fields.\u000a\u000a# Layout\u000a\u000a`MaybeUninit<T>` is guaranteed to have the same size, alignment, and ABI as `T`:\u000a\u000a```rust\u000ause std::mem::{MaybeUninit, size_of, align_of};\u000aassert_eq!(size_of::<MaybeUninit<u64>>(), size_of::<u64>());\u000aassert_eq!(align_of::<MaybeUninit<u64>>(), align_of::<u64>());\u000a```\u000a\u000aHowever remember that a type *containing* a `MaybeUninit<T>` is not necessarily the same\u000alayout; Rust does not in general guarantee that the fields of a `Foo<T>` have the same order as\u000aa `Foo<U>` even if `T` and `U` have the same size and alignment. Furthermore because any bit\u000avalue is valid for a `MaybeUninit<T>` the compiler can't apply non-zero/niche-filling\u000aoptimizations, potentially resulting in a larger size:\u000a\u000a```rust\u000aassert_eq!(size_of::<Option<bool>>(), 1);\u000aassert_eq!(size_of::<Option<MaybeUninit<bool>>>(), 2);\u000a```\u000a\u000aIf `T` is FFI-safe, then so is `MaybeUninit<T>`.\u000a\u000aWhile `MaybeUninit` is `#[repr(transparent)]` (indicating it guarantees the same size,\u000aalignment, and ABI as `T`), this does *not* change any of the previous caveats. `Option<T>` and\u000a`Option<MaybeUninit<T>>` may still have different sizes, and types containing a field of type\u000a`T` may be laid out (and sized) differently than if that field were `MaybeUninit<T>`.\u000a`MaybeUninit` is a union type, and `#[repr(transparent)]` on unions is unstable (see [the\u000atracking issue](https://github.com/rust-lang/rust/issues/60405)). Over time, the exact\u000aguarantees of `#[repr(transparent)]` on unions may evolve, and `MaybeUninit` may or may not\u000aremain `#[repr(transparent)]`. That said, `MaybeUninit<T>` will *always* guarantee that it has\u000athe same size, alignment, and ABI as `T`; it's just that the way `MaybeUninit` implements that\u000aguarantee may evolve."
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000acore::mem::maybe_uninit::MaybeUninit\u000a```\u000a\u000a```rust\u000apub const fn new(val: T) -> MaybeUninit<T>\u000a```\u000a\u000a---\u000a\u000aCreates a new `MaybeUninit<T>` initialized with the given value.\u000aIt is safe to call [`assume_init`] on the return value of this function.\u000a\u000aNote that dropping a `MaybeUninit<T>` will never call `T`'s drop code.\u000aIt is your responsibility to make sure `T` gets dropped if it got initialized."
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000acore::mem::maybe_uninit::MaybeUninit\u000a```\u000a\u000a```rust\u000apub const fn uninit() -> MaybeUninit<T>\u000a```\u000a\u000a---\u000a\u000aCreates a new `MaybeUninit<T>` in an uninitialized state.\u000a\u000aNote that dropping a `MaybeUninit<T>` will never call `T`'s drop code.\u000aIt is your responsibility to make sure `T` gets dropped if it got initialized.\u000a\u000aSee the [type-level documentation](https://doc.rust-lang.org/nightly/core/mem/maybe_uninit/union.MaybeUninit.html) for some examples."
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000acore::mem::maybe_uninit::MaybeUninit\u000a```\u000a\u000a```rust\u000apub unsafe fn assume_init(self) -> T\u000a```\u000a\u000a---\u000a\u000aExtracts the value from the `MaybeUninit<T>` container. This is a great way\u000ato ensure that the data will get dropped, because the resulting `T` is\u000asubject to the usual drop handling.\u000a\u000a# Safety\u000a\u000aIt is up to the caller to guarantee that the `MaybeUninit<T>` really is in an initialized\u000astate. Calling this when the content is not yet fully initialized causes immediate undefined\u000abehavior. The [type-level documentation](https://doc.rust-lang.org/nightly/core/mem/maybe_uninit/union.MaybeUninit.html#initialization-invariant) contains more information about\u000athis initialization invariant.\u000a\u000aOn top of that, remember that most types have additional invariants beyond merely\u000abeing considered initialized at the type level. For example, a `1`-initialized [`Vec<T>`]\u000ais considered initialized (under the current implementation; this does not constitute\u000aa stable guarantee) because the only requirement the compiler knows about it\u000ais that the data pointer must be non-null. Creating such a `Vec<T>` does not cause\u000a*immediate* undefined behavior, but will cause undefined behavior with most\u000asafe operations (including dropping it).\u000a\u000a# Examples\u000a\u000aCorrect usage of this method:\u000a\u000a```rust\u000ause std::mem::MaybeUninit;\u000a\u000alet mut x = MaybeUninit::<bool>::uninit();\u000aunsafe { x.as_mut_ptr().write(true); }\u000alet x_init = unsafe { x.assume_init() };\u000aassert_eq!(x_init, true);\u000a```\u000a\u000a*Incorrect* usage of this method:\u000a\u000a```rust\u000ause std::mem::MaybeUninit;\u000a\u000alet x = MaybeUninit::<Vec<u32>>::uninit();\u000alet x_init = unsafe { x.assume_init() };\u000a// `x` had not been initialized yet, so this last line caused undefined behavior. âš ï¸\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000acore::num\u000a```\u000a\u000a```rust\u000apub const fn pow(self, exp: u32) -> Self\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000acore::num\u000a```\u000a\u000a```rust\u000apub const fn wrapping_add(self, rhs: Self) -> Self\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000acore::ops::arith\u000a```\u000a\u000a```rust\u000apub trait Add<Rhs = Self>\u000a```\u000a\u000a---\u000a\u000aThe addition operator `+`.\u000a\u000aNote that `Rhs` is `Self` by default, but this is not mandatory. For\u000aexample, [`std::time::SystemTime`] implements `Add<Duration>`, which permits\u000aoperations of the form `SystemTime = SystemTime + Duration`.\u000a\u000a# Examples\u000a\u000a## `Add`able points\u000a\u000a```rust\u000ause std::ops::Add;\u000a\u000a#[derive(Debug, Copy, Clone, PartialEq)]\u000astruct Point {\u000a    x: i32,\u000a    y: i32,\u000a}\u000a\u000aimpl Add for Point {\u000a    type Output = Self;\u000a\u000a    fn add(self, other: Self) -> Self {\u000a        Self {\u000a            x: self.x + other.x,\u000a            y: self.y + other.y,\u000a        }\u000a    }\u000a}\u000a\u000aassert_eq!(Point { x: 1, y: 0 } + Point { x: 2, y: 3 },\u000a           Point { x: 3, y: 3 });\u000a```\u000a\u000a## Implementing `Add` with generics\u000a\u000aHere is an example of the same `Point` struct implementing the `Add` trait\u000ausing generics.\u000a\u000a```rust\u000ause std::ops::Add;\u000a\u000a#[derive(Debug, Copy, Clone, PartialEq)]\u000astruct Point<T> {\u000a    x: T,\u000a    y: T,\u000a}\u000a\u000a// Notice that the implementation uses the associated type `Output`.\u000aimpl<T: Add<Output = T>> Add for Point<T> {\u000a    type Output = Self;\u000a\u000a    fn add(self, other: Self) -> Self::Output {\u000a        Self {\u000a            x: self.x + other.x,\u000a            y: self.y + other.y,\u000a        }\u000a    }\u000a}\u000a\u000aassert_eq!(Point { x: 1, y: 0 } + Point { x: 2, y: 3 },\u000a           Point { x: 3, y: 3 });\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000acore::ops::arith\u000a```\u000a\u000a```rust\u000apub trait AddAssign<Rhs = Self>\u000a```\u000a\u000a---\u000a\u000aThe addition assignment operator `+=`.\u000a\u000a# Examples\u000a\u000aThis example creates a `Point` struct that implements the `AddAssign`\u000atrait, and then demonstrates add-assigning to a mutable `Point`.\u000a\u000a```rust\u000ause std::ops::AddAssign;\u000a\u000a#[derive(Debug, Copy, Clone, PartialEq)]\u000astruct Point {\u000a    x: i32,\u000a    y: i32,\u000a}\u000a\u000aimpl AddAssign for Point {\u000a    fn add_assign(&mut self, other: Self) {\u000a        *self = Self {\u000a            x: self.x + other.x,\u000a            y: self.y + other.y,\u000a        };\u000a    }\u000a}\u000a\u000alet mut point = Point { x: 1, y: 0 };\u000apoint += Point { x: 2, y: 3 };\u000aassert_eq!(point, Point { x: 3, y: 3 });\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000acore::ops::arith\u000a```\u000a\u000a```rust\u000apub trait Mul<Rhs = Self>\u000a```\u000a\u000a---\u000a\u000aThe multiplication operator `*`.\u000a\u000aNote that `Rhs` is `Self` by default, but this is not mandatory.\u000a\u000a# Examples\u000a\u000a## `Mul`tipliable rational numbers\u000a\u000a```rust\u000ause std::ops::Mul;\u000a\u000a// By the fundamental theorem of arithmetic, rational numbers in lowest\u000a// terms are unique. So, by keeping `Rational`s in reduced form, we can\u000a// derive `Eq` and `PartialEq`.\u000a#[derive(Debug, Eq, PartialEq)]\u000astruct Rational {\u000a    numerator: usize,\u000a    denominator: usize,\u000a}\u000a\u000aimpl Rational {\u000a    fn new(numerator: usize, denominator: usize) -> Self {\u000a        if denominator == 0 {\u000a            panic!(\"Zero is an invalid denominator!\");\u000a        }\u000a\u000a        // Reduce to lowest terms by dividing by the greatest common\u000a        // divisor.\u000a        let gcd = gcd(numerator, denominator);\u000a        Self {\u000a            numerator: numerator / gcd,\u000a            denominator: denominator / gcd,\u000a        }\u000a    }\u000a}\u000a\u000aimpl Mul for Rational {\u000a    // The multiplication of rational numbers is a closed operation.\u000a    type Output = Self;\u000a\u000a    fn mul(self, rhs: Self) -> Self {\u000a        let numerator = self.numerator * rhs.numerator;\u000a        let denominator = self.denominator * rhs.denominator;\u000a        Self::new(numerator, denominator)\u000a    }\u000a}\u000a\u000a// Euclid's two-thousand-year-old algorithm for finding the greatest common\u000a// divisor.\u000afn gcd(x: usize, y: usize) -> usize {\u000a    let mut x = x;\u000a    let mut y = y;\u000a    while y != 0 {\u000a        let t = y;\u000a        y = x % y;\u000a        x = t;\u000a    }\u000a    x\u000a}\u000a\u000aassert_eq!(Rational::new(1, 2), Rational::new(2, 4));\u000aassert_eq!(Rational::new(2, 3) * Rational::new(3, 4),\u000a           Rational::new(1, 2));\u000a```\u000a\u000a## Multiplying vectors by scalars as in linear algebra\u000a\u000a```rust\u000ause std::ops::Mul;\u000a\u000astruct Scalar { value: usize }\u000a\u000a#[derive(Debug, PartialEq)]\u000astruct Vector { value: Vec<usize> }\u000a\u000aimpl Mul<Scalar> for Vector {\u000a    type Output = Self;\u000a\u000a    fn mul(self, rhs: Scalar) -> Self::Output {\u000a        Self { value: self.value.iter().map(|v| v * rhs.value).collect() }\u000a    }\u000a}\u000a\u000alet vector = Vector { value: vec![2, 4, 6] };\u000alet scalar = Scalar { value: 3 };\u000aassert_eq!(vector * scalar, Vector { value: vec![6, 12, 18] });\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000acore::ops::arith\u000a```\u000a\u000a```rust\u000apub trait Neg\u000a```\u000a\u000a---\u000a\u000aThe unary negation operator `-`.\u000a\u000a# Examples\u000a\u000aAn implementation of `Neg` for `Sign`, which allows the use of `-` to\u000anegate its value.\u000a\u000a```rust\u000ause std::ops::Neg;\u000a\u000a#[derive(Debug, PartialEq)]\u000aenum Sign {\u000a    Negative,\u000a    Zero,\u000a    Positive,\u000a}\u000a\u000aimpl Neg for Sign {\u000a    type Output = Self;\u000a\u000a    fn neg(self) -> Self::Output {\u000a        match self {\u000a            Sign::Negative => Sign::Positive,\u000a            Sign::Zero => Sign::Zero,\u000a            Sign::Positive => Sign::Negative,\u000a        }\u000a    }\u000a}\u000a\u000a// A negative positive is a negative.\u000aassert_eq!(-Sign::Positive, Sign::Negative);\u000a// A double negative is a positive.\u000aassert_eq!(-Sign::Negative, Sign::Positive);\u000a// Zero is its own negation.\u000aassert_eq!(-Sign::Zero, Sign::Zero);\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000acore::ops::arith\u000a```\u000a\u000a```rust\u000apub type Output\u000a```\u000a\u000a---\u000a\u000aThe resulting type after applying the `*` operator."
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000acore::ops::arith\u000a```\u000a\u000a```rust\u000apub type Output\u000a```\u000a\u000a---\u000a\u000aThe resulting type after applying the `+` operator."
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000acore::ops::arith\u000a```\u000a\u000a```rust\u000apub type Output\u000a```\u000a\u000a---\u000a\u000aThe resulting type after applying the `-` operator."
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000acore::ops::function\u000a```\u000a\u000a```rust\u000apub trait Fn<Args>\u000awhere\u000a    Self: FnMut<Args>,\u000a```\u000a\u000a---\u000a\u000aThe version of the call operator that takes an immutable receiver.\u000a\u000aInstances of `Fn` can be called repeatedly without mutating state.\u000a\u000a*This trait (`Fn`) is not to be confused with [function pointers]\u000a(`fn`).*\u000a\u000a`Fn` is implemented automatically by closures which only take immutable\u000areferences to captured variables or don't capture anything at all, as well\u000aas (safe) [function pointers] (with some caveats, see their documentation\u000afor more details). Additionally, for any type `F` that implements `Fn`, `&F`\u000aimplements `Fn`, too.\u000a\u000aSince both [`FnMut`](https://doc.rust-lang.org/nightly/core/ops/function/trait.FnMut.html) and [`FnOnce`](https://doc.rust-lang.org/nightly/core/ops/function/trait.FnOnce.html) are supertraits of `Fn`, any\u000ainstance of `Fn` can be used as a parameter where a [`FnMut`](https://doc.rust-lang.org/nightly/core/ops/function/trait.FnMut.html) or [`FnOnce`](https://doc.rust-lang.org/nightly/core/ops/function/trait.FnOnce.html)\u000ais expected.\u000a\u000aUse `Fn` as a bound when you want to accept a parameter of function-like\u000atype and need to call it repeatedly and without mutating state (e.g., when\u000acalling it concurrently). If you do not need such strict requirements, use\u000a[`FnMut`](https://doc.rust-lang.org/nightly/core/ops/function/trait.FnMut.html) or [`FnOnce`](https://doc.rust-lang.org/nightly/core/ops/function/trait.FnOnce.html) as bounds.\u000a\u000aSee the [chapter on closures in *The Rust Programming Language*](https://doc.rust-lang.org/nightly/core/book/ch13-01-closures.html) for\u000asome more information on this topic.\u000a\u000aAlso of note is the special syntax for `Fn` traits (e.g.\u000a`Fn(usize, bool) -> usize`). Those interested in the technical details of\u000athis can refer to [the relevant section in the *Rustonomicon*](https://doc.rust-lang.org/nightly/core/nomicon/hrtb.html).\u000a\u000a# Examples\u000a\u000a## Calling a closure\u000a\u000a```rust\u000alet square = |x| x * x;\u000aassert_eq!(square(5), 25);\u000a```\u000a\u000a## Using a `Fn` parameter\u000a\u000a```rust\u000afn call_with_one<F>(func: F) -> usize\u000a    where F: Fn(usize) -> usize {\u000a    func(1)\u000a}\u000a\u000alet double = |x| x * 2;\u000aassert_eq!(call_with_one(double), 2);\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000acore::ops::range\u000a```\u000a\u000a```rust\u000apub struct Range<Idx>\u000a```\u000a\u000a---\u000a\u000aA (half-open) range bounded inclusively below and exclusively above\u000a(`start..end`).\u000a\u000aThe `Range` `start..end` contains all values with `x >= start` and\u000a`x < end`. It is empty unless `start < end`.\u000a\u000a# Examples\u000a\u000a```rust\u000aassert_eq!((3..5), std::ops::Range { start: 3, end: 5 });\u000aassert_eq!(3 + 4 + 5, (3..6).sum());\u000a\u000alet arr = [0, 1, 2, 3, 4];\u000aassert_eq!(arr[ ..  ], [0,1,2,3,4]);\u000aassert_eq!(arr[ .. 3], [0,1,2    ]);\u000aassert_eq!(arr[ ..=3], [0,1,2,3  ]);\u000aassert_eq!(arr[1..  ], [  1,2,3,4]);\u000aassert_eq!(arr[1.. 3], [  1,2    ]);  // Range\u000aassert_eq!(arr[1..=3], [  1,2,3  ]);\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000acore::ops::range\u000a```\u000a\u000a```rust\u000apub struct RangeFrom<Idx>\u000a```\u000a\u000a---\u000a\u000aA range only bounded inclusively below (`start..`).\u000a\u000aThe `RangeFrom` `start..` contains all values with `x >= start`.\u000a\u000a*Note*: Overflow in the [`Iterator`](https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html) implementation (when the contained\u000adata type reaches its numerical limit) is allowed to panic, wrap, or\u000asaturate. This behavior is defined by the implementation of the [`Step`]\u000atrait. For primitive integers, this follows the normal rules, and respects\u000athe overflow checks profile (panic in debug, wrap in release). Note also\u000athat overflow happens earlier than you might assume: the overflow happens\u000ain the call to `next` that yields the maximum value, as the range must be\u000aset to a state to yield the next value.\u000a\u000a# Examples\u000a\u000a```rust\u000aassert_eq!((2..), std::ops::RangeFrom { start: 2 });\u000aassert_eq!(2 + 3 + 4, (2..).take(3).sum());\u000a\u000alet arr = [0, 1, 2, 3, 4];\u000aassert_eq!(arr[ ..  ], [0,1,2,3,4]);\u000aassert_eq!(arr[ .. 3], [0,1,2    ]);\u000aassert_eq!(arr[ ..=3], [0,1,2,3  ]);\u000aassert_eq!(arr[1..  ], [  1,2,3,4]);  // RangeFrom\u000aassert_eq!(arr[1.. 3], [  1,2    ]);\u000aassert_eq!(arr[1..=3], [  1,2,3  ]);\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000acore::ops::range\u000a```\u000a\u000a```rust\u000apub struct RangeFull\u000a```\u000a\u000a---\u000a\u000aAn unbounded range (`..`).\u000a\u000a`RangeFull` is primarily used as a [slicing index], its shorthand is `..`.\u000aIt cannot serve as an [`Iterator`](https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html) because it doesn't have a starting point.\u000a\u000a# Examples\u000a\u000aThe `..` syntax is a `RangeFull`:\u000a\u000a```rust\u000aassert_eq!((..), std::ops::RangeFull);\u000a```\u000a\u000aIt does not have an [`IntoIterator`](https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html) implementation, so you can't use it in\u000aa `for` loop directly. This won't compile:\u000a\u000a```rust\u000afor i in .. {\u000a   // ...\u000a}\u000a```\u000a\u000aUsed as a [slicing index], `RangeFull` produces the full array as a slice.\u000a\u000a```rust\u000alet arr = [0, 1, 2, 3, 4];\u000aassert_eq!(arr[ ..  ], [0,1,2,3,4]);  // RangeFull\u000aassert_eq!(arr[ .. 3], [0,1,2    ]);\u000aassert_eq!(arr[ ..=3], [0,1,2,3  ]);\u000aassert_eq!(arr[1..  ], [  1,2,3,4]);\u000aassert_eq!(arr[1.. 3], [  1,2    ]);\u000aassert_eq!(arr[1..=3], [  1,2,3  ]);\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000acore::ops::range::RangeFrom\u000a```\u000a\u000a```rust\u000apub start: Idx\u000a```\u000a\u000a---\u000a\u000aThe lower bound of the range (inclusive)."
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000acore::option\u000a```\u000a\u000a```rust\u000apub enum Option<T>\u000a```\u000a\u000a---\u000a\u000aThe `Option` type. See [the module level documentation](https://doc.rust-lang.org/nightly/core/option/index.html) for more."
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000acore::option::Option\u000a```\u000a\u000a```rust\u000aNone\u000a```\u000a\u000a---\u000a\u000aNo value"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000acore::option::Option\u000a```\u000a\u000a```rust\u000aSome(T)\u000a```\u000a\u000a---\u000a\u000aSome value `T`"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000acore::option::Option\u000a```\u000a\u000a```rust\u000apub const fn unwrap(self) -> T\u000a```\u000a\u000a---\u000a\u000aReturns the contained [`Some`](https://doc.rust-lang.org/nightly/core/option/enum.Option.html) value, consuming the `self` value.\u000a\u000aBecause this function may panic, its use is generally discouraged.\u000aInstead, prefer to use pattern matching and handle the [`None`](https://doc.rust-lang.org/nightly/core/option/enum.Option.html)\u000acase explicitly, or call [`unwrap_or`], [`unwrap_or_else`], or\u000a[`unwrap_or_default`].\u000a\u000a# Panics\u000a\u000aPanics if the self value equals [`None`](https://doc.rust-lang.org/nightly/core/option/enum.Option.html).\u000a\u000a# Examples\u000a\u000a```rust\u000alet x = Some(\"air\");\u000aassert_eq!(x.unwrap(), \"air\");\u000a```\u000a\u000a```{.should_panic}\u000alet x: Option<&str> = None;\u000aassert_eq!(x.unwrap(), \"air\"); // fails\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000acore::option::Option\u000a```\u000a\u000a```rust\u000apub fn take(&mut self) -> Option<T>\u000a```\u000a\u000a---\u000a\u000aTakes the value out of the option, leaving a [`None`](https://doc.rust-lang.org/nightly/core/option/enum.Option.html) in its place.\u000a\u000a# Examples\u000a\u000a```rust\u000alet mut x = Some(2);\u000alet y = x.take();\u000aassert_eq!(x, None);\u000aassert_eq!(y, Some(2));\u000a\u000alet mut x: Option<u32> = None;\u000alet y = x.take();\u000aassert_eq!(x, None);\u000aassert_eq!(y, None);\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000acore::result\u000a```\u000a\u000a```rust\u000apub enum Result<T, E>\u000a```\u000a\u000a---\u000a\u000a`Result` is a type that represents either success ([`Ok`](https://doc.rust-lang.org/nightly/core/result/enum.Result.html)) or failure ([`Err`](https://doc.rust-lang.org/nightly/core/result/enum.Result.html)).\u000a\u000aSee the [`std::result`](https://doc.rust-lang.org/nightly/core/result/index.html) module documentation for details."
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000acore::result::Result\u000a```\u000a\u000a```rust\u000aErr(E)\u000a```\u000a\u000a---\u000a\u000aContains the error value"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000acore::result::Result\u000a```\u000a\u000a```rust\u000aOk(T)\u000a```\u000a\u000a---\u000a\u000aContains the success value"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000acore::result::Result\u000a```\u000a\u000a```rust\u000apub const fn is_err(&self) -> bool\u000a```\u000a\u000a---\u000a\u000aReturns `true` if the result is [`Err`](https://doc.rust-lang.org/nightly/core/result/enum.Result.html).\u000a\u000a# Examples\u000a\u000aBasic usage:\u000a\u000a```rust\u000alet x: Result<i32, &str> = Ok(-3);\u000aassert_eq!(x.is_err(), false);\u000a\u000alet x: Result<i32, &str> = Err(\"Some error message\");\u000aassert_eq!(x.is_err(), true);\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000acore::result::Result\u000a```\u000a\u000a```rust\u000apub const fn is_ok(&self) -> bool\u000a```\u000a\u000a---\u000a\u000aReturns `true` if the result is [`Ok`](https://doc.rust-lang.org/nightly/core/result/enum.Result.html).\u000a\u000a# Examples\u000a\u000aBasic usage:\u000a\u000a```rust\u000alet x: Result<i32, &str> = Ok(-3);\u000aassert_eq!(x.is_ok(), true);\u000a\u000alet x: Result<i32, &str> = Err(\"Some error message\");\u000aassert_eq!(x.is_ok(), false);\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000acore::result::Result\u000a```\u000a\u000a```rust\u000apub fn err(self) -> Option<E>\u000a```\u000a\u000a---\u000a\u000aConverts from `Result<T, E>` to [`Option<E>`].\u000a\u000aConverts `self` into an [`Option<E>`], consuming `self`,\u000aand discarding the success value, if any.\u000a\u000a# Examples\u000a\u000aBasic usage:\u000a\u000a```rust\u000alet x: Result<u32, &str> = Ok(2);\u000aassert_eq!(x.err(), None);\u000a\u000alet x: Result<u32, &str> = Err(\"Nothing here\");\u000aassert_eq!(x.err(), Some(\"Nothing here\"));\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000acore::result::Result\u000a```\u000a\u000a```rust\u000apub fn expect(self, msg: &str) -> T\u000a```\u000a\u000a---\u000a\u000aReturns the contained [`Ok`](https://doc.rust-lang.org/nightly/core/result/enum.Result.html) value, consuming the `self` value.\u000a\u000a# Panics\u000a\u000aPanics if the value is an [`Err`](https://doc.rust-lang.org/nightly/core/result/enum.Result.html), with a panic message including the\u000apassed message, and the content of the [`Err`](https://doc.rust-lang.org/nightly/core/result/enum.Result.html).\u000a\u000a# Examples\u000a\u000aBasic usage:\u000a\u000a```{.should_panic}\u000alet x: Result<u32, &str> = Err(\"emergency failure\");\u000ax.expect(\"Testing expect\"); // panics with `Testing expect: emergency failure`\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000acore::result::Result\u000a```\u000a\u000a```rust\u000apub fn ok(self) -> Option<T>\u000a```\u000a\u000a---\u000a\u000aConverts from `Result<T, E>` to [`Option<T>`].\u000a\u000aConverts `self` into an [`Option<T>`], consuming `self`,\u000aand discarding the error, if any.\u000a\u000a# Examples\u000a\u000aBasic usage:\u000a\u000a```rust\u000alet x: Result<u32, &str> = Ok(2);\u000aassert_eq!(x.ok(), Some(2));\u000a\u000alet x: Result<u32, &str> = Err(\"Nothing here\");\u000aassert_eq!(x.ok(), None);\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000acore::result::Result\u000a```\u000a\u000a```rust\u000apub fn unwrap(self) -> T\u000a```\u000a\u000a---\u000a\u000aReturns the contained [`Ok`](https://doc.rust-lang.org/nightly/core/result/enum.Result.html) value, consuming the `self` value.\u000a\u000aBecause this function may panic, its use is generally discouraged.\u000aInstead, prefer to use pattern matching and handle the [`Err`](https://doc.rust-lang.org/nightly/core/result/enum.Result.html)\u000acase explicitly, or call [`unwrap_or`], [`unwrap_or_else`], or\u000a[`unwrap_or_default`].\u000a\u000a# Panics\u000a\u000aPanics if the value is an [`Err`](https://doc.rust-lang.org/nightly/core/result/enum.Result.html), with a panic message provided by the\u000a[`Err`](https://doc.rust-lang.org/nightly/core/result/enum.Result.html)'s value.\u000a\u000a# Examples\u000a\u000aBasic usage:\u000a\u000a```rust\u000alet x: Result<u32, &str> = Ok(2);\u000aassert_eq!(x.unwrap(), 2);\u000a```\u000a\u000a```{.should_panic}\u000alet x: Result<u32, &str> = Err(\"emergency failure\");\u000ax.unwrap(); // panics with `emergency failure`\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000acore::result::Result\u000a```\u000a\u000a```rust\u000apub fn unwrap_or(self, default: T) -> T\u000a```\u000a\u000a---\u000a\u000aReturns the contained [`Ok`](https://doc.rust-lang.org/nightly/core/result/enum.Result.html) value or a provided default.\u000a\u000aArguments passed to `unwrap_or` are eagerly evaluated; if you are passing\u000athe result of a function call, it is recommended to use [`unwrap_or_else`],\u000awhich is lazily evaluated.\u000a\u000a# Examples\u000a\u000aBasic usage:\u000a\u000a```rust\u000alet default = 2;\u000alet x: Result<u32, &str> = Ok(9);\u000aassert_eq!(x.unwrap_or(default), 9);\u000a\u000alet x: Result<u32, &str> = Err(\"error\");\u000aassert_eq!(x.unwrap_or(default), default);\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000acore::slice\u000a```\u000a\u000a```rust\u000apub const fn len(&self) -> usize\u000a```\u000a\u000a---\u000a\u000aReturns the number of elements in the slice.\u000a\u000a# Examples\u000a\u000a```rust\u000alet a = [1, 2, 3];\u000aassert_eq!(a.len(), 3);\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000acore::slice\u000a```\u000a\u000a```rust\u000apub fn first(&self) -> Option<&T>\u000a```\u000a\u000a---\u000a\u000aReturns the first element of the slice, or `None` if it is empty.\u000a\u000a# Examples\u000a\u000a```rust\u000alet v = [10, 40, 30];\u000aassert_eq!(Some(&10), v.first());\u000a\u000alet w: &[i32] = &[];\u000aassert_eq!(None, w.first());\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000acore::slice\u000a```\u000a\u000a```rust\u000apub fn get<I>(&self, index: I) -> Option<&I::Output>\u000awhere\u000a    I: SliceIndex<Self>,\u000a```\u000a\u000a---\u000a\u000aReturns a reference to an element or subslice depending on the type of\u000aindex.\u000a\u000a* If given a position, returns a reference to the element at that\u000a  position or `None` if out of bounds.\u000a* If given a range, returns the subslice corresponding to that range,\u000a  or `None` if out of bounds.\u000a\u000a# Examples\u000a\u000a```rust\u000alet v = [10, 40, 30];\u000aassert_eq!(Some(&40), v.get(1));\u000aassert_eq!(Some(&[10, 40][..]), v.get(0..2));\u000aassert_eq!(None, v.get(3));\u000aassert_eq!(None, v.get(0..4));\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000acore::slice\u000a```\u000a\u000a```rust\u000apub fn iter(&self) -> Iter<'_, T>\u000a```\u000a\u000a---\u000a\u000aReturns an iterator over the slice.\u000a\u000a# Examples\u000a\u000a```rust\u000alet x = &[1, 2, 4];\u000alet mut iterator = x.iter();\u000a\u000aassert_eq!(iterator.next(), Some(&1));\u000aassert_eq!(iterator.next(), Some(&2));\u000aassert_eq!(iterator.next(), Some(&4));\u000aassert_eq!(iterator.next(), None);\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000acore::slice\u000a```\u000a\u000a```rust\u000apub fn iter_mut(&mut self) -> IterMut<'_, T>\u000a```\u000a\u000a---\u000a\u000aReturns an iterator that allows modifying each value.\u000a\u000a# Examples\u000a\u000a```rust\u000alet x = &mut [1, 2, 4];\u000afor elem in x.iter_mut() {\u000a    *elem += 2;\u000a}\u000aassert_eq!(x, &[3, 4, 6]);\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000acore::slice\u000a```\u000a\u000a```rust\u000apub fn reverse(&mut self)\u000a```\u000a\u000a---\u000a\u000aReverses the order of elements in the slice, in place.\u000a\u000a# Examples\u000a\u000a```rust\u000alet mut v = [1, 2, 3];\u000av.reverse();\u000aassert!(v == [3, 2, 1]);\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000acore::str\u000a```\u000a\u000a```rust\u000apub fn chars(&self) -> Chars<'_>\u000a```\u000a\u000a---\u000a\u000aReturns an iterator over the [`char`]s of a string slice.\u000a\u000aAs a string slice consists of valid UTF-8, we can iterate through a\u000astring slice by [`char`]. This method returns such an iterator.\u000a\u000aIt's important to remember that [`char`] represents a Unicode Scalar\u000aValue, and may not match your idea of what a 'character' is. Iteration\u000aover grapheme clusters may be what you actually want. This functionality\u000ais not provided by Rust's standard library, check crates.io instead.\u000a\u000a# Examples\u000a\u000aBasic usage:\u000a\u000a```rust\u000alet word = \"goodbye\";\u000a\u000alet count = word.chars().count();\u000aassert_eq!(7, count);\u000a\u000alet mut chars = word.chars();\u000a\u000aassert_eq!(Some('g'), chars.next());\u000aassert_eq!(Some('o'), chars.next());\u000aassert_eq!(Some('o'), chars.next());\u000aassert_eq!(Some('d'), chars.next());\u000aassert_eq!(Some('b'), chars.next());\u000aassert_eq!(Some('y'), chars.next());\u000aassert_eq!(Some('e'), chars.next());\u000a\u000aassert_eq!(None, chars.next());\u000a```\u000a\u000aRemember, [`char`]s may not match your intuition about characters:\u000a\u000a```rust\u000alet y = \"yÌ†\";\u000a\u000alet mut chars = y.chars();\u000a\u000aassert_eq!(Some('y'), chars.next()); // not 'yÌ†'\u000aassert_eq!(Some('\\u{0306}'), chars.next());\u000a\u000aassert_eq!(None, chars.next());\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000acore::str\u000a```\u000a\u000a```rust\u000apub fn split_at(&self, mid: usize) -> (&str, &str)\u000a```\u000a\u000a---\u000a\u000aDivide one string slice into two at an index.\u000a\u000aThe argument, `mid`, should be a byte offset from the start of the\u000astring. It must also be on the boundary of a UTF-8 code point.\u000a\u000aThe two slices returned go from the start of the string slice to `mid`,\u000aand from `mid` to the end of the string slice.\u000a\u000aTo get mutable string slices instead, see the [`split_at_mut`]\u000amethod.\u000a\u000a# Panics\u000a\u000aPanics if `mid` is not on a UTF-8 code point boundary, or if it is\u000apast the end of the last code point of the string slice.\u000a\u000a# Examples\u000a\u000aBasic usage:\u000a\u000a```rust\u000alet s = \"Per Martin-LÃ¶f\";\u000a\u000alet (first, last) = s.split_at(3);\u000a\u000aassert_eq!(\"Per\", first);\u000aassert_eq!(\" Martin-LÃ¶f\", last);\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000acore::str\u000a```\u000a\u000a```rust\u000apub fn starts_with<'a, P>(&'a self, pat: P) -> bool\u000awhere\u000a    P: Pattern<'a>,\u000a```\u000a\u000a---\u000a\u000aReturns `true` if the given pattern matches a prefix of this\u000astring slice.\u000a\u000aReturns `false` if it does not.\u000a\u000aThe [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\u000afunction or closure that determines if a character matches.\u000a\u000a# Examples\u000a\u000aBasic usage:\u000a\u000a```rust\u000alet bananas = \"bananas\";\u000a\u000aassert!(bananas.starts_with(\"bana\"));\u000aassert!(!bananas.starts_with(\"nana\"));\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000acore::str::traits\u000a```\u000a\u000a```rust\u000apub trait FromStr\u000awhere\u000a    Self: Sized,\u000a```\u000a\u000a---\u000a\u000aParse a value from a string\u000a\u000a`FromStr`'s [`from_str`] method is often used implicitly, through\u000a[`str`](`str`)'s [`parse`] method. See [`parse`]'s documentation for examples.\u000a\u000a`FromStr` does not have a lifetime parameter, and so you can only parse types\u000athat do not contain a lifetime parameter themselves. In other words, you can\u000aparse an `i32` with `FromStr`, but not a `&i32`. You can parse a struct that\u000acontains an `i32`, but not one that contains an `&i32`.\u000a\u000a# Examples\u000a\u000aBasic implementation of `FromStr` on an example `Point` type:\u000a\u000a```rust\u000ause std::str::FromStr;\u000ause std::num::ParseIntError;\u000a\u000a#[derive(Debug, PartialEq)]\u000astruct Point {\u000a    x: i32,\u000a    y: i32\u000a}\u000a\u000aimpl FromStr for Point {\u000a    type Err = ParseIntError;\u000a\u000a    fn from_str(s: &str) -> Result<Self, Self::Err> {\u000a        let coords: Vec<&str> = s.trim_matches(|p| p == '(' || p == ')' )\u000a                                 .split(',')\u000a                                 .collect();\u000a\u000a        let x_fromstr = coords[0].parse::<i32>()?;\u000a        let y_fromstr = coords[1].parse::<i32>()?;\u000a\u000a        Ok(Point { x: x_fromstr, y: y_fromstr })\u000a    }\u000a}\u000a\u000alet p = Point::from_str(\"(1,2)\");\u000aassert_eq!(p.unwrap(), Point{ x: 1, y: 2} )\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000acore::str::traits::FromStr\u000a```\u000a\u000a```rust\u000apub fn from_str(s: &str) -> Result<Self, Self::Err>\u000a```\u000a\u000a---\u000a\u000aParses a string `s` to return a value of this type.\u000a\u000aIf parsing succeeds, return the value inside [`Ok`](https://doc.rust-lang.org/nightly/core/result/enum.Result.html), otherwise\u000awhen the string is ill-formatted return an error specific to the\u000ainside [`Err`](https://doc.rust-lang.org/nightly/core/result/enum.Result.html). The error type is specific to implementation of the trait.\u000a\u000a# Examples\u000a\u000aBasic usage with [`i32`](https://doc.rust-lang.org/nightly/core/std/primitive.i32.html), a type that implements `FromStr`:\u000a\u000a```rust\u000ause std::str::FromStr;\u000a\u000alet s = \"5\";\u000alet x = i32::from_str(s).unwrap();\u000a\u000aassert_eq!(5, x);\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000acore::u64\u000a```\u000a\u000a```rust\u000apub const MAX: u64 = 18446744073709551615 (0xFFFFFFFFFFFFFFFF)\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000acrew_size: usize\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000ad: RcDoc\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000adeep_foo: u64\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000ae1: Expr\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000ae2: Expr\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000ae: &Error\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000ae: &String\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000ae: &f64\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000ae: &i64\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000ae: Error\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000ae: Expr\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000ae: T\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000aextern crate num\u000a```\u000a\u000a---\u000a\u000aA collection of numeric types and traits for Rust.\u000a\u000aThis includes new types for big integers, rationals, and complex numbers,\u000anew traits for generic programming on numeric properties like `Integer`,\u000aand generic range iterators.\u000a\u000a## Example\u000a\u000aThis example uses the BigRational type and [Newton's method](https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method) to\u000aapproximate a square root to arbitrary precision:\u000a\u000a```rust\u000a\u000ause num::FromPrimitive;\u000ause num::bigint::BigInt;\u000ause num::rational::{Ratio, BigRational};\u000a\u000afn approx_sqrt(number: u64, iterations: usize) -> BigRational {\u000a    let start: Ratio<BigInt> = Ratio::from_integer(FromPrimitive::from_u64(number).unwrap());\u000a    let mut approx = start.clone();\u000a\u000a    for _ in 0..iterations {\u000a        approx = (&approx + (&start / &approx)) /\u000a            Ratio::from_integer(FromPrimitive::from_u64(2).unwrap());\u000a    }\u000a\u000a    approx\u000a}\u000a\u000afn main() {\u000a    println!(\"{}\", approx_sqrt(10, 4)); // prints 4057691201/1283082416\u000a}\u000a\u000a```\u000a\u000a## Compatibility\u000a\u000aThe `num` crate is tested for rustc 1.31 and greater."
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000aextern crate num_traits\u000a```\u000a\u000a---\u000a\u000aNumeric traits for generic mathematics\u000a\u000a## Compatibility\u000a\u000aThe `num-traits` crate is tested for rustc 1.8 and greater."
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000aextern crate pretty\u000a```\u000a\u000a---\u000a\u000aThis crate defines a\u000a[Wadler-style](http://homepages.inf.ed.ac.uk/wadler/papers/prettier/prettier.pdf)\u000apretty-printing API.\u000a\u000aStart with with the static functions of [Doc](https://docs.rs/pretty/0.10.0/pretty/enum.Doc.html).\u000a\u000a## Quick start\u000a\u000aLet's pretty-print simple sexps!  We want to pretty print sexps like\u000a\u000a```lisp\u000a(1 2 3)\u000a```\u000a\u000aor, if the line would be too long, like\u000a\u000a```lisp\u000a((1)\u000a (2 3)\u000a (4 5 6))\u000a```\u000a\u000aA *simple symbolic expression* consists of a numeric *atom* or a nested ordered *list* of\u000asymbolic expression children.\u000a\u000a```rust\u000aenum SExp {\u000a    Atom(u32),\u000a    List(Vec<SExp>),\u000a}\u000ause SExp::*;\u000a```\u000a\u000aWe define a simple conversion to a [Doc](https://docs.rs/pretty/0.10.0/pretty/enum.Doc.html).  Atoms are rendered as strings; lists\u000aare recursively rendered, with spaces between children where appropriate.  Children are\u000a[nested]() and [grouped](), allowing them to be laid out in a single line as appropriate.\u000a\u000a```rust\u000aimpl SExp {\u000a    /// Return a pretty printed format of self.\u000a    pub fn to_doc(&self) -> RcDoc<()> {\u000a        match *self {\u000a            Atom(ref x) => RcDoc::as_string(x),\u000a            List(ref xs) =>\u000a                RcDoc::text(\"(\")\u000a                    .append(RcDoc::intersperse(xs.into_iter().map(|x| x.to_doc()), Doc::line()).nest(1).group())\u000a                    .append(RcDoc::text(\")\"))\u000a        }\u000a    }\u000a}\u000a```\u000a\u000aNext, we convert the [Doc](https://docs.rs/pretty/0.10.0/pretty/enum.Doc.html) to a plain old string.\u000a\u000a```rust\u000aimpl SExp {\u000a    pub fn to_pretty(&self, width: usize) -> String {\u000a        let mut w = Vec::new();\u000a        self.to_doc().render(width, &mut w).unwrap();\u000a        String::from_utf8(w).unwrap()\u000a    }\u000a}\u000a```\u000a\u000aAnd finally we can test that the nesting and grouping behaves as we expected.\u000a\u000a```rust\u000alet atom = SExp::Atom(5);\u000aassert_eq!(\"5\", atom.to_pretty(10));\u000alet list = SExp::List(vec![SExp::Atom(1), SExp::Atom(2), SExp::Atom(3)]);\u000aassert_eq!(\"(1 2 3)\", list.to_pretty(10));\u000aassert_eq!(\"\\\u000a(1\u000a 2\u000a 3)\", list.to_pretty(5));\u000a```\u000a\u000a## Advanced usage\u000a\u000aThere's a more efficient pattern that uses the [DocAllocator](https://docs.rs/pretty/0.10.0/pretty/trait.DocAllocator.html) trait, as\u000aimplemented by [BoxAllocator](https://docs.rs/pretty/0.10.0/pretty/struct.BoxAllocator.html), to allocate\u000a[DocBuilder](https://docs.rs/pretty/0.10.0/pretty/struct.DocBuilder.html) instances.  See\u000a[examples/trees.rs](https://github.com/freebroccolo/pretty.rs/blob/master/examples/trees.rs#L39)\u000afor this approach."
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000aextern crate std\u000a```\u000a\u000a---\u000a\u000a# The Rust Standard Library\u000a\u000aThe Rust Standard Library is the foundation of portable Rust software, a\u000aset of minimal and battle-tested shared abstractions for the [broader Rust\u000aecosystem](https://crates.io). It offers core types, like [`Vec<T>`] and\u000a[`Option<T>`], library-defined [operations on language\u000aprimitives](https://doc.rust-lang.org/nightly/std/index.html#primitives), [standard macros](https://doc.rust-lang.org/nightly/std/index.html#macros), [I/O] and\u000a[multithreading], among [many other things](https://doc.rust-lang.org/nightly/std/index.html#what-is-in-the-standard-library-documentation).\u000a\u000a`std` is available to all Rust crates by default. Therefore, the\u000astandard library can be accessed in [`use`] statements through the path\u000a`std`, as in [`use std::env`].\u000a\u000a# How to read this documentation\u000a\u000aIf you already know the name of what you are looking for, the fastest way to\u000afind it is to use the <a href=\"#\" onclick=\"focusSearchBar();\">search\u000abar</a> at the top of the page.\u000a\u000aOtherwise, you may want to jump to one of these useful sections:\u000a\u000a* [`std::*` modules](https://doc.rust-lang.org/nightly/std/index.html#modules)\u000a* [Primitive types](https://doc.rust-lang.org/nightly/std/index.html#primitives)\u000a* [Standard macros](https://doc.rust-lang.org/nightly/std/index.html#macros)\u000a* [The Rust Prelude]\u000a\u000aIf this is your first time, the documentation for the standard library is\u000awritten to be casually perused. Clicking on interesting things should\u000agenerally lead you to interesting places. Still, there are important bits\u000ayou don't want to miss, so read on for a tour of the standard library and\u000aits documentation!\u000a\u000aOnce you are familiar with the contents of the standard library you may\u000abegin to find the verbosity of the prose distracting. At this stage in your\u000adevelopment you may want to press the `[-]` button near the top of the\u000apage to collapse it into a more skimmable view.\u000a\u000aWhile you are looking at that `[-]` button also notice the `[src]`\u000abutton. Rust's API documentation comes with the source code and you are\u000aencouraged to read it. The standard library source is generally high\u000aquality and a peek behind the curtains is often enlightening.\u000a\u000a# What is in the standard library documentation?\u000a\u000aFirst of all, The Rust Standard Library is divided into a number of focused\u000amodules, [all listed further down this page](https://doc.rust-lang.org/nightly/std/index.html#modules). These modules are\u000athe bedrock upon which all of Rust is forged, and they have mighty names\u000alike [`std::slice`] and [`std::cmp`]. Modules' documentation typically\u000aincludes an overview of the module along with examples, and are a smart\u000aplace to start familiarizing yourself with the library.\u000a\u000aSecond, implicit methods on [primitive types] are documented here. This can\u000abe a source of confusion for two reasons:\u000a\u000a1. While primitives are implemented by the compiler, the standard library\u000a   implements methods directly on the primitive types (and it is the only\u000a   library that does so), which are [documented in the section on\u000a   primitives](https://doc.rust-lang.org/nightly/std/index.html#primitives).\u000a1. The standard library exports many modules *with the same name as\u000a   primitive types*. These define additional items related to the primitive\u000a   type, but not the all-important methods.\u000a\u000aSo for example there is a [page for the primitive type\u000a`i32`](https://doc.rust-lang.org/nightly/std/primitive.i32.html) that lists all the methods that can be called on\u000a32-bit integers (very useful), and there is a [page for the module\u000a`std::i32`] that documents the constant values [`MIN`] and [`MAX`] (rarely\u000auseful).\u000a\u000aNote the documentation for the primitives [`str`] and [`[T]`](https://doc.rust-lang.org/nightly/alloc/slice/index.html) (also\u000acalled 'slice'). Many method calls on [`String`](https://doc.rust-lang.org/nightly/alloc/string/struct.String.html) and [`Vec<T>`] are actually\u000acalls to methods on [`str`] and [`[T]`](https://doc.rust-lang.org/nightly/alloc/slice/index.html) respectively, via [deref\u000acoercions](https://doc.rust-lang.org/nightly/book/ch15-02-deref.html#implicit-deref-coercions-with-functions-and-methods).\u000a\u000aThird, the standard library defines [The Rust Prelude], a small collection\u000aof items - mostly traits - that are imported into every module of every\u000acrate. The traits in the prelude are pervasive, making the prelude\u000adocumentation a good entry point to learning about the library.\u000a\u000aAnd finally, the standard library exports a number of standard macros, and\u000a[lists them on this page](https://doc.rust-lang.org/nightly/std/index.html#macros) (technically, not all of the standard\u000amacros are defined by the standard library - some are defined by the\u000acompiler - but they are documented here the same). Like the prelude, the\u000astandard macros are imported by default into all crates.\u000a\u000a# Contributing changes to the documentation\u000a\u000aCheck out the rust contribution guidelines [here](https://rustc-dev-guide.rust-lang.org/getting-started.html).\u000aThe source for this documentation can be found on\u000a[GitHub](https://github.com/rust-lang/rust).\u000aTo contribute changes, make sure you read the guidelines first, then submit\u000apull-requests for your suggested changes.\u000a\u000aContributions are appreciated! If you see a part of the docs that can be\u000aimproved, submit a PR, or chat with us first on [Discord](https://discord.gg/rust-lang)\u000a\\#docs.\u000a\u000a# A Tour of The Rust Standard Library\u000a\u000aThe rest of this crate documentation is dedicated to pointing out notable\u000afeatures of The Rust Standard Library.\u000a\u000a## Containers and collections\u000a\u000aThe [`option`](https://doc.rust-lang.org/nightly/core/option/index.html) and [`result`](https://doc.rust-lang.org/nightly/core/result/index.html) modules define optional and error-handling\u000atypes, [`Option<T>`] and [`Result<T, E>`]. The [`iter`](https://doc.rust-lang.org/nightly/core/iter/index.html) module defines\u000aRust's iterator trait, [`Iterator`](https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html), which works with the [`for`] loop to\u000aaccess collections.\u000a\u000aThe standard library exposes three common ways to deal with contiguous\u000aregions of memory:\u000a\u000a* [`Vec<T>`] - A heap-allocated *vector* that is resizable at runtime.\u000a* [`[T; n]`](https://doc.rust-lang.org/nightly/core/array/index.html) - An inline *array* with a fixed size at compile time.\u000a* [`[T]`](https://doc.rust-lang.org/nightly/alloc/slice/index.html) - A dynamically sized *slice* into any other kind of contiguous\u000a  storage, whether heap-allocated or not.\u000a\u000aSlices can only be handled through some kind of *pointer*, and as such come\u000ain many flavors such as:\u000a\u000a* `&[T]` - *shared slice*\u000a* `&mut [T]` - *mutable slice*\u000a* [`Box<[T]>`](https://doc.rust-lang.org/nightly/alloc/boxed/index.html) - *owned slice*\u000a\u000a[`str`], a UTF-8 string slice, is a primitive type, and the standard library\u000adefines many methods for it. Rust [`str`]s are typically accessed as\u000aimmutable references: `&str`. Use the owned [`String`](https://doc.rust-lang.org/nightly/alloc/string/struct.String.html) for building and\u000amutating strings.\u000a\u000aFor converting to strings use the [`format`](https://doc.rust-lang.org/nightly/alloc/macros/macro.format.html) macro, and for converting from\u000astrings use the [`FromStr`] trait.\u000a\u000aData may be shared by placing it in a reference-counted box or the [`Rc`]\u000atype, and if further contained in a [`Cell`] or [`RefCell`], may be mutated\u000aas well as shared. Likewise, in a concurrent setting it is common to pair an\u000aatomically-reference-counted box, [`Arc`], with a [`Mutex`] to get the same\u000aeffect.\u000a\u000aThe [`collections`](https://doc.rust-lang.org/nightly/std/collections/index.html) module defines maps, sets, linked lists and other\u000atypical collection types, including the common [`HashMap<K, V>`].\u000a\u000a## Platform abstractions and I/O\u000a\u000aBesides basic data types, the standard library is largely concerned with\u000aabstracting over differences in common platforms, most notably Windows and\u000aUnix derivatives.\u000a\u000aCommon types of I/O, including [files], [TCP], [UDP], are defined in the\u000a[`io`](https://doc.rust-lang.org/nightly/std/io/index.html), [`fs`](https://doc.rust-lang.org/nightly/std/fs/index.html), and [`net`](https://doc.rust-lang.org/nightly/std/net/index.html) modules.\u000a\u000aThe [`thread`](https://doc.rust-lang.org/nightly/std/thread/index.html) module contains Rust's threading abstractions. [`sync`](https://doc.rust-lang.org/nightly/std/sync/index.html)\u000acontains further primitive shared memory types, including [`atomic`] and\u000a[`mpsc`], which contains the channel types for message passing."
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000af32\u000a```\u000a\u000a---\u000a\u000aA 32-bit floating point type (specifically, the \"binary32\" type defined in IEEE 754-2008).\u000a\u000aThis type can represent a wide range of decimal numbers, like `3.5`, `27`,\u000a`-113.75`, `0.0078125`, `34359738368`, `0`, `-1`. So unlike integer types\u000a(such as `i32`), floating point types can represent non-integer numbers,\u000atoo.\u000a\u000aHowever, being able to represent this wide range of numbers comes at the\u000acost of precision: floats can only represent some of the real numbers and\u000acalculation with floats round to a nearby representable number. For example,\u000a`5.0` and `1.0` can be exactly represented as `f32`, but `1.0 / 5.0` results\u000ain `0.20000000298023223876953125` since `0.2` cannot be exactly represented\u000aas `f32`. Note however, that printing floats with `println` and friends will\u000aoften discard insignificant digits: `println!(\"{}\", 1.0f32 / 5.0f32)` will\u000aprint `0.2`.\u000a\u000aAdditionally, `f32` can represent a couple of special values:\u000a\u000a* `-0`: this is just due to how floats are encoded. It is semantically\u000a  equivalent to `0` and `-0.0 == 0.0` results in `true`.\u000a* [âˆž](#associatedconstant.INFINITY) and\u000a  [âˆ’âˆž](#associatedconstant.NEG_INFINITY): these result from calculations\u000a  like `1.0 / 0.0`.\u000a* [NaN (not a number)](#associatedconstant.NAN): this value results from\u000a  calculations like `(-1.0).sqrt()`. NaN has some potentially unexpected\u000a  behavior: it is unequal to any float, including itself! It is also neither\u000a  smaller nor greater than any float, making it impossible to sort. Lastly,\u000a  it is considered infectious as almost all calculations where one of the\u000a  operands is NaN will also result in NaN.\u000a\u000aFor more information on floating point numbers, see [Wikipedia](https://en.wikipedia.org/wiki/Single-precision_floating-point_format).\u000a\u000a*[See also the `std::f32::consts` module](`crate::f32::consts`).*"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000af64\u000a```\u000a\u000a---\u000a\u000aA 64-bit floating point type (specifically, the \"binary64\" type defined in IEEE 754-2008).\u000a\u000aThis type is very similar to [`f32`], but has increased\u000aprecision by using twice as many bits. Please see [the documentation for\u000a`f32`](prim@f32) or [Wikipedia on double precision\u000avalues](https://en.wikipedia.org/wiki/Double-precision_floating-point_format) for more information.\u000a\u000a*[See also the `std::f64::consts` module](`crate::f64::consts`).*"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000af: &dyn Fn(u8) -> bool\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000af: String\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000ag: i32\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000ah: usize\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000ai16\u000a```\u000a\u000a---\u000a\u000aThe 16-bit signed integer type."
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000ai32\u000a```\u000a\u000a---\u000a\u000aThe 32-bit signed integer type."
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000ai64\u000a```\u000a\u000a---\u000a\u000aThe 64-bit signed integer type."
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000ai8\u000a```\u000a\u000a---\u000a\u000aThe 8-bit signed integer type."
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000ai: &&str\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000ai: &P\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000ai: &i32\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000ai: &i64\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000ai: &u8\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000ai: i32\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000ai: i8\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000ai: u64\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000ai: u8\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000ai: usize\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000aisize\u000a```\u000a\u000a---\u000a\u000aThe pointer-sized signed integer type.\u000a\u000aThe size of this primitive is how many bytes it takes to reference any\u000alocation in memory. For example, on a 32 bit target, this is 4 bytes\u000aand on a 64 bit target, this is 8 bytes."
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000ak: &String\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000ak: &dyn Fn(u8) -> bool\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000al: &str\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000al: Tree<T>\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000aleft: &Tree<T>\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alen: usize\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet _a: &[u64]\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet _b: Box<(i32, &str)>\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet _fifth: &String\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet _m1: &mut i32\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet _oodles: &str\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet _poodles: &str\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet _r0: &i32\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet _r1: &i32\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet _v: !\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet _v: &str\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet _v: ()\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet _v: bool\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet _w: &mut dyn Write\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet _x: i32\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet _zoodles: &str\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet a1: GSM\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet a1: P\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet a: &[f64]\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet a: &mut i32\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet a: ()\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet a: P<f64>\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet a: RangeFrom<bool>\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet a: RangeFull\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet a: S\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet a: Tree<i64>\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet a: Vec<S>\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet a: Vec<f64>\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet a: Vec<i32>\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet a: [i32; 7]\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet a: i32\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet a_ref: &A\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet aria: A\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet arr: &[u8]\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet aside: Vec<i32>\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet b1: Box<[bool]>\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet b1: GSM\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet b: &[f64]\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet b: &i32\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet b: P<f64>\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet b: Range<u8>\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet b: RangeFrom<bool>\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet b: RangeFull\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet b: Tree<i64>\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet b: Vec<S>\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet b: [f64; 2]\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet box1: Box<Expr>\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet box2: Box<Expr>\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet brib: B\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet bs: [i32; 3]\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet buf: [u8; 1024]\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet c1: GSM\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet c: &i32\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet c: Option<char>\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet c: Tree<i64>\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet c: Vec<f64>\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet c: bool\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet d1: GSM\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet d: Vec<i64>\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet e: E\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet f: File\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet f: Foo\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet f: |Vec<i32>| -> i32\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet fifth: String\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet foo: Foo\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet fs: [File; 8]\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet h1: usize\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet h: File\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet head: Vec<f64>\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000alet i: Result<u64, ParseIntError>\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet i: usize\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet j: usize\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet ks: Vec<String>\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet ky_fn: |&S| -> i64\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet label: String\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000alet lazy_caterer: [u32; 6]\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet len: usize\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet m0: &mut i32\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet m1: &mut (i32, i32)\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet m: &mut i32\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet m: Metadata\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet msg: Message\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet mut a: Vec<f64>\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet mut acc: u64\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet mut b: Vec<i32>\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet mut biggest: &i32\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet mut buf: Vec<u8>\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet mut buf: [u8; 8192]\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet mut byte: Vec<u8>\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet mut c: Vec<Person>\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet mut count: u64\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet mut d: &[S]\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000alet mut fs: [MaybeUninit<File>; 8]\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet mut i: u64\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000alet mut iter: TreeIter<T>\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet mut j: usize\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet mut m: u64\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet mut n: Option<u64>\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet mut n: u64\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet mut ns: Vec<i32>\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet mut ns: Vec<u64>\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet mut o: Complex<i32>\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet mut one: File\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet mut q1: Q<u64>\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet mut q: Q\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet mut r1: u64\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet mut s1: i32\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet mut s2: i32\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet mut s: &i32\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet mut s: String\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000alet mut seen: HashSet<u8>\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000alet mut sieve: [bool; 10000]\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet mut smallest: &i32\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000alet mut strs: Vec<String>\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet mut t1: Tree<i32>\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000alet mut t: HashMap<String, Vec<String>>\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet mut t: String\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet mut total: N\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet mut two: File\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet mut u: Vec<f64>\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet mut v1: (i32, i32)\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet mut v: Vec<String>\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet mut v: Vec<i16>\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet mut v: Vec<i32>\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet mut v: Vec<i64>\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet mut v: Vec<u8>\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet mut w: Vec<u8>\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet mut wave: Vec<f64>\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000alet mut x: HashMap<String, u64>\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet mut x: Vec<i32>\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet mut y1: i32\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet mut y: i32\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet n: Box<Node<T>>\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet n: Option<String>\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet n: Ratio<i64>\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet name2: i64\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet name: i64\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet next: i32\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet node: &Node<T>\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet noodles: String\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet o: JSValue\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet one: Tree<u64>\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet p: P\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet parabola: [i32; 7]\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000alet point: Box<(f64, f64)>\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet r1: &(i32, i32)\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet r1: &i32\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet r1: Q<u64>\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet r2: &i32\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet r: &P\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet r: &Vec<i32>\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet r: &[u8]\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet r: &i32\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet r: &i64\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000alet r: Result<(), Box<dyn Any + Send>>\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet r: u64\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet res: String\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet rr: &&P\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet rrr: &&&P\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet s1: String\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet s: &i32\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet s: S\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet s: String\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet s: U\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet s: Vec<&str>\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet s: Vec<String>\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet second: String\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet spider: Spider\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet strs: Vec<String>\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet sub1: Tree<i64>\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet sub: Tree<i64>\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet t1: Tree<u64>\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet t2: Tree<i32>\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet t2: Tree<u64>\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet t3: Tree<i32>\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet t4: Tree<i32>\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet t5: Tree<i32>\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000alet t: (Option<String>, Vec<Person>)\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000alet t: (Vec<String>, Vec<String>)\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet t: (i32, &str)\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet t: String\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet t: T\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet t: Vec<&str>\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet t: Vec<String>\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet tail: [f64; 2]\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet taxonomy: [&str; 3]\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet third: String\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet ts: Vec<RcDoc>\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet two: Tree<u64>\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet u: Vec<String>\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet u: Vec<i32>\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet u: {unknown}\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet us: Vec<u8>\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet v1: ETy<String>\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet v1: Vec<u8>\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet v2: ETy<String>\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet v3: ETy<String>\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet v: Color\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet v: JSValue\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet v: Option<&str>\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet v: String\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet v: Vec<String>\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet v: Vec<i32>\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet v: [i32; 3]\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet v: i64\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet v: u64\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet vs: &Vec<char>\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet vs: &Vec<i32>\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet w1: (i32, i32)\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet w1: usize\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet w: [i32; 2]\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet wave2: Vec<f64>\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet words: Vec<&str>\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet x1: i32\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet x: &str\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet x: (i32, &str)\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet x: A\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet x: Complex<i32>\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet x: E<u64>\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet x: Vec<i32>\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet x: i32\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet x: i64\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet y1: i32\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet y: Complex<i32>\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet y: f64\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet y: i32\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet z: Complex<i32>\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000alet zero: &Tree<u64>\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000am: i32\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000am: u64\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000amut cs: Vec<S>\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000amut m: u64\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000amut n: u64\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000amut s: String\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000amut s: Vec<&str>\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000amut tree: &Tree<T>\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000amut y: i32\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000an: &Node<T>\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000an: &mut Box<Node<T>>\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000an: Box<Node<T>>\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000an: i32\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000an: u64\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000an: usize\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000anode: &Node<T>\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000anum\u000a```\u000a\u000a```rust\u000amod rational\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000anum_rational\u000a```\u000a\u000a```rust\u000apub struct Ratio<T>\u000a```\u000a\u000a---\u000a\u000aRepresents the ratio between two numbers."
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000anum_rational\u000a```\u000a\u000a```rust\u000apub type Rational64 = Ratio<i64>\u000a```\u000a\u000a---\u000a\u000aAlias for a `Ratio` of 64-bit-sized integers."
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000anum_rational::Ratio\u000a```\u000a\u000a```rust\u000apub const fn denom(&self) -> &T\u000a```\u000a\u000a---\u000a\u000aGets an immutable reference to the denominator."
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000anum_rational::Ratio\u000a```\u000a\u000a```rust\u000apub const fn new_raw(numer: T, denom: T) -> Ratio<T>\u000a```\u000a\u000a---\u000a\u000aCreates a `Ratio` without checking for `denom == 0` or reducing.\u000a\u000a**There are several methods that will panic if used on a `Ratio` with\u000a`denom == 0`.**"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000anum_rational::Ratio\u000a```\u000a\u000a```rust\u000apub const fn numer(&self) -> &T\u000a```\u000a\u000a---\u000a\u000aGets an immutable reference to the numerator."
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000anum_rational::Ratio\u000a```\u000a\u000a```rust\u000apub fn from_integer(t: T) -> Ratio<T>\u000a```\u000a\u000a---\u000a\u000aCreates a `Ratio` representing the integer `t`."
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000anum_rational::Ratio\u000a```\u000a\u000a```rust\u000apub fn is_integer(&self) -> bool\u000a```\u000a\u000a---\u000a\u000aReturns true if the rational number is an integer (denominator is 1)."
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000anum_traits\u000a```\u000a\u000a```rust\u000amod identities\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000anum_traits::identities\u000a```\u000a\u000a```rust\u000apub fn zero<T>() -> T\u000awhere\u000a    T: Zero,\u000a```\u000a\u000a---\u000a\u000aReturns the additive identity, `0`."
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000anum_traits::identities\u000a```\u000a\u000a```rust\u000apub trait Zero\u000awhere\u000a    Self: Sized + Add<Self, Output = Self>,\u000a```\u000a\u000a---\u000a\u000aDefines an additive identity element for `Self`.\u000a\u000a# Laws\u000a\u000a```{.text}\u000aa + 0 = a       âˆ€ a âˆˆ Self\u000a0 + a = a       âˆ€ a âˆˆ Self\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000aop: char\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000aother: &Complex<T>\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000ap: &[u8]\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000ap: &i32\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000ap: &mut MaybeUninit<File>\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000ap: &u64\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000apoint: &[i32; 3]\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000aprefix: &str\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000apretty\u000a```\u000a\u000a```rust\u000apub struct RcDoc<'a, A = ()>\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000apretty::Doc\u000a```\u000a\u000a```rust\u000apub fn render<W>(&self, width: usize, out: &mut W) -> io::Result<()>\u000awhere\u000a    W: ?Sized + io::Write,\u000a```\u000a\u000a---\u000a\u000aWrites a rendered document to a `std::io::Write` object."
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000apretty::RcDoc\u000a```\u000a\u000a```rust\u000apub fn append<D>(self, that: D) -> Self\u000awhere\u000a    D: Into<BuildDoc<'a, Self, A>>,\u000a```\u000a\u000a---\u000a\u000aAppend the given document after this document."
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000apretty::RcDoc\u000a```\u000a\u000a```rust\u000apub fn concat<I>(docs: I) -> Self\u000awhere\u000a    I: IntoIterator,\u000a    I::Item: Into<BuildDoc<'a, Self, A>>,\u000a```\u000a\u000a---\u000a\u000aA single document concatenating all the given documents."
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000apretty::RcDoc\u000a```\u000a\u000a```rust\u000apub fn intersperse<I, S>(docs: I, separator: S) -> Self\u000awhere\u000a    I: IntoIterator,\u000a    I::Item: Into<BuildDoc<'a, Self, A>>,\u000a    S: Into<BuildDoc<'a, Self, A>> + Clone,\u000a    A: Clone,\u000a```\u000a\u000a---\u000a\u000aA single document interspersing the given separator `S` between the given documents.  For\u000aexample, if the documents are `[A, B, C, ..., Z]`, this yields `[A, S, B, S, C, S, ..., S, Z]`.\u000a\u000aCompare [the `intersperse` method from the `itertools` crate](https://docs.rs/itertools/0.5.9/itertools/trait.Itertools.html#method.intersperse).\u000a\u000aNOTE: The separator type, `S` may need to be cloned. Consider using cheaply cloneable ptr\u000alike `RefDoc` or `RcDoc`"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000apretty::RcDoc\u000a```\u000a\u000a```rust\u000apub fn space() -> Self\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000apretty::RcDoc\u000a```\u000a\u000a```rust\u000apub fn text<U>(data: U) -> Self\u000awhere\u000a    U: Into<Cow<'a, str>>,\u000a```\u000a\u000a---\u000a\u000aThe given text, which must not contain line breaks."
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000aproblem: String\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000aq: &Q<T>\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000aq: &mut Q<T>\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000ar: &i32\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000ar: &u8\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000ar: Ratio<i64>\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000ar: Tree<T>\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000ar: i32\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000ar: u64\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000areader: &mut R\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000arhs: Complex<R>\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000arhs: Complex<T>\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000aright: &Tree<T>\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000as: &String\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000as: &mut String\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000as: &str\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000as: S\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000aself: &Complex<T>\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000aself: &JSValue\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000aself: &O\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000aself: &Q\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000aself: &Q<T>\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000aself: &Self\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000aself: &T\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000aself: &Tree<T>\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000aself: &mut Complex<T>\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000aself: &mut Q\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000aself: &mut Q<T>\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000aself: &mut Tree<T>\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000aself: &mut TreeIter<T>\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000aself: Complex<L>\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000aself: Complex<T>\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000aself: Q\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000aslice: &[f64]\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000aslice: &[i32]\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000astd\u000a```\u000a\u000a```rust\u000amod collections\u000a```\u000a\u000a---\u000a\u000aCollection types.\u000a\u000aRust's standard collection library provides efficient implementations of the\u000amost common general purpose programming data structures. By using the\u000astandard implementations, it should be possible for two libraries to\u000acommunicate without significant data conversion.\u000a\u000aTo get this out of the way: you should probably just use [`Vec`](https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html) or [`HashMap`](https://doc.rust-lang.org/nightly/std/collections/hash/map/struct.HashMap.html).\u000aThese two collections cover most use cases for generic data storage and\u000aprocessing. They are exceptionally good at doing what they do. All the other\u000acollections in the standard library have specific use cases where they are\u000athe optimal choice, but these cases are borderline *niche* in comparison.\u000aEven when `Vec` and `HashMap` are technically suboptimal, they're probably a\u000agood enough choice to get started.\u000a\u000aRust's collections can be grouped into four major categories:\u000a\u000a* Sequences: [`Vec`](https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html), [`VecDeque`](https://doc.rust-lang.org/nightly/alloc/collections/vec_deque/struct.VecDeque.html), [`LinkedList`](https://doc.rust-lang.org/nightly/alloc/collections/linked_list/struct.LinkedList.html)\u000a* Maps: [`HashMap`](https://doc.rust-lang.org/nightly/std/collections/hash/map/struct.HashMap.html), [`BTreeMap`](https://doc.rust-lang.org/nightly/alloc/collections/btree/map/struct.BTreeMap.html)\u000a* Sets: [`HashSet`](https://doc.rust-lang.org/nightly/std/collections/hash/set/struct.HashSet.html), [`BTreeSet`](https://doc.rust-lang.org/nightly/alloc/collections/btree/set/struct.BTreeSet.html)\u000a* Misc: [`BinaryHeap`](https://doc.rust-lang.org/nightly/alloc/collections/binary_heap/struct.BinaryHeap.html)\u000a\u000a# When Should You Use Which Collection?\u000a\u000aThese are fairly high-level and quick break-downs of when each collection\u000ashould be considered. Detailed discussions of strengths and weaknesses of\u000aindividual collections can be found on their own documentation pages.\u000a\u000a### Use a `Vec` when:\u000a\u000a* You want to collect items up to be processed or sent elsewhere later, and\u000a  don't care about any properties of the actual values being stored.\u000a* You want a sequence of elements in a particular order, and will only be\u000a  appending to (or near) the end.\u000a* You want a stack.\u000a* You want a resizable array.\u000a* You want a heap-allocated array.\u000a\u000a### Use a `VecDeque` when:\u000a\u000a* You want a [`Vec`](https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html) that supports efficient insertion at both ends of the\u000a  sequence.\u000a* You want a queue.\u000a* You want a double-ended queue (deque).\u000a\u000a### Use a `LinkedList` when:\u000a\u000a* You want a [`Vec`](https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html) or [`VecDeque`](https://doc.rust-lang.org/nightly/alloc/collections/vec_deque/struct.VecDeque.html) of unknown size, and can't tolerate\u000a  amortization.\u000a* You want to efficiently split and append lists.\u000a* You are *absolutely* certain you *really*, *truly*, want a doubly linked\u000a  list.\u000a\u000a### Use a `HashMap` when:\u000a\u000a* You want to associate arbitrary keys with an arbitrary value.\u000a* You want a cache.\u000a* You want a map, with no extra functionality.\u000a\u000a### Use a `BTreeMap` when:\u000a\u000a* You want a map sorted by its keys.\u000a* You want to be able to get a range of entries on-demand.\u000a* You're interested in what the smallest or largest key-value pair is.\u000a* You want to find the largest or smallest key that is smaller or larger\u000a  than something.\u000a\u000a### Use the `Set` variant of any of these `Map`s when:\u000a\u000a* You just want to remember which keys you've seen.\u000a* There is no meaningful value to associate with your keys.\u000a* You just want a set.\u000a\u000a### Use a `BinaryHeap` when:\u000a\u000a* You want to store a bunch of elements, but only ever want to process the\u000a  \"biggest\" or \"most important\" one at any given time.\u000a* You want a priority queue.\u000a\u000a# Performance\u000a\u000aChoosing the right collection for the job requires an understanding of what\u000aeach collection is good at. Here we briefly summarize the performance of\u000adifferent collections for certain important operations. For further details,\u000asee each type's documentation, and note that the names of actual methods may\u000adiffer from the tables below on certain collections.\u000a\u000aThroughout the documentation, we will follow a few conventions. For all\u000aoperations, the collection's size is denoted by n. If another collection is\u000ainvolved in the operation, it contains m elements. Operations which have an\u000a*amortized* cost are suffixed with a `*`. Operations with an *expected*\u000acost are suffixed with a `~`.\u000a\u000aAll amortized costs are for the potential need to resize when capacity is\u000aexhausted. If a resize occurs it will take *O*(*n*) time. Our collections never\u000aautomatically shrink, so removal operations aren't amortized. Over a\u000asufficiently large series of operations, the average cost per operation will\u000adeterministically equal the given cost.\u000a\u000aOnly [`HashMap`](https://doc.rust-lang.org/nightly/std/collections/hash/map/struct.HashMap.html) has expected costs, due to the probabilistic nature of hashing.\u000aIt is theoretically possible, though very unlikely, for [`HashMap`](https://doc.rust-lang.org/nightly/std/collections/hash/map/struct.HashMap.html) to\u000aexperience worse performance.\u000a\u000a## Sequences\u000a\u000a||get(i)|insert(i)|remove(i)|append|split_off(i)|\u000a|--|------|---------|---------|------|------------|\u000a|[`Vec`](https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html)|O(1)|O(n-i)\\*|O(n-i)|O(m)\\*|O(n-i)|\u000a|[`VecDeque`](https://doc.rust-lang.org/nightly/alloc/collections/vec_deque/struct.VecDeque.html)|O(1)|O(min(i, n-i))\\*|O(min(i, n-i))|O(m)\\*|O(min(i, n-i))|\u000a|[`LinkedList`](https://doc.rust-lang.org/nightly/alloc/collections/linked_list/struct.LinkedList.html)|O(min(i, n-i))|O(min(i, n-i))|O(min(i, n-i))|O(1)|O(min(i, n-i))|\u000a\u000aNote that where ties occur, [`Vec`](https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html) is generally going to be faster than [`VecDeque`](https://doc.rust-lang.org/nightly/alloc/collections/vec_deque/struct.VecDeque.html), and\u000a[`VecDeque`](https://doc.rust-lang.org/nightly/alloc/collections/vec_deque/struct.VecDeque.html) is generally going to be faster than [`LinkedList`](https://doc.rust-lang.org/nightly/alloc/collections/linked_list/struct.LinkedList.html).\u000a\u000a## Maps\u000a\u000aFor Sets, all operations have the cost of the equivalent Map operation.\u000a\u000a||get|insert|remove|predecessor|append|\u000a|--|---|------|------|-----------|------|\u000a|[`HashMap`](https://doc.rust-lang.org/nightly/std/collections/hash/map/struct.HashMap.html)|O(1)~|O(1)~\\*|O(1)~|N/A|N/A|\u000a|[`BTreeMap`](https://doc.rust-lang.org/nightly/alloc/collections/btree/map/struct.BTreeMap.html)|O(log(n))|O(log(n))|O(log(n))|O(log(n))|O(n+m)|\u000a\u000a# Correct and Efficient Usage of Collections\u000a\u000aOf course, knowing which collection is the right one for the job doesn't\u000ainstantly permit you to use it correctly. Here are some quick tips for\u000aefficient and correct usage of the standard collections in general. If\u000ayou're interested in how to use a specific collection in particular, consult\u000aits documentation for detailed discussion and code examples.\u000a\u000a## Capacity Management\u000a\u000aMany collections provide several constructors and methods that refer to\u000a\"capacity\". These collections are generally built on top of an array.\u000aOptimally, this array would be exactly the right size to fit only the\u000aelements stored in the collection, but for the collection to do this would\u000abe very inefficient. If the backing array was exactly the right size at all\u000atimes, then every time an element is inserted, the collection would have to\u000agrow the array to fit it. Due to the way memory is allocated and managed on\u000amost computers, this would almost surely require allocating an entirely new\u000aarray and copying every single element from the old one into the new one.\u000aHopefully you can see that this wouldn't be very efficient to do on every\u000aoperation.\u000a\u000aMost collections therefore use an *amortized* allocation strategy. They\u000agenerally let themselves have a fair amount of unoccupied space so that they\u000aonly have to grow on occasion. When they do grow, they allocate a\u000asubstantially larger array to move the elements into so that it will take a\u000awhile for another grow to be required. While this strategy is great in\u000ageneral, it would be even better if the collection *never* had to resize its\u000abacking array. Unfortunately, the collection itself doesn't have enough\u000ainformation to do this itself. Therefore, it is up to us programmers to give\u000ait hints.\u000a\u000aAny `with_capacity` constructor will instruct the collection to allocate\u000aenough space for the specified number of elements. Ideally this will be for\u000aexactly that many elements, but some implementation details may prevent\u000athis. See collection-specific documentation for details. In general, use\u000a`with_capacity` when you know exactly how many elements will be inserted, or\u000aat least have a reasonable upper-bound on that number.\u000a\u000aWhen anticipating a large influx of elements, the `reserve` family of\u000amethods can be used to hint to the collection how much room it should make\u000afor the coming items. As with `with_capacity`, the precise behavior of\u000athese methods will be specific to the collection of interest.\u000a\u000aFor optimal performance, collections will generally avoid shrinking\u000athemselves. If you believe that a collection will not soon contain any more\u000aelements, or just really need the memory, the `shrink_to_fit` method prompts\u000athe collection to shrink the backing array to the minimum size capable of\u000aholding its elements.\u000a\u000aFinally, if ever you're interested in what the actual capacity of the\u000acollection is, most collections provide a `capacity` method to query this\u000ainformation on demand. This can be useful for debugging purposes, or for\u000ause with the `reserve` methods.\u000a\u000a## Iterators\u000a\u000aIterators are a powerful and robust mechanism used throughout Rust's\u000astandard libraries. Iterators provide a sequence of values in a generic,\u000asafe, efficient and convenient way. The contents of an iterator are usually\u000a*lazily* evaluated, so that only the values that are actually needed are\u000aever actually produced, and no allocation need be done to temporarily store\u000athem. Iterators are primarily consumed using a `for` loop, although many\u000afunctions also take iterators where a collection or sequence of values is\u000adesired.\u000a\u000aAll of the standard collections provide several iterators for performing\u000abulk manipulation of their contents. The three primary iterators almost\u000aevery collection should provide are `iter`, `iter_mut`, and `into_iter`.\u000aSome of these are not provided on collections where it would be unsound or\u000aunreasonable to provide them.\u000a\u000a`iter` provides an iterator of immutable references to all the contents of a\u000acollection in the most \"natural\" order. For sequence collections like [`Vec`](https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html),\u000athis means the items will be yielded in increasing order of index starting\u000aat 0. For ordered collections like [`BTreeMap`](https://doc.rust-lang.org/nightly/alloc/collections/btree/map/struct.BTreeMap.html), this means that the items\u000awill be yielded in sorted order. For unordered collections like [`HashMap`](https://doc.rust-lang.org/nightly/std/collections/hash/map/struct.HashMap.html),\u000athe items will be yielded in whatever order the internal representation made\u000amost convenient. This is great for reading through all the contents of the\u000acollection.\u000a\u000a```rust\u000alet vec = vec![1, 2, 3, 4];\u000afor x in vec.iter() {\u000a   println!(\"vec contained {}\", x);\u000a}\u000a```\u000a\u000a`iter_mut` provides an iterator of *mutable* references in the same order as\u000a`iter`. This is great for mutating all the contents of the collection.\u000a\u000a```rust\u000alet mut vec = vec![1, 2, 3, 4];\u000afor x in vec.iter_mut() {\u000a   *x += 1;\u000a}\u000a```\u000a\u000a`into_iter` transforms the actual collection into an iterator over its\u000acontents by-value. This is great when the collection itself is no longer\u000aneeded, and the values are needed elsewhere. Using `extend` with `into_iter`\u000ais the main way that contents of one collection are moved into another.\u000a`extend` automatically calls `into_iter`, and takes any `T: `[`IntoIterator`].\u000aCalling `collect` on an iterator itself is also a great way to convert one\u000acollection into another. Both of these methods should internally use the\u000acapacity management tools discussed in the previous section to do this as\u000aefficiently as possible.\u000a\u000a```rust\u000alet mut vec1 = vec![1, 2, 3, 4];\u000alet vec2 = vec![10, 20, 30, 40];\u000avec1.extend(vec2);\u000a```\u000a\u000a```rust\u000ause std::collections::VecDeque;\u000a\u000alet vec = vec![1, 2, 3, 4];\u000alet buf: VecDeque<_> = vec.into_iter().collect();\u000a```\u000a\u000aIterators also provide a series of *adapter* methods for performing common\u000athreads to sequences. Among the adapters are functional favorites like `map`,\u000a`fold`, `skip` and `take`. Of particular interest to collections is the\u000a`rev` adapter, that reverses any iterator that supports this operation. Most\u000acollections provide reversible iterators as the way to iterate over them in\u000areverse order.\u000a\u000a```rust\u000alet vec = vec![1, 2, 3, 4];\u000afor x in vec.iter().rev() {\u000a   println!(\"vec contained {}\", x);\u000a}\u000a```\u000a\u000aSeveral other collection methods also return iterators to yield a sequence\u000aof results but avoid allocating an entire collection to store the result in.\u000aThis provides maximum flexibility as `collect` or `extend` can be called to\u000a\"pipe\" the sequence into any collection if desired. Otherwise, the sequence\u000acan be looped over with a `for` loop. The iterator can also be discarded\u000aafter partial use, preventing the computation of the unused items.\u000a\u000a## Entries\u000a\u000aThe `entry` API is intended to provide an efficient mechanism for\u000amanipulating the contents of a map conditionally on the presence of a key or\u000anot. The primary motivating use case for this is to provide efficient\u000aaccumulator maps. For instance, if one wishes to maintain a count of the\u000anumber of times each key has been seen, they will have to perform some\u000aconditional logic on whether this is the first time the key has been seen or\u000anot. Normally, this would require a `find` followed by an `insert`,\u000aeffectively duplicating the search effort on each insertion.\u000a\u000aWhen a user calls `map.entry(&key)`, the map will search for the key and\u000athen yield a variant of the `Entry` enum.\u000a\u000aIf a `Vacant(entry)` is yielded, then the key *was not* found. In this case\u000athe only valid operation is to `insert` a value into the entry. When this is\u000adone, the vacant entry is consumed and converted into a mutable reference to\u000athe value that was inserted. This allows for further manipulation of the\u000avalue beyond the lifetime of the search itself. This is useful if complex\u000alogic needs to be performed on the value regardless of whether the value was\u000ajust inserted.\u000a\u000aIf an `Occupied(entry)` is yielded, then the key *was* found. In this case,\u000athe user has several options: they can `get`, `insert` or `remove` the\u000avalue of the occupied entry. Additionally, they can convert the occupied\u000aentry into a mutable reference to its value, providing symmetry to the\u000avacant `insert` case.\u000a\u000a### Examples\u000a\u000aHere are the two primary ways in which `entry` is used. First, a simple\u000aexample where the logic performed on the values is trivial.\u000a\u000a#### Counting the number of times each character in a string occurs\u000a\u000a```rust\u000ause std::collections::btree_map::BTreeMap;\u000a\u000alet mut count = BTreeMap::new();\u000alet message = \"she sells sea shells by the sea shore\";\u000a\u000afor c in message.chars() {\u000a    *count.entry(c).or_insert(0) += 1;\u000a}\u000a\u000aassert_eq!(count.get(&'s'), Some(&8));\u000a\u000aprintln!(\"Number of occurrences of each character\");\u000afor (char, count) in &count {\u000a    println!(\"{}: {}\", char, count);\u000a}\u000a```\u000a\u000aWhen the logic to be performed on the value is more complex, we may simply\u000ause the `entry` API to ensure that the value is initialized and perform the\u000alogic afterwards.\u000a\u000a#### Tracking the inebriation of customers at a bar\u000a\u000a```rust\u000ause std::collections::btree_map::BTreeMap;\u000a\u000a// A client of the bar. They have a blood alcohol level.\u000astruct Person { blood_alcohol: f32 }\u000a\u000a// All the orders made to the bar, by client ID.\u000alet orders = vec![1, 2, 1, 2, 3, 4, 1, 2, 2, 3, 4, 1, 1, 1];\u000a\u000a// Our clients.\u000alet mut blood_alcohol = BTreeMap::new();\u000a\u000afor id in orders {\u000a    // If this is the first time we've seen this customer, initialize them\u000a    // with no blood alcohol. Otherwise, just retrieve them.\u000a    let person = blood_alcohol.entry(id).or_insert(Person { blood_alcohol: 0.0 });\u000a\u000a    // Reduce their blood alcohol level. It takes time to order and drink a beer!\u000a    person.blood_alcohol *= 0.9;\u000a\u000a    // Check if they're sober enough to have another beer.\u000a    if person.blood_alcohol > 0.3 {\u000a        // Too drunk... for now.\u000a        println!(\"Sorry {}, I have to cut you off\", id);\u000a    } else {\u000a        // Have another!\u000a        person.blood_alcohol += 0.1;\u000a    }\u000a}\u000a```\u000a\u000a# Insert and complex keys\u000a\u000aIf we have a more complex key, calls to `insert` will\u000anot update the value of the key. For example:\u000a\u000a```rust\u000ause std::cmp::Ordering;\u000ause std::collections::BTreeMap;\u000ause std::hash::{Hash, Hasher};\u000a\u000a#[derive(Debug)]\u000astruct Foo {\u000a    a: u32,\u000a    b: &'static str,\u000a}\u000a\u000a// we will compare `Foo`s by their `a` value only.\u000aimpl PartialEq for Foo {\u000a    fn eq(&self, other: &Self) -> bool { self.a == other.a }\u000a}\u000a\u000aimpl Eq for Foo {}\u000a\u000a// we will hash `Foo`s by their `a` value only.\u000aimpl Hash for Foo {\u000a    fn hash<H: Hasher>(&self, h: &mut H) { self.a.hash(h); }\u000a}\u000a\u000aimpl PartialOrd for Foo {\u000a    fn partial_cmp(&self, other: &Self) -> Option<Ordering> { self.a.partial_cmp(&other.a) }\u000a}\u000a\u000aimpl Ord for Foo {\u000a    fn cmp(&self, other: &Self) -> Ordering { self.a.cmp(&other.a) }\u000a}\u000a\u000alet mut map = BTreeMap::new();\u000amap.insert(Foo { a: 1, b: \"baz\" }, 99);\u000a\u000a// We already have a Foo with an a of 1, so this will be updating the value.\u000amap.insert(Foo { a: 1, b: \"xyz\" }, 100);\u000a\u000a// The value has been updated...\u000aassert_eq!(map.values().next().unwrap(), &100);\u000a\u000a// ...but the key hasn't changed. b is still \"baz\", not \"xyz\".\u000aassert_eq!(map.keys().next().unwrap().b, \"baz\");\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000astd\u000a```\u000a\u000a```rust\u000amod env\u000a```\u000a\u000a---\u000a\u000aInspection and manipulation of the process's environment.\u000a\u000aThis module contains functions to inspect various aspects such as\u000aenvironment variables, process arguments, the current directory, and various\u000aother important directories.\u000a\u000aThere are several functions and structs in this module that have a\u000acounterpart ending in `os`. Those ending in `os` will return an [`OsString`](https://doc.rust-lang.org/nightly/std/ffi/os_str/struct.OsString.html)\u000aand those without will return a [`String`](https://doc.rust-lang.org/nightly/alloc/string/struct.String.html)."
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000astd\u000a```\u000a\u000a```rust\u000amod f64\u000a```\u000a\u000a---\u000a\u000aThis module provides constants which are specific to the implementation\u000aof the `f64` floating point data type.\u000a\u000a*[See also the `f64` primitive type](https://doc.rust-lang.org/nightly/std/primitive.f64.html).*\u000a\u000aMathematically significant numbers are provided in the `consts` sub-module.\u000a\u000aAlthough using these constants wonâ€™t cause compilation warnings,\u000anew code should use the associated constants directly on the primitive type."
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000astd\u000a```\u000a\u000a```rust\u000amod fs\u000a```\u000a\u000a---\u000a\u000aFilesystem manipulation operations.\u000a\u000aThis module contains basic methods to manipulate the contents of the local\u000afilesystem. All methods in this module represent cross-platform filesystem\u000aoperations. Extra platform-specific functionality can be found in the\u000aextension traits of `std::os::$platform`."
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000astd\u000a```\u000a\u000a```rust\u000amod io\u000a```\u000a\u000a---\u000a\u000aTraits, helpers, and type definitions for core I/O functionality.\u000a\u000aThe `std::io` module contains a number of common things you'll need\u000awhen doing input and output. The most core part of this module is\u000athe [`Read`](https://doc.rust-lang.org/nightly/std/io/trait.Read.html) and [`Write`](https://doc.rust-lang.org/nightly/std/io/trait.Write.html) traits, which provide the\u000amost general interface for reading and writing input and output.\u000a\u000a# Read and Write\u000a\u000aBecause they are traits, [`Read`](https://doc.rust-lang.org/nightly/std/io/trait.Read.html) and [`Write`](https://doc.rust-lang.org/nightly/std/io/trait.Write.html) are implemented by a number\u000aof other types, and you can implement them for your types too. As such,\u000ayou'll see a few different types of I/O throughout the documentation in\u000athis module: [`File`]s, [`TcpStream`]s, and sometimes even [`Vec<T>`]s. For\u000aexample, [`Read`](https://doc.rust-lang.org/nightly/std/io/trait.Read.html) adds a [`read`](https://doc.rust-lang.org/nightly/std/io/trait.Read.html#tymethod.read) method, which we can use on\u000a[`File`]s:\u000a\u000a```rust\u000ause std::io;\u000ause std::io::prelude::*;\u000ause std::fs::File;\u000a\u000afn main() -> io::Result<()> {\u000a    let mut f = File::open(\"foo.txt\")?;\u000a    let mut buffer = [0; 10];\u000a\u000a    // read up to 10 bytes\u000a    let n = f.read(&mut buffer)?;\u000a\u000a    println!(\"The bytes: {:?}\", &buffer[..n]);\u000a    Ok(())\u000a}\u000a```\u000a\u000a[`Read`](https://doc.rust-lang.org/nightly/std/io/trait.Read.html) and [`Write`](https://doc.rust-lang.org/nightly/std/io/trait.Write.html) are so important, implementors of the two traits have a\u000anickname: readers and writers. So you'll sometimes see 'a reader' instead\u000aof 'a type that implements the [`Read`](https://doc.rust-lang.org/nightly/std/io/trait.Read.html) trait'. Much easier!\u000a\u000a## Seek and BufRead\u000a\u000aBeyond that, there are two important traits that are provided: [`Seek`](https://doc.rust-lang.org/nightly/std/io/trait.Seek.html)\u000aand [`BufRead`](https://doc.rust-lang.org/nightly/std/io/trait.BufRead.html). Both of these build on top of a reader to control\u000ahow the reading happens. [`Seek`](https://doc.rust-lang.org/nightly/std/io/trait.Seek.html) lets you control where the next byte is\u000acoming from:\u000a\u000a```rust\u000ause std::io;\u000ause std::io::prelude::*;\u000ause std::io::SeekFrom;\u000ause std::fs::File;\u000a\u000afn main() -> io::Result<()> {\u000a    let mut f = File::open(\"foo.txt\")?;\u000a    let mut buffer = [0; 10];\u000a\u000a    // skip to the last 10 bytes of the file\u000a    f.seek(SeekFrom::End(-10))?;\u000a\u000a    // read up to 10 bytes\u000a    let n = f.read(&mut buffer)?;\u000a\u000a    println!(\"The bytes: {:?}\", &buffer[..n]);\u000a    Ok(())\u000a}\u000a```\u000a\u000a[`BufRead`](https://doc.rust-lang.org/nightly/std/io/trait.BufRead.html) uses an internal buffer to provide a number of other ways to read, but\u000ato show it off, we'll need to talk about buffers in general. Keep reading!\u000a\u000a## BufReader and BufWriter\u000a\u000aByte-based interfaces are unwieldy and can be inefficient, as we'd need to be\u000amaking near-constant calls to the operating system. To help with this,\u000a`std::io` comes with two structs, [`BufReader`](https://doc.rust-lang.org/nightly/std/io/buffered/struct.BufReader.html) and [`BufWriter`](https://doc.rust-lang.org/nightly/std/io/buffered/struct.BufWriter.html), which wrap\u000areaders and writers. The wrapper uses a buffer, reducing the number of\u000acalls and providing nicer methods for accessing exactly what you want.\u000a\u000aFor example, [`BufReader`](https://doc.rust-lang.org/nightly/std/io/buffered/struct.BufReader.html) works with the [`BufRead`](https://doc.rust-lang.org/nightly/std/io/trait.BufRead.html) trait to add extra\u000amethods to any reader:\u000a\u000a```rust\u000ause std::io;\u000ause std::io::prelude::*;\u000ause std::io::BufReader;\u000ause std::fs::File;\u000a\u000afn main() -> io::Result<()> {\u000a    let f = File::open(\"foo.txt\")?;\u000a    let mut reader = BufReader::new(f);\u000a    let mut buffer = String::new();\u000a\u000a    // read a line into buffer\u000a    reader.read_line(&mut buffer)?;\u000a\u000a    println!(\"{}\", buffer);\u000a    Ok(())\u000a}\u000a```\u000a\u000a[`BufWriter`](https://doc.rust-lang.org/nightly/std/io/buffered/struct.BufWriter.html) doesn't add any new ways of writing; it just buffers every call\u000ato [`write`](https://doc.rust-lang.org/nightly/std/io/trait.Write.html#tymethod.write):\u000a\u000a```rust\u000ause std::io;\u000ause std::io::prelude::*;\u000ause std::io::BufWriter;\u000ause std::fs::File;\u000a\u000afn main() -> io::Result<()> {\u000a    let f = File::create(\"foo.txt\")?;\u000a    {\u000a        let mut writer = BufWriter::new(f);\u000a\u000a        // write a byte to the buffer\u000a        writer.write(&[42])?;\u000a\u000a    } // the buffer is flushed once writer goes out of scope\u000a\u000a    Ok(())\u000a}\u000a```\u000a\u000a## Standard input and output\u000a\u000aA very common source of input is standard input:\u000a\u000a```rust\u000ause std::io;\u000a\u000afn main() -> io::Result<()> {\u000a    let mut input = String::new();\u000a\u000a    io::stdin().read_line(&mut input)?;\u000a\u000a    println!(\"You typed: {}\", input.trim());\u000a    Ok(())\u000a}\u000a```\u000a\u000aNote that you cannot use the [`?` operator] in functions that do not return\u000aa [`Result<T, E>`](https://doc.rust-lang.org/nightly/core/result/enum.Result.html). Instead, you can call [`.unwrap()`]\u000aor `match` on the return value to catch any possible errors:\u000a\u000a```rust\u000ause std::io;\u000a\u000alet mut input = String::new();\u000a\u000aio::stdin().read_line(&mut input).unwrap();\u000a```\u000a\u000aAnd a very common source of output is standard output:\u000a\u000a```rust\u000ause std::io;\u000ause std::io::prelude::*;\u000a\u000afn main() -> io::Result<()> {\u000a    io::stdout().write(&[42])?;\u000a    Ok(())\u000a}\u000a```\u000a\u000aOf course, using [`io::stdout`] directly is less common than something like\u000a[`println`](https://doc.rust-lang.org/nightly/std/macros/macro.println.html).\u000a\u000a## Iterator types\u000a\u000aA large number of the structures provided by `std::io` are for various\u000aways of iterating over I/O. For example, [`Lines`](https://doc.rust-lang.org/nightly/std/io/struct.Lines.html) is used to split over\u000alines:\u000a\u000a```rust\u000ause std::io;\u000ause std::io::prelude::*;\u000ause std::io::BufReader;\u000ause std::fs::File;\u000a\u000afn main() -> io::Result<()> {\u000a    let f = File::open(\"foo.txt\")?;\u000a    let reader = BufReader::new(f);\u000a\u000a    for line in reader.lines() {\u000a        println!(\"{}\", line?);\u000a    }\u000a    Ok(())\u000a}\u000a```\u000a\u000a## Functions\u000a\u000aThere are a number of [functions](https://doc.rust-lang.org/nightly/std/io/index.html#functions-1) that offer access to various\u000afeatures. For example, we can use three of these functions to copy everything\u000afrom standard input to standard output:\u000a\u000a```rust\u000ause std::io;\u000a\u000afn main() -> io::Result<()> {\u000a    io::copy(&mut io::stdin(), &mut io::stdout())?;\u000a    Ok(())\u000a}\u000a```\u000a\u000a## io::Result\u000a\u000aLast, but certainly not least, is [`io::Result`]. This type is used\u000aas the return type of many `std::io` functions that can cause an error, and\u000acan be returned from your own functions as well. Many of the examples in this\u000amodule use the [`?` operator]:\u000a\u000a```rust\u000ause std::io;\u000a\u000afn read_input() -> io::Result<()> {\u000a    let mut input = String::new();\u000a\u000a    io::stdin().read_line(&mut input)?;\u000a\u000a    println!(\"You typed: {}\", input.trim());\u000a\u000a    Ok(())\u000a}\u000a```\u000a\u000aThe return type of `read_input()`, [`io::Result<()>`](https://doc.rust-lang.org/nightly/std/io/error/type.Result.html), is a very\u000acommon type for functions which don't have a 'real' return value, but do want to\u000areturn errors if they happen. In this case, the only purpose of this function is\u000ato read the line and print it, so we use `()`.\u000a\u000a## Platform-specific behavior\u000a\u000aMany I/O functions throughout the standard library are documented to indicate\u000awhat various library or syscalls they are delegated to. This is done to help\u000aapplications both understand what's happening under the hood as well as investigate\u000aany possibly unclear semantics. Note, however, that this is informative, not a binding\u000acontract. The implementation of many of these functions are subject to change over\u000atime and may call fewer or more syscalls/library functions."
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000astd\u000a```\u000a\u000a```rust\u000amod panic\u000a```\u000a\u000a---\u000a\u000aPanic support in the standard library."
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000astd\u000a```\u000a\u000a```rust\u000amod process\u000a```\u000a\u000a---\u000a\u000aA module for working with processes.\u000a\u000aThis module is mostly concerned with spawning and interacting with child\u000aprocesses, but it also provides [`abort`](https://doc.rust-lang.org/nightly/std/process/fn.abort.html) and [`exit`](https://doc.rust-lang.org/nightly/std/process/fn.exit.html) for terminating the\u000acurrent process.\u000a\u000a# Spawning a process\u000a\u000aThe [`Command`](https://doc.rust-lang.org/nightly/std/process/struct.Command.html) struct is used to configure and spawn processes:\u000a\u000a```rust\u000ause std::process::Command;\u000a\u000alet output = Command::new(\"echo\")\u000a                     .arg(\"Hello world\")\u000a                     .output()\u000a                     .expect(\"Failed to execute command\");\u000a\u000aassert_eq!(b\"Hello world\\n\", output.stdout.as_slice());\u000a```\u000a\u000aSeveral methods on [`Command`](https://doc.rust-lang.org/nightly/std/process/struct.Command.html), such as [`spawn`] or [`output`], can be used\u000ato spawn a process. In particular, [`output`] spawns the child process and\u000awaits until the process terminates, while [`spawn`] will return a [`Child`](https://doc.rust-lang.org/nightly/std/process/struct.Child.html)\u000athat represents the spawned child process.\u000a\u000a# Handling I/O\u000a\u000aThe [`stdout`], [`stdin`], and [`stderr`] of a child process can be\u000aconfigured by passing an [`Stdio`](https://doc.rust-lang.org/nightly/std/process/struct.Stdio.html) to the corresponding method on\u000a[`Command`](https://doc.rust-lang.org/nightly/std/process/struct.Command.html). Once spawned, they can be accessed from the [`Child`](https://doc.rust-lang.org/nightly/std/process/struct.Child.html). For\u000aexample, piping output from one command into another command can be done\u000alike so:\u000a\u000a```rust\u000ause std::process::{Command, Stdio};\u000a\u000a// stdout must be configured with `Stdio::piped` in order to use\u000a// `echo_child.stdout`\u000alet echo_child = Command::new(\"echo\")\u000a    .arg(\"Oh no, a tpyo!\")\u000a    .stdout(Stdio::piped())\u000a    .spawn()\u000a    .expect(\"Failed to start echo process\");\u000a\u000a// Note that `echo_child` is moved here, but we won't be needing\u000a// `echo_child` anymore\u000alet echo_out = echo_child.stdout.expect(\"Failed to open echo stdout\");\u000a\u000alet mut sed_child = Command::new(\"sed\")\u000a    .arg(\"s/tpyo/typo/\")\u000a    .stdin(Stdio::from(echo_out))\u000a    .stdout(Stdio::piped())\u000a    .spawn()\u000a    .expect(\"Failed to start sed process\");\u000a\u000alet output = sed_child.wait_with_output().expect(\"Failed to wait on sed\");\u000aassert_eq!(b\"Oh no, a typo!\\n\", output.stdout.as_slice());\u000a```\u000a\u000aNote that [`ChildStderr`](https://doc.rust-lang.org/nightly/std/process/struct.ChildStderr.html) and [`ChildStdout`](https://doc.rust-lang.org/nightly/std/process/struct.ChildStdout.html) implement [`Read`] and\u000a[`ChildStdin`](https://doc.rust-lang.org/nightly/std/process/struct.ChildStdin.html) implements [`Write`]:\u000a\u000a```rust\u000ause std::process::{Command, Stdio};\u000ause std::io::Write;\u000a\u000alet mut child = Command::new(\"/bin/cat\")\u000a    .stdin(Stdio::piped())\u000a    .stdout(Stdio::piped())\u000a    .spawn()\u000a    .expect(\"failed to execute child\");\u000a\u000a{\u000a    // limited borrow of stdin\u000a    let stdin = child.stdin.as_mut().expect(\"failed to get stdin\");\u000a    stdin.write_all(b\"test\").expect(\"failed to write to stdin\");\u000a}\u000a\u000alet output = child\u000a    .wait_with_output()\u000a    .expect(\"failed to wait on child\");\u000a\u000aassert_eq!(b\"test\", output.stdout.as_slice());\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000astd\u000a```\u000a\u000a```rust\u000amod thread\u000a```\u000a\u000a---\u000a\u000aNative threads.\u000a\u000a## The threading model\u000a\u000aAn executing Rust program consists of a collection of native OS threads,\u000aeach with their own stack and local state. Threads can be named, and\u000aprovide some built-in support for low-level synchronization.\u000a\u000aCommunication between threads can be done through\u000a[channels], Rust's message-passing types, along with [other forms of thread\u000asynchronization](https://doc.rust-lang.org/nightly/std/sync/index.html) and shared-memory data\u000astructures. In particular, types that are guaranteed to be\u000athreadsafe are easily shared between threads using the\u000aatomically-reference-counted container, [`Arc`](https://doc.rust-lang.org/nightly/alloc/sync/struct.Arc.html).\u000a\u000aFatal logic errors in Rust cause *thread panic*, during which\u000aa thread will unwind the stack, running destructors and freeing\u000aowned resources. While not meant as a 'try/catch' mechanism, panics\u000ain Rust can nonetheless be caught (unless compiling with `panic=abort`) with\u000a[`catch_unwind`](https://doc.rust-lang.org/nightly/std/panic/fn.catch_unwind.html) and recovered\u000afrom, or alternatively be resumed with\u000a[`resume_unwind`](https://doc.rust-lang.org/nightly/std/panic/fn.resume_unwind.html). If the panic\u000ais not caught the thread will exit, but the panic may optionally be\u000adetected from a different thread with [`join`]. If the main thread panics\u000awithout the panic being caught, the application will exit with a\u000anon-zero exit code.\u000a\u000aWhen the main thread of a Rust program terminates, the entire program shuts\u000adown, even if other threads are still running. However, this module provides\u000aconvenient facilities for automatically waiting for the termination of a\u000achild thread (i.e., join).\u000a\u000a## Spawning a thread\u000a\u000aA new thread can be spawned using the [`thread::spawn`](https://doc.rust-lang.org/nightly/std/thread/fn.spawn.html) function:\u000a\u000a```rust\u000ause std::thread;\u000a\u000athread::spawn(move || {\u000a    // some work here\u000a});\u000a```\u000a\u000aIn this example, the spawned thread is \"detached\" from the current\u000athread. This means that it can outlive its parent (the thread that spawned\u000ait), unless this parent is the main thread.\u000a\u000aThe parent thread can also wait on the completion of the child\u000athread; a call to [`spawn`](https://doc.rust-lang.org/nightly/std/thread/fn.spawn.html) produces a [`JoinHandle`](https://doc.rust-lang.org/nightly/std/thread/struct.JoinHandle.html), which provides\u000aa `join` method for waiting:\u000a\u000a```rust\u000ause std::thread;\u000a\u000alet child = thread::spawn(move || {\u000a    // some work here\u000a});\u000a// some work here\u000alet res = child.join();\u000a```\u000a\u000aThe [`join`] method returns a [`thread::Result`] containing [`Ok`] of the final\u000avalue produced by the child thread, or [`Err`] of the value given to\u000aa call to [`panic`](https://doc.rust-lang.org/nightly/core/macros/macro.panic.html) if the child panicked.\u000a\u000a## Configuring threads\u000a\u000aA new thread can be configured before it is spawned via the [`Builder`](https://doc.rust-lang.org/nightly/std/thread/struct.Builder.html) type,\u000awhich currently allows you to set the name and stack size for the child thread:\u000a\u000a```rust\u000ause std::thread;\u000a\u000athread::Builder::new().name(\"child1\".to_string()).spawn(move || {\u000a    println!(\"Hello, world!\");\u000a});\u000a```\u000a\u000a## The `Thread` type\u000a\u000aThreads are represented via the [`Thread`](https://doc.rust-lang.org/nightly/std/thread/struct.Thread.html) type, which you can get in one of\u000atwo ways:\u000a\u000a* By spawning a new thread, e.g., using the [`thread::spawn`](https://doc.rust-lang.org/nightly/std/thread/fn.spawn.html)\u000a  function, and calling [`thread`](`JoinHandle::thread`) on the [`JoinHandle`](https://doc.rust-lang.org/nightly/std/thread/struct.JoinHandle.html).\u000a* By requesting the current thread, using the [`thread::current`] function.\u000a\u000aThe [`thread::current`] function is available even for threads not spawned\u000aby the APIs of this module.\u000a\u000a## Thread-local storage\u000a\u000aThis module also provides an implementation of thread-local storage for Rust\u000aprograms. Thread-local storage is a method of storing data into a global\u000avariable that each thread in the program will have its own copy of.\u000aThreads do not share this data, so accesses do not need to be synchronized.\u000a\u000aA thread-local key owns the value it contains and will destroy the value when the\u000athread exits. It is created with the [`thread_local`](https://doc.rust-lang.org/nightly/std/thread/local/macro.thread_local.html) macro and can contain any\u000avalue that is `'static` (no borrowed pointers). It provides an accessor function,\u000a[`with`], that yields a shared reference to the value to the specified\u000aclosure. Thread-local keys allow only shared access to values, as there would be no\u000away to guarantee uniqueness if mutable borrows were allowed. Most values\u000awill want to make use of some form of **interior mutability** through the\u000a[`Cell`] or [`RefCell`] types.\u000a\u000a## Naming threads\u000a\u000aThreads are able to have associated names for identification purposes. By default, spawned\u000athreads are unnamed. To specify a name for a thread, build the thread with [`Builder`](https://doc.rust-lang.org/nightly/std/thread/struct.Builder.html) and pass\u000athe desired thread name to [`Builder::name`](`Builder::name`). To retrieve the thread name from within the\u000athread, use [`Thread::name`]. A couple examples of where the name of a thread gets used:\u000a\u000a* If a panic occurs in a named thread, the thread name will be printed in the panic message.\u000a* The thread name is provided to the OS where applicable (e.g., `pthread_setname_np` in\u000a  unix-like platforms).\u000a\u000a## Stack size\u000a\u000aThe default stack size for spawned threads is 2 MiB, though this particular stack size is\u000asubject to change in the future. There are two ways to manually specify the stack size for\u000aspawned threads:\u000a\u000a* Build the thread with [`Builder`](https://doc.rust-lang.org/nightly/std/thread/struct.Builder.html) and pass the desired stack size to [`Builder::stack_size`](`Builder::stack_size`).\u000a* Set the `RUST_MIN_STACK` environment variable to an integer representing the desired stack\u000a  size (in bytes). Note that setting [`Builder::stack_size`](`Builder::stack_size`) will override this.\u000a\u000aNote that the stack size of the main thread is *not* determined by Rust."
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000astd::collections::hash::map\u000a```\u000a\u000a```rust\u000apub struct HashMap<K, V, S = RandomState>\u000a```\u000a\u000a---\u000a\u000aA hash map implemented with quadratic probing and SIMD lookup.\u000a\u000aBy default, `HashMap` uses a hashing algorithm selected to provide\u000aresistance against HashDoS attacks. The algorithm is randomly seeded, and a\u000areasonable best-effort is made to generate this seed from a high quality,\u000asecure source of randomness provided by the host without blocking the\u000aprogram. Because of this, the randomness of the seed depends on the output\u000aquality of the system's random number generator when the seed is created.\u000aIn particular, seeds generated when the system's entropy pool is abnormally\u000alow such as during system boot may be of a lower quality.\u000a\u000aThe default hashing algorithm is currently SipHash 1-3, though this is\u000asubject to change at any point in the future. While its performance is very\u000acompetitive for medium sized keys, other hashing algorithms will outperform\u000ait for small keys such as integers as well as large keys such as long\u000astrings, though those algorithms will typically *not* protect against\u000aattacks such as HashDoS.\u000a\u000aThe hashing algorithm can be replaced on a per-`HashMap` basis using the\u000a[`default`], [`with_hasher`], and [`with_capacity_and_hasher`] methods. Many\u000aalternative algorithms are available on crates.io, such as the [`fnv`] crate.\u000a\u000aIt is required that the keys implement the [`Eq`](https://doc.rust-lang.org/nightly/core/cmp/trait.Eq.html) and [`Hash`](https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html) traits, although\u000athis can frequently be achieved by using `#[derive(PartialEq, Eq, Hash)]`.\u000aIf you implement these yourself, it is important that the following\u000aproperty holds:\u000a\u000a```text\u000ak1 == k2 -> hash(k1) == hash(k2)\u000a```\u000a\u000aIn other words, if two keys are equal, their hashes must be equal.\u000a\u000aIt is a logic error for a key to be modified in such a way that the key's\u000ahash, as determined by the [`Hash`](https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html) trait, or its equality, as determined by\u000athe [`Eq`](https://doc.rust-lang.org/nightly/core/cmp/trait.Eq.html) trait, changes while it is in the map. This is normally only\u000apossible through [`Cell`], [`RefCell`], global state, I/O, or unsafe code.\u000a\u000aThe hash table implementation is a Rust port of Google's [SwissTable].\u000aThe original C++ version of SwissTable can be found [here], and this\u000a[CppCon talk] gives an overview of how the algorithm works.\u000a\u000a# Examples\u000a\u000a```rust\u000ause std::collections::HashMap;\u000a\u000a// Type inference lets us omit an explicit type signature (which\u000a// would be `HashMap<String, String>` in this example).\u000alet mut book_reviews = HashMap::new();\u000a\u000a// Review some books.\u000abook_reviews.insert(\u000a    \"Adventures of Huckleberry Finn\".to_string(),\u000a    \"My favorite book.\".to_string(),\u000a);\u000abook_reviews.insert(\u000a    \"Grimms' Fairy Tales\".to_string(),\u000a    \"Masterpiece.\".to_string(),\u000a);\u000abook_reviews.insert(\u000a    \"Pride and Prejudice\".to_string(),\u000a    \"Very enjoyable.\".to_string(),\u000a);\u000abook_reviews.insert(\u000a    \"The Adventures of Sherlock Holmes\".to_string(),\u000a    \"Eye lyked it alot.\".to_string(),\u000a);\u000a\u000a// Check for a specific one.\u000a// When collections store owned values (String), they can still be\u000a// queried using references (&str).\u000aif !book_reviews.contains_key(\"Les MisÃ©rables\") {\u000a    println!(\"We've got {} reviews, but Les MisÃ©rables ain't one.\",\u000a             book_reviews.len());\u000a}\u000a\u000a// oops, this review has a lot of spelling mistakes, let's delete it.\u000abook_reviews.remove(\"The Adventures of Sherlock Holmes\");\u000a\u000a// Look up the values associated with some keys.\u000alet to_find = [\"Pride and Prejudice\", \"Alice's Adventure in Wonderland\"];\u000afor &book in &to_find {\u000a    match book_reviews.get(book) {\u000a        Some(review) => println!(\"{}: {}\", book, review),\u000a        None => println!(\"{} is unreviewed.\", book)\u000a    }\u000a}\u000a\u000a// Look up the value for a key (will panic if the key is not found).\u000aprintln!(\"Review for Jane: {}\", book_reviews[\"Pride and Prejudice\"]);\u000a\u000a// Iterate over everything.\u000afor (book, review) in &book_reviews {\u000a    println!(\"{}: \\\"{}\\\"\", book, review);\u000a}\u000a```\u000a\u000a`HashMap` also implements an [`Entry API`](https://doc.rust-lang.org/nightly/std/collections/hash/map/struct.HashMap.html#method.entry), which allows\u000afor more complex methods of getting, setting, updating and removing keys and\u000atheir values:\u000a\u000a```rust\u000ause std::collections::HashMap;\u000a\u000a// type inference lets us omit an explicit type signature (which\u000a// would be `HashMap<&str, u8>` in this example).\u000alet mut player_stats = HashMap::new();\u000a\u000afn random_stat_buff() -> u8 {\u000a    // could actually return some random value here - let's just return\u000a    // some fixed value for now\u000a    42\u000a}\u000a\u000a// insert a key only if it doesn't already exist\u000aplayer_stats.entry(\"health\").or_insert(100);\u000a\u000a// insert a key using a function that provides a new value only if it\u000a// doesn't already exist\u000aplayer_stats.entry(\"defence\").or_insert_with(random_stat_buff);\u000a\u000a// update a key, guarding against the key possibly not being set\u000alet stat = player_stats.entry(\"attack\").or_insert(100);\u000a*stat += random_stat_buff();\u000a```\u000a\u000aThe easiest way to use `HashMap` with a custom key type is to derive [`Eq`](https://doc.rust-lang.org/nightly/core/cmp/trait.Eq.html) and [`Hash`](https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html).\u000aWe must also derive [`PartialEq`](https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html).\u000a\u000a```rust\u000ause std::collections::HashMap;\u000a\u000a#[derive(Hash, Eq, PartialEq, Debug)]\u000astruct Viking {\u000a    name: String,\u000a    country: String,\u000a}\u000a\u000aimpl Viking {\u000a    /// Creates a new Viking.\u000a    fn new(name: &str, country: &str) -> Viking {\u000a        Viking { name: name.to_string(), country: country.to_string() }\u000a    }\u000a}\u000a\u000a// Use a HashMap to store the vikings' health points.\u000alet mut vikings = HashMap::new();\u000a\u000avikings.insert(Viking::new(\"Einar\", \"Norway\"), 25);\u000avikings.insert(Viking::new(\"Olaf\", \"Denmark\"), 24);\u000avikings.insert(Viking::new(\"Harald\", \"Iceland\"), 12);\u000a\u000a// Use derived implementation to print the status of the vikings.\u000afor (viking, health) in &vikings {\u000a    println!(\"{:?} has {} hp\", viking, health);\u000a}\u000a```\u000a\u000aA `HashMap` with fixed list of elements can be initialized from an array:\u000a\u000a```rust\u000ause std::collections::HashMap;\u000a\u000alet timber_resources: HashMap<&str, i32> = [(\"Norway\", 100), (\"Denmark\", 50), (\"Iceland\", 10)]\u000a    .iter().cloned().collect();\u000a// use the values stored in map\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000astd::collections::hash::map::HashMap\u000a```\u000a\u000a```rust\u000apub fn insert(&mut self, k: K, v: V) -> Option<V>\u000a```\u000a\u000a---\u000a\u000aInserts a key-value pair into the map.\u000a\u000aIf the map did not have this key present, [`None`](https://doc.rust-lang.org/nightly/core/option/enum.Option.html) is returned.\u000a\u000aIf the map did have this key present, the value is updated, and the old\u000avalue is returned. The key is not updated, though; this matters for\u000atypes that can be `==` without being identical. See the [module-level\u000adocumentation] for more.\u000a\u000a# Examples\u000a\u000a```rust\u000ause std::collections::HashMap;\u000a\u000alet mut map = HashMap::new();\u000aassert_eq!(map.insert(37, \"a\"), None);\u000aassert_eq!(map.is_empty(), false);\u000a\u000amap.insert(37, \"b\");\u000aassert_eq!(map.insert(37, \"c\"), Some(\"b\"));\u000aassert_eq!(map[&37], \"c\");\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000astd::collections::hash::map::HashMap\u000a```\u000a\u000a```rust\u000apub fn len(&self) -> usize\u000a```\u000a\u000a---\u000a\u000aReturns the number of elements in the map.\u000a\u000a# Examples\u000a\u000a```rust\u000ause std::collections::HashMap;\u000a\u000alet mut a = HashMap::new();\u000aassert_eq!(a.len(), 0);\u000aa.insert(1, \"a\");\u000aassert_eq!(a.len(), 1);\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000astd::collections::hash::map::HashMap\u000a```\u000a\u000a```rust\u000apub fn new() -> HashMap<K, V, RandomState>\u000a```\u000a\u000a---\u000a\u000aCreates an empty `HashMap`.\u000a\u000aThe hash map is initially created with a capacity of 0, so it will not allocate until it\u000ais first inserted into.\u000a\u000a# Examples\u000a\u000a```rust\u000ause std::collections::HashMap;\u000alet mut map: HashMap<&str, i32> = HashMap::new();\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000astd::collections::hash::map::HashMap\u000a```\u000a\u000a```rust\u000apub fn values_mut(&mut self) -> ValuesMut<'_, K, V>\u000a```\u000a\u000a---\u000a\u000aAn iterator visiting all values mutably in arbitrary order.\u000aThe iterator element type is `&'a mut V`.\u000a\u000a# Examples\u000a\u000a```rust\u000ause std::collections::HashMap;\u000a\u000alet mut map = HashMap::new();\u000a\u000amap.insert(\"a\", 1);\u000amap.insert(\"b\", 2);\u000amap.insert(\"c\", 3);\u000a\u000afor val in map.values_mut() {\u000a    *val = *val + 10;\u000a}\u000a\u000afor val in map.values() {\u000a    println!(\"{}\", val);\u000a}\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000astd::collections::hash::set\u000a```\u000a\u000a```rust\u000apub struct HashSet<T, S = RandomState>\u000a```\u000a\u000a---\u000a\u000aA hash set implemented as a `HashMap` where the value is `()`.\u000a\u000aAs with the [`HashMap`] type, a `HashSet` requires that the elements\u000aimplement the [`Eq`](https://doc.rust-lang.org/nightly/core/cmp/trait.Eq.html) and [`Hash`](https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html) traits. This can frequently be achieved by\u000ausing `#[derive(PartialEq, Eq, Hash)]`. If you implement these yourself,\u000ait is important that the following property holds:\u000a\u000a```text\u000ak1 == k2 -> hash(k1) == hash(k2)\u000a```\u000a\u000aIn other words, if two keys are equal, their hashes must be equal.\u000a\u000aIt is a logic error for an item to be modified in such a way that the\u000aitem's hash, as determined by the [`Hash`](https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html) trait, or its equality, as\u000adetermined by the [`Eq`](https://doc.rust-lang.org/nightly/core/cmp/trait.Eq.html) trait, changes while it is in the set. This is\u000anormally only possible through [`Cell`], [`RefCell`], global state, I/O, or\u000aunsafe code.\u000a\u000a# Examples\u000a\u000a```rust\u000ause std::collections::HashSet;\u000a// Type inference lets us omit an explicit type signature (which\u000a// would be `HashSet<String>` in this example).\u000alet mut books = HashSet::new();\u000a\u000a// Add some books.\u000abooks.insert(\"A Dance With Dragons\".to_string());\u000abooks.insert(\"To Kill a Mockingbird\".to_string());\u000abooks.insert(\"The Odyssey\".to_string());\u000abooks.insert(\"The Great Gatsby\".to_string());\u000a\u000a// Check for a specific one.\u000aif !books.contains(\"The Winds of Winter\") {\u000a    println!(\"We have {} books, but The Winds of Winter ain't one.\",\u000a             books.len());\u000a}\u000a\u000a// Remove a book.\u000abooks.remove(\"The Odyssey\");\u000a\u000a// Iterate over everything.\u000afor book in &books {\u000a    println!(\"{}\", book);\u000a}\u000a```\u000a\u000aThe easiest way to use `HashSet` with a custom type is to derive\u000a[`Eq`](https://doc.rust-lang.org/nightly/core/cmp/trait.Eq.html) and [`Hash`](https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html). We must also derive [`PartialEq`](https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html), this will in the\u000afuture be implied by [`Eq`](https://doc.rust-lang.org/nightly/core/cmp/trait.Eq.html).\u000a\u000a```rust\u000ause std::collections::HashSet;\u000a#[derive(Hash, Eq, PartialEq, Debug)]\u000astruct Viking {\u000a    name: String,\u000a    power: usize,\u000a}\u000a\u000alet mut vikings = HashSet::new();\u000a\u000avikings.insert(Viking { name: \"Einar\".to_string(), power: 9 });\u000avikings.insert(Viking { name: \"Einar\".to_string(), power: 9 });\u000avikings.insert(Viking { name: \"Olaf\".to_string(), power: 4 });\u000avikings.insert(Viking { name: \"Harald\".to_string(), power: 8 });\u000a\u000a// Use derived implementation to print the vikings.\u000afor x in &vikings {\u000a    println!(\"{:?}\", x);\u000a}\u000a```\u000a\u000aA `HashSet` with fixed list of elements can be initialized from an array:\u000a\u000a```rust\u000ause std::collections::HashSet;\u000a\u000alet viking_names: HashSet<&'static str> =\u000a    [ \"Einar\", \"Olaf\", \"Harald\" ].iter().cloned().collect();\u000a// use the values stored in the set\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000astd::collections::hash::set::HashSet\u000a```\u000a\u000a```rust\u000apub fn insert(&mut self, value: T) -> bool\u000a```\u000a\u000a---\u000a\u000aAdds a value to the set.\u000a\u000aIf the set did not have this value present, `true` is returned.\u000a\u000aIf the set did have this value present, `false` is returned.\u000a\u000a# Examples\u000a\u000a```rust\u000ause std::collections::HashSet;\u000a\u000alet mut set = HashSet::new();\u000a\u000aassert_eq!(set.insert(2), true);\u000aassert_eq!(set.insert(2), false);\u000aassert_eq!(set.len(), 1);\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000astd::collections::hash::set::HashSet\u000a```\u000a\u000a```rust\u000apub fn new() -> HashSet<T, RandomState>\u000a```\u000a\u000a---\u000a\u000aCreates an empty `HashSet`.\u000a\u000aThe hash set is initially created with a capacity of 0, so it will not allocate until it\u000ais first inserted into.\u000a\u000a# Examples\u000a\u000a```rust\u000ause std::collections::HashSet;\u000alet set: HashSet<i32> = HashSet::new();\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000astd::env\u000a```\u000a\u000a```rust\u000apub fn args() -> Args\u000a```\u000a\u000a---\u000a\u000aReturns the arguments that this program was started with (normally passed\u000avia the command line).\u000a\u000aThe first element is traditionally the path of the executable, but it can be\u000aset to arbitrary text, and may not even exist. This means this property should\u000anot be relied upon for security purposes.\u000a\u000aOn Unix systems the shell usually expands unquoted arguments with glob patterns\u000a(such as `*` and `?`). On Windows this is not done, and such arguments are\u000apassed as-is.\u000a\u000aOn glibc Linux systems, arguments are retrieved by placing a function in `.init_array`.\u000aGlibc passes `argc`, `argv`, and `envp` to functions in `.init_array`, as a non-standard\u000aextension. This allows `std::env::args` to work even in a `cdylib` or `staticlib`, as it\u000adoes on macOS and Windows.\u000a\u000a# Panics\u000a\u000aThe returned iterator will panic during iteration if any argument to the\u000aprocess is not valid unicode. If this is not desired,\u000ause the [`args_os`](https://doc.rust-lang.org/nightly/std/env/fn.args_os.html) function instead.\u000a\u000a# Examples\u000a\u000a```rust\u000ause std::env;\u000a\u000a// Prints each argument on a separate line\u000afor argument in env::args() {\u000a    println!(\"{}\", argument);\u000a}\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000astd::fs\u000a```\u000a\u000a```rust\u000apub struct File\u000a```\u000a\u000a---\u000a\u000aA reference to an open file on the filesystem.\u000a\u000aAn instance of a `File` can be read and/or written depending on what options\u000ait was opened with. Files also implement [`Seek`](https://doc.rust-lang.org/nightly/std/io/trait.Seek.html) to alter the logical cursor\u000athat the file contains internally.\u000a\u000aFiles are automatically closed when they go out of scope.  Errors detected\u000aon closing are ignored by the implementation of `Drop`.  Use the method\u000a[`sync_all`] if these errors must be manually handled.\u000a\u000a# Examples\u000a\u000aCreates a new file and write bytes to it (you can also use [`write`](https://doc.rust-lang.org/nightly/std/fs/fn.write.html)):\u000a\u000a```rust\u000ause std::fs::File;\u000ause std::io::prelude::*;\u000a\u000afn main() -> std::io::Result<()> {\u000a    let mut file = File::create(\"foo.txt\")?;\u000a    file.write_all(b\"Hello, world!\")?;\u000a    Ok(())\u000a}\u000a```\u000a\u000aRead the contents of a file into a [`String`](https://doc.rust-lang.org/nightly/alloc/string/struct.String.html) (you can also use [`read`](https://doc.rust-lang.org/nightly/std/fs/fn.read.html)):\u000a\u000a```rust\u000ause std::fs::File;\u000ause std::io::prelude::*;\u000a\u000afn main() -> std::io::Result<()> {\u000a    let mut file = File::open(\"foo.txt\")?;\u000a    let mut contents = String::new();\u000a    file.read_to_string(&mut contents)?;\u000a    assert_eq!(contents, \"Hello, world!\");\u000a    Ok(())\u000a}\u000a```\u000a\u000aIt can be more efficient to read the contents of a file with a buffered\u000a[`Read`](https://doc.rust-lang.org/nightly/std/io/trait.Read.html)er. This can be accomplished with [`BufReader<R>`]:\u000a\u000a```rust\u000ause std::fs::File;\u000ause std::io::BufReader;\u000ause std::io::prelude::*;\u000a\u000afn main() -> std::io::Result<()> {\u000a    let file = File::open(\"foo.txt\")?;\u000a    let mut buf_reader = BufReader::new(file);\u000a    let mut contents = String::new();\u000a    buf_reader.read_to_string(&mut contents)?;\u000a    assert_eq!(contents, \"Hello, world!\");\u000a    Ok(())\u000a}\u000a```\u000a\u000aNote that, although read and write methods require a `&mut File`, because\u000aof the interfaces for [`Read`](https://doc.rust-lang.org/nightly/std/io/trait.Read.html) and [`Write`](https://doc.rust-lang.org/nightly/std/io/trait.Write.html), the holder of a `&File` can\u000astill modify the file, either through methods that take `&File` or by\u000aretrieving the underlying OS object and modifying the file that way.\u000aAdditionally, many operating systems allow concurrent modification of files\u000aby different processes. Avoid assuming that holding a `&File` means that the\u000afile will not change."
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000astd::fs::File\u000a```\u000a\u000a```rust\u000apub fn create<P>(path: P) -> io::Result<File>\u000awhere\u000a    P: AsRef<Path>,\u000a```\u000a\u000a---\u000a\u000aOpens a file in write-only mode.\u000a\u000aThis function will create a file if it does not exist,\u000aand will truncate it if it does.\u000a\u000aSee the [`OpenOptions::open`](`OpenOptions::open`) function for more details.\u000a\u000a# Examples\u000a\u000a```rust\u000ause std::fs::File;\u000a\u000afn main() -> std::io::Result<()> {\u000a    let mut f = File::create(\"foo.txt\")?;\u000a    Ok(())\u000a}\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000astd::fs::File\u000a```\u000a\u000a```rust\u000apub fn metadata(&self) -> io::Result<Metadata>\u000a```\u000a\u000a---\u000a\u000aQueries metadata about the underlying file.\u000a\u000a# Examples\u000a\u000a```rust\u000ause std::fs::File;\u000a\u000afn main() -> std::io::Result<()> {\u000a    let mut f = File::open(\"foo.txt\")?;\u000a    let metadata = f.metadata()?;\u000a    Ok(())\u000a}\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000astd::fs::File\u000a```\u000a\u000a```rust\u000apub fn open<P>(path: P) -> io::Result<File>\u000awhere\u000a    P: AsRef<Path>,\u000a```\u000a\u000a---\u000a\u000aAttempts to open a file in read-only mode.\u000a\u000aSee the [`OpenOptions::open`](`OpenOptions::open`) method for more details.\u000a\u000a# Errors\u000a\u000aThis function will return an error if `path` does not already exist.\u000aOther errors may also be returned according to [`OpenOptions::open`](`OpenOptions::open`).\u000a\u000a# Examples\u000a\u000a```rust\u000ause std::fs::File;\u000a\u000afn main() -> std::io::Result<()> {\u000a    let mut f = File::open(\"foo.txt\")?;\u000a    Ok(())\u000a}\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000astd::fs::Metadata\u000a```\u000a\u000a```rust\u000apub fn is_dir(&self) -> bool\u000a```\u000a\u000a---\u000a\u000aReturns `true` if this metadata is for a directory. The\u000aresult is mutually exclusive to the result of\u000a[`Metadata::is_file`](`Metadata::is_file`), and will be false for symlink metadata\u000aobtained from [`symlink_metadata`](https://doc.rust-lang.org/nightly/std/fs/fn.symlink_metadata.html).\u000a\u000a# Examples\u000a\u000a```rust\u000afn main() -> std::io::Result<()> {\u000a    use std::fs;\u000a\u000a    let metadata = fs::metadata(\"foo.txt\")?;\u000a\u000a    assert!(!metadata.is_dir());\u000a    Ok(())\u000a}\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000astd::io\u000a```\u000a\u000a```rust\u000apub trait Read\u000a```\u000a\u000a---\u000a\u000aThe `Read` trait allows for reading bytes from a source.\u000a\u000aImplementors of the `Read` trait are called 'readers'.\u000a\u000aReaders are defined by one required method, [`read`]. Each call to [`read`]\u000awill attempt to pull bytes from this source into a provided buffer. A\u000anumber of other methods are implemented in terms of [`read`], giving\u000aimplementors a number of ways to read bytes while only needing to implement\u000aa single method.\u000a\u000aReaders are intended to be composable with one another. Many implementors\u000athroughout [`std::io`] take and provide types which implement the `Read`\u000atrait.\u000a\u000aPlease note that each call to [`read`] may involve a system call, and\u000atherefore, using something that implements [`BufRead`](https://doc.rust-lang.org/nightly/std/io/trait.BufRead.html), such as\u000a[`BufReader`](https://doc.rust-lang.org/nightly/std/io/buffered/struct.BufReader.html), will be more efficient.\u000a\u000a# Examples\u000a\u000a[`File`]s implement `Read`:\u000a\u000a```rust\u000ause std::io;\u000ause std::io::prelude::*;\u000ause std::fs::File;\u000a\u000afn main() -> io::Result<()> {\u000a    let mut f = File::open(\"foo.txt\")?;\u000a    let mut buffer = [0; 10];\u000a\u000a    // read up to 10 bytes\u000a    f.read(&mut buffer)?;\u000a\u000a    let mut buffer = Vec::new();\u000a    // read the whole file\u000a    f.read_to_end(&mut buffer)?;\u000a\u000a    // read into a String, so that you don't need to do the conversion.\u000a    let mut buffer = String::new();\u000a    f.read_to_string(&mut buffer)?;\u000a\u000a    // and more! See the other methods for more details.\u000a    Ok(())\u000a}\u000a```\u000a\u000aRead from [`&str`] because [`&[u8]`](https://doc.rust-lang.org/nightly/std/primitive.slice.html) implements `Read`:\u000a\u000a```rust\u000ause std::io::prelude::*;\u000a\u000afn main() -> io::Result<()> {\u000a    let mut b = \"This string will be read\".as_bytes();\u000a    let mut buffer = [0; 10];\u000a\u000a    // read up to 10 bytes\u000a    b.read(&mut buffer)?;\u000a\u000a    // etc... it works exactly as a File does!\u000a    Ok(())\u000a}\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000astd::io\u000a```\u000a\u000a```rust\u000apub trait Write\u000a```\u000a\u000a---\u000a\u000aA trait for objects which are byte-oriented sinks.\u000a\u000aImplementors of the `Write` trait are sometimes called 'writers'.\u000a\u000aWriters are defined by two required methods, [`write`] and [`flush`]:\u000a\u000a* The [`write`] method will attempt to write some data into the object,\u000a  returning how many bytes were successfully written.\u000a\u000a* The [`flush`] method is useful for adaptors and explicit buffers\u000a  themselves for ensuring that all buffered data has been pushed out to the\u000a  'true sink'.\u000a\u000aWriters are intended to be composable with one another. Many implementors\u000athroughout [`std::io`] take and provide types which implement the `Write`\u000atrait.\u000a\u000a# Examples\u000a\u000a```rust\u000ause std::io::prelude::*;\u000ause std::fs::File;\u000a\u000afn main() -> std::io::Result<()> {\u000a    let data = b\"some bytes\";\u000a\u000a    let mut pos = 0;\u000a    let mut buffer = File::create(\"foo.txt\")?;\u000a\u000a    while pos < data.len() {\u000a        let bytes_written = buffer.write(&data[pos..])?;\u000a        pos += bytes_written;\u000a    }\u000a    Ok(())\u000a}\u000a```\u000a\u000aThe trait also provides convenience methods like [`write_all`], which calls\u000a`write` in a loop until its entire input has been written."
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000astd::io::Read\u000a```\u000a\u000a```rust\u000apub fn read(&mut self, buf: &mut [u8]) -> Result<usize>\u000a```\u000a\u000a---\u000a\u000aPull some bytes from this source into the specified buffer, returning\u000ahow many bytes were read.\u000a\u000aThis function does not provide any guarantees about whether it blocks\u000awaiting for data, but if an object needs to block for a read and cannot,\u000ait will typically signal this via an [`Err`](https://doc.rust-lang.org/nightly/core/result/enum.Result.html) return value.\u000a\u000aIf the return value of this method is [`Ok(n)`], then it must be\u000aguaranteed that `0 <= n <= buf.len()`. A nonzero `n` value indicates\u000athat the buffer `buf` has been filled in with `n` bytes of data from this\u000asource. If `n` is `0`, then it can indicate one of two scenarios:\u000a\u000a1. This reader has reached its \"end of file\" and will likely no longer\u000a   be able to produce bytes. Note that this does not mean that the\u000a   reader will *always* no longer be able to produce bytes.\u000a1. The buffer specified was 0 bytes in length.\u000a\u000aIt is not an error if the returned value `n` is smaller than the buffer size,\u000aeven when the reader is not at the end of the stream yet.\u000aThis may happen for example because fewer bytes are actually available right now\u000a(e. g. being close to end-of-file) or because read() was interrupted by a signal.\u000a\u000aNo guarantees are provided about the contents of `buf` when this\u000afunction is called, implementations cannot rely on any property of the\u000acontents of `buf` being true. It is recommended that *implementations*\u000aonly write data to `buf` instead of reading its contents.\u000a\u000aCorrespondingly, however, *callers* of this method may not assume any guarantees\u000aabout how the implementation uses `buf`. The trait is safe to implement,\u000aso it is possible that the code that's supposed to write to the buffer might also read\u000afrom it. It is your responsibility to make sure that `buf` is initialized\u000abefore calling `read`. Calling `read` with an uninitialized `buf` (of the kind one\u000aobtains via [`MaybeUninit<T>`]) is not safe, and can lead to undefined behavior.\u000a\u000a# Errors\u000a\u000aIf this function encounters any form of I/O or other error, an error\u000avariant will be returned. If an error is returned then it must be\u000aguaranteed that no bytes were read.\u000a\u000aAn error of the [`ErrorKind::Interrupted`](https://doc.rust-lang.org/nightly/std/io/error/enum.ErrorKind.html) kind is non-fatal and the read\u000aoperation should be retried if there is nothing else to do.\u000a\u000a# Examples\u000a\u000a[`File`]s implement `Read`:\u000a\u000a```rust\u000ause std::io;\u000ause std::io::prelude::*;\u000ause std::fs::File;\u000a\u000afn main() -> io::Result<()> {\u000a    let mut f = File::open(\"foo.txt\")?;\u000a    let mut buffer = [0; 10];\u000a\u000a    // read up to 10 bytes\u000a    let n = f.read(&mut buffer[..])?;\u000a\u000a    println!(\"The bytes: {:?}\", &buffer[..n]);\u000a    Ok(())\u000a}\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000astd::io::Read\u000a```\u000a\u000a```rust\u000apub fn read_to_end(&mut self, buf: &mut Vec<u8>) -> Result<usize>\u000a```\u000a\u000a---\u000a\u000aRead all bytes until EOF in this source, placing them into `buf`.\u000a\u000aAll bytes read from this source will be appended to the specified buffer\u000a`buf`. This function will continuously call [`read`] to append more data to\u000a`buf` until [`read`] returns either [`Ok(0)`] or an error of\u000anon-[`ErrorKind::Interrupted`](https://doc.rust-lang.org/nightly/std/io/error/enum.ErrorKind.html) kind.\u000a\u000aIf successful, this function will return the total number of bytes read.\u000a\u000a# Errors\u000a\u000aIf this function encounters an error of the kind\u000a[`ErrorKind::Interrupted`](https://doc.rust-lang.org/nightly/std/io/error/enum.ErrorKind.html) then the error is ignored and the operation\u000awill continue.\u000a\u000aIf any other read error is encountered then this function immediately\u000areturns. Any bytes which have already been read will be appended to\u000a`buf`.\u000a\u000a# Examples\u000a\u000a[`File`]s implement `Read`:\u000a\u000a```rust\u000ause std::io;\u000ause std::io::prelude::*;\u000ause std::fs::File;\u000a\u000afn main() -> io::Result<()> {\u000a    let mut f = File::open(\"foo.txt\")?;\u000a    let mut buffer = Vec::new();\u000a\u000a    // read the whole file\u000a    f.read_to_end(&mut buffer)?;\u000a    Ok(())\u000a}\u000a```\u000a\u000a(See also the [`std::fs::read`] convenience function for reading from a\u000afile.)"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000astd::io::Read\u000a```\u000a\u000a```rust\u000apub fn read_to_string(&mut self, buf: &mut String) -> Result<usize>\u000a```\u000a\u000a---\u000a\u000aRead all bytes until EOF in this source, appending them to `buf`.\u000a\u000aIf successful, this function returns the number of bytes which were read\u000aand appended to `buf`.\u000a\u000a# Errors\u000a\u000aIf the data in this stream is *not* valid UTF-8 then an error is\u000areturned and `buf` is unchanged.\u000a\u000aSee [`read_to_end`] for other error semantics.\u000a\u000a# Examples\u000a\u000a[`File`]s implement `Read`:\u000a\u000a```rust\u000ause std::io;\u000ause std::io::prelude::*;\u000ause std::fs::File;\u000a\u000afn main() -> io::Result<()> {\u000a    let mut f = File::open(\"foo.txt\")?;\u000a    let mut buffer = String::new();\u000a\u000a    f.read_to_string(&mut buffer)?;\u000a    Ok(())\u000a}\u000a```\u000a\u000a(See also the [`std::fs::read_to_string`] convenience function for\u000areading from a file.)"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000astd::io::Write\u000a```\u000a\u000a```rust\u000apub fn write_all(&mut self, buf: &[u8]) -> Result<()>\u000a```\u000a\u000a---\u000a\u000aAttempts to write an entire buffer into this writer.\u000a\u000aThis method will continuously call [`write`] until there is no more data\u000ato be written or an error of non-[`ErrorKind::Interrupted`](https://doc.rust-lang.org/nightly/std/io/error/enum.ErrorKind.html) kind is\u000areturned. This method will not return until the entire buffer has been\u000asuccessfully written or such an error occurs. The first error that is\u000anot of [`ErrorKind::Interrupted`](https://doc.rust-lang.org/nightly/std/io/error/enum.ErrorKind.html) kind generated from this method will be\u000areturned.\u000a\u000aIf the buffer contains no data, this will never call [`write`].\u000a\u000a# Errors\u000a\u000aThis function will return the first error of\u000anon-[`ErrorKind::Interrupted`](https://doc.rust-lang.org/nightly/std/io/error/enum.ErrorKind.html) kind that [`write`] returns.\u000a\u000a# Examples\u000a\u000a```rust\u000ause std::io::prelude::*;\u000ause std::fs::File;\u000a\u000afn main() -> std::io::Result<()> {\u000a    let mut buffer = File::create(\"foo.txt\")?;\u000a\u000a    buffer.write_all(b\"some bytes\")?;\u000a    Ok(())\u000a}\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000astd::io::error\u000a```\u000a\u000a```rust\u000apub enum ErrorKind\u000a```\u000a\u000a---\u000a\u000aA list specifying general categories of I/O error.\u000a\u000aThis list is intended to grow over time and it is not recommended to\u000aexhaustively match against it.\u000a\u000aIt is used with the [`io::Error`] type."
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000astd::io::error\u000a```\u000a\u000a```rust\u000apub struct Error\u000a```\u000a\u000a---\u000a\u000aThe error type for I/O operations of the [`Read`], [`Write`], [`Seek`], and\u000aassociated traits.\u000a\u000aErrors mostly originate from the underlying OS, but custom instances of\u000a`Error` can be created with crafted error messages and a particular value of\u000a[`ErrorKind`](https://doc.rust-lang.org/nightly/std/io/error/enum.ErrorKind.html)."
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000astd::io::error\u000a```\u000a\u000a```rust\u000apub type Result = result::Result<T, Error>\u000a```\u000a\u000a---\u000a\u000aA specialized [`Result`] type for I/O operations.\u000a\u000aThis type is broadly used across [`std::io`] for any operation which may\u000aproduce an error.\u000a\u000aThis typedef is generally used to avoid writing out [`io::Error`] directly and\u000ais otherwise a direct mapping to [`Result`].\u000a\u000aWhile usual Rust style is to import types directly, aliases of [`Result`]\u000aoften are not, to make it easier to distinguish between them. [`Result`] is\u000agenerally assumed to be [`std::result::Result`](https://doc.rust-lang.org/nightly/core/result/enum.Result.html), and so users of this alias\u000awill generally use `io::Result` instead of shadowing the [prelude]'s import\u000aof [`std::result::Result`](https://doc.rust-lang.org/nightly/core/result/enum.Result.html).\u000a\u000a# Examples\u000a\u000aA convenience function that bubbles an `io::Result` to its caller:\u000a\u000a```rust\u000ause std::io;\u000a\u000afn get_string() -> io::Result<String> {\u000a    let mut buffer = String::new();\u000a\u000a    io::stdin().read_line(&mut buffer)?;\u000a\u000a    Ok(buffer)\u000a}\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000astd::io::error::Error\u000a```\u000a\u000a```rust\u000apub fn kind(&self) -> ErrorKind\u000a```\u000a\u000a---\u000a\u000aReturns the corresponding [`ErrorKind`](https://doc.rust-lang.org/nightly/std/io/error/enum.ErrorKind.html) for this error.\u000a\u000a# Examples\u000a\u000a```rust\u000ause std::io::{Error, ErrorKind};\u000a\u000afn print_error(err: Error) {\u000a    println!(\"{:?}\", err.kind());\u000a}\u000a\u000afn main() {\u000a    // Will print \"Other\".\u000a    print_error(Error::last_os_error());\u000a    // Will print \"AddrInUse\".\u000a    print_error(Error::new(ErrorKind::AddrInUse, \"oh no!\"));\u000a}\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000astd::io::error::ErrorKind\u000a```\u000a\u000a```rust\u000aInterrupted\u000a```\u000a\u000a---\u000a\u000aThis operation was interrupted.\u000a\u000aInterrupted operations can typically be retried."
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000astd::macros\u000a```\u000a\u000a```rust\u000amacro_rules! eprintln\u000a```\u000a\u000a---\u000a\u000aPrints to the standard error, with a newline.\u000a\u000aEquivalent to the [`println`](https://doc.rust-lang.org/nightly/std/macros/macro.println.html) macro, except that output goes to\u000a[`io::stderr`] instead of [`io::stdout`]. See [`println`](https://doc.rust-lang.org/nightly/std/macros/macro.println.html) for\u000aexample usage.\u000a\u000aUse `eprintln!` only for error and progress messages. Use `println!`\u000ainstead for the primary output of your program.\u000a\u000a# Panics\u000a\u000aPanics if writing to `io::stderr` fails.\u000a\u000a# Examples\u000a\u000a```rust\u000aeprintln!(\"Error: Could not complete task\");\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000astd::macros\u000a```\u000a\u000a```rust\u000amacro_rules! panic\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000astd::macros\u000a```\u000a\u000a```rust\u000amacro_rules! print\u000a```\u000a\u000a---\u000a\u000aPrints to the standard output.\u000a\u000aEquivalent to the [`println`](https://doc.rust-lang.org/nightly/std/macros/macro.println.html) macro except that a newline is not printed at\u000athe end of the message.\u000a\u000aNote that stdout is frequently line-buffered by default so it may be\u000anecessary to use [`io::stdout().flush`](https://doc.rust-lang.org/nightly/std/io/trait.Write.html#tymethod.flush) to ensure the output is emitted\u000aimmediately.\u000a\u000aUse `print!` only for the primary output of your program. Use\u000a[`eprint`](https://doc.rust-lang.org/nightly/std/macros/macro.eprint.html) instead to print error and progress messages.\u000a\u000a# Panics\u000a\u000aPanics if writing to `io::stdout()` fails.\u000a\u000a# Examples\u000a\u000a```rust\u000ause std::io::{self, Write};\u000a\u000aprint!(\"this \");\u000aprint!(\"will \");\u000aprint!(\"be \");\u000aprint!(\"on \");\u000aprint!(\"the \");\u000aprint!(\"same \");\u000aprint!(\"line \");\u000a\u000aio::stdout().flush().unwrap();\u000a\u000aprint!(\"this string has a newline, why not choose println! instead?\\n\");\u000a\u000aio::stdout().flush().unwrap();\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000astd::macros\u000a```\u000a\u000a```rust\u000amacro_rules! println\u000a```\u000a\u000a---\u000a\u000aPrints to the standard output, with a newline.\u000a\u000aOn all platforms, the newline is the LINE FEED character (`\\n`/`U+000A`) alone\u000a(no additional CARRIAGE RETURN (`\\r`/`U+000D`)).\u000a\u000aUse the [`format`](https://doc.rust-lang.org/nightly/alloc/macros/macro.format.html) syntax to write data to the standard output.\u000aSee [`std::fmt`] for more information.\u000a\u000aUse `println!` only for the primary output of your program. Use\u000a[`eprintln`](https://doc.rust-lang.org/nightly/std/macros/macro.eprintln.html) instead to print error and progress messages.\u000a\u000a# Panics\u000a\u000aPanics if writing to [`io::stdout`] fails.\u000a\u000a# Examples\u000a\u000a```rust\u000aprintln!(); // prints just a newline\u000aprintln!(\"hello there!\");\u000aprintln!(\"format {} arguments\", \"some\");\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000astd::panic\u000a```\u000a\u000a```rust\u000apub fn catch_unwind<F, R>(f: F) -> Result<R>\u000awhere\u000a    F: FnOnce() -> R + UnwindSafe,\u000a```\u000a\u000a---\u000a\u000aInvokes a closure, capturing the cause of an unwinding panic if one occurs.\u000a\u000aThis function will return `Ok` with the closure's result if the closure\u000adoes not panic, and will return `Err(cause)` if the closure panics. The\u000a`cause` returned is the object with which panic was originally invoked.\u000a\u000aIt is currently undefined behavior to unwind from Rust code into foreign\u000acode, so this function is particularly useful when Rust is called from\u000aanother language (normally C). This can run arbitrary Rust code, capturing a\u000apanic and allowing a graceful handling of the error.\u000a\u000aIt is **not** recommended to use this function for a general try/catch\u000amechanism. The [`Result`](https://doc.rust-lang.org/nightly/std/thread/type.Result.html) type is more appropriate to use for functions that\u000acan fail on a regular basis. Additionally, this function is not guaranteed\u000ato catch all panics, see the \"Notes\" section below.\u000a\u000aThe closure provided is required to adhere to the [`UnwindSafe`](https://doc.rust-lang.org/nightly/std/panic/trait.UnwindSafe.html) trait to ensure\u000athat all captured variables are safe to cross this boundary. The purpose of\u000athis bound is to encode the concept of [exception safety](https://github.com/rust-lang/rfcs/blob/master/text/1236-stabilize-catch-panic.md) in the type\u000asystem. Most usage of this function should not need to worry about this\u000abound as programs are naturally unwind safe without `unsafe` code. If it\u000abecomes a problem the [`AssertUnwindSafe`](https://doc.rust-lang.org/nightly/std/panic/struct.AssertUnwindSafe.html) wrapper struct can be used to quickly\u000aassert that the usage here is indeed unwind safe.\u000a\u000a# Notes\u000a\u000aNote that this function **may not catch all panics** in Rust. A panic in\u000aRust is not always implemented via unwinding, but can be implemented by\u000aaborting the process as well. This function *only* catches unwinding panics,\u000anot those that abort the process.\u000a\u000aAlso note that unwinding into Rust code with a foreign exception (e.g. a\u000aan exception thrown from C++ code) is undefined behavior.\u000a\u000a# Examples\u000a\u000a```rust\u000ause std::panic;\u000a\u000alet result = panic::catch_unwind(|| {\u000a    println!(\"hello!\");\u000a});\u000aassert!(result.is_ok());\u000a\u000alet result = panic::catch_unwind(|| {\u000a    panic!(\"oh no!\");\u000a});\u000aassert!(result.is_err());\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000astd::process\u000a```\u000a\u000a```rust\u000apub fn exit(code: i32) -> !\u000a```\u000a\u000a---\u000a\u000aTerminates the current process with the specified exit code.\u000a\u000aThis function will never return and will immediately terminate the current\u000aprocess. The exit code is passed through to the underlying OS and will be\u000aavailable for consumption by another process.\u000a\u000aNote that because this function never returns, and that it terminates the\u000aprocess, no destructors on the current stack or any other thread's stack\u000awill be run. If a clean shutdown is needed it is recommended to only call\u000athis function at a known point where there are no more destructors left\u000ato run.\u000a\u000a## Platform-specific behavior\u000a\u000a**Unix**: On Unix-like platforms, it is unlikely that all 32 bits of `exit`\u000awill be visible to a parent process inspecting the exit code. On most\u000aUnix-like platforms, only the eight least-significant bits are considered.\u000a\u000a# Examples\u000a\u000aDue to this functionâ€™s behavior regarding destructors, a conventional way\u000ato use the function is to extract the actual computation to another\u000afunction and compute the exit code from its return value:\u000a\u000a```rust\u000afn run_app() -> Result<(), ()> {\u000a    // Application logic here\u000a    Ok(())\u000a}\u000a\u000afn main() {\u000a    std::process::exit(match run_app() {\u000a        Ok(_) => 0,\u000a        Err(err) => {\u000a            eprintln!(\"error: {:?}\", err);\u000a            1\u000a        }\u000a    });\u000a}\u000a```\u000a\u000aDue to [platform-specific behavior], the exit code for this example will be\u000a`0` on Linux, but `256` on Windows:\u000a\u000a```rust\u000ause std::process;\u000a\u000aprocess::exit(0x0100);\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000astd::thread\u000a```\u000a\u000a```rust\u000apub fn spawn<F, T>(f: F) -> JoinHandle<T>\u000awhere\u000a    F: FnOnce() -> T + Send + 'static,\u000a    T: Send + 'static,\u000a```\u000a\u000a---\u000a\u000aSpawns a new thread, returning a [`JoinHandle`](https://doc.rust-lang.org/nightly/std/thread/struct.JoinHandle.html) for it.\u000a\u000aThe join handle will implicitly *detach* the child thread upon being\u000adropped. In this case, the child thread may outlive the parent (unless\u000athe parent thread is the main thread; the whole process is terminated when\u000athe main thread finishes). Additionally, the join handle provides a [`join`]\u000amethod that can be used to join the child thread. If the child thread\u000apanics, [`join`] will return an [`Err`] containing the argument given to\u000a[`panic`](https://doc.rust-lang.org/nightly/core/macros/macro.panic.html).\u000a\u000aThis will create a thread using default parameters of [`Builder`](https://doc.rust-lang.org/nightly/std/thread/struct.Builder.html), if you\u000awant to specify the stack size or the name of the thread, use this API\u000ainstead.\u000a\u000aAs you can see in the signature of `spawn` there are two constraints on\u000aboth the closure given to `spawn` and its return value, let's explain them:\u000a\u000a* The `'static` constraint means that the closure and its return value\u000a  must have a lifetime of the whole program execution. The reason for this\u000a  is that threads can `detach` and outlive the lifetime they have been\u000a  created in.\u000a  Indeed if the thread, and by extension its return value, can outlive their\u000a  caller, we need to make sure that they will be valid afterwards, and since\u000a  we *can't* know when it will return we need to have them valid as long as\u000a  possible, that is until the end of the program, hence the `'static`\u000a  lifetime.\u000a* The [`Send`](https://doc.rust-lang.org/nightly/core/marker/trait.Send.html) constraint is because the closure will need to be passed\u000a  *by value* from the thread where it is spawned to the new thread. Its\u000a  return value will need to be passed from the new thread to the thread\u000a  where it is `join`ed.\u000a  As a reminder, the [`Send`](https://doc.rust-lang.org/nightly/core/marker/trait.Send.html) marker trait expresses that it is safe to be\u000a  passed from thread to thread. [`Sync`](https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html) expresses that it is safe to have a\u000a  reference be passed from thread to thread.\u000a\u000a# Panics\u000a\u000aPanics if the OS fails to create a thread; use [`Builder::spawn`](`Builder::spawn`)\u000ato recover from such errors.\u000a\u000a# Examples\u000a\u000aCreating a thread.\u000a\u000a```rust\u000ause std::thread;\u000a\u000alet handler = thread::spawn(|| {\u000a    // thread code\u000a});\u000a\u000ahandler.join().unwrap();\u000a```\u000a\u000aAs mentioned in the module documentation, threads are usually made to\u000acommunicate using [`channels`], here is how it usually looks.\u000a\u000aThis example also shows how to use `move`, in order to give ownership\u000aof values to a thread.\u000a\u000a```rust\u000ause std::thread;\u000ause std::sync::mpsc::channel;\u000a\u000alet (tx, rx) = channel();\u000a\u000alet sender = thread::spawn(move || {\u000a    tx.send(\"Hello, thread\".to_owned())\u000a        .expect(\"Unable to send on channel\");\u000a});\u000a\u000alet receiver = thread::spawn(move || {\u000a    let value = rx.recv().expect(\"Unable to receive from channel\");\u000a    println!(\"{}\", value);\u000a});\u000a\u000asender.join().expect(\"The sender thread has panicked\");\u000areceiver.join().expect(\"The receiver thread has panicked\");\u000a```\u000a\u000aA thread can also return a value through its [`JoinHandle`](https://doc.rust-lang.org/nightly/std/thread/struct.JoinHandle.html), you can use\u000athis to make asynchronous computations (futures might be more appropriate\u000athough).\u000a\u000a```rust\u000ause std::thread;\u000a\u000alet computation = thread::spawn(|| {\u000a    // Some expensive computation.\u000a    42\u000a});\u000a\u000alet result = computation.join().unwrap();\u000aprintln!(\"{}\", result);\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000astd::thread\u000a```\u000a\u000a```rust\u000apub struct JoinHandle<T>\u000a```\u000a\u000a---\u000a\u000aAn owned permission to join on a thread (block on its termination).\u000a\u000aA `JoinHandle` *detaches* the associated thread when it is dropped, which\u000ameans that there is no longer any handle to thread and no way to `join`\u000aon it.\u000a\u000aDue to platform restrictions, it is not possible to [`Clone`](https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html) this\u000ahandle: the ability to join a thread is a uniquely-owned permission.\u000a\u000aThis `struct` is created by the [`thread::spawn`] function and the\u000a[`thread::Builder::spawn`] method.\u000a\u000a# Examples\u000a\u000aCreation from [`thread::spawn`]:\u000a\u000a```rust\u000ause std::thread;\u000a\u000alet join_handle: thread::JoinHandle<_> = thread::spawn(|| {\u000a    // some work here\u000a});\u000a```\u000a\u000aCreation from [`thread::Builder::spawn`]:\u000a\u000a```rust\u000ause std::thread;\u000a\u000alet builder = thread::Builder::new();\u000a\u000alet join_handle: thread::JoinHandle<_> = builder.spawn(|| {\u000a    // some work here\u000a}).unwrap();\u000a```\u000a\u000aChild being detached and outliving its parent:\u000a\u000a```rust\u000ause std::thread;\u000ause std::time::Duration;\u000a\u000alet original_thread = thread::spawn(|| {\u000a    let _detached_thread = thread::spawn(|| {\u000a        // Here we sleep to make sure that the first thread returns before.\u000a        thread::sleep(Duration::from_millis(10));\u000a        // This will be called, even though the JoinHandle is dropped.\u000a        println!(\"â™« Still alive â™«\");\u000a    });\u000a});\u000a\u000aoriginal_thread.join().expect(\"The thread being joined has panicked\");\u000aprintln!(\"Original thread is joined.\");\u000a\u000a// We make sure that the new thread has time to run, before the main\u000a// thread returns.\u000a\u000athread::sleep(Duration::from_millis(1000));\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000astr\u000a```\u000a\u000a---\u000a\u000aString slices.\u000a\u000a*[See also the `std::str` module](`crate::str`).*\u000a\u000aThe `str` type, also called a 'string slice', is the most primitive string\u000atype. It is usually seen in its borrowed form, `&str`. It is also the type\u000aof string literals, `&'static str`.\u000a\u000aString slices are always valid UTF-8.\u000a\u000a# Examples\u000a\u000aString literals are string slices:\u000a\u000a```rust\u000alet hello = \"Hello, world!\";\u000a\u000a// with an explicit type annotation\u000alet hello: &'static str = \"Hello, world!\";\u000a```\u000a\u000aThey are `'static` because they're stored directly in the final binary, and\u000aso will be valid for the `'static` duration.\u000a\u000a# Representation\u000a\u000aA `&str` is made up of two components: a pointer to some bytes, and a\u000alength. You can look at these with the [`as_ptr`] and [`len`] methods:\u000a\u000a```rust\u000ause std::slice;\u000ause std::str;\u000a\u000alet story = \"Once upon a time...\";\u000a\u000alet ptr = story.as_ptr();\u000alet len = story.len();\u000a\u000a// story has nineteen bytes\u000aassert_eq!(19, len);\u000a\u000a// We can re-build a str out of ptr and len. This is all unsafe because\u000a// we are responsible for making sure the two components are valid:\u000alet s = unsafe {\u000a    // First, we build a &[u8]...\u000a    let slice = slice::from_raw_parts(ptr, len);\u000a\u000a    // ... and then convert that slice into a string slice\u000a    str::from_utf8(slice)\u000a};\u000a\u000aassert_eq!(s, Ok(story));\u000a```\u000a\u000aNote: This example shows the internals of `&str`. `unsafe` should not be\u000aused to get a string slice under normal circumstances. Use `as_str`\u000ainstead."
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000asym: char\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000asz: u32\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000at: &HashMap<String, Vec<String>>\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000at: &Tree<T>\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000at: &mut HashMap<String, Vec<String>>\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000at: &str\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000at: T\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000at: Tree<T>\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000atext: String\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000atotal: u64\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000au128\u000a```\u000a\u000a---\u000a\u000aThe 128-bit unsigned integer type."
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000au16\u000a```\u000a\u000a---\u000a\u000aThe 16-bit unsigned integer type."
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000au1: Vec<i32>\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000au32\u000a```\u000a\u000a---\u000a\u000aThe 32-bit unsigned integer type."
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000au64\u000a```\u000a\u000a---\u000a\u000aThe 64-bit unsigned integer type."
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000au8\u000a```\u000a\u000a---\u000a\u000aThe 8-bit unsigned integer type."
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000ausize\u000a```\u000a\u000a---\u000a\u000aThe pointer-sized unsigned integer type.\u000a\u000aThe size of this primitive is how many bytes it takes to reference any\u000alocation in memory. For example, on a 32 bit target, this is 4 bytes\u000aand on a 64 bit target, this is 8 bytes."
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000av1: &[N]\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000av1: Vec<i32>\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000av2: &[N]\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000av: &JSValue\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000av: &String\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000av: &Vec<(JSLabel, JSValue)>\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000av: &Vec<JSValue>\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000av: &[i32]\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000av: T\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000av: bool\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000avec: &[P]\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000avec: &[f64]\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000avec: &mut Vec<f64>\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000avs: &Vec<String>\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": {
        "key": "\u000a```rust\u000avs: &[(JSLabel, JSValue)]\u000a```"
      },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000avs: &[JSValue]\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000avs: &[u8]\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000avs: &mut Vec<String>\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000aw: usize\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000awidth: usize\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000awriter: &mut W\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000ax: &str\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000ax: P\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000ax: Ratio<i64>\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000ax: Vec<i32>\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000ax: char\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000ax: i32\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000ax: i64\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000ax: u64\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000ax: u8\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000axs: &String\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000ay: &i32\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000ay: &str\u000a```" },
      "language": 30
    }
  },
  {
    "key": {
      "text": { "key": "\u000a```rust\u000ay: i32\u000a```" },
      "language": 30
    }
  }
]