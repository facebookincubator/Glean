{-
  Copyright (c) Meta Platforms, Inc. and affiliates.
  All rights reserved.

  This source code is licensed under the BSD-style license found in the
  LICENSE file in the root directory of this source tree.
-}


module Glean.Search.EntityQuery
  ( ModifyQuery(..)
  , EntityQuery
  , queryToEntity
  , queryToRepoName
  ) where

import Data.Default
import Data.Foldable ( asum )

import qualified Glean
import Glean.Schema.Code.Types as Code
import Glean.Schema.CodeCxx.Types as Cxx
import Glean.Schema.CodePp.Types as Pp
import Glean.Schema.CodeHack.Types as Hack
import Glean.Schema.CodeHs.Types as Hs
import Glean.Schema.CodeJava.Types as Java
import Glean.Schema.CodePython.Types as Python
import Glean.Schema.Cxx1.Types as Cxx
import Glean.Schema.Hack.Types as Hack
import Glean.Schema.Python.Types as Python
import Glean.Schema.Query.Code.Types as Query.Code
import Glean.Schema.Query.CodeCxx.Types as Query.Code.Cxx
import Glean.Schema.Query.CodeHack.Types as Query.Code.Hack
import Glean.Schema.Query.CodeHs.Types as Query.Code.Hs
import Glean.Schema.Query.CodePp.Types as Query.Code.Pp
import Glean.Schema.Query.CodePython.Types as Query.Code.Python
import Glean.Schema.Query.CodeJava.Types as Query.Code.Java
import Glean.Schema.Query.Cxx1.Types as Query.Cxx
import Glean.Schema.Query.Hack.Types as Query.Hack
import Glean.Schema.Query.Python.Types as Query.Python
import Glean.Util.SchemaRepos
import Glean.Util.Some (Some)

-- -----------------------------------------------------------------------------
-- Helpful type names

-- | This lets up pass in 'Glean.recursive' (or 'id') to modify a query
-- for a predicate type that is still unknown. Used in 'EntityQuery'
--
-- The 'Data.Default.def' is 'id'
newtype ModifyQuery = ModifyQuery
  { modifyQuery :: forall p. Glean.Query p -> Glean.Query p }

instance Default ModifyQuery where def = ModifyQuery id

-- | This is returned by 'queryToEntity' to allow the caller to specify
-- the repo hash (in 'Glean.Repo') and pass query modifiers (e.g. 'recursive')
type EntityQuery
  = Some Glean.Backend
  -> Glean.Repo
  -> ModifyQuery -- ^ query modifier, e.g. `recursive`
  -> IO [Code.Entity]

-- | Helper type (not exported) that encapsulates a partially applied
-- (but still polymorphic) 'Glean.runQuery_'
type ExecuteLeafQuery
  = forall leaf. (Glean.ThriftQuery leaf)
  => Glean.QueryOf leaf
  -> IO [leaf]

-- -----------------------------------------------------------------------------
-- Helpers for queryToEntity

-- | Get the suggested repo name fot a 'Query.Code.Entity', used for
-- the 'RepoName' from 'queryToEntity'
queryToRepoName :: Query.Code.Entity -> Either String FromSchemaRepos
queryToRepoName q@Query.Code.Entity{..} = maybe err Right $ asum
  [ FromSchemaRepos cxxRepo <$ entity_cxx
  , FromSchemaRepos cxxRepo <$ entity_pp
  , FromSchemaRepos javaRepo <$ entity_java
  , FromSchemaRepos hsRepo <$ entity_hs
  , FromSchemaRepos pythonRepo <$ entity_python
  , FromSchemaRepos hackRepo <$ entity_hack
  ]
  where
    err = Left $
      "ERROR: queryToRepoName cannot handle new alternative in: " <> show q

-- | 'branchId' is an internal helper function
branchId
  :: (Glean.SumBranches inner p, Monad m)
  => (Glean.QueryOf inner -> m [inner])
  -> Maybe (Glean.QueryOf inner)
  -> m [p]
branchId goInner mInner =
  maybe (return []) (fmap (map Glean.injectBranch) . goInner) mInner

-- -----------------------------------------------------------------------------

-- | This expects a 'Query.Code.Entity' that was generated by 'entityToQuery'.
-- In particular this expects the query to have only one branch, and this
-- expects to search only over a single suggested 'RepoName'
-- (which is returned).
--
-- Note that this expects you to have set a 'limit' as it uses
-- 'Glean.runQuery' and not 'Glean.runQuery_'.
--
-- The caller must supply the returned 'EntityQuery' with a specific
-- repo and hash to actually peform the query.
--
-- It is permissible to pass the 'EntityQuery' a 'Glean.Repo' whose 'RepoName'
-- does not match the suggestion. ( This is useful while testing. )
queryToEntity
  :: Query.Code.Entity
  -> (FromSchemaRepos, EntityQuery)
queryToEntity queryIn =
  let fsr = either error id $ queryToRepoName queryIn
      entityQuery backend repo (ModifyQuery modifier) =
        let elq :: ExecuteLeafQuery
            elq = fmap fst . Glean.runQuery backend repo
              . modifier . Glean.query
        in runEntityQuery elq queryIn
  in (fsr, entityQuery)

runEntityQuery
  :: ExecuteLeafQuery
  -> Query.Code.Entity
  -> IO [Code.Entity]
runEntityQuery elq Query.Code.Entity{..} =
  fmap concat . sequence $
  [ branchId (queryIdCxxEntity elq) entity_cxx
  , branchId (queryIdPpEntity elq) entity_pp
  , branchId (queryIdJavaEntity elq) entity_java
  , branchId (queryIdHsEntity elq) entity_hs
  , branchId (queryIdPythonEntity elq) entity_python
  , branchId (queryIdHackEntity elq) entity_hack
  ]

queryIdPpEntity
  :: ExecuteLeafQuery
  -> Query.Code.Pp.Entity
  -> IO [Pp.Entity]
queryIdPpEntity elq Query.Code.Pp.Entity{..} =
  fmap concat . sequence $
  [ branchId elq entity_define
  , branchId elq entity_undef
  , branchId elq entity_include_
  ]

queryIdCxxEntity
  :: ExecuteLeafQuery
  -> Query.Code.Cxx.Entity
  -> IO [Cxx.Entity]
queryIdCxxEntity elq Query.Code.Cxx.Entity{..} =
  fmap concat . sequence $
  [ branchId (queryIdCxxDecl elq) entity_decl
  , branchId (queryIdCxxDefn elq) entity_defn
  , branchId elq entity_enumerator
  ]

queryIdCxxDecl
  :: ExecuteLeafQuery
  -> Query.Cxx.Declaration
  -> IO [Cxx.Declaration]
queryIdCxxDecl elq Query.Cxx.Declaration{..} =
  fmap concat . sequence $
  [ branchId elq declaration_namespace_
  , branchId elq declaration_usingDeclaration
  , branchId elq declaration_usingDirective
  , branchId elq declaration_record_
  , branchId elq declaration_enum_
  , branchId elq declaration_function_
  , branchId elq declaration_variable
  , branchId elq declaration_objcContainer
  , branchId elq declaration_objcMethod
  , branchId elq declaration_objcProperty
  , branchId elq declaration_typeAlias
  ]

queryIdCxxDefn
  :: ExecuteLeafQuery
  -> Query.Code.Cxx.Definition
  -> IO [Cxx.Definition]
queryIdCxxDefn elq Query.Code.Cxx.Definition{..} =
  fmap concat . sequence $
  [ branchId elq definition_record_
  , branchId elq definition_function_
  , branchId elq definition_enum_
  , branchId elq definition_objcMethod
  , branchId elq definition_objcContainer
  , branchId elq definition_variable
  , branchId elq definition_namespace_
  ]

queryIdJavaEntity
  :: ExecuteLeafQuery
  -> Query.Code.Java.Entity
  -> IO [Java.Entity]
queryIdJavaEntity elq Query.Code.Java.Entity{..} =
  fmap concat . sequence $
  [ branchId elq entity_class_
  ]

queryIdHsEntity
  :: ExecuteLeafQuery
  -> Query.Code.Hs.Entity
  -> IO [Hs.Entity]
queryIdHsEntity elq Query.Code.Hs.Entity{..} =
  fmap concat . sequence $
  [ branchId elq entity_function_
  , branchId elq entity_class_
  ]

queryIdPythonEntity
  :: ExecuteLeafQuery
  -> Query.Code.Python.Entity
  -> IO [Python.Entity]
queryIdPythonEntity elq Query.Code.Python.Entity{..} =
  fmap concat . sequence $
  [ branchId (queryIdPythonDeclaration elq) entity_decl
  ]

queryIdPythonDeclaration
  :: ExecuteLeafQuery
  -> Query.Python.Declaration
  -> IO [Python.Declaration]
queryIdPythonDeclaration elq Query.Python.Declaration{..} =
  fmap concat . sequence $
  [ branchId elq declaration_cls
  , branchId elq declaration_func
  , branchId elq declaration_variable
  , branchId elq declaration_imp
  , branchId elq declaration_module
  ]

queryIdHackEntity
  :: ExecuteLeafQuery
  -> Query.Code.Hack.Entity
  -> IO [Hack.Entity]
queryIdHackEntity elq Query.Code.Hack.Entity{..} =
  fmap concat . sequence $
  [ branchId (queryIdHackDecl elq) entity_decl
  ]

queryIdHackDecl
  :: ExecuteLeafQuery
  -> Query.Hack.Declaration
  -> IO [Hack.Declaration]
queryIdHackDecl elq Query.Hack.Declaration{..} =
  fmap concat . sequence $
  [ branchId elq declaration_classConst
  , branchId (queryIdHackContainer elq) declaration_container
  , branchId elq declaration_enumerator
  , branchId elq declaration_function_
  , branchId elq declaration_globalConst
  , branchId elq declaration_namespace_
  , branchId elq declaration_method
  , branchId elq declaration_property_
  , branchId elq declaration_typeConst
  , branchId elq declaration_typedef_
  ]

queryIdHackContainer
  :: ExecuteLeafQuery
  -> Query.Hack.ContainerDeclaration
  -> IO [Hack.ContainerDeclaration]
queryIdHackContainer elq Query.Hack.ContainerDeclaration{..} =
  fmap concat . sequence $
  [ branchId elq containerDeclaration_class_
  , branchId elq containerDeclaration_interface_
  , branchId elq containerDeclaration_trait
  ]
