"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[98],{15680:(e,n,a)=>{a.r(n),a.d(n,{MDXContext:()=>d,MDXProvider:()=>c,mdx:()=>x,useMDXComponents:()=>p,withMDXComponents:()=>m});var t=a(96540);function i(e,n,a){return n in e?Object.defineProperty(e,n,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[n]=a,e}function l(){return l=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var a=arguments[n];for(var t in a)Object.prototype.hasOwnProperty.call(a,t)&&(e[t]=a[t])}return e},l.apply(this,arguments)}function r(e,n){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);n&&(t=t.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),a.push.apply(a,t)}return a}function s(e){for(var n=1;n<arguments.length;n++){var a=null!=arguments[n]?arguments[n]:{};n%2?r(Object(a),!0).forEach((function(n){i(e,n,a[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(a,n))}))}return e}function o(e,n){if(null==e)return{};var a,t,i=function(e,n){if(null==e)return{};var a,t,i={},l=Object.keys(e);for(t=0;t<l.length;t++)a=l[t],n.indexOf(a)>=0||(i[a]=e[a]);return i}(e,n);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(t=0;t<l.length;t++)a=l[t],n.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var d=t.createContext({}),m=function(e){return function(n){var a=p(n.components);return t.createElement(e,l({},n,{components:a}))}},p=function(e){var n=t.useContext(d),a=n;return e&&(a="function"==typeof e?e(n):s(s({},n),e)),a},c=function(e){var n=p(e.components);return t.createElement(d.Provider,{value:n},e.children)},h="mdxType",u={inlineCode:"code",wrapper:function(e){var n=e.children;return t.createElement(t.Fragment,{},n)}},f=t.forwardRef((function(e,n){var a=e.components,i=e.mdxType,l=e.originalType,r=e.parentName,d=o(e,["components","mdxType","originalType","parentName"]),m=p(a),c=i,h=m["".concat(r,".").concat(c)]||m[c]||u[c]||l;return a?t.createElement(h,s(s({ref:n},d),{},{components:a})):t.createElement(h,s({ref:n},d))}));function x(e,n){var a=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var l=a.length,r=new Array(l);r[0]=f;var s={};for(var o in n)hasOwnProperty.call(n,o)&&(s[o]=n[o]);s.originalType=e,s[h]="string"==typeof e?e:i,r[1]=s;for(var d=2;d<l;d++)r[d]=a[d];return t.createElement.apply(null,r)}return t.createElement.apply(null,a)}f.displayName="MDXCreateElement"},89450:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>d,contentTitle:()=>s,default:()=>h,frontMatter:()=>r,metadata:()=>o,toc:()=>m});var t=a(58168),i=(a(96540),a(15680)),l=a(14423);const r={id:"guide",title:"Angle Guide",sidebar_label:"Guide"},s=void 0,o={unversionedId:"angle/guide",id:"angle/guide",title:"Angle Guide",description:"The following guide will explain Angle from first principles, leading you through from simple queries to more complex ones.",source:"@site/docs/angle/guide.md",sourceDirName:"angle",slug:"/angle/guide",permalink:"/docs/angle/guide",draft:!1,editUrl:"https://github.com/facebookincubator/Glean/tree/main/glean/website/docs/angle/guide.md",tags:[],version:"current",frontMatter:{id:"guide",title:"Angle Guide",sidebar_label:"Guide"},sidebar:"someSidebar",previous:{title:"Introduction",permalink:"/docs/angle/intro"},next:{title:"Query Efficiency",permalink:"/docs/angle/efficiency"}},d={},m=[{value:"Just the facts",id:"just-the-facts",level:2},{value:"Matching nested facts",id:"matching-nested-facts",level:2},{value:"Union types",id:"union-types",level:2},{value:"Maybe",id:"maybe",level:2},{value:"Choice",id:"choice",level:2},{value:"Variables and more complex queries",id:"variables-and-more-complex-queries",level:2},{value:"Statements",id:"statements",level:2},{value:"Dot syntax",id:"dot-syntax",level:2},{value:"Dot syntax for union types",id:"dot-syntax-for-union-types",level:3},{value:"Extracting the key of a fact",id:"extracting-the-key-of-a-fact",level:3},{value:"If-then-else",id:"if-then-else",level:2},{value:"Arrays",id:"arrays",level:2},{value:"Sets",id:"sets",level:2},{value:"String prefix",id:"string-prefix",level:2},{value:"Tuples",id:"tuples",level:2},{value:"Enums and bool",id:"enums-and-bool",level:2},{value:"Negation",id:"negation",level:2}],p={toc:m},c="wrapper";function h(e){let{components:n,...a}=e;return(0,i.mdx)(c,(0,t.A)({},p,a,{components:n,mdxType:"MDXLayout"}),(0,i.mdx)("p",null,"The following guide will explain Angle from first principles, leading you through from simple queries to more complex ones."),(0,i.mdx)("p",null,"If you want to try the examples for yourself, or experiment with\nchanges to the example schema, you should first follow the\ninstructions in ",(0,i.mdx)("a",{parentName:"p",href:"/docs/walkthrough"},"Walkthrough")," to get set up."),(0,i.mdx)(l.FbInternalOnly,{mdxType:"FbInternalOnly"},(0,i.mdx)("p",null,"There are also ",(0,i.mdx)("a",{parentName:"p",href:"https://www.internalfb.com/intern/wiki/Glean/Query/Angle/Angle_examples/"},"examples of using Angle")," to query real data.")),(0,i.mdx)("h2",{id:"just-the-facts"},"Just the facts"),(0,i.mdx)("p",null,"Data in Glean is described by a ",(0,i.mdx)("em",{parentName:"p"},"schema"),", which we normally put in a file with the extension ",(0,i.mdx)("inlineCode",{parentName:"p"},"angle"),". For the purposes of this guide we\u2019ll use the example schema in ",(0,i.mdx)("inlineCode",{parentName:"p"},"example.angle"),". Full details about defining schemas can be found in ",(0,i.mdx)("a",{parentName:"p",href:"/docs/schema/basic"},"Schemas"),". The ",(0,i.mdx)("inlineCode",{parentName:"p"},"example.angle")," file contains a schema definition like this:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-lang=angle"},"schema example.1 {\n\n# definitions go here\n\n}\n")),(0,i.mdx)("p",null,"This says we\u2019re defining a schema called ",(0,i.mdx)("inlineCode",{parentName:"p"},"example"),", with version 1."),(0,i.mdx)("p",null,"The schema contains definitions for ",(0,i.mdx)("em",{parentName:"p"},"predicates"),". A predicate is the type of ",(0,i.mdx)("em",{parentName:"p"},"facts"),", which are the individual pieces of information that Glean stores.  Our example schema models a simplified class hierarchy for an object-oriented language, starting with a predicate for a ",(0,i.mdx)("inlineCode",{parentName:"p"},"Class"),":"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-lang=angle"},"predicate Class :\n  {\n     name : string,\n     line : nat,\n  }\n")),(0,i.mdx)("p",null,"This says that the facts of ",(0,i.mdx)("inlineCode",{parentName:"p"},"Class")," are records with two fields, a ",(0,i.mdx)("inlineCode",{parentName:"p"},"name")," field which contains a ",(0,i.mdx)("inlineCode",{parentName:"p"},"string"),", and a ",(0,i.mdx)("inlineCode",{parentName:"p"},"line")," field which contains a ",(0,i.mdx)("inlineCode",{parentName:"p"},"nat")," (\u201cnat\u201d is short for \u201cnatural number\u201d, which is limited to 64 bits in Glean)."),(0,i.mdx)("p",null,"The simplest type of Angle query is one that just selects facts from\nthe database that match a pattern.  For our first Angle query, let\u2019s\nfind a class by its name:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre"},'facts> example.Class { name = "Pet" }\n{ "id": 1024, "key": { "name": "Pet", "line": 10 } }\n\n1 results, 1 facts, 4.61ms, 117632 bytes, 677 compiled bytes\n')),(0,i.mdx)("p",null,"(The last line contains statistics about query performance from Glean; I\u2019ll leave this out in the rest of the examples.)"),(0,i.mdx)("p",null,"What\u2019s going on here?"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},"The query consists of the ",(0,i.mdx)("em",{parentName:"li"},"predicate name")," ",(0,i.mdx)("inlineCode",{parentName:"li"},"example.Class")," followed by a ",(0,i.mdx)("em",{parentName:"li"},"pattern")," ",(0,i.mdx)("inlineCode",{parentName:"li"},'{ name = "Pet" }')),(0,i.mdx)("li",{parentName:"ul"},"Note that when we refer to a predicate in a query, the name is ",(0,i.mdx)("em",{parentName:"li"},"qualified")," by prefixing the schema name, so it\u2019s ",(0,i.mdx)("inlineCode",{parentName:"li"},"example.Class")," rather than just ",(0,i.mdx)("inlineCode",{parentName:"li"},"Class"),"."),(0,i.mdx)("li",{parentName:"ul"},"The query returns all the facts of ",(0,i.mdx)("inlineCode",{parentName:"li"},"example.Class")," that match the pattern")),(0,i.mdx)("p",null,"The shell shows results in JSON format. When you\u2019re making Glean\nqueries from code, the results will normally be decoded into native\ndata types that you can manipulate directly in whatever language\nyou\u2019re using; for more details see ",(0,i.mdx)("a",{parentName:"p",href:"/docs/schema/thrift"},"Thrift and\nJSON"),"."),(0,i.mdx)("p",null,"Note that each fact has a unique ",(0,i.mdx)("inlineCode",{parentName:"p"},"id"),". This is how Glean identifies facts in its database. As a user you normally won\u2019t have to worry about fact ",(0,i.mdx)("inlineCode",{parentName:"p"},"id"),"s; you can think of them like memory addresses."),(0,i.mdx)("p",null,"The pattern specifies which facts to return. In the example above, our pattern is matching a record type and specifying a subset of the fields: just the ",(0,i.mdx)("inlineCode",{parentName:"p"},"name")," field. We could match the ",(0,i.mdx)("inlineCode",{parentName:"p"},"line")," field instead:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-lang=sh"},'facts> example.Class { line = 20 }\n{ "id": 1025, "key": { "name": "Lizard", "line": 20 } }\n')),(0,i.mdx)("admonition",{type:"note"},(0,i.mdx)("p",{parentName:"admonition"},"Your patterns should normally match fields at the ",(0,i.mdx)("em",{parentName:"p"},"beginning")," of the\nrecord, because facts in the database are indexed by a prefix of the\nfields. Matching a field in the middle of the record works by scanning\nall the facts, which could be expensive. We\u2019ll get into this in more\ndetail in ",(0,i.mdx)("a",{parentName:"p",href:"/docs/angle/efficiency"},"Query Efficiency"),".")),(0,i.mdx)("p",null,'What other kinds of patterns can we use? Well, the simplest patterns are the wildcard, \u201c_\u201d, which matches anything, and "never", which always fails to match.'),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-lang=angle"},'facts> example.Class _\n{ "id": 1026, "key": { "name": "Fish", "line": 30 } }\n{ "id": 1027, "key": { "name": "Goldfish", "line": 40 } }\n{ "id": 1025, "key": { "name": "Lizard", "line": 20 } }\n{ "id": 1024, "key": { "name": "Pet", "line": 10 } }\nfacts> example.Class never\n(no results)\n')),(0,i.mdx)("p",null,"We\u2019ll introduce more kinds of pattern in the following sections. The full list of patterns can be found in ",(0,i.mdx)("a",{parentName:"p",href:"/docs/angle/reference"},"Angle Reference"),"."),(0,i.mdx)("h2",{id:"matching-nested-facts"},"Matching nested facts"),(0,i.mdx)("p",null,"The real power of Glean comes from relationships between facts. Facts can refer directly to other facts, and we can write queries that directly match on these connections."),(0,i.mdx)("p",null,"Our example schema has a predicate that expresses the inheritance relationship between classes:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-lang=angle"},"predicate Parent :\n  {\n     child : Class,\n     parent : Class,\n  }\n")),(0,i.mdx)("p",null,"Let\u2019s find what ",(0,i.mdx)("inlineCode",{parentName:"p"},"Fish")," inherits from:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-lang=angle"},'facts> example.Parent { child = { name = "Fish" }}\n{\n  "id": 1029,\n  "key": { "child": { "id": 1026, "key": { "name": "Fish", "line": 30 } }, "parent": { "id": 1024, "key": { "name": "Pet", "line": 10 } } }\n}\n')),(0,i.mdx)("p",null,"Let\u2019s break this down."),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},'{ child = { name = "Fish" }}')," is a pattern that matches the key type of ",(0,i.mdx)("inlineCode",{parentName:"li"},"Parent")),(0,i.mdx)("li",{parentName:"ul"},"So, looking at the schema, ",(0,i.mdx)("inlineCode",{parentName:"li"},'{ name = "Fish" }')," is a pattern that should match the ",(0,i.mdx)("inlineCode",{parentName:"li"},"Class")," in the field ",(0,i.mdx)("inlineCode",{parentName:"li"},"child"),".")),(0,i.mdx)("p",null,"By default Angle queries recursively expand facts in the results.  We can see in the above result that the ",(0,i.mdx)("inlineCode",{parentName:"p"},"child")," and ",(0,i.mdx)("inlineCode",{parentName:"p"},"parent")," fields contain the full facts they point to.  If we want the result to be \u201cshallow\u201d, meaning it contains just the facts that match and not the nested facts, we can ask Glean to not expand the content of those references. In the shell this is done by running the command ",(0,i.mdx)("inlineCode",{parentName:"p"},":expand off"),":"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-lang=angle"},'facts> :expand off\nfacts> example.Parent { child = { name = "Fish" }}\n{ "id": 1029, "key": { "child": { "id": 1026 }, "parent": { "id": 1024 } } }\n')),(0,i.mdx)("p",null,"We can of course go the other way and find all the children of a class:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-lang=angle"},'facts> example.Parent { parent = { name = "Pet" }}\n{\n  "id": 1028,\n  "key": {\n    "child": { "id": 1025, "key": { "name": "Lizard", "line": 20 } },\n    "parent": { "id": 1024, "key": { "name": "Pet", "line": 10 } }\n  }\n}\n{\n  "id": 1029,\n  "key": {\n    "child": { "id": 1026, "key": { "name": "Fish", "line": 30 } },\n    "parent": { "id": 1024, "key": { "name": "Pet", "line": 10 } }\n  }\n}\n')),(0,i.mdx)("p",null,"But as before, note that this would be an inefficient query if we had a lot of data because the pattern is matching on the second field of ",(0,i.mdx)("inlineCode",{parentName:"p"},"Parent")," (namely ",(0,i.mdx)("inlineCode",{parentName:"p"},"parent"),"). Later we\u2019ll see how to make these queries more efficient using a derived predicate."),(0,i.mdx)("h2",{id:"union-types"},"Union types"),(0,i.mdx)("p",null,"Our examples so far have dealt with record types. Glean also supports ",(0,i.mdx)("em",{parentName:"p"},"union types"),", also called ",(0,i.mdx)("em",{parentName:"p"},"sum types"),", which are used to express multiple alternatives. For example, let\u2019s expand our schema to include class members which can be either a method or a variable:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-lang=angle"},"predicate Has :\n  {\n    class_ : Class,\n    has : Member,\n    access : enum { public_ | private_ },\n  }\n\npredicate Member :\n  {\n    method : { name : string, doc : maybe string } |\n    variable : { name : string }\n  }\n")),(0,i.mdx)("p",null,"The predicate ",(0,i.mdx)("inlineCode",{parentName:"p"},"Has")," maps a ",(0,i.mdx)("inlineCode",{parentName:"p"},"Class")," to a ",(0,i.mdx)("inlineCode",{parentName:"p"},"Member")," (with a ",(0,i.mdx)("inlineCode",{parentName:"p"},"public_")," or ",(0,i.mdx)("inlineCode",{parentName:"p"},"private_")," annotation), and a ",(0,i.mdx)("inlineCode",{parentName:"p"},"Member")," is either ",(0,i.mdx)("inlineCode",{parentName:"p"},"method")," or ",(0,i.mdx)("inlineCode",{parentName:"p"},"variable"),", with some associated data. Note that a ",(0,i.mdx)("inlineCode",{parentName:"p"},"Class")," might have more than one ",(0,i.mdx)("inlineCode",{parentName:"p"},"Member"),", which is fine: there can be multiple ",(0,i.mdx)("inlineCode",{parentName:"p"},"Has")," facts for a given ",(0,i.mdx)("inlineCode",{parentName:"p"},"Class"),"."),(0,i.mdx)("admonition",{type:"note"},(0,i.mdx)("p",{parentName:"admonition"},"The schema uses ",(0,i.mdx)("inlineCode",{parentName:"p"},"class_")," rather than ",(0,i.mdx)("inlineCode",{parentName:"p"},"class")," as a field name, because\n",(0,i.mdx)("inlineCode",{parentName:"p"},"class")," is a reserved word in Angle. Similarly, we added trailing\nunderscores to ",(0,i.mdx)("inlineCode",{parentName:"p"},"public_")," and",(0,i.mdx)("inlineCode",{parentName:"p"},"private_")," for the same reason."),(0,i.mdx)("p",{parentName:"admonition"},"There are many such reserved words, which are reserved not because Angle uses them, but because they cause problems for code that is automatically generated from the schema. To avoid having too many ad-hoc language-specific naming rules, Glean prevents certain problematic names from being used in the schema. The Angle compiler will tell you if you try to use a reserved word.")),(0,i.mdx)("p",null,"Let\u2019s find classes that have a variable called ",(0,i.mdx)("inlineCode",{parentName:"p"},"fins"),":"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-lang=angle"},'facts> example.Has { has = { variable = { name = "fins" }}}\n{\n  "id": 1036,\n  "key": {\n    "class_": { "id": 1026, "key": { "name": "Fish", "line": 30 } },\n    "has": { "id": 1035, "key": { "variable": { "name": "fins" } } },\n    "access": 1\n  }\n}\n')),(0,i.mdx)("p",null,"The key thing here is that we matched on ",(0,i.mdx)("inlineCode",{parentName:"p"},"Member")," which is a union type, using the pattern ",(0,i.mdx)("inlineCode",{parentName:"p"},'{ variable = { name = "fins" }}'),". A pattern to match a union type looks very much like a record pattern, but it can have only a single field, in this case either ",(0,i.mdx)("inlineCode",{parentName:"p"},"variable")," or ",(0,i.mdx)("inlineCode",{parentName:"p"},"method"),"."),(0,i.mdx)("h2",{id:"maybe"},"Maybe"),(0,i.mdx)("p",null,"Glean has one built-in union type called ",(0,i.mdx)("inlineCode",{parentName:"p"},"maybe"),", which is useful when we want to have optional values in the data. It's used in our example schema to attach optional documentation to a class member:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-lang=angle"},"predicate Member :\n  {\n    method : { name : string, doc : maybe string } |\n    variable : { name : string }\n  }\n")),(0,i.mdx)("p",null,"The type ",(0,i.mdx)("inlineCode",{parentName:"p"},"maybe string")," behaves exactly as if it were defined as the union type ",(0,i.mdx)("inlineCode",{parentName:"p"},"{ nothing | just : string }"),".  That means we can write a pattern that matches it, exactly as we would write a pattern for ",(0,i.mdx)("inlineCode",{parentName:"p"},"{ nothing | just : string }"),":"),(0,i.mdx)("p",null,"Methods without documentation:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre"},"facts> example.Member { method = { doc = nothing } }\n")),(0,i.mdx)("p",null,"Methods with documentation:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre"},"facts> example.Member { method = { doc = {  just = _ }}}\n")),(0,i.mdx)("h2",{id:"choice"},"Choice"),(0,i.mdx)("p",null,"In a pattern we can express multiple alternatives by separating patterns with a vertical bar ",(0,i.mdx)("inlineCode",{parentName:"p"},"|"),"."),(0,i.mdx)("p",null,"For example, we can find classes on lines 20 or 30:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-lang=angle"},'facts> example.Class { line = 20 | 30 }\n{ "id": 1025, "key": { "name": "Lizard", "line": 20 } }\n{ "id": 1026, "key": { "name": "Fish", "line": 30 } }\n')),(0,i.mdx)("p",null,"Or we can find all the classes that have either a ",(0,i.mdx)("inlineCode",{parentName:"p"},"method")," called ",(0,i.mdx)("inlineCode",{parentName:"p"},"feed")," or a ",(0,i.mdx)("inlineCode",{parentName:"p"},"variable")," with any name:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-lang=angle"},'facts> example.Has { has = { method = { name = "feed" }} | { variable = _ }}\n\n(results omitted)\n')),(0,i.mdx)("h2",{id:"variables-and-more-complex-queries"},"Variables and more complex queries"),(0,i.mdx)("p",null,"So far we\u2019ve seen how to query for facts by matching patterns, including matching nested facts.  In this section we\u2019ll see how to construct more complex queries that combine matching facts from multiple predicates."),(0,i.mdx)("p",null,"Suppose we want to find all the parents of classes that have a variable called ",(0,i.mdx)("inlineCode",{parentName:"p"},"fins"),". We need to build a query that will"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},"find the classes with a variable called ",(0,i.mdx)("inlineCode",{parentName:"li"},"fins")," using ",(0,i.mdx)("inlineCode",{parentName:"li"},"example.Has")," as we did above"),(0,i.mdx)("li",{parentName:"ul"},"find their parents using ",(0,i.mdx)("inlineCode",{parentName:"li"},"example.Parent"))),(0,i.mdx)("p",null,"We can combine these two as follows:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-lang=angle"},'example.Has\n  {\n    class_ = C,\n    has = { variable = { name = "fins" }}\n  };\nexample.Parent { child = C }\n')),(0,i.mdx)("admonition",{type:"note"},(0,i.mdx)("p",{parentName:"admonition"},"I\u2019ve written this on several lines with indentation to illustrate it\nbetter, to do this in the shell you will need to use the ",(0,i.mdx)("inlineCode",{parentName:"p"},":edit"),"\ncommand to put the query in a temporary file.")),(0,i.mdx)("p",null,"The key thing here is that we used a ",(0,i.mdx)("em",{parentName:"p"},"variable")," ",(0,i.mdx)("inlineCode",{parentName:"p"},"C")," to stand for the ",(0,i.mdx)("inlineCode",{parentName:"p"},"class_")," field when matching facts of ",(0,i.mdx)("inlineCode",{parentName:"p"},"example.Has"),", and then we searched for ",(0,i.mdx)("inlineCode",{parentName:"p"},"example.Parent")," facts with the same value of ",(0,i.mdx)("inlineCode",{parentName:"p"},"C")," for the ",(0,i.mdx)("inlineCode",{parentName:"p"},"child")," field."),(0,i.mdx)("p",null,"Note that variables must ",(0,i.mdx)("em",{parentName:"p"},"always")," begin with an upper-case letter, while schema names (",(0,i.mdx)("inlineCode",{parentName:"p"},"example)")," and field names (",(0,i.mdx)("inlineCode",{parentName:"p"},"child"),") begin with a lower-case letter."),(0,i.mdx)("p",null,"The semicolon separates multiple ",(0,i.mdx)("em",{parentName:"p"},"statements")," in a query. When there are multiple statements the results of the query are the facts that match the last statement, in this case the ",(0,i.mdx)("inlineCode",{parentName:"p"},"example.Parent"),".  Let\u2019s try it:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-lang=angle"},'facts> example.Has { class_ = C, has = { variable = { name = "fins" }}}; example.Parent { child = C }\n{\n  "id": 1029,\n  "key": {\n    "child": { "id": 1026, "key": { "name": "Fish", "line": 30 } },\n    "parent": { "id": 1024, "key": { "name": "Pet", "line": 10 } }\n  }\n}\n')),(0,i.mdx)("p",null," Suppose we don\u2019t care too much about the child here, we only care about getting a list of the parents. We can avoid returning the redundant information by specifying explicitly what it is we want to return from the query:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-lang=angle"},'P where\n    example.Has\n      {\n        class_ = C,\n        has = { variable = { name = "fins" }}\n      };\n    example.Parent { child = C, parent = P }\n')),(0,i.mdx)("p",null,"The general form of the query is ",(0,i.mdx)("em",{parentName:"p"},(0,i.mdx)("inlineCode",{parentName:"em"},"expression"))," ",(0,i.mdx)("inlineCode",{parentName:"p"},"where")," ",(0,i.mdx)("em",{parentName:"p"},(0,i.mdx)("inlineCode",{parentName:"em"},"statements")),", where ",(0,i.mdx)("em",{parentName:"p"},(0,i.mdx)("inlineCode",{parentName:"em"},"expression"))," is an arbitrary expression and each statement is a pattern that matches some facts. The results of the query are the distinct values of ",(0,i.mdx)("em",{parentName:"p"},(0,i.mdx)("inlineCode",{parentName:"em"},"expression"))," for which all the statements match facts in the database."),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-lang=angle"},'facts> P where example.Has { class_ = C, has = { variable = { name = "fins" }}}; example.Parent { child = C, parent = P }\n{ "id": 1024, "key": { "name": "Pet", "line": 10 } }\n')),(0,i.mdx)("h2",{id:"statements"},"Statements"),(0,i.mdx)("p",null,"In general, a statement can be of the form ",(0,i.mdx)("em",{parentName:"p"},"A = B.")," For example, if we write"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-lang=angle"},'C = example.Class { name = "Fish" };\nexample.Parent { child = C }\n')),(0,i.mdx)("p",null,"that\u2019s the same as"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-lang=angle"},'example.Parent { child = { name = "Fish" }}\n')),(0,i.mdx)("p",null,"A statement can have a pattern on either side, for example"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-lang=angle"},'C where\n  C = example.Class { name = N };\n  N = "Fish" | "Goldfish"\n')),(0,i.mdx)("p",null,"A statement can itself be a set of alternatives separated by a vertical bar ",(0,i.mdx)("inlineCode",{parentName:"p"},"|"),". For example, we can find classes that are either a parent of the ",(0,i.mdx)("inlineCode",{parentName:"p"},"Goldfish")," or have a ",(0,i.mdx)("inlineCode",{parentName:"p"},"feed")," method:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-lang=angle"},'C where\n  example.Parent { child = { name = "Goldfish" }, parent = C } |\n  example.Has { class_ = C, has = { method = { name = "feed" }}}\n')),(0,i.mdx)("h2",{id:"dot-syntax"},"Dot syntax"),(0,i.mdx)("p",null,'So far we\'ve been extracting fields from records by writing patterns,\nbut we can also extract fields from records using the traditional "dot\nsyntax". For example, instead of'),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre"},'example.Parent { child = { name = "Fish" }}\n')),(0,i.mdx)("p",null,"we could write"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre"},'example.Parent P where P.child.name = "Fish"\n')),(0,i.mdx)("p",null,"Here"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"example.Parent P")," selects facts of ",(0,i.mdx)("inlineCode",{parentName:"li"},"example.Parent")," and binds the key to the variable ",(0,i.mdx)("inlineCode",{parentName:"li"},"P")),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},'P.child.name = "Fish"')," is a constraint on the ",(0,i.mdx)("inlineCode",{parentName:"li"},"name")," field of the ",(0,i.mdx)("inlineCode",{parentName:"li"},"child")," field of ",(0,i.mdx)("inlineCode",{parentName:"li"},"P")),(0,i.mdx)("li",{parentName:"ul"},"the query returns all facts of ",(0,i.mdx)("inlineCode",{parentName:"li"},"example.Parent")," that satisfy the constraint")),(0,i.mdx)("p",null,"Dot syntax tends to be more concise than patterns when there are\ndeeply-nested records, because it avoids all the nested braces."),(0,i.mdx)("h3",{id:"dot-syntax-for-union-types"},"Dot syntax for union types"),(0,i.mdx)("p",null,"Matching union types can also be achieved using dot syntax. For\nexample, earlier we had"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre"},'example.Has { has = { variable = { name = "fins" }}}\n')),(0,i.mdx)("p",null,"using dot syntax this would be"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre"},'example.Has H where H.has.variable?.name = "fins"\n')),(0,i.mdx)("p",null,"Note that when selecting a union type we add a '?' suffix,\nas with ",(0,i.mdx)("inlineCode",{parentName:"p"},".variable?")," in the example above. This makes it more obvious\nthat we're doing something conditional: if ",(0,i.mdx)("inlineCode",{parentName:"p"},"X.has")," is not a\n",(0,i.mdx)("inlineCode",{parentName:"p"},"variable"),", then ",(0,i.mdx)("inlineCode",{parentName:"p"},"X.has.variable?")," has no values."),(0,i.mdx)("p",null,"Selecting from union types works nicely with choice (",(0,i.mdx)("inlineCode",{parentName:"p"},"|"),"):"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre"},"Name where\n  example.Has H;\n  Name = (H.has.variable?.name | H.has.method?.name)\n")),(0,i.mdx)("p",null,"returns all the names of variables and methods."),(0,i.mdx)("h3",{id:"extracting-the-key-of-a-fact"},"Extracting the key of a fact"),(0,i.mdx)("p",null,"It's sometimes useful to be able to extract the key of a fact. If we\nhave a variable ",(0,i.mdx)("inlineCode",{parentName:"p"},"X")," of some predicate type, then we can extract the\nkey of ",(0,i.mdx)("inlineCode",{parentName:"p"},"X")," with ",(0,i.mdx)("inlineCode",{parentName:"p"},"X.*"),". If ",(0,i.mdx)("inlineCode",{parentName:"p"},"X")," has type ",(0,i.mdx)("inlineCode",{parentName:"p"},"P")," and ",(0,i.mdx)("inlineCode",{parentName:"p"},"P")," is a predicate with\nkey type ",(0,i.mdx)("inlineCode",{parentName:"p"},"K"),", then ",(0,i.mdx)("inlineCode",{parentName:"p"},"X.*")," has type ",(0,i.mdx)("inlineCode",{parentName:"p"},"K"),"."),(0,i.mdx)("p",null,"Usually we don't need to extract the key explicitly because Angle does\nit automatically. For example if ",(0,i.mdx)("inlineCode",{parentName:"p"},"X : example.Class"),", then ",(0,i.mdx)("inlineCode",{parentName:"p"},"X.name")," is\nshorthand for ",(0,i.mdx)("inlineCode",{parentName:"p"},"X.*.name"),". But sometimes we just want the key without\nselecting a field, or perhaps the key isn't a record. In those cases,\n",(0,i.mdx)("inlineCode",{parentName:"p"},"X.*")," can be useful."),(0,i.mdx)("h2",{id:"if-then-else"},"If-then-else"),(0,i.mdx)("p",null,"We can conditionally match patterns using ",(0,i.mdx)("inlineCode",{parentName:"p"},"if then else"),"."),(0,i.mdx)("p",null,"Variables matched in the condition will be available in the ",(0,i.mdx)("inlineCode",{parentName:"p"},"then")," branch."),(0,i.mdx)("p",null,"Whilst a choice will always evaluate both of its branches, the ",(0,i.mdx)("inlineCode",{parentName:"p"},"else")," branch of an if will\nnever be evaluated if the condition succeeds at least once."),(0,i.mdx)("p",null,"For example, we could get all child classes if inheritance is being used in the codebase, or\nretrieve all classes if it isn't."),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre"},'facts > if (example.Parent { child = X }) then X else example.Class _\n  { "id": 1025, "key": { "name": "Lizard", "line": 20 } }\n  { "id": 1026, "key": { "name": "Fish", "line": 30 } }\n  { "id": 1027, "key": { "name": "Goldfish", "line": 40 } }\n')),(0,i.mdx)("p",null,"Please note that ",(0,i.mdx)("inlineCode",{parentName:"p"},"if")," cannot be used in stored derived predicates. This\nis the case because they require the use of negation, which is disallowed in\nstored predicates."),(0,i.mdx)("h2",{id:"arrays"},"Arrays"),(0,i.mdx)("p",null,"When the schema uses an array, we need to be able to write queries that traverse the elements of the array. For example, a common use of an array is to represent the list of declarations in a source file. Our example schema defines the ",(0,i.mdx)("inlineCode",{parentName:"p"},"FileClasses")," predicate:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-lang=angle"},"predicate FileClasses :\n  {\n    file : string,\n    classes : [Class]\n  }\n")),(0,i.mdx)("p",null,"The goal here is to map efficiently from a filename to the list of classes defined in that file. Suppose we want to write a query that finds all the classes called ",(0,i.mdx)("inlineCode",{parentName:"p"},"Goldfish")," in the file ",(0,i.mdx)("inlineCode",{parentName:"p"},"petshop.example"),", we could do it like this:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-lang=angle"},'example.FileClasses { file = "petshop.example", classes = Cs };\n{ name = "Goldfish" } = Cs[..]\n')),(0,i.mdx)("p",null,"The second line is the interesting one: ",(0,i.mdx)("inlineCode",{parentName:"p"},'{ name = "Goldfish" } = Cs[..]')," means"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},"on the right-hand side, ",(0,i.mdx)("inlineCode",{parentName:"li"},"Cs[..]")," means \u201ceach element of the array ",(0,i.mdx)("inlineCode",{parentName:"li"},"Cs"),"\u201d"),(0,i.mdx)("li",{parentName:"ul"},"the left-hand side is a pattern, filtering only those ",(0,i.mdx)("inlineCode",{parentName:"li"},"Class")," facts that match ",(0,i.mdx)("inlineCode",{parentName:"li"},'{ name = "Goldfish" }'))),(0,i.mdx)("p",null,"We can also match the whole array with a pattern of the form ",(0,i.mdx)("inlineCode",{parentName:"p"},"[ p1, p2, .. ]")),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-lang=angle"},'facts> X where [_,X,_] = [1,2,3]\n{ "id": 1040, "key": 2 }\n')),(0,i.mdx)("p",null,"Or if we don't care about the length of the array:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-lang=angle"},'facts> X where [_,X, ..] = [1,2,3]\n{ "id": 1040, "key": 2 }\n')),(0,i.mdx)("h2",{id:"sets"},"Sets"),(0,i.mdx)("p",null,"Sets are similar to arrays but helpful when the order of the elements are not important and duplicates are also irrelevant.\nA common example is when storing cross references. For instance, the python schema has a predicate which contains all\nname cross references in a file. The cross references are currently stored in an array but it could be stored in a set as below."),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-lang=angle"},"predicate XRefsViaNameByFile:\n    {\n        file: src.File,\n        xrefs: set XRefViaName,\n    }\n")),(0,i.mdx)("p",null,"If we want to know for a particular file and a particular name, where it is used we could write the following query:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-lang=angle"},'XRefsViaNameByFile { file = "foo.py", xrefs = XRefs };\n{ target = { name = "Bar" } } = elements XRefs\n')),(0,i.mdx)("p",null,"The second line uses the construct ",(0,i.mdx)("inlineCode",{parentName:"p"},"elements")," which is similar to the ",(0,i.mdx)("inlineCode",{parentName:"p"},"[..]")," syntax for arrays."),(0,i.mdx)("p",null,"We can also create new sets from the results of a query. This is done using the ",(0,i.mdx)("inlineCode",{parentName:"p"},"all")," construct. For instance\n",(0,i.mdx)("inlineCode",{parentName:"p"},"all (1 | 2 | 3)")," is a set containing the number ",(0,i.mdx)("inlineCode",{parentName:"p"},"1"),", ",(0,i.mdx)("inlineCode",{parentName:"p"},"2"),", and ",(0,i.mdx)("inlineCode",{parentName:"p"},"3"),"."),(0,i.mdx)("p",null,"The ",(0,i.mdx)("inlineCode",{parentName:"p"},"all")," construct can be used in combination with the ",(0,i.mdx)("inlineCode",{parentName:"p"},"elements")," construct to, for instance, map over a set\nof elements and transform them. In the example below, the second line takes each element of the ",(0,i.mdx)("inlineCode",{parentName:"p"},"StringSet")," and\napplies the primitive ",(0,i.mdx)("inlineCode",{parentName:"p"},"prim.toLower")," to it. The result is a set where all the strings are lowercase."),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-lang=angle"},'StringSet = all ("Foo" | "Bar" | "Baz" );\nall (String = elements StringSet; prim.toLower String)\n')),(0,i.mdx)("h2",{id:"string-prefix"},"String prefix"),(0,i.mdx)("p",null,"We\u2019ve seen many examples of patterns that match strings. Glean also supports matching strings by ",(0,i.mdx)("em",{parentName:"p"},"prefix"),"; for example:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-lang=angle"},'facts> example.Class { name = "F".. }\n{ "id": 1026, "key": { "name": "Fish", "line": 30 } }\n')),(0,i.mdx)("p",null,"The syntax ",(0,i.mdx)("inlineCode",{parentName:"p"},'"F"..')," means ",(0,i.mdx)("em",{parentName:"p"},"strings beginning with the prefix")," ",(0,i.mdx)("inlineCode",{parentName:"p"},'\u201dF"'),"."),(0,i.mdx)("admonition",{type:"note"},(0,i.mdx)("p",{parentName:"admonition"},"Why only prefix and not substring matching in general? Prefix matching can be supported efficiently by Glean\u2019s prefix-tree representation of the fact database. Other kinds of string matching could be supported, but they wouldn\u2019t be able to exploit the database representation so there\u2019s little advantage to implementing them in Angle compared with filtering on the client-side.")),(0,i.mdx)("h2",{id:"tuples"},"Tuples"),(0,i.mdx)("p",null,"A ",(0,i.mdx)("em",{parentName:"p"},"tuple")," is just a a way of writing a record without the field names.  So for example, instead of"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre"},"example.Parent { child = C }\n")),(0,i.mdx)("p",null,"we could write"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre"},"example.Parent { C, _ }\n")),(0,i.mdx)("p",null,"When using a tuple you have to list ",(0,i.mdx)("em",{parentName:"p"},"all")," the fields, in the same order as they are declared in the schema.  That's why ",(0,i.mdx)("inlineCode",{parentName:"p"},"{ child = C }")," becomes ",(0,i.mdx)("inlineCode",{parentName:"p"},"{ C, _ }")," when written as a tuple."),(0,i.mdx)("p",null,"There are upsides and downsides to using the tuple notation:"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},"Pro: more concise"),(0,i.mdx)("li",{parentName:"ul"},"Con: brittle and sensitive to changes in the schema. If we add a field, then tuple patterns will break whereas record patterns won't.")),(0,i.mdx)("p",null,'As a rule of thumb we tend to use tuple syntax in cases where the predicate is "obviously" a relation, such as ',(0,i.mdx)("inlineCode",{parentName:"p"},"example.Parent"),", but we wouldn't use tuple syntax for more complex records."),(0,i.mdx)("h2",{id:"enums-and-bool"},"Enums and bool"),(0,i.mdx)("p",null,"An ",(0,i.mdx)("inlineCode",{parentName:"p"},"enum")," type is a set of named constants. In the ",(0,i.mdx)("inlineCode",{parentName:"p"},"Has")," predicate we used an ",(0,i.mdx)("inlineCode",{parentName:"p"},"enum")," type to indicate whether a class member is ",(0,i.mdx)("inlineCode",{parentName:"p"},"public_")," or ",(0,i.mdx)("inlineCode",{parentName:"p"},"private_"),":"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-lang=angle"},"predicate Has :\n  {\n    class_ : Class,\n    has : Member,\n    access : enum { public_ | private_ },\n  }\n")),(0,i.mdx)("p",null,"To match an ",(0,i.mdx)("inlineCode",{parentName:"p"},"enum")," we just use the appropriate identifier, in this case ",(0,i.mdx)("inlineCode",{parentName:"p"},"public_")," or ",(0,i.mdx)("inlineCode",{parentName:"p"},"private"),":"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-lang=angle"},'facts> example.Has { access = private_ }\n{ "id": 1036, "key": { "class_": { "id": 1026 }, "has": { "id": 1035 }, "access": 1 } }\n')),(0,i.mdx)("p",null,"Note that in the JSON format results, an ",(0,i.mdx)("inlineCode",{parentName:"p"},"enum")," is represented by an integer. When you make queries in code, the ",(0,i.mdx)("inlineCode",{parentName:"p"},"enum")," will be represented by an appropriate type, such as a ",(0,i.mdx)("inlineCode",{parentName:"p"},"data")," type in Haskell."),(0,i.mdx)("p",null,"The boolean type ",(0,i.mdx)("inlineCode",{parentName:"p"},"bool")," is a special case of an ",(0,i.mdx)("inlineCode",{parentName:"p"},"enum"),", defined like this:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-lang=angle"},"type bool = enum { false | true }\n")),(0,i.mdx)("admonition",{type:"note"},(0,i.mdx)("p",{parentName:"admonition"},"Normally the constants of an ",(0,i.mdx)("inlineCode",{parentName:"p"},"enum")," should begin with a lower case\nletter. You can use constants beginning with an upper-case letter, but\nto distinguish the constant from a variable name you may sometimes\nneed to provide a type signature, e.g. ",(0,i.mdx)("inlineCode",{parentName:"p"},"Constant : Type")," rather than\njust ",(0,i.mdx)("inlineCode",{parentName:"p"},"Constant"),".")),(0,i.mdx)("h2",{id:"negation"},"Negation"),(0,i.mdx)("p",null,"If we want results that do not match a certain criterion, we can use ",(0,i.mdx)("inlineCode",{parentName:"p"},"!")," to\nspecify a subquery that should fail. A subquery fails if it doesn't return any\nresult."),(0,i.mdx)("p",null,"For example, we can find classes that don't have methods"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-lang=angle"},'facts> C where C = example.Class _; !(example.Has { class_ = C, has = { method = _ } })\n{ "id": 1026, "key": { "name": "Fish", "line": 30 } }\n{ "id": 1027, "key": { "name": "Goldfish", "line": 40 } }\n{ "id": 1025, "key": { "name": "Lizard", "line": 20 } }\n')),(0,i.mdx)("p",null,"Or we could find the maximum element in an array"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-lang=angle"},'facts> X where Values = [5,1,2,3]; X = Values[..]; !(Y = Values[..]; Y > X)\n{ "id": 1091, "key": 5 }\n')),(0,i.mdx)("p",null,"The query asks for the ",(0,i.mdx)("inlineCode",{parentName:"p"},"X")," for which given all values of ",(0,i.mdx)("inlineCode",{parentName:"p"},"Y")," ",(0,i.mdx)("em",{parentName:"p"},"none")," is greater\nthan it.  If ",(0,i.mdx)("inlineCode",{parentName:"p"},"Y = Values[..]")," were outside of the negation, the meaning would\nbe give me all ",(0,i.mdx)("inlineCode",{parentName:"p"},"X")," for which there is ",(0,i.mdx)("em",{parentName:"p"},"at least one")," ",(0,i.mdx)("inlineCode",{parentName:"p"},"Y")," that is not greater\nthan it. The answer to that would be all elements."))}h.isMDXComponent=!0},80510:function(e,n,a){var t=this&&this.__awaiter||function(e,n,a,t){return new(a||(a=Promise))((function(i,l){function r(e){try{o(t.next(e))}catch(n){l(n)}}function s(e){try{o(t.throw(e))}catch(n){l(n)}}function o(e){var n;e.done?i(e.value):(n=e.value,n instanceof a?n:new a((function(e){e(n)}))).then(r,s)}o((t=t.apply(e,n||[])).next())}))};Object.defineProperty(n,"__esModule",{value:!0}),n.getSpecInfo=void 0;const i=a(88266);n.getSpecInfo=function(e){return t(this,void 0,void 0,(function*(){return yield i.call({module:"bloks",api:"getSpecInfo",args:{styleId:e}})}))}},88266:function(e,n){var a=this&&this.__awaiter||function(e,n,a,t){return new(a||(a=Promise))((function(i,l){function r(e){try{o(t.next(e))}catch(n){l(n)}}function s(e){try{o(t.throw(e))}catch(n){l(n)}}function o(e){var n;e.done?i(e.value):(n=e.value,n instanceof a?n:new a((function(e){e(n)}))).then(r,s)}o((t=t.apply(e,n||[])).next())}))};Object.defineProperty(n,"__esModule",{value:!0}),n.call=void 0;let t=!1,i=0;const l={};n.call=function(e){return a(this,void 0,void 0,(function*(){if("staticdocs.thefacebook.com"!==window.location.hostname&&"localhost"!==window.location.hostname)return Promise.reject(new Error("Not running on static docs"));t||(t=!0,window.addEventListener("message",(e=>{if("static-docs-bridge-response"!==e.data.event)return;const n=e.data.id;n in l||console.error(`Recieved response for id: ${n} with no matching receiver`),"response"in e.data?l[n].resolve(e.data.response):l[n].reject(new Error(e.data.error)),delete l[n]})));const n=i++,a=new Promise(((e,a)=>{l[n]={resolve:e,reject:a}})),r={event:"static-docs-bridge-call",id:n,module:e.module,api:e.api,args:e.args},s="localhost"===window.location.hostname?"*":"https://www.internalfb.com";return window.parent.postMessage(r,s),a}))}},70680:function(e,n,a){var t=this&&this.__awaiter||function(e,n,a,t){return new(a||(a=Promise))((function(i,l){function r(e){try{o(t.next(e))}catch(n){l(n)}}function s(e){try{o(t.throw(e))}catch(n){l(n)}}function o(e){var n;e.done?i(e.value):(n=e.value,n instanceof a?n:new a((function(e){e(n)}))).then(r,s)}o((t=t.apply(e,n||[])).next())}))};Object.defineProperty(n,"__esModule",{value:!0}),n.reportFeatureUsage=n.reportContentCopied=void 0;const i=a(88266);n.reportContentCopied=function(e){return t(this,void 0,void 0,(function*(){const{textContent:n}=e;try{yield i.call({module:"feedback",api:"reportContentCopied",args:{textContent:n}})}catch(a){}}))},n.reportFeatureUsage=function(e){return t(this,void 0,void 0,(function*(){const{featureName:n,id:a}=e;console.log("used feature");try{yield i.call({module:"feedback",api:"reportFeatureUsage",args:{featureName:n,id:a}})}catch(t){}}))}},14423:function(e,n,a){var t=this&&this.__createBinding||(Object.create?function(e,n,a,t){void 0===t&&(t=a),Object.defineProperty(e,t,{enumerable:!0,get:function(){return n[a]}})}:function(e,n,a,t){void 0===t&&(t=a),e[t]=n[a]}),i=this&&this.__setModuleDefault||(Object.create?function(e,n){Object.defineProperty(e,"default",{enumerable:!0,value:n})}:function(e,n){e.default=n}),l=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var n={};if(null!=e)for(var a in e)"default"!==a&&Object.prototype.hasOwnProperty.call(e,a)&&t(n,e,a);return i(n,e),n};Object.defineProperty(n,"__esModule",{value:!0}),n.OssOnly=n.FbInternalOnly=n.getEphemeralDiffNumber=n.hasEphemeralDiffNumber=n.isInternal=n.validateFbContentArgs=n.fbInternalOnly=n.fbContent=n.inpageeditor=n.feedback=n.uidocs=n.bloks=void 0,n.bloks=l(a(80510)),n.uidocs=l(a(3730)),n.feedback=l(a(70680)),n.inpageeditor=l(a(45458));const r=["internal","external"];function s(e){return d(e),m()?"internal"in e?o(e.internal):[]:"external"in e?o(e.external):[]}function o(e){return"function"==typeof e?e():e}function d(e){if("object"!=typeof e)throw new Error(`fbContent() args must be an object containing keys: ${r}. Instead got ${e}`);if(!Object.keys(e).find((e=>r.find((n=>n===e)))))throw new Error(`No valid args found in ${JSON.stringify(e)}. Accepted keys: ${r}`);const n=Object.keys(e).filter((e=>!r.find((n=>n===e))));if(n.length>0)throw new Error(`Unexpected keys ${n} found in fbContent() args. Accepted keys: ${r}`)}function m(){try{return Boolean(!1)}catch(e){return console.log("process.env.FB_INTERNAL couldn't be read, maybe you forgot to add the required webpack EnvironmentPlugin config?",e),!1}}function p(){try{return null}catch(e){return console.log("process.env.PHABRICATOR_DIFF_NUMBER couldn't be read, maybe you forgot to add the required webpack EnvironmentPlugin config?",e),null}}n.fbContent=s,n.fbInternalOnly=function(e){return s({internal:e})},n.validateFbContentArgs=d,n.isInternal=m,n.hasEphemeralDiffNumber=function(){return Boolean(p())},n.getEphemeralDiffNumber=p,n.FbInternalOnly=function(e){return m()?e.children:null},n.OssOnly=function(e){return m()?null:e.children}},45458:function(e,n,a){var t=this&&this.__awaiter||function(e,n,a,t){return new(a||(a=Promise))((function(i,l){function r(e){try{o(t.next(e))}catch(n){l(n)}}function s(e){try{o(t.throw(e))}catch(n){l(n)}}function o(e){var n;e.done?i(e.value):(n=e.value,n instanceof a?n:new a((function(e){e(n)}))).then(r,s)}o((t=t.apply(e,n||[])).next())}))};Object.defineProperty(n,"__esModule",{value:!0}),n.submitDiff=void 0;const i=a(88266);n.submitDiff=function(e){return t(this,void 0,void 0,(function*(){const{file_path:n,new_content:a,project_name:t,diff_number:l}=e;try{return yield i.call({module:"inpageeditor",api:"createPhabricatorDiffApi",args:{file_path:n,new_content:a,project_name:t,diff_number:l}})}catch(r){throw new Error(`Error occurred while trying to submit diff. Stack trace: ${r}`)}}))}},3730:function(e,n,a){var t=this&&this.__awaiter||function(e,n,a,t){return new(a||(a=Promise))((function(i,l){function r(e){try{o(t.next(e))}catch(n){l(n)}}function s(e){try{o(t.throw(e))}catch(n){l(n)}}function o(e){var n;e.done?i(e.value):(n=e.value,n instanceof a?n:new a((function(e){e(n)}))).then(r,s)}o((t=t.apply(e,n||[])).next())}))};Object.defineProperty(n,"__esModule",{value:!0}),n.getApi=n.docsets=void 0;const i=a(88266);n.docsets={BLOKS_CORE:"887372105406659"},n.getApi=function(e){return t(this,void 0,void 0,(function*(){const{name:n,framework:a,docset:t}=e;return yield i.call({module:"uidocs",api:"getApi",args:{name:n,framework:a,docset:t}})}))}}}]);