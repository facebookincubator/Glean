"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[5894],{76042:e=>{e.exports=JSON.parse('{"blogPosts":[{"id":"release-0-2","metadata":{"permalink":"/blog/release-0-2","source":"@site/blog/2026-02-06-glean-0-2.md","title":"Glean Release 0.2","description":"I just uploaded","date":"2026-02-06T00:00:00.000Z","formattedDate":"February 6, 2026","tags":[{"label":"glean","permalink":"/blog/tags/glean"},{"label":"release","permalink":"/blog/tags/release"}],"readingTime":9.07,"hasTruncateMarker":false,"authors":[{"name":"Simon Marlow","title":"Simon Marlow","url":"https://simonmar.github.io/","imageURL":"http://simonmar.github.io/images/simonmarlow.jpg"}],"frontMatter":{"slug":"release-0-2","title":"Glean Release 0.2","author":"Simon Marlow","author_title":"Simon Marlow","author_url":"https://simonmar.github.io/","author_image_url":"http://simonmar.github.io/images/simonmarlow.jpg","tags":["glean","release"]},"nextItem":{"title":"Incremental indexing with Glean","permalink":"/blog/incremental"}},"content":"import {SrcFile,SrcFileLink} from \'@site/utils\';\\n\\nI just uploaded\\n[glean-0.2.0.0](https://hackage.haskell.org/package/glean-0.2.0.0) to\\nHackage, along with releases of the Haskell Thrift compiler and other\\ndependencies.\\n\\nSince version 0.1.0.0, Glean has been installable using plain `cabal\\ninstall` which vastly improves on the previous complex build\\nprocess. For full details, see [Building Glean From\\nSource](https://glean.software/docs/building/), but to summarise: on a\\nrecent Linux distro, with GHC 9.2-9.6 and cabal 3.6+, install some\\nprerequisite system packages (listed in the building docs above), and\\nthen just\\n\\n```\\ncabal install glean\\n```\\n\\nThe build takes a while, partly because one of the dependencies is a\\ncabal-packaged copy of the \\"folly\\" C++ library\\n([folly-clib](https://hackage.haskell.org/package/folly-clib)) and\\n[cabal doesn\'t currently build C++ files in\\nparallel](https://github.com/haskell/cabal/issues/7127).\\n\\n## Changes in 0.2.0.0\\n\\nSome pretty big things have landed:\\n\\n* Glean now comes with a generic LSP server,\\n  [glean-lsp](https://hackage.haskell.org/package/glean-lsp), which\\n  supports common IDE operations like go-to-definition,\\n  go-to-references, hover documentation, and symbol search. This means\\n  you can index a software project with Glean and then browse it using\\n  VS Code (for example). I\'ll give a couple of worked examples below\\n  showing step-by-step how to do this for some real world codebases.\\n\\n* Glean has a new experimental DB backend based on\\n  [LMDB](https://www.symas.com/mdb). LMDB is much smaller and simpler\\n  than RocksDB, and in most of our benchmarks it performed around\\n  30-40% better. We\'re still investigating some performance issues\\n  encountered with very large indexing jobs, though. Currently it\'s\\n  still not possible to build Glean without the RockDB dependency,\\n  but we do intend to fix this in the future.\\n\\n* Added a new Haskell indexer that consumes `.hie` files directly, and\\n  collects much richer data than the old indexer - in particular it\\n  indexes local variables and collects type information for all\\n  variable occurrences, which appears on hover with `glean-lsp` and VS\\n  Code.\\n\\n* We\'re now also releasing the C++ indexer as a Cabal package along\\n  with Glean:\\n  [glean-clang](https://hackage.haskell.org/package/glean-clang), so\\n  Glean can be used to index C++ projects out of the box.\\n\\n## Examples\\n\\nHere are a couple of things you can play with, once you\'ve [built and\\ninstalled Glean](https://glean.software/docs/building/).\\n\\n### Index LLVM + Clang and browse it in VS Code\\n\\nClone an LLVM source tree:\\n\\n```\\ngit clone https://github.com/llvm/llvm-project.git\\n```\\n\\nConfigure, including Clang. This step also produces the\\n`compile_commands.json` file that Glean will later use during\\nindexing:\\n\\n```\\ncd llvm-project/llvm\\nmkdir build && cd build\\ncmake -DCMAKE_EXPORT_COMPILE_COMMANDS=1 -DCMAKE_BUILD_TYPE=Debug -DLLVM_ENABLE_PROJECTS=clang ..\\n```\\n\\nNext, build LLVM. This step is required because LLVM includes a lot of\\ngenerated code which is produced as part of the build process, so to\\nindex the source files we need to ensure all the generated code has\\nbeen built first.\\n\\n```\\ncmake --build . -j12\\n```\\n\\nGo and get a coffee. Or two. (beware, even with 32GB this tends to OOM\\nmy laptop, so you might want to reduce `-j12` to something\\nlower). Next, we can index the project using Glean\'s C++\\nindexer.\\n\\nIf you haven\'t already install Glean\'s C++ indexer, do that:\\n\\n```\\ncabal install glean-clang\\n```\\n\\nNext we\'ll run the indexer. We\'ll store the resulting DB in\\n`llvm-project/gleandb` for now.\\n\\n```\\ncd ..\\nglean --db-root gleandb index cpp-cmake --db llvm/1 --cdb-dir \\"$(pwd)/llvm/build\\" . -j12\\n```\\n\\nGo and get another coffee... this is essentially running the compiler\\nover all the C++ code again. It *should* need no more than 16GB or so\\nwith 12 indexer processes running in parallel.\\n\\nNote that you need to do this from the `llvm-project` directory, this\\nensures that the filenames in the Glean DB will be relative to that\\ndirectory which is what `glean-lsp` expects. (Storing the data under\\nthe wrong filenames is the most common cause of things not working\\nwhen we connect up the full IDE/LSP/Glean stack).\\n\\nNext we need to set up VS Code and `glean-lsp`. There are full\\ninstructions for `glean-lsp` in its <SrcFileLink\\nfile=\\"lsp/README.md\\">README</SrcFileLink>, but here\'s specifically how\\nto set it up for LLVM using the index we just created.\\n\\nFirst install `glean-lsp` if you haven\'t already:\\n\\n```\\ncabal install glean-lsp\\n```\\n\\nTo use this LSP server with VS Code, you need a generic LSP client\\nsuch as [Generic LSP Client\\n(v2)](https://github.com/zsol/vscode-glspc). Install that extension in\\nVS Code, and then create `llvm-project/.vscode/settings.json`:\\n\\n```\\n[\\n    \\"glean-lsp\\": {\\n        \\"repo\\": \\"llvm\\"\\n    },\\n    \\"glspc.server.command\\": \\"glean-lsp\\"\\n    \\"glspc.server.commandArguments\\": [\\"--db-root\\", \\"gleandb\\"],\\n    \\"glspc.server.languageId\\": [\\n      \\"cpp\\", \\"c\\"\\n    ]\\n}\\n```\\n\\nNow in VS Code, \\"Open Folder\\" and select the `llvm-project` folder. If\\nyou have another C++ extension installed, it probably makes sense to\\ndisable it for this folder, otherwise you\'ll see responses from both\\nextensions for things like go-to-definition.\\n\\nOpen a source file,\\ne.g. `llvm-project/clang/include/clang/AST/Decl.h`.  You should have\\ncode navigation features available: holding down Ctrl while moving the\\nmouse around should underline identifiers, and clicking on an\\nidentifier should jump to its definition. You should be able to\\nright-click \\"Go to References\\" on a definition to find references\\nthroughout the whole LLVM + Clang tree instantly, and `Ctrl+T` for\\nsymbol search should work. Hovering the mouse over an identifier\\nshould show its type.\\n\\nIf things aren\'t working, then the first place to look for problems is in\\nthe output window for the Generic LSP Client: show the Output window,\\nand then select Generic LSP Client from the dropdown on the right.\\n\\nYou can also open the DB in Glean\'s shell to check that it looks right:\\n\\n```\\nglean shell --db-root llvm-project/gleandb --db llvm\\n```\\n\\nTry e.g. `:stat` to see the contents, and try `src.File _` to show\\nknown source files.\\n\\n### Download a DB of Stackage and try some queries\\n\\nYou can [download a DB of Stackage\\n21.21](https://drive.google.com/file/d/1rixJ6VCl6OlsECGnSjsH6IlXxFUU_msD/view?usp=sharing)\\nand try some queries. This DB was produced by building ~3000 packages\\nin Stackage 21.21 and then producing a Glean DB from the `.hie` files;\\nfor more details see [Indexing Hackage: Glean\\nvs. hiedb](https://simonmar.github.io/posts/2025-05-22-Glean-Haskell.html).\\n\\nUnpack the DB:\\n\\n```\\nmkdir /tmp/glean && tar xf glean-stackage-21.21.tar -C /tmp/glean\\n```\\n\\nand start the Glean shell:\\n\\n```\\n$ glean shell --db-root /tmp/glean\\nGlean Shell, built on 2025-07-14 13:39:35.711312749 UTC, from rev <unknown>\\nUsing local DBs from rocksdb:/tmp/glean\\ntype :help for help.\\n> \\n```\\n\\nLoad the DB:\\n\\n```\\n> :db stackage/1\\nstackage>\\n```\\n\\nLet\'s see what\'s in it:\\n\\n```\\nstackage> :stat\\nhs.ClassDecl.3\\n  count: 6503\\n  size:  350074 (341.87 kiB) 0.0309%\\nhs.ConstrDecl.3\\n  count: 89371\\n  size:  4048652 (3.86 MiB) 0.3569%\\nhs.DataDecl.3\\n  count: 40711\\n  size:  2017999 (1.92 MiB) 0.1779%\\n...\\nTotal: 21735709 facts (1.06 GiB)\\n```\\n\\nLet\'s find the class declaration for `Hashable`. First we have to find\\nits name:\\n\\n```\\nstackage> hs.Name { occ = { name = \\"Hashable\\" }}\\n{\\n  \\"id\\": 11500325,\\n  \\"key\\": {\\n    \\"occ\\": { \\"id\\": 11923, \\"key\\": { \\"name\\": \\"Hashable\\", \\"namespace_\\": 3 } },\\n    \\"mod\\": {\\n      \\"id\\": 733072,\\n      \\"key\\": {\\n        \\"name\\": { \\"id\\": 733071, \\"key\\": \\"Language.Preprocessor.Cpphs.SymTab\\" },\\n        \\"unit\\": { \\"id\\": 560159, \\"key\\": \\"cpphs-1.20.9.1-inplace\\" }\\n      }\\n    },\\n    \\"sort\\": { \\"external\\": { } }\\n  }\\n}\\n...\\n5 results, 20 facts, 7.40ms, 316816 bytes, 914 compiled bytes\\n```\\n\\nWe got 5 results, and only one of them was the one we wanted. So let\'s\\nrestrict the query to find only results in the `hashable` package:\\n\\n```\\nstackage> hs.Name { occ = { name = \\"Hashable\\" }, mod = { unit = \\"hashable\\".. }}\\n{\\n  \\"id\\": 11924,\\n  \\"key\\": {\\n    \\"occ\\": { \\"id\\": 11923, \\"key\\": { \\"name\\": \\"Hashable\\", \\"namespace_\\": 3 } },\\n    \\"mod\\": {\\n      \\"id\\": 11922,\\n      \\"key\\": {\\n        \\"name\\": { \\"id\\": 11920, \\"key\\": \\"Data.Hashable.Class\\" },\\n        \\"unit\\": { \\"id\\": 11921, \\"key\\": \\"hashable-1.4.3.0-inplace\\" }\\n      }\\n    },\\n    \\"sort\\": { \\"external\\": { } }\\n  }\\n}\\n\\n1 results, 5 facts, 1.18ms, 353848 bytes, 1489 compiled bytes\\n```\\n\\nOK, now let\'s find the class declaration:\\n\\n```\\nstackage> hs.ClassDecl { name = { occ = { name = \\"Hashable\\" }, mod = { unit = \\"hashable\\".. }}}\\n{\\n  \\"id\\": 19072033,\\n  \\"key\\": {\\n    \\"name\\": {\\n      \\"id\\": 11924,\\n      \\"key\\": {\\n        \\"occ\\": { \\"id\\": 11923, \\"key\\": { \\"name\\": \\"Hashable\\", \\"namespace_\\": 3 } },\\n        \\"mod\\": {\\n          \\"id\\": 11922,\\n          \\"key\\": {\\n            \\"name\\": { \\"id\\": 11920, \\"key\\": \\"Data.Hashable.Class\\" },\\n            \\"unit\\": { \\"id\\": 11921, \\"key\\": \\"hashable-1.4.3.0-inplace\\" }\\n          }\\n        },\\n        \\"sort\\": { \\"external\\": { } }\\n      }\\n    },\\n    \\"methods\\": [\\n      {\\n...\\n}\\n\\n1 results, 15 facts, 6.45ms, 514328 bytes, 1777 compiled bytes\\n```\\n\\nLet\'s find the method names of the class:\\n\\n```\\nstackage> (C.methods[..]).name.occ.name where C = hs.ClassDecl { name = { occ = { name = \\"Hashable\\" }, mod = { unit = \\"hashable\\".. }}}\\n{ \\"id\\": 21736733, \\"key\\": \\"hashWithSalt\\" }\\n{ \\"id\\": 21736734, \\"key\\": \\"hash\\" }\\n```\\n\\nAnd finally, let\'s see how many instances in Stackage 21.21 provide a\\ndefinition of `hashWithSalt`:\\n\\n```\\nstackage> :count I where B = hs.InstanceBind { name = { occ = { name = \\"hashWithSalt\\" }, mod = { unit = \\"hashable\\".. }}}; hs.InstanceBindToDecl { bind = B, decl = { inst = I }}; \\n\\n267 results, 267 facts, 26.40ms, 644736 bytes, 2462 compiled bytes\\n```\\n\\nTo see where these instance declarations are:\\n\\n```\\nstackage> I.loc where B = hs.InstanceBind { name = { occ = { name = \\"hashWithSalt\\" }, mod = { unit = \\"hashable\\".. }}}; hs.InstanceBindToDecl { bind = B, decl = { inst = I }}\\n{\\n  \\"id\\": 21736733,\\n  \\"key\\": {\\n    \\"file\\": { \\"id\\": 3982208, \\"key\\": \\"text-latin1-0.3.1/src/Text/Latin1.hs\\" },\\n    \\"span\\": { \\"start\\": 2662, \\"length\\": 157 }\\n  }\\n}\\n{\\n  \\"id\\": 21736734,\\n  \\"key\\": {\\n    \\"file\\": { \\"id\\": 11054592, \\"key\\": \\"shake-0.19.7/src/General/Thread.hs\\" },\\n    \\"span\\": { \\"start\\": 526, \\"length\\": 87 }\\n  }\\n}\\n{\\n  \\"id\\": 21736735,\\n  \\"key\\": {\\n    \\"file\\": { \\"id\\": 5786370, \\"key\\": \\"strict-tuple-0.1.5.3/src/Data/Tuple/Strict/T6.hs\\" },\\n    \\"span\\": { \\"start\\": 1887, \\"length\\": 265 }\\n  }\\n}\\n...\\n```\\n\\nThere are also some example queries in an [earlier blog\\npost](https://simonmar.github.io/posts/2025-05-22-Glean-Haskell.html) (however, the\\n<SrcFileLink file=\\"glean/schema/source/hs.angle\\">schema</SrcFileLink>\\nfor Haskell has changed in a few ways since that post so some of the\\nqueries might not work exactly as written).\\n\\n### Index your own Haskell code\\n\\nTo index the code of a Cabal package, add the following to your `cabal.project`:\\n\\n```\\npackage *\\n    ghc-options:\\n        -fwrite-ide-info\\n        -hiedir .hiefiles\\n```\\n\\nThen\\n\\n```\\n$ cabal build\\n$ glean index haskell-hie --db-root /tmp/glean --db mydb/1 .hiefiles\\n```\\n\\nand then you can query the new DB in the shell:\\n\\n```\\n$ glean shell --db-root /tmp/glean --db mydb/1\\n```\\n\\n### Run a Glass server and make some simple queries\\n\\nGlass is a \\"symbol server\\", it provides a higher-level interface to\\nthe Glean data, with operations like `documentSymbols` for finding all\\nthe symbols in a file, and `findReferences` for finding all the\\nreferences to a symbol. I used Glass to connect VS Code to Glean in\\nthe [previous blog\\npost](https://simonmar.github.io/posts/2025-06-11-Glean-stackage-vscode.html).\\n\\nGlass makes requests to a Glean server, so we need to start both\\n`glean-server` and `glass-server`, like this:\\n\\n```\\n$ glean-server --db-root /tmp/glean --port 12345\\n```\\n\\nand in another terminal:\\n\\n```\\n$ glass-server --service localhost:12345 --port 12346\\n```\\n\\nthen we can make requests using `glean-democlient`, for example to\\nlist the symbols in the file `src/Data/Aeson.hs` in the `aeson-2.1.2.1` package:\\n\\n```\\n$ glass-democlient --service localhost:12346 list stackage/aeson-2.1.2.1/src/Data/Aeson.hs\\nstackage/hs/aeson/Data/Aeson/var/eitherDecodeFileStrict\\nstackage/hs/aeson/Data/Aeson/var/eitherDecodeFileStrict%27\\nstackage/hs/aeson/Data/Aeson/var/eitherDecodeStrict\\nstackage/hs/aeson/Data/Aeson/var/fp/4335/2\\nstackage/hs/aeson/Data/Aeson/var/eitherDecodeStrict%27\\nstackage/hs/aeson/Data/Aeson/tyvar/a/6101/50\\nstackage/hs/aeson/Data/Aeson/tyvar/a/6563/56\\nstackage/hs/aeson/Data/Aeson/var/encodeFile\\nstackage/hs/aeson/Data/Aeson/tyvar/a/7047/61\\n...\\n```\\n\\nEach of those symbols is a \\"Symbol ID\\", which is a string that\\nuniquely identifies a particular symbol to Glass. Using the Symbol ID\\nwe can find all the references to a symbol:\\n\\n```"},{"id":"incremental","metadata":{"permalink":"/blog/incremental","source":"@site/blog/2022-12-01-incremental.md","title":"Incremental indexing with Glean","description":"This post describes how Glean supports incremental indexing of","date":"2022-12-01T00:00:00.000Z","formattedDate":"December 1, 2022","tags":[{"label":"glean","permalink":"/blog/tags/glean"},{"label":"incremental","permalink":"/blog/tags/incremental"}],"readingTime":7.075,"hasTruncateMarker":false,"authors":[{"name":"Simon Marlow","title":"Simon Marlow","url":"https://simonmar.github.io/","imageURL":"http://simonmar.github.io/images/simonmarlow.jpg"}],"frontMatter":{"slug":"incremental","title":"Incremental indexing with Glean","author":"Simon Marlow","author_title":"Simon Marlow","author_url":"https://simonmar.github.io/","author_image_url":"http://simonmar.github.io/images/simonmarlow.jpg","tags":["glean","incremental"]},"prevItem":{"title":"Glean Release 0.2","permalink":"/blog/release-0-2"}},"content":"import {SrcFile,SrcFileLink} from \'@site/utils\';\\n\\n\\n  This post describes how Glean supports *incremental indexing* of\\n  source code, to maintain an up-to-date index of a large repository\\n  using minimal resources. This is an overview of the problems and\\n  some aspects of how we solved them; for the technical details of the\\n  implementation see [Implementation Notes:\\n  Incrementality](/docs/implementation/incrementality).\\n\\n## Background\\n\\nIndexing a large amount of source code can take a long time. It\'s not\\nuncommon for very large indexing jobs to take multple\\nhours. Furthermore, a monolithic indexing job produces a large DB that\\ncan be slow to ship around, for example to replicate across a fleet of\\nGlean servers.\\n\\nSource code changes often, and we would like to keep the index up to\\ndate, but redoing the monolithic indexing job for every change is out\\nof the question. Instead what we would like to do is to update a\\nmonolithic index with the *changes* between the base revision and the\\ncurrent revision, which should hopefully be faster than a full\\nrepository indexing job because we only have to look at the things\\nthat have changed. The goal is to be able to index the changes in\\n*O(changes)* rather than *O(repository)*, or as close to that as we\\ncan get.\\n\\n## How incrementality works\\n\\nTo produce a modified DB, we hide a portion of the data in the\\noriginal DB, and then stack a DB with the new data on top. Like this:\\n\\n![Incremental stack](./incremental/stack.jpg)\\n\\nThe user asks for the DB \\"new\\", and they can then work with the data\\nin exactly the same way as they would for a single DB. The fact that\\nthe DB is a stack is invisible to a user making queries. Furthermore,\\nthe DB \\"old\\" still exists and can be used simultaneously, giving us\\naccess to multiple versions of the DB at the same time. We can even\\nhave many different versions of \\"new\\", each replacing a different\\nportion of \\"old\\".\\n\\nAll of the interesting stuff is in how we hide part of the data in the\\nold DB.  How do we hide part of the data?\\n\\nWhen facts are added to a Glean DB, the producer of the facts can\\nlabel facts with a *unit*. A unit is just a string; Glean doesn\'t impose\\nany particular meaning on units so the indexer can use whatever\\nconvention it likes, but typically a unit might be a filename or\\nmodule name. For example, when indexing a file F, the indexer would\\nlabel all the facts it produces with the unit F.\\n\\nTo hide some of the data in a DB, we specify which units to exclude\\nfrom the base DB, like this:\\n\\n```\\nglean create --repo <new> --incremental <old> --exclude A,B,C\\n```\\n\\nwould create a DB `<new>` that stacks on top of `<old>`, hiding units A, B\\nand C.\\n\\nSo to index some code incrementally, we would first decide which files\\nneed to be reindexed, create an incremental DB that hides those files\\nfrom the base DB and then add the new facts.\\n\\nTo implement hiding correctly, Glean has to remember which facts are\\nowned by which units. But it\'s not quite that simple, because facts\\ncan refer to each other, and the DB contents must be valid (which has\\na formal definition but informally means \\"no dangling\\nreferences\\"). For example, if we have facts **x** and **y**, where **x** refers to\\n**y**:\\n\\n![Fact dependency](./incremental/factdep1.jpg)\\n\\nand we hide unit B, then **y** must still be visible, otherwise the\\nreference from **x** would be dangling and the DB would not be valid.\\n\\nSo after the indexer has finished producing facts, Glean propagates\\nall the units through the graph of facts, resulting in a mapping from\\nfacts to **ownership sets**.\\n\\n![Fact dependency with ownership sets](./incremental/factdep2.jpg)\\n\\nIt turns out that while there are lots of facts, there are relatively\\nfew distinct ownership sets. Furthermore, facts produced together tend\\nto have the same ownership set, and we can use this to store the\\nmapping from facts to ownership sets efficiently. To summarise:\\n\\n\\n* Ownership sets are assigned unique IDs and stored in the DB using <a href=\\"https://github.com/facebook/folly/blob/main/folly/experimental/EliasFanoCoding.h\\">Elias Fano Coding</a>\\n* The mapping from facts to ownership sets is\\n  stored as an interval map\\n\\nAs a result, keeping all this information only adds about 7% to the DB\\nsize.\\n\\n### What about derived facts?\\n\\nDerived facts must also have ownership sets, because we have to know\\nwhich derived facts to hide. When is a derived fact visible? When all\\nof the facts that it was derived from are visible.\\n\\nFor example, if we have a fact **r** that was derived from **p** and **q**:\\n\\n![Derived fact](./incremental/derived.jpg)\\n\\nThe ownership set of **r** is `{ P } & { Q }`, indicating that it should be\\nvisible if both P and Q are visible. Note that facts might be derived\\nfrom other derived facts, so these ownership expressions can get\\narbitrarily large. Normalising them to disjunctive normal form would\\nbe possible, but we haven\'t found that to be necessary so far.\\n\\n### Performance\\n\\nThere are three aspects to performance:\\n\\n* **Indexing performance**. We measured the impact of computing\\n ownership at indexing time to be 2-3% for Python, for Hack it was in\\n the noise, and we don\'t\\n expect other languages to be significantly different.\\n* **Query performance**. Initially query performance for an\\n incremental stack was much slower because we have to calculate the visibility of every fact discovered during a query. However, with some [caching optimisations](/docs/implementation/incrementality#caching-fact-ownership) we were able to get the overhead to less than 10% for \\"typical\\" queries, of the kind that Glass does. Queries that do a lot of searching may be impacted by around 3x, but these are not typically found in production use cases.\\n* **Incremental derivation performance**. We would like derivation in the incremental DB to take time proportional to the number of facts in the increment. We implemented incremental derivation for some kinds of query; optimising queries to achieve this in general is a hard problem that we\'ll return to probably next year.\\n\\n### Stacked incremental DBs\\n\\nSo far we have only been considering how to stack a single increment\\non top of a base DB. What if we want to create deeper stacks?\\n\\n![Stacked incremental database](./incremental/stacked-incremental.jpg)\\n\\nThe DB \\"newer\\" stacks on top of \\"new\\", and hides some more units. So\\nthere are now portions of both \\"new\\" and \\"old\\" that need to be hidden\\n(the darker grey boxes), in addition to the original portion of \\"old\\"\\nthat we hid (light grey box).\\n\\nAs before, we might have multiple versions of \\"newer\\" stacked on top\\nof the same \\"new\\", and in general these DB stacks form a tree. All the\\nintermediate nodes of the tree are usable simultaneously: no data is\\nbeing modified, only shared and viewed differently depending on which\\nnode we choose as the top of our stack.\\n\\nOne interesting aspect that arises when we consider how to track\\nownership of facts in this model is fact dependencies across the\\nboundaries between DBs.  For instance, suppose we have\\n\\n![Stacked dependency](./incremental/stacked-dependency.jpg)\\n\\nIf we hide B, then considering the ownership data for \\"old\\" alone\\nwould tell us that y is invisible. But we must make it visible,\\nbecause x depends on it. So when computing the ownership data for\\n\\"new\\", we have to transitively propagate ownership to facts in the\\nbase DB(s), store that in \\"new\\", and consult it when deciding which\\nfacts in \\"old\\" are visible.\\n\\n### Derived facts in stacked incremental DBs\\n\\nA fact might be derived from multiple facts in different DBs in the\\nstack, and we have to represent its ownership correctly. Therefore\\n\\n* There must be a single namespace of ownership sets for the whole DB stack. That is, stacked DBs add more sets. (or else we copy ownership sets from the base DB, which doesn\'t seem attractive).\\n* Since a fact may be owned multiple different ways (see previous section) we have to take this into account when computing the ownership expression for a derived fact.\\n\\nThis is the most complex diagram in the post (phew!):\\n\\n![Stacked derived](./incremental/stacked-derived.jpg)\\n\\nHere the dashed arrow means \\"derived from\\" and the solid arrow means\\n\\"refers to\\".\\n\\nThe fact **d** should be visible if both **x** and **y** are visible. The\\nownership of **x** is `{A}` and **y** is `{B,C}` (because it is referred to from **z**\\nwhich has owner B), so the final owner of **d** is `{A} && {B,C}`.\\n\\nTracking all this shouldn\'t be too expensive, but it\'s tricky to get\\nright!"}]}')}}]);